/*! For license information please see stylist-widget.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("stylist-widget",[],t):"object"==typeof exports?exports["stylist-widget"]=t():e["stylist-widget"]=t()}(this,(()=>(()=>{var e={20:(e,t,n)=>{"use strict";var r=n(540),s=Symbol.for("react.element"),a=Symbol.for("react.fragment"),i=Object.prototype.hasOwnProperty,o=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function u(e,t,n){var r,a={},u=null,c=null;for(r in void 0!==n&&(u=""+n),void 0!==t.key&&(u=""+t.key),void 0!==t.ref&&(c=t.ref),t)i.call(t,r)&&!l.hasOwnProperty(r)&&(a[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps)void 0===a[r]&&(a[r]=t[r]);return{$$typeof:s,type:e,key:u,ref:c,props:a,_owner:o.current}}t.Fragment=a,t.jsx=u,t.jsxs=u},31:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},67:function(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],n^=(e^=e<<13)^e<<9,r[s]=n,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)},108:()=>{},162:(e,t,n)=>{"use strict";var r=n(540),s=n(888);var a="function"==typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e==1/t)||e!=e&&t!=t},i=s.useSyncExternalStore,o=r.useRef,l=r.useEffect,u=r.useMemo,c=r.useDebugValue;t.useSyncExternalStoreWithSelector=function(e,t,n,r,s){var d=o(null);if(null===d.current){var h={hasValue:!1,value:null};d.current=h}else h=d.current;d=u((function(){function e(e){if(!l){if(l=!0,i=e,e=r(e),void 0!==s&&h.hasValue){var t=h.value;if(s(t,e))return o=t}return o=e}if(t=o,a(i,e))return t;var n=r(e);return void 0!==s&&s(t,n)?(i=e,t):(i=e,o=n)}var i,o,l=!1,u=void 0===n?null:n;return[function(){return e(t())},null===u?void 0:function(){return e(u())}]}),[t,n,r,s]);var p=i(e,d[0],d[1]);return l((function(){h.hasValue=!0,h.value=p}),[p]),c(p),p}},180:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new a(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.alea=o}(0,e=n.nmd(e),n.amdD)},181:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor128=o}(0,e=n.nmd(e),n.amdD)},234:()=>{},242:(e,t,n)=>{"use strict";e.exports=n(162)},287:(e,t)=>{"use strict";var n=Symbol.for("react.element"),r=Symbol.for("react.portal"),s=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),l=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function b(){}function v(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}y.prototype.isReactComponent={},y.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},y.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=y.prototype;var x=v.prototype=new b;x.constructor=v,m(x,y.prototype),x.isPureReactComponent=!0;var w=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},I={key:!0,ref:!0,__self:!0,__source:!0};function N(e,t,r){var s,a={},i=null,o=null;if(null!=t)for(s in void 0!==t.ref&&(o=t.ref),void 0!==t.key&&(i=""+t.key),t)k.call(t,s)&&!I.hasOwnProperty(s)&&(a[s]=t[s]);var l=arguments.length-2;if(1===l)a.children=r;else if(1<l){for(var u=Array(l),c=0;c<l;c++)u[c]=arguments[c+2];a.children=u}if(e&&e.defaultProps)for(s in l=e.defaultProps)void 0===a[s]&&(a[s]=l[s]);return{$$typeof:n,type:e,key:i,ref:o,props:a,_owner:S.current}}function T(e){return"object"==typeof e&&null!==e&&e.$$typeof===n}var C=/\/+/g;function E(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function $(e,t,s,a,i){var o=typeof e;"undefined"!==o&&"boolean"!==o||(e=null);var l=!1;if(null===e)l=!0;else switch(o){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case n:case r:l=!0}}if(l)return i=i(l=e),e=""===a?"."+E(l,0):a,w(i)?(s="",null!=e&&(s=e.replace(C,"$&/")+"/"),$(i,t,s,"",(function(e){return e}))):null!=i&&(T(i)&&(i=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(i,s+(!i.key||l&&l.key===i.key?"":(""+i.key).replace(C,"$&/")+"/")+e)),t.push(i)),1;if(l=0,a=""===a?".":a+":",w(e))for(var u=0;u<e.length;u++){var c=a+E(o=e[u],u);l+=$(o,t,s,c,i)}else if(c=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"==typeof c)for(e=c.call(e),u=0;!(o=e.next()).done;)l+=$(o=o.value,t,s,c=a+E(o,u++),i);else if("object"===o)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return l}function _(e,t,n){if(null==e)return e;var r=[],s=0;return $(e,r,"","",(function(e){return t.call(n,e,s++)})),r}function O(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var R={current:null},A={transition:null},D={ReactCurrentDispatcher:R,ReactCurrentBatchConfig:A,ReactCurrentOwner:S};function F(){throw Error("act(...) is not supported in production builds of React.")}t.Children={map:_,forEach:function(e,t,n){_(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return _(e,(function(){t++})),t},toArray:function(e){return _(e,(function(e){return e}))||[]},only:function(e){if(!T(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=y,t.Fragment=s,t.Profiler=i,t.PureComponent=v,t.StrictMode=a,t.Suspense=c,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=D,t.act=F,t.cloneElement=function(e,t,r){if(null==e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var s=m({},e.props),a=e.key,i=e.ref,o=e._owner;if(null!=t){if(void 0!==t.ref&&(i=t.ref,o=S.current),void 0!==t.key&&(a=""+t.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(u in t)k.call(t,u)&&!I.hasOwnProperty(u)&&(s[u]=void 0===t[u]&&void 0!==l?l[u]:t[u])}var u=arguments.length-2;if(1===u)s.children=r;else if(1<u){l=Array(u);for(var c=0;c<u;c++)l[c]=arguments[c+2];s.children=l}return{$$typeof:n,type:e.type,key:a,ref:i,props:s,_owner:o}},t.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:o,_context:e},e.Consumer=e},t.createElement=N,t.createFactory=function(e){var t=N.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:u,render:e}},t.isValidElement=T,t.lazy=function(e){return{$$typeof:h,_payload:{_status:-1,_result:e},_init:O}},t.memo=function(e,t){return{$$typeof:d,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=A.transition;A.transition={};try{e()}finally{A.transition=t}},t.unstable_act=F,t.useCallback=function(e,t){return R.current.useCallback(e,t)},t.useContext=function(e){return R.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return R.current.useDeferredValue(e)},t.useEffect=function(e,t){return R.current.useEffect(e,t)},t.useId=function(){return R.current.useId()},t.useImperativeHandle=function(e,t,n){return R.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return R.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return R.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return R.current.useMemo(e,t)},t.useReducer=function(e,t,n){return R.current.useReducer(e,t,n)},t.useRef=function(e){return R.current.useRef(e)},t.useState=function(e){return R.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return R.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return R.current.useTransition()},t.version="18.3.1"},338:(e,t,n)=>{"use strict";var r=n(961);t.H=r.createRoot,r.hydrateRoot},391:(e,t,n)=>{var r=n(180),s=n(181),a=n(31),i=n(67),o=n(833),l=n(717),u=n(801);u.alea=r,u.xor128=s,u.xorwow=a,u.xorshift7=i,u.xor4096=o,u.tychei=l,e.exports=u},463:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,s=e[r];if(!(0<a(s,t)))break e;e[r]=t,e[n]=s,n=r}}function r(e){return 0===e.length?null:e[0]}function s(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,s=e.length,i=s>>>1;r<i;){var o=2*(r+1)-1,l=e[o],u=o+1,c=e[u];if(0>a(l,n))u<s&&0>a(c,l)?(e[r]=c,e[u]=n,r=u):(e[r]=l,e[o]=n,r=o);else{if(!(u<s&&0>a(c,n)))break e;e[r]=c,e[u]=n,r=u}}}return t}function a(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"==typeof performance&&"function"==typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var o=Date,l=o.now();t.unstable_now=function(){return o.now()-l}}var u=[],c=[],d=1,h=null,p=3,f=!1,m=!1,g=!1,y="function"==typeof setTimeout?setTimeout:null,b="function"==typeof clearTimeout?clearTimeout:null,v="undefined"!=typeof setImmediate?setImmediate:null;function x(e){for(var t=r(c);null!==t;){if(null===t.callback)s(c);else{if(!(t.startTime<=e))break;s(c),t.sortIndex=t.expirationTime,n(u,t)}t=r(c)}}function w(e){if(g=!1,x(e),!m)if(null!==r(u))m=!0,A(k);else{var t=r(c);null!==t&&D(w,t.startTime-e)}}function k(e,n){m=!1,g&&(g=!1,b(T),T=-1),f=!0;var a=p;try{for(x(n),h=r(u);null!==h&&(!(h.expirationTime>n)||e&&!$());){var i=h.callback;if("function"==typeof i){h.callback=null,p=h.priorityLevel;var o=i(h.expirationTime<=n);n=t.unstable_now(),"function"==typeof o?h.callback=o:h===r(u)&&s(u),x(n)}else s(u);h=r(u)}if(null!==h)var l=!0;else{var d=r(c);null!==d&&D(w,d.startTime-n),l=!1}return l}finally{h=null,p=a,f=!1}}"undefined"!=typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,I=!1,N=null,T=-1,C=5,E=-1;function $(){return!(t.unstable_now()-E<C)}function _(){if(null!==N){var e=t.unstable_now();E=e;var n=!0;try{n=N(!0,e)}finally{n?S():(I=!1,N=null)}}else I=!1}if("function"==typeof v)S=function(){v(_)};else if("undefined"!=typeof MessageChannel){var O=new MessageChannel,R=O.port2;O.port1.onmessage=_,S=function(){R.postMessage(null)}}else S=function(){y(_,0)};function A(e){N=e,I||(I=!0,S())}function D(e,n){T=y((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,A(k))},t.unstable_forceFrameRate=function(e){0>e||125<e||(C=0<e?Math.floor(1e3/e):5)},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return r(u)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,s,a){var i=t.unstable_now();switch("object"==typeof a&&null!==a?a="number"==typeof(a=a.delay)&&0<a?i+a:i:a=i,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:d++,callback:s,priorityLevel:e,startTime:a,expirationTime:o=a+o,sortIndex:-1},a>i?(e.sortIndex=a,n(c,e),null===r(u)&&e===r(c)&&(g?(b(T),T=-1):g=!0,D(w,a-i))):(e.sortIndex=o,n(u,e),m||f||(m=!0,A(k))),e},t.unstable_shouldYield=$,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},493:(e,t,n)=>{"use strict";var r=n(540);var s="function"==typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e==1/t)||e!=e&&t!=t},a=r.useState,i=r.useEffect,o=r.useLayoutEffect,l=r.useDebugValue;function u(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!s(e,n)}catch(e){return!0}}var c="undefined"==typeof window||void 0===window.document||void 0===window.document.createElement?function(e,t){return t()}:function(e,t){var n=t(),r=a({inst:{value:n,getSnapshot:t}}),s=r[0].inst,c=r[1];return o((function(){s.value=n,s.getSnapshot=t,u(s)&&c({inst:s})}),[e,n,t]),i((function(){return u(s)&&c({inst:s}),e((function(){u(s)&&c({inst:s})}))}),[e]),l(n),n};t.useSyncExternalStore=void 0!==r.useSyncExternalStore?r.useSyncExternalStore:c},530:()=>{},540:(e,t,n)=>{"use strict";e.exports=n(287)},551:(e,t,n)=>{"use strict";var r=n(540),s=n(982);function a(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var i=new Set,o={};function l(e,t){u(e,t),u(e+"Capture",t)}function u(e,t){for(o[e]=t,e=0;e<t.length;e++)i.add(t[e])}var c=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement),d=Object.prototype.hasOwnProperty,h=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function m(e,t,n,r,s,a,i){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=r,this.attributeNamespace=s,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=a,this.removeEmptyString=i}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){g[e]=new m(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];g[t]=new m(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){g[e]=new m(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){g[e]=new m(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){g[e]=new m(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){g[e]=new m(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){g[e]=new m(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){g[e]=new m(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){g[e]=new m(e,5,!1,e.toLowerCase(),null,!1,!1)}));var y=/[\-:]([a-z])/g;function b(e){return e[1].toUpperCase()}function v(e,t,n,r){var s=g.hasOwnProperty(t)?g[t]:null;(null!==s?0!==s.type:r||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,r){if(null==t||function(e,t,n,r){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,r))return!0;if(r)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,s,r)&&(n=null),r||null===s?function(e){return!!d.call(f,e)||!d.call(p,e)&&(h.test(e)?f[e]=!0:(p[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):s.mustUseProperty?e[s.propertyName]=null===n?3!==s.type&&"":n:(t=s.attributeName,r=s.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(s=s.type)||4===s&&!0===n?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!1,!1)})),g.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!0,!0)}));var x=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,w=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),I=Symbol.for("react.strict_mode"),N=Symbol.for("react.profiler"),T=Symbol.for("react.provider"),C=Symbol.for("react.context"),E=Symbol.for("react.forward_ref"),$=Symbol.for("react.suspense"),_=Symbol.for("react.suspense_list"),O=Symbol.for("react.memo"),R=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var A=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var D=Symbol.iterator;function F(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=D&&e[D]||e["@@iterator"])?e:null}var M,L=Object.assign;function z(e){if(void 0===M)try{throw Error()}catch(e){var t=e.stack.trim().match(/\n( *(at )?)/);M=t&&t[1]||""}return"\n"+M+e}var P=!1;function B(e,t){if(!e||P)return"";P=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"==typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(e){var r=e}Reflect.construct(e,[],t)}else{try{t.call()}catch(e){r=e}e.call(t.prototype)}else{try{throw Error()}catch(e){r=e}e()}}catch(t){if(t&&r&&"string"==typeof t.stack){for(var s=t.stack.split("\n"),a=r.stack.split("\n"),i=s.length-1,o=a.length-1;1<=i&&0<=o&&s[i]!==a[o];)o--;for(;1<=i&&0<=o;i--,o--)if(s[i]!==a[o]){if(1!==i||1!==o)do{if(i--,0>--o||s[i]!==a[o]){var l="\n"+s[i].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}}while(1<=i&&0<=o);break}}}finally{P=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?z(e):""}function U(e){switch(e.tag){case 5:return z(e.type);case 16:return z("Lazy");case 13:return z("Suspense");case 19:return z("SuspenseList");case 0:case 2:case 15:return e=B(e.type,!1);case 11:return e=B(e.type.render,!1);case 1:return e=B(e.type,!0);default:return""}}function j(e){if(null==e)return null;if("function"==typeof e)return e.displayName||e.name||null;if("string"==typeof e)return e;switch(e){case S:return"Fragment";case k:return"Portal";case N:return"Profiler";case I:return"StrictMode";case $:return"Suspense";case _:return"SuspenseList"}if("object"==typeof e)switch(e.$$typeof){case C:return(e.displayName||"Context")+".Consumer";case T:return(e._context.displayName||"Context")+".Provider";case E:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case O:return null!==(t=e.displayName||null)?t:j(e.type)||"Memo";case R:t=e._payload,e=e._init;try{return j(e(t))}catch(e){}}return null}function W(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return j(t);case 8:return t===I?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"==typeof t)return t.displayName||t.name||null;if("string"==typeof t)return t}return null}function V(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function G(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function H(e){e._valueTracker||(e._valueTracker=function(e){var t=G(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&void 0!==n&&"function"==typeof n.get&&"function"==typeof n.set){var s=n.get,a=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return s.call(this)},set:function(e){r=""+e,a.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function q(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=G(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function K(e){if(void 0===(e=e||("undefined"!=typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function X(e,t){var n=t.checked;return L({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Y(e,t){var n=null==t.defaultValue?"":t.defaultValue,r=null!=t.checked?t.checked:t.defaultChecked;n=V(null!=t.value?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function Q(e,t){null!=(t=t.checked)&&v(e,"checked",t,!1)}function J(e,t){Q(e,t);var n=V(t.value),r=t.type;if(null!=n)"number"===r?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===r||"reset"===r)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,V(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function Z(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!("submit"!==r&&"reset"!==r||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&K(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,r){if(e=e.options,t){t={};for(var s=0;s<n.length;s++)t["$"+n[s]]=!0;for(n=0;n<e.length;n++)s=t.hasOwnProperty("$"+e[n].value),e[n].selected!==s&&(e[n].selected=s),s&&r&&(e[n].defaultSelected=!0)}else{for(n=""+V(n),t=null,s=0;s<e.length;s++){if(e[s].value===n)return e[s].selected=!0,void(r&&(e[s].defaultSelected=!0));null!==t||e[s].disabled||(t=e[s])}null!==t&&(t.selected=!0)}}function re(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(a(91));return L({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function se(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(a(92));if(te(n)){if(1<n.length)throw Error(a(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:V(n)}}function ae(e,t){var n=V(t.value),r=V(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=r&&(e.defaultValue=""+r)}function ie(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function oe(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function le(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?oe(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var ue,ce,de=(ce=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((ue=ue||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=ue.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!=typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,r){MSApp.execUnsafeLocalFunction((function(){return ce(e,t)}))}:ce);function he(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function me(e,t,n){return null==t||"boolean"==typeof t||""===t?"":n||"number"!=typeof t||0===t||pe.hasOwnProperty(e)&&pe[e]?(""+t).trim():t+"px"}function ge(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var r=0===n.indexOf("--"),s=me(n,t[n],r);"float"===n&&(n="cssFloat"),r?e.setProperty(n,s):e[n]=s}}Object.keys(pe).forEach((function(e){fe.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pe[t]=pe[e]}))}));var ye=L({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function be(e,t){if(t){if(ye[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(a(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(a(60));if("object"!=typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(a(61))}if(null!=t.style&&"object"!=typeof t.style)throw Error(a(62))}}function ve(e,t){if(-1===e.indexOf("-"))return"string"==typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var xe=null;function we(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ke=null,Se=null,Ie=null;function Ne(e){if(e=vs(e)){if("function"!=typeof ke)throw Error(a(280));var t=e.stateNode;t&&(t=ws(t),ke(e.stateNode,e.type,t))}}function Te(e){Se?Ie?Ie.push(e):Ie=[e]:Se=e}function Ce(){if(Se){var e=Se,t=Ie;if(Ie=Se=null,Ne(e),t)for(e=0;e<t.length;e++)Ne(t[e])}}function Ee(e,t){return e(t)}function $e(){}var _e=!1;function Oe(e,t,n){if(_e)return e(t,n);_e=!0;try{return Ee(e,t,n)}finally{_e=!1,(null!==Se||null!==Ie)&&($e(),Ce())}}function Re(e,t){var n=e.stateNode;if(null===n)return null;var r=ws(n);if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!=typeof n)throw Error(a(231,t,typeof n));return n}var Ae=!1;if(c)try{var De={};Object.defineProperty(De,"passive",{get:function(){Ae=!0}}),window.addEventListener("test",De,De),window.removeEventListener("test",De,De)}catch(ce){Ae=!1}function Fe(e,t,n,r,s,a,i,o,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(n,u)}catch(e){this.onError(e)}}var Me=!1,Le=null,ze=!1,Pe=null,Be={onError:function(e){Me=!0,Le=e}};function Ue(e,t,n,r,s,a,i,o,l){Me=!1,Le=null,Fe.apply(Be,arguments)}function je(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{!!(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function We(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function Ve(e){if(je(e)!==e)throw Error(a(188))}function Ge(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=je(e)))throw Error(a(188));return t!==e?null:e}for(var n=e,r=t;;){var s=n.return;if(null===s)break;var i=s.alternate;if(null===i){if(null!==(r=s.return)){n=r;continue}break}if(s.child===i.child){for(i=s.child;i;){if(i===n)return Ve(s),e;if(i===r)return Ve(s),t;i=i.sibling}throw Error(a(188))}if(n.return!==r.return)n=s,r=i;else{for(var o=!1,l=s.child;l;){if(l===n){o=!0,n=s,r=i;break}if(l===r){o=!0,r=s,n=i;break}l=l.sibling}if(!o){for(l=i.child;l;){if(l===n){o=!0,n=i,r=s;break}if(l===r){o=!0,r=i,n=s;break}l=l.sibling}if(!o)throw Error(a(189))}}if(n.alternate!==r)throw Error(a(190))}if(3!==n.tag)throw Error(a(188));return n.stateNode.current===n?e:t}(e))?He(e):null}function He(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=He(e);if(null!==t)return t;e=e.sibling}return null}var qe=s.unstable_scheduleCallback,Ke=s.unstable_cancelCallback,Xe=s.unstable_shouldYield,Ye=s.unstable_requestPaint,Qe=s.unstable_now,Je=s.unstable_getCurrentPriorityLevel,Ze=s.unstable_ImmediatePriority,et=s.unstable_UserBlockingPriority,tt=s.unstable_NormalPriority,nt=s.unstable_LowPriority,rt=s.unstable_IdlePriority,st=null,at=null;var it=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(ot(e)/lt|0)|0},ot=Math.log,lt=Math.LN2;var ut=64,ct=4194304;function dt(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function ht(e,t){var n=e.pendingLanes;if(0===n)return 0;var r=0,s=e.suspendedLanes,a=e.pingedLanes,i=268435455&n;if(0!==i){var o=i&~s;0!==o?r=dt(o):0!==(a&=i)&&(r=dt(a))}else 0!==(i=n&~s)?r=dt(i):0!==a&&(r=dt(a));if(0===r)return 0;if(0!==t&&t!==r&&!(t&s)&&((s=r&-r)>=(a=t&-t)||16===s&&4194240&a))return t;if(4&r&&(r|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=r;0<t;)s=1<<(n=31-it(t)),r|=e[n],t&=~s;return r}function pt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function mt(){var e=ut;return!(4194240&(ut<<=1))&&(ut=64),e}function gt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function yt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-it(t)]=n}function bt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-it(n),s=1<<r;s&t|e[r]&t&&(e[r]|=t),n&=~s}}var vt=0;function xt(e){return 1<(e&=-e)?4<e?268435455&e?16:536870912:4:1}var wt,kt,St,It,Nt,Tt=!1,Ct=[],Et=null,$t=null,_t=null,Ot=new Map,Rt=new Map,At=[],Dt="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Ft(e,t){switch(e){case"focusin":case"focusout":Et=null;break;case"dragenter":case"dragleave":$t=null;break;case"mouseover":case"mouseout":_t=null;break;case"pointerover":case"pointerout":Ot.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Rt.delete(t.pointerId)}}function Mt(e,t,n,r,s,a){return null===e||e.nativeEvent!==a?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:a,targetContainers:[s]},null!==t&&(null!==(t=vs(t))&&kt(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==s&&-1===t.indexOf(s)&&t.push(s),e)}function Lt(e){var t=bs(e.target);if(null!==t){var n=je(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=We(n)))return e.blockedOn=t,void Nt(e.priority,(function(){St(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function zt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Xt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=vs(n))&&kt(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);xe=r,n.target.dispatchEvent(r),xe=null,t.shift()}return!0}function Pt(e,t,n){zt(e)&&n.delete(t)}function Bt(){Tt=!1,null!==Et&&zt(Et)&&(Et=null),null!==$t&&zt($t)&&($t=null),null!==_t&&zt(_t)&&(_t=null),Ot.forEach(Pt),Rt.forEach(Pt)}function Ut(e,t){e.blockedOn===t&&(e.blockedOn=null,Tt||(Tt=!0,s.unstable_scheduleCallback(s.unstable_NormalPriority,Bt)))}function jt(e){function t(t){return Ut(t,e)}if(0<Ct.length){Ut(Ct[0],e);for(var n=1;n<Ct.length;n++){var r=Ct[n];r.blockedOn===e&&(r.blockedOn=null)}}for(null!==Et&&Ut(Et,e),null!==$t&&Ut($t,e),null!==_t&&Ut(_t,e),Ot.forEach(t),Rt.forEach(t),n=0;n<At.length;n++)(r=At[n]).blockedOn===e&&(r.blockedOn=null);for(;0<At.length&&null===(n=At[0]).blockedOn;)Lt(n),null===n.blockedOn&&At.shift()}var Wt=x.ReactCurrentBatchConfig,Vt=!0;function Gt(e,t,n,r){var s=vt,a=Wt.transition;Wt.transition=null;try{vt=1,qt(e,t,n,r)}finally{vt=s,Wt.transition=a}}function Ht(e,t,n,r){var s=vt,a=Wt.transition;Wt.transition=null;try{vt=4,qt(e,t,n,r)}finally{vt=s,Wt.transition=a}}function qt(e,t,n,r){if(Vt){var s=Xt(e,t,n,r);if(null===s)Vr(e,t,r,Kt,n),Ft(e,r);else if(function(e,t,n,r,s){switch(t){case"focusin":return Et=Mt(Et,e,t,n,r,s),!0;case"dragenter":return $t=Mt($t,e,t,n,r,s),!0;case"mouseover":return _t=Mt(_t,e,t,n,r,s),!0;case"pointerover":var a=s.pointerId;return Ot.set(a,Mt(Ot.get(a)||null,e,t,n,r,s)),!0;case"gotpointercapture":return a=s.pointerId,Rt.set(a,Mt(Rt.get(a)||null,e,t,n,r,s)),!0}return!1}(s,e,t,n,r))r.stopPropagation();else if(Ft(e,r),4&t&&-1<Dt.indexOf(e)){for(;null!==s;){var a=vs(s);if(null!==a&&wt(a),null===(a=Xt(e,t,n,r))&&Vr(e,t,r,Kt,n),a===s)break;s=a}null!==s&&r.stopPropagation()}else Vr(e,t,r,null,n)}}var Kt=null;function Xt(e,t,n,r){if(Kt=null,null!==(e=bs(e=we(r))))if(null===(t=je(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=We(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Kt=e,null}function Yt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Je()){case Ze:return 1;case et:return 4;case tt:case nt:return 16;case rt:return 536870912;default:return 16}default:return 16}}var Qt=null,Jt=null,Zt=null;function en(){if(Zt)return Zt;var e,t,n=Jt,r=n.length,s="value"in Qt?Qt.value:Qt.textContent,a=s.length;for(e=0;e<r&&n[e]===s[e];e++);var i=r-e;for(t=1;t<=i&&n[r-t]===s[a-t];t++);return Zt=s.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function rn(){return!1}function sn(e){function t(t,n,r,s,a){for(var i in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=s,this.target=a,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(s):s[i]);return this.isDefaultPrevented=(null!=s.defaultPrevented?s.defaultPrevented:!1===s.returnValue)?nn:rn,this.isPropagationStopped=rn,this}return L(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!=typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!=typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var an,on,ln,un={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},cn=sn(un),dn=L({},un,{view:0,detail:0}),hn=sn(dn),pn=L({},dn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Nn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==ln&&(ln&&"mousemove"===e.type?(an=e.screenX-ln.screenX,on=e.screenY-ln.screenY):on=an=0,ln=e),an)},movementY:function(e){return"movementY"in e?e.movementY:on}}),fn=sn(pn),mn=sn(L({},pn,{dataTransfer:0})),gn=sn(L({},dn,{relatedTarget:0})),yn=sn(L({},un,{animationName:0,elapsedTime:0,pseudoElement:0})),bn=L({},un,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),vn=sn(bn),xn=sn(L({},un,{data:0})),wn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function In(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Sn[e])&&!!t[e]}function Nn(){return In}var Tn=L({},dn,{key:function(e){if(e.key){var t=wn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?kn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Nn,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Cn=sn(Tn),En=sn(L({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),$n=sn(L({},dn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Nn})),_n=sn(L({},un,{propertyName:0,elapsedTime:0,pseudoElement:0})),On=L({},pn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Rn=sn(On),An=[9,13,27,32],Dn=c&&"CompositionEvent"in window,Fn=null;c&&"documentMode"in document&&(Fn=document.documentMode);var Mn=c&&"TextEvent"in window&&!Fn,Ln=c&&(!Dn||Fn&&8<Fn&&11>=Fn),zn=String.fromCharCode(32),Pn=!1;function Bn(e,t){switch(e){case"keyup":return-1!==An.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Un(e){return"object"==typeof(e=e.detail)&&"data"in e?e.data:null}var jn=!1;var Wn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Vn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Wn[e.type]:"textarea"===t}function Gn(e,t,n,r){Te(r),0<(t=Hr(t,"onChange")).length&&(n=new cn("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Hn=null,qn=null;function Kn(e){zr(e,0)}function Xn(e){if(q(xs(e)))return e}function Yn(e,t){if("change"===e)return t}var Qn=!1;if(c){var Jn;if(c){var Zn="oninput"in document;if(!Zn){var er=document.createElement("div");er.setAttribute("oninput","return;"),Zn="function"==typeof er.oninput}Jn=Zn}else Jn=!1;Qn=Jn&&(!document.documentMode||9<document.documentMode)}function tr(){Hn&&(Hn.detachEvent("onpropertychange",nr),qn=Hn=null)}function nr(e){if("value"===e.propertyName&&Xn(qn)){var t=[];Gn(t,qn,e,we(e)),Oe(Kn,t)}}function rr(e,t,n){"focusin"===e?(tr(),qn=n,(Hn=t).attachEvent("onpropertychange",nr)):"focusout"===e&&tr()}function sr(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Xn(qn)}function ar(e,t){if("click"===e)return Xn(t)}function ir(e,t){if("input"===e||"change"===e)return Xn(t)}var or="function"==typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e==1/t)||e!=e&&t!=t};function lr(e,t){if(or(e,t))return!0;if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var s=n[r];if(!d.call(t,s)||!or(e[s],t[s]))return!1}return!0}function ur(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function cr(e,t){var n,r=ur(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=ur(r)}}function dr(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?dr(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function hr(){for(var e=window,t=K();t instanceof e.HTMLIFrameElement;){try{var n="string"==typeof t.contentWindow.location.href}catch(e){n=!1}if(!n)break;t=K((e=t.contentWindow).document)}return t}function pr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fr(e){var t=hr(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&dr(n.ownerDocument.documentElement,n)){if(null!==r&&pr(n))if(t=r.start,void 0===(e=r.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var s=n.textContent.length,a=Math.min(r.start,s);r=void 0===r.end?a:Math.min(r.end,s),!e.extend&&a>r&&(s=r,r=a,a=s),s=cr(n,a);var i=cr(n,r);s&&i&&(1!==e.rangeCount||e.anchorNode!==s.node||e.anchorOffset!==s.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&((t=t.createRange()).setStart(s.node,s.offset),e.removeAllRanges(),a>r?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"==typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var mr=c&&"documentMode"in document&&11>=document.documentMode,gr=null,yr=null,br=null,vr=!1;function xr(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;vr||null==gr||gr!==K(r)||("selectionStart"in(r=gr)&&pr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},br&&lr(br,r)||(br=r,0<(r=Hr(yr,"onSelect")).length&&(t=new cn("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=gr)))}function wr(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var kr={animationend:wr("Animation","AnimationEnd"),animationiteration:wr("Animation","AnimationIteration"),animationstart:wr("Animation","AnimationStart"),transitionend:wr("Transition","TransitionEnd")},Sr={},Ir={};function Nr(e){if(Sr[e])return Sr[e];if(!kr[e])return e;var t,n=kr[e];for(t in n)if(n.hasOwnProperty(t)&&t in Ir)return Sr[e]=n[t];return e}c&&(Ir=document.createElement("div").style,"AnimationEvent"in window||(delete kr.animationend.animation,delete kr.animationiteration.animation,delete kr.animationstart.animation),"TransitionEvent"in window||delete kr.transitionend.transition);var Tr=Nr("animationend"),Cr=Nr("animationiteration"),Er=Nr("animationstart"),$r=Nr("transitionend"),_r=new Map,Or="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Rr(e,t){_r.set(e,t),l(t,[e])}for(var Ar=0;Ar<Or.length;Ar++){var Dr=Or[Ar];Rr(Dr.toLowerCase(),"on"+(Dr[0].toUpperCase()+Dr.slice(1)))}Rr(Tr,"onAnimationEnd"),Rr(Cr,"onAnimationIteration"),Rr(Er,"onAnimationStart"),Rr("dblclick","onDoubleClick"),Rr("focusin","onFocus"),Rr("focusout","onBlur"),Rr($r,"onTransitionEnd"),u("onMouseEnter",["mouseout","mouseover"]),u("onMouseLeave",["mouseout","mouseover"]),u("onPointerEnter",["pointerout","pointerover"]),u("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Fr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Mr=new Set("cancel close invalid load scroll toggle".split(" ").concat(Fr));function Lr(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,r,s,i,o,l,u){if(Ue.apply(this,arguments),Me){if(!Me)throw Error(a(198));var c=Le;Me=!1,Le=null,ze||(ze=!0,Pe=c)}}(r,t,void 0,e),e.currentTarget=null}function zr(e,t){t=!!(4&t);for(var n=0;n<e.length;n++){var r=e[n],s=r.event;r=r.listeners;e:{var a=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==a&&s.isPropagationStopped())break e;Lr(s,o,u),a=l}else for(i=0;i<r.length;i++){if(l=(o=r[i]).instance,u=o.currentTarget,o=o.listener,l!==a&&s.isPropagationStopped())break e;Lr(s,o,u),a=l}}}if(ze)throw e=Pe,ze=!1,Pe=null,e}function Pr(e,t){var n=t[ms];void 0===n&&(n=t[ms]=new Set);var r=e+"__bubble";n.has(r)||(Wr(t,e,2,!1),n.add(r))}function Br(e,t,n){var r=0;t&&(r|=4),Wr(n,e,r,t)}var Ur="_reactListening"+Math.random().toString(36).slice(2);function jr(e){if(!e[Ur]){e[Ur]=!0,i.forEach((function(t){"selectionchange"!==t&&(Mr.has(t)||Br(t,!1,e),Br(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Ur]||(t[Ur]=!0,Br("selectionchange",!1,t))}}function Wr(e,t,n,r){switch(Yt(t)){case 1:var s=Gt;break;case 4:s=Ht;break;default:s=qt}n=s.bind(null,t,n,e),s=void 0,!Ae||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(s=!0),r?void 0!==s?e.addEventListener(t,n,{capture:!0,passive:s}):e.addEventListener(t,n,!0):void 0!==s?e.addEventListener(t,n,{passive:s}):e.addEventListener(t,n,!1)}function Vr(e,t,n,r,s){var a=r;if(!(1&t||2&t||null===r))e:for(;;){if(null===r)return;var i=r.tag;if(3===i||4===i){var o=r.stateNode.containerInfo;if(o===s||8===o.nodeType&&o.parentNode===s)break;if(4===i)for(i=r.return;null!==i;){var l=i.tag;if((3===l||4===l)&&((l=i.stateNode.containerInfo)===s||8===l.nodeType&&l.parentNode===s))return;i=i.return}for(;null!==o;){if(null===(i=bs(o)))return;if(5===(l=i.tag)||6===l){r=a=i;continue e}o=o.parentNode}}r=r.return}Oe((function(){var r=a,s=we(n),i=[];e:{var o=_r.get(e);if(void 0!==o){var l=cn,u=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":l=Cn;break;case"focusin":u="focus",l=gn;break;case"focusout":u="blur",l=gn;break;case"beforeblur":case"afterblur":l=gn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=mn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=$n;break;case Tr:case Cr:case Er:l=yn;break;case $r:l=_n;break;case"scroll":l=hn;break;case"wheel":l=Rn;break;case"copy":case"cut":case"paste":l=vn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=En}var c=!!(4&t),d=!c&&"scroll"===e,h=c?null!==o?o+"Capture":null:o;c=[];for(var p,f=r;null!==f;){var m=(p=f).stateNode;if(5===p.tag&&null!==m&&(p=m,null!==h&&(null!=(m=Re(f,h))&&c.push(Gr(f,m,p)))),d)break;f=f.return}0<c.length&&(o=new l(o,u,null,n,s),i.push({event:o,listeners:c}))}}if(!(7&t)){if(l="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||n===xe||!(u=n.relatedTarget||n.fromElement)||!bs(u)&&!u[fs])&&(l||o)&&(o=s.window===s?s:(o=s.ownerDocument)?o.defaultView||o.parentWindow:window,l?(l=r,null!==(u=(u=n.relatedTarget||n.toElement)?bs(u):null)&&(u!==(d=je(u))||5!==u.tag&&6!==u.tag)&&(u=null)):(l=null,u=r),l!==u)){if(c=fn,m="onMouseLeave",h="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(c=En,m="onPointerLeave",h="onPointerEnter",f="pointer"),d=null==l?o:xs(l),p=null==u?o:xs(u),(o=new c(m,f+"leave",l,n,s)).target=d,o.relatedTarget=p,m=null,bs(s)===r&&((c=new c(h,f+"enter",u,n,s)).target=p,c.relatedTarget=d,m=c),d=m,l&&u)e:{for(h=u,f=0,p=c=l;p;p=qr(p))f++;for(p=0,m=h;m;m=qr(m))p++;for(;0<f-p;)c=qr(c),f--;for(;0<p-f;)h=qr(h),p--;for(;f--;){if(c===h||null!==h&&c===h.alternate)break e;c=qr(c),h=qr(h)}c=null}else c=null;null!==l&&Kr(i,o,l,c,!1),null!==u&&null!==d&&Kr(i,d,u,c,!0)}if("select"===(l=(o=r?xs(r):window).nodeName&&o.nodeName.toLowerCase())||"input"===l&&"file"===o.type)var g=Yn;else if(Vn(o))if(Qn)g=ir;else{g=sr;var y=rr}else(l=o.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===o.type||"radio"===o.type)&&(g=ar);switch(g&&(g=g(e,r))?Gn(i,g,n,s):(y&&y(e,o,r),"focusout"===e&&(y=o._wrapperState)&&y.controlled&&"number"===o.type&&ee(o,"number",o.value)),y=r?xs(r):window,e){case"focusin":(Vn(y)||"true"===y.contentEditable)&&(gr=y,yr=r,br=null);break;case"focusout":br=yr=gr=null;break;case"mousedown":vr=!0;break;case"contextmenu":case"mouseup":case"dragend":vr=!1,xr(i,n,s);break;case"selectionchange":if(mr)break;case"keydown":case"keyup":xr(i,n,s)}var b;if(Dn)e:{switch(e){case"compositionstart":var v="onCompositionStart";break e;case"compositionend":v="onCompositionEnd";break e;case"compositionupdate":v="onCompositionUpdate";break e}v=void 0}else jn?Bn(e,n)&&(v="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(v="onCompositionStart");v&&(Ln&&"ko"!==n.locale&&(jn||"onCompositionStart"!==v?"onCompositionEnd"===v&&jn&&(b=en()):(Jt="value"in(Qt=s)?Qt.value:Qt.textContent,jn=!0)),0<(y=Hr(r,v)).length&&(v=new xn(v,e,null,n,s),i.push({event:v,listeners:y}),b?v.data=b:null!==(b=Un(n))&&(v.data=b))),(b=Mn?function(e,t){switch(e){case"compositionend":return Un(t);case"keypress":return 32!==t.which?null:(Pn=!0,zn);case"textInput":return(e=t.data)===zn&&Pn?null:e;default:return null}}(e,n):function(e,t){if(jn)return"compositionend"===e||!Dn&&Bn(e,t)?(e=en(),Zt=Jt=Qt=null,jn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Ln&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(r=Hr(r,"onBeforeInput")).length&&(s=new xn("onBeforeInput","beforeinput",null,n,s),i.push({event:s,listeners:r}),s.data=b))}zr(i,t)}))}function Gr(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Hr(e,t){for(var n=t+"Capture",r=[];null!==e;){var s=e,a=s.stateNode;5===s.tag&&null!==a&&(s=a,null!=(a=Re(e,n))&&r.unshift(Gr(e,a,s)),null!=(a=Re(e,t))&&r.push(Gr(e,a,s))),e=e.return}return r}function qr(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Kr(e,t,n,r,s){for(var a=t._reactName,i=[];null!==n&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(null!==l&&l===r)break;5===o.tag&&null!==u&&(o=u,s?null!=(l=Re(n,a))&&i.unshift(Gr(n,l,o)):s||null!=(l=Re(n,a))&&i.push(Gr(n,l,o))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var Xr=/\r\n?/g,Yr=/\u0000|\uFFFD/g;function Qr(e){return("string"==typeof e?e:""+e).replace(Xr,"\n").replace(Yr,"")}function Jr(e,t,n){if(t=Qr(t),Qr(e)!==t&&n)throw Error(a(425))}function Zr(){}var es=null,ts=null;function ns(e,t){return"textarea"===e||"noscript"===e||"string"==typeof t.children||"number"==typeof t.children||"object"==typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var rs="function"==typeof setTimeout?setTimeout:void 0,ss="function"==typeof clearTimeout?clearTimeout:void 0,as="function"==typeof Promise?Promise:void 0,is="function"==typeof queueMicrotask?queueMicrotask:void 0!==as?function(e){return as.resolve(null).then(e).catch(os)}:rs;function os(e){setTimeout((function(){throw e}))}function ls(e,t){var n=t,r=0;do{var s=n.nextSibling;if(e.removeChild(n),s&&8===s.nodeType)if("/$"===(n=s.data)){if(0===r)return e.removeChild(s),void jt(t);r--}else"$"!==n&&"$?"!==n&&"$!"!==n||r++;n=s}while(n);jt(t)}function us(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function cs(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var ds=Math.random().toString(36).slice(2),hs="__reactFiber$"+ds,ps="__reactProps$"+ds,fs="__reactContainer$"+ds,ms="__reactEvents$"+ds,gs="__reactListeners$"+ds,ys="__reactHandles$"+ds;function bs(e){var t=e[hs];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fs]||n[hs]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=cs(e);null!==e;){if(n=e[hs])return n;e=cs(e)}return t}n=(e=n).parentNode}return null}function vs(e){return!(e=e[hs]||e[fs])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function xs(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(a(33))}function ws(e){return e[ps]||null}var ks=[],Ss=-1;function Is(e){return{current:e}}function Ns(e){0>Ss||(e.current=ks[Ss],ks[Ss]=null,Ss--)}function Ts(e,t){Ss++,ks[Ss]=e.current,e.current=t}var Cs={},Es=Is(Cs),$s=Is(!1),_s=Cs;function Os(e,t){var n=e.type.contextTypes;if(!n)return Cs;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var s,a={};for(s in n)a[s]=t[s];return r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=a),a}function Rs(e){return null!=(e=e.childContextTypes)}function As(){Ns($s),Ns(Es)}function Ds(e,t,n){if(Es.current!==Cs)throw Error(a(168));Ts(Es,t),Ts($s,n)}function Fs(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,"function"!=typeof r.getChildContext)return n;for(var s in r=r.getChildContext())if(!(s in t))throw Error(a(108,W(e)||"Unknown",s));return L({},n,r)}function Ms(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Cs,_s=Es.current,Ts(Es,e),Ts($s,$s.current),!0}function Ls(e,t,n){var r=e.stateNode;if(!r)throw Error(a(169));n?(e=Fs(e,t,_s),r.__reactInternalMemoizedMergedChildContext=e,Ns($s),Ns(Es),Ts(Es,e)):Ns($s),Ts($s,n)}var zs=null,Ps=!1,Bs=!1;function Us(e){null===zs?zs=[e]:zs.push(e)}function js(){if(!Bs&&null!==zs){Bs=!0;var e=0,t=vt;try{var n=zs;for(vt=1;e<n.length;e++){var r=n[e];do{r=r(!0)}while(null!==r)}zs=null,Ps=!1}catch(t){throw null!==zs&&(zs=zs.slice(e+1)),qe(Ze,js),t}finally{vt=t,Bs=!1}}return null}var Ws=[],Vs=0,Gs=null,Hs=0,qs=[],Ks=0,Xs=null,Ys=1,Qs="";function Js(e,t){Ws[Vs++]=Hs,Ws[Vs++]=Gs,Gs=e,Hs=t}function Zs(e,t,n){qs[Ks++]=Ys,qs[Ks++]=Qs,qs[Ks++]=Xs,Xs=e;var r=Ys;e=Qs;var s=32-it(r)-1;r&=~(1<<s),n+=1;var a=32-it(t)+s;if(30<a){var i=s-s%5;a=(r&(1<<i)-1).toString(32),r>>=i,s-=i,Ys=1<<32-it(t)+s|n<<s|r,Qs=a+e}else Ys=1<<a|n<<s|r,Qs=e}function ea(e){null!==e.return&&(Js(e,1),Zs(e,1,0))}function ta(e){for(;e===Gs;)Gs=Ws[--Vs],Ws[Vs]=null,Hs=Ws[--Vs],Ws[Vs]=null;for(;e===Xs;)Xs=qs[--Ks],qs[Ks]=null,Qs=qs[--Ks],qs[Ks]=null,Ys=qs[--Ks],qs[Ks]=null}var na=null,ra=null,sa=!1,aa=null;function ia(e,t){var n=_u(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function oa(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,na=e,ra=us(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,na=e,ra=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Xs?{id:Ys,overflow:Qs}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=_u(18,null,null,0)).stateNode=t,n.return=e,e.child=n,na=e,ra=null,!0);default:return!1}}function la(e){return!(!(1&e.mode)||128&e.flags)}function ua(e){if(sa){var t=ra;if(t){var n=t;if(!oa(e,t)){if(la(e))throw Error(a(418));t=us(n.nextSibling);var r=na;t&&oa(e,t)?ia(r,n):(e.flags=-4097&e.flags|2,sa=!1,na=e)}}else{if(la(e))throw Error(a(418));e.flags=-4097&e.flags|2,sa=!1,na=e}}}function ca(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;na=e}function da(e){if(e!==na)return!1;if(!sa)return ca(e),sa=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!ns(e.type,e.memoizedProps)),t&&(t=ra)){if(la(e))throw ha(),Error(a(418));for(;t;)ia(e,t),t=us(t.nextSibling)}if(ca(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(a(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){ra=us(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}ra=null}}else ra=na?us(e.stateNode.nextSibling):null;return!0}function ha(){for(var e=ra;e;)e=us(e.nextSibling)}function pa(){ra=na=null,sa=!1}function fa(e){null===aa?aa=[e]:aa.push(e)}var ma=x.ReactCurrentBatchConfig;function ga(e,t,n){if(null!==(e=n.ref)&&"function"!=typeof e&&"object"!=typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(a(309));var r=n.stateNode}if(!r)throw Error(a(147,e));var s=r,i=""+e;return null!==t&&null!==t.ref&&"function"==typeof t.ref&&t.ref._stringRef===i?t.ref:(t=function(e){var t=s.refs;null===e?delete t[i]:t[i]=e},t._stringRef=i,t)}if("string"!=typeof e)throw Error(a(284));if(!n._owner)throw Error(a(290,e))}return e}function ya(e,t){throw e=Object.prototype.toString.call(t),Error(a(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function ba(e){return(0,e._init)(e._payload)}function va(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function s(e,t){return(e=Ru(e,t)).index=0,e.sibling=null,e}function i(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=2,n):r:(t.flags|=2,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=2),t}function l(e,t,n,r){return null===t||6!==t.tag?((t=Mu(n,e.mode,r)).return=e,t):((t=s(t,n)).return=e,t)}function u(e,t,n,r){var a=n.type;return a===S?d(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===a||"object"==typeof a&&null!==a&&a.$$typeof===R&&ba(a)===t.type)?((r=s(t,n.props)).ref=ga(e,t,n),r.return=e,r):((r=Au(n.type,n.key,n.props,null,e.mode,r)).ref=ga(e,t,n),r.return=e,r)}function c(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Lu(n,e.mode,r)).return=e,t):((t=s(t,n.children||[])).return=e,t)}function d(e,t,n,r,a){return null===t||7!==t.tag?((t=Du(n,e.mode,r,a)).return=e,t):((t=s(t,n)).return=e,t)}function h(e,t,n){if("string"==typeof t&&""!==t||"number"==typeof t)return(t=Mu(""+t,e.mode,n)).return=e,t;if("object"==typeof t&&null!==t){switch(t.$$typeof){case w:return(n=Au(t.type,t.key,t.props,null,e.mode,n)).ref=ga(e,null,t),n.return=e,n;case k:return(t=Lu(t,e.mode,n)).return=e,t;case R:return h(e,(0,t._init)(t._payload),n)}if(te(t)||F(t))return(t=Du(t,e.mode,n,null)).return=e,t;ya(e,t)}return null}function p(e,t,n,r){var s=null!==t?t.key:null;if("string"==typeof n&&""!==n||"number"==typeof n)return null!==s?null:l(e,t,""+n,r);if("object"==typeof n&&null!==n){switch(n.$$typeof){case w:return n.key===s?u(e,t,n,r):null;case k:return n.key===s?c(e,t,n,r):null;case R:return p(e,t,(s=n._init)(n._payload),r)}if(te(n)||F(n))return null!==s?null:d(e,t,n,r,null);ya(e,n)}return null}function f(e,t,n,r,s){if("string"==typeof r&&""!==r||"number"==typeof r)return l(t,e=e.get(n)||null,""+r,s);if("object"==typeof r&&null!==r){switch(r.$$typeof){case w:return u(t,e=e.get(null===r.key?n:r.key)||null,r,s);case k:return c(t,e=e.get(null===r.key?n:r.key)||null,r,s);case R:return f(e,t,n,(0,r._init)(r._payload),s)}if(te(r)||F(r))return d(t,e=e.get(n)||null,r,s,null);ya(t,r)}return null}function m(s,a,o,l){for(var u=null,c=null,d=a,m=a=0,g=null;null!==d&&m<o.length;m++){d.index>m?(g=d,d=null):g=d.sibling;var y=p(s,d,o[m],l);if(null===y){null===d&&(d=g);break}e&&d&&null===y.alternate&&t(s,d),a=i(y,a,m),null===c?u=y:c.sibling=y,c=y,d=g}if(m===o.length)return n(s,d),sa&&Js(s,m),u;if(null===d){for(;m<o.length;m++)null!==(d=h(s,o[m],l))&&(a=i(d,a,m),null===c?u=d:c.sibling=d,c=d);return sa&&Js(s,m),u}for(d=r(s,d);m<o.length;m++)null!==(g=f(d,s,m,o[m],l))&&(e&&null!==g.alternate&&d.delete(null===g.key?m:g.key),a=i(g,a,m),null===c?u=g:c.sibling=g,c=g);return e&&d.forEach((function(e){return t(s,e)})),sa&&Js(s,m),u}function g(s,o,l,u){var c=F(l);if("function"!=typeof c)throw Error(a(150));if(null==(l=c.call(l)))throw Error(a(151));for(var d=c=null,m=o,g=o=0,y=null,b=l.next();null!==m&&!b.done;g++,b=l.next()){m.index>g?(y=m,m=null):y=m.sibling;var v=p(s,m,b.value,u);if(null===v){null===m&&(m=y);break}e&&m&&null===v.alternate&&t(s,m),o=i(v,o,g),null===d?c=v:d.sibling=v,d=v,m=y}if(b.done)return n(s,m),sa&&Js(s,g),c;if(null===m){for(;!b.done;g++,b=l.next())null!==(b=h(s,b.value,u))&&(o=i(b,o,g),null===d?c=b:d.sibling=b,d=b);return sa&&Js(s,g),c}for(m=r(s,m);!b.done;g++,b=l.next())null!==(b=f(m,s,g,b.value,u))&&(e&&null!==b.alternate&&m.delete(null===b.key?g:b.key),o=i(b,o,g),null===d?c=b:d.sibling=b,d=b);return e&&m.forEach((function(e){return t(s,e)})),sa&&Js(s,g),c}return function e(r,a,i,l){if("object"==typeof i&&null!==i&&i.type===S&&null===i.key&&(i=i.props.children),"object"==typeof i&&null!==i){switch(i.$$typeof){case w:e:{for(var u=i.key,c=a;null!==c;){if(c.key===u){if((u=i.type)===S){if(7===c.tag){n(r,c.sibling),(a=s(c,i.props.children)).return=r,r=a;break e}}else if(c.elementType===u||"object"==typeof u&&null!==u&&u.$$typeof===R&&ba(u)===c.type){n(r,c.sibling),(a=s(c,i.props)).ref=ga(r,c,i),a.return=r,r=a;break e}n(r,c);break}t(r,c),c=c.sibling}i.type===S?((a=Du(i.props.children,r.mode,l,i.key)).return=r,r=a):((l=Au(i.type,i.key,i.props,null,r.mode,l)).ref=ga(r,a,i),l.return=r,r=l)}return o(r);case k:e:{for(c=i.key;null!==a;){if(a.key===c){if(4===a.tag&&a.stateNode.containerInfo===i.containerInfo&&a.stateNode.implementation===i.implementation){n(r,a.sibling),(a=s(a,i.children||[])).return=r,r=a;break e}n(r,a);break}t(r,a),a=a.sibling}(a=Lu(i,r.mode,l)).return=r,r=a}return o(r);case R:return e(r,a,(c=i._init)(i._payload),l)}if(te(i))return m(r,a,i,l);if(F(i))return g(r,a,i,l);ya(r,i)}return"string"==typeof i&&""!==i||"number"==typeof i?(i=""+i,null!==a&&6===a.tag?(n(r,a.sibling),(a=s(a,i)).return=r,r=a):(n(r,a),(a=Mu(i,r.mode,l)).return=r,r=a),o(r)):n(r,a)}}var xa=va(!0),wa=va(!1),ka=Is(null),Sa=null,Ia=null,Na=null;function Ta(){Na=Ia=Sa=null}function Ca(e){var t=ka.current;Ns(ka),e._currentValue=t}function Ea(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function $a(e,t){Sa=e,Na=Ia=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(!!(e.lanes&t)&&(bo=!0),e.firstContext=null)}function _a(e){var t=e._currentValue;if(Na!==e)if(e={context:e,memoizedValue:t,next:null},null===Ia){if(null===Sa)throw Error(a(308));Ia=e,Sa.dependencies={lanes:0,firstContext:e}}else Ia=Ia.next=e;return t}var Oa=null;function Ra(e){null===Oa?Oa=[e]:Oa.push(e)}function Aa(e,t,n,r){var s=t.interleaved;return null===s?(n.next=n,Ra(t)):(n.next=s.next,s.next=n),t.interleaved=n,Da(e,r)}function Da(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Fa=!1;function Ma(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function La(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function za(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function Pa(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,2&Cl){var s=r.pending;return null===s?t.next=t:(t.next=s.next,s.next=t),r.pending=t,Da(e,n)}return null===(s=r.interleaved)?(t.next=t,Ra(r)):(t.next=s.next,s.next=t),r.interleaved=t,Da(e,n)}function Ba(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,4194240&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}function Ua(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var s=null,a=null;if(null!==(n=n.firstBaseUpdate)){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===a?s=a=i:a=a.next=i,n=n.next}while(null!==n);null===a?s=a=t:a=a.next=t}else s=a=t;return n={baseState:r.baseState,firstBaseUpdate:s,lastBaseUpdate:a,shared:r.shared,effects:r.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function ja(e,t,n,r){var s=e.updateQueue;Fa=!1;var a=s.firstBaseUpdate,i=s.lastBaseUpdate,o=s.shared.pending;if(null!==o){s.shared.pending=null;var l=o,u=l.next;l.next=null,null===i?a=u:i.next=u,i=l;var c=e.alternate;null!==c&&((o=(c=c.updateQueue).lastBaseUpdate)!==i&&(null===o?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(null!==a){var d=s.baseState;for(i=0,c=u=l=null,o=a;;){var h=o.lane,p=o.eventTime;if((r&h)===h){null!==c&&(c=c.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(h=t,p=n,m.tag){case 1:if("function"==typeof(f=m.payload)){d=f.call(p,d,h);break e}d=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null==(h="function"==typeof(f=m.payload)?f.call(p,d,h):f))break e;d=L({},d,h);break e;case 2:Fa=!0}}null!==o.callback&&0!==o.lane&&(e.flags|=64,null===(h=s.effects)?s.effects=[o]:h.push(o))}else p={eventTime:p,lane:h,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===c?(u=c=p,l=d):c=c.next=p,i|=h;if(null===(o=o.next)){if(null===(o=s.shared.pending))break;o=(h=o).next,h.next=null,s.lastBaseUpdate=h,s.shared.pending=null}}if(null===c&&(l=d),s.baseState=l,s.firstBaseUpdate=u,s.lastBaseUpdate=c,null!==(t=s.shared.interleaved)){s=t;do{i|=s.lane,s=s.next}while(s!==t)}else null===a&&(s.shared.lanes=0);Fl|=i,e.lanes=i,e.memoizedState=d}}function Wa(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var r=e[t],s=r.callback;if(null!==s){if(r.callback=null,r=n,"function"!=typeof s)throw Error(a(191,s));s.call(r)}}}var Va={},Ga=Is(Va),Ha=Is(Va),qa=Is(Va);function Ka(e){if(e===Va)throw Error(a(174));return e}function Xa(e,t){switch(Ts(qa,t),Ts(Ha,e),Ts(Ga,Va),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:le(null,"");break;default:t=le(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Ns(Ga),Ts(Ga,t)}function Ya(){Ns(Ga),Ns(Ha),Ns(qa)}function Qa(e){Ka(qa.current);var t=Ka(Ga.current),n=le(t,e.type);t!==n&&(Ts(Ha,e),Ts(Ga,n))}function Ja(e){Ha.current===e&&(Ns(Ga),Ns(Ha))}var Za=Is(0);function ei(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(128&t.flags)return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var ti=[];function ni(){for(var e=0;e<ti.length;e++)ti[e]._workInProgressVersionPrimary=null;ti.length=0}var ri=x.ReactCurrentDispatcher,si=x.ReactCurrentBatchConfig,ai=0,ii=null,oi=null,li=null,ui=!1,ci=!1,di=0,hi=0;function pi(){throw Error(a(321))}function fi(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!or(e[n],t[n]))return!1;return!0}function mi(e,t,n,r,s,i){if(ai=i,ii=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,ri.current=null===e||null===e.memoizedState?Ji:Zi,e=n(r,s),ci){i=0;do{if(ci=!1,di=0,25<=i)throw Error(a(301));i+=1,li=oi=null,t.updateQueue=null,ri.current=eo,e=n(r,s)}while(ci)}if(ri.current=Qi,t=null!==oi&&null!==oi.next,ai=0,li=oi=ii=null,ui=!1,t)throw Error(a(300));return e}function gi(){var e=0!==di;return di=0,e}function yi(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===li?ii.memoizedState=li=e:li=li.next=e,li}function bi(){if(null===oi){var e=ii.alternate;e=null!==e?e.memoizedState:null}else e=oi.next;var t=null===li?ii.memoizedState:li.next;if(null!==t)li=t,oi=e;else{if(null===e)throw Error(a(310));e={memoizedState:(oi=e).memoizedState,baseState:oi.baseState,baseQueue:oi.baseQueue,queue:oi.queue,next:null},null===li?ii.memoizedState=li=e:li=li.next=e}return li}function vi(e,t){return"function"==typeof t?t(e):t}function xi(e){var t=bi(),n=t.queue;if(null===n)throw Error(a(311));n.lastRenderedReducer=e;var r=oi,s=r.baseQueue,i=n.pending;if(null!==i){if(null!==s){var o=s.next;s.next=i.next,i.next=o}r.baseQueue=s=i,n.pending=null}if(null!==s){i=s.next,r=r.baseState;var l=o=null,u=null,c=i;do{var d=c.lane;if((ai&d)===d)null!==u&&(u=u.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),r=c.hasEagerState?c.eagerState:e(r,c.action);else{var h={lane:d,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};null===u?(l=u=h,o=r):u=u.next=h,ii.lanes|=d,Fl|=d}c=c.next}while(null!==c&&c!==i);null===u?o=r:u.next=l,or(r,t.memoizedState)||(bo=!0),t.memoizedState=r,t.baseState=o,t.baseQueue=u,n.lastRenderedState=r}if(null!==(e=n.interleaved)){s=e;do{i=s.lane,ii.lanes|=i,Fl|=i,s=s.next}while(s!==e)}else null===s&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function wi(e){var t=bi(),n=t.queue;if(null===n)throw Error(a(311));n.lastRenderedReducer=e;var r=n.dispatch,s=n.pending,i=t.memoizedState;if(null!==s){n.pending=null;var o=s=s.next;do{i=e(i,o.action),o=o.next}while(o!==s);or(i,t.memoizedState)||(bo=!0),t.memoizedState=i,null===t.baseQueue&&(t.baseState=i),n.lastRenderedState=i}return[i,r]}function ki(){}function Si(e,t){var n=ii,r=bi(),s=t(),i=!or(r.memoizedState,s);if(i&&(r.memoizedState=s,bo=!0),r=r.queue,Fi(Ti.bind(null,n,r,e),[e]),r.getSnapshot!==t||i||null!==li&&1&li.memoizedState.tag){if(n.flags|=2048,_i(9,Ni.bind(null,n,r,s,t),void 0,null),null===El)throw Error(a(349));30&ai||Ii(n,t,s)}return s}function Ii(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Ni(e,t,n,r){t.value=n,t.getSnapshot=r,Ci(t)&&Ei(e)}function Ti(e,t,n){return n((function(){Ci(t)&&Ei(e)}))}function Ci(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!or(e,n)}catch(e){return!0}}function Ei(e){var t=Da(e,1);null!==t&&tu(t,e,1,-1)}function $i(e){var t=yi();return"function"==typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:vi,lastRenderedState:e},t.queue=e,e=e.dispatch=qi.bind(null,ii,e),[t.memoizedState,e]}function _i(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},null===(t=ii.updateQueue)?(t={lastEffect:null,stores:null},ii.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function Oi(){return bi().memoizedState}function Ri(e,t,n,r){var s=yi();ii.flags|=e,s.memoizedState=_i(1|t,n,void 0,void 0===r?null:r)}function Ai(e,t,n,r){var s=bi();r=void 0===r?null:r;var a=void 0;if(null!==oi){var i=oi.memoizedState;if(a=i.destroy,null!==r&&fi(r,i.deps))return void(s.memoizedState=_i(t,n,a,r))}ii.flags|=e,s.memoizedState=_i(1|t,n,a,r)}function Di(e,t){return Ri(8390656,8,e,t)}function Fi(e,t){return Ai(2048,8,e,t)}function Mi(e,t){return Ai(4,2,e,t)}function Li(e,t){return Ai(4,4,e,t)}function zi(e,t){return"function"==typeof t?(e=e(),t(e),function(){t(null)}):null!=t?(e=e(),t.current=e,function(){t.current=null}):void 0}function Pi(e,t,n){return n=null!=n?n.concat([e]):null,Ai(4,4,zi.bind(null,t,e),n)}function Bi(){}function Ui(e,t){var n=bi();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&fi(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function ji(e,t){var n=bi();t=void 0===t?null:t;var r=n.memoizedState;return null!==r&&null!==t&&fi(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function Wi(e,t,n){return 21&ai?(or(n,t)||(n=mt(),ii.lanes|=n,Fl|=n,e.baseState=!0),t):(e.baseState&&(e.baseState=!1,bo=!0),e.memoizedState=n)}function Vi(e,t){var n=vt;vt=0!==n&&4>n?n:4,e(!0);var r=si.transition;si.transition={};try{e(!1),t()}finally{vt=n,si.transition=r}}function Gi(){return bi().memoizedState}function Hi(e,t,n){var r=eu(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},Ki(e))Xi(t,n);else if(null!==(n=Aa(e,t,n,r))){tu(n,e,r,Zl()),Yi(n,t,r)}}function qi(e,t,n){var r=eu(e),s={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(Ki(e))Xi(t,s);else{var a=e.alternate;if(0===e.lanes&&(null===a||0===a.lanes)&&null!==(a=t.lastRenderedReducer))try{var i=t.lastRenderedState,o=a(i,n);if(s.hasEagerState=!0,s.eagerState=o,or(o,i)){var l=t.interleaved;return null===l?(s.next=s,Ra(t)):(s.next=l.next,l.next=s),void(t.interleaved=s)}}catch(e){}null!==(n=Aa(e,t,s,r))&&(tu(n,e,r,s=Zl()),Yi(n,t,r))}}function Ki(e){var t=e.alternate;return e===ii||null!==t&&t===ii}function Xi(e,t){ci=ui=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Yi(e,t,n){if(4194240&n){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,bt(e,n)}}var Qi={readContext:_a,useCallback:pi,useContext:pi,useEffect:pi,useImperativeHandle:pi,useInsertionEffect:pi,useLayoutEffect:pi,useMemo:pi,useReducer:pi,useRef:pi,useState:pi,useDebugValue:pi,useDeferredValue:pi,useTransition:pi,useMutableSource:pi,useSyncExternalStore:pi,useId:pi,unstable_isNewReconciler:!1},Ji={readContext:_a,useCallback:function(e,t){return yi().memoizedState=[e,void 0===t?null:t],e},useContext:_a,useEffect:Di,useImperativeHandle:function(e,t,n){return n=null!=n?n.concat([e]):null,Ri(4194308,4,zi.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Ri(4194308,4,e,t)},useInsertionEffect:function(e,t){return Ri(4,2,e,t)},useMemo:function(e,t){var n=yi();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=yi();return t=void 0!==n?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=Hi.bind(null,ii,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},yi().memoizedState=e},useState:$i,useDebugValue:Bi,useDeferredValue:function(e){return yi().memoizedState=e},useTransition:function(){var e=$i(!1),t=e[0];return e=Vi.bind(null,e[1]),yi().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=ii,s=yi();if(sa){if(void 0===n)throw Error(a(407));n=n()}else{if(n=t(),null===El)throw Error(a(349));30&ai||Ii(r,t,n)}s.memoizedState=n;var i={value:n,getSnapshot:t};return s.queue=i,Di(Ti.bind(null,r,i,e),[e]),r.flags|=2048,_i(9,Ni.bind(null,r,i,n,t),void 0,null),n},useId:function(){var e=yi(),t=El.identifierPrefix;if(sa){var n=Qs;t=":"+t+"R"+(n=(Ys&~(1<<32-it(Ys)-1)).toString(32)+n),0<(n=di++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=hi++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},Zi={readContext:_a,useCallback:Ui,useContext:_a,useEffect:Fi,useImperativeHandle:Pi,useInsertionEffect:Mi,useLayoutEffect:Li,useMemo:ji,useReducer:xi,useRef:Oi,useState:function(){return xi(vi)},useDebugValue:Bi,useDeferredValue:function(e){return Wi(bi(),oi.memoizedState,e)},useTransition:function(){return[xi(vi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1},eo={readContext:_a,useCallback:Ui,useContext:_a,useEffect:Fi,useImperativeHandle:Pi,useInsertionEffect:Mi,useLayoutEffect:Li,useMemo:ji,useReducer:wi,useRef:Oi,useState:function(){return wi(vi)},useDebugValue:Bi,useDeferredValue:function(e){var t=bi();return null===oi?t.memoizedState=e:Wi(t,oi.memoizedState,e)},useTransition:function(){return[wi(vi)[0],bi().memoizedState]},useMutableSource:ki,useSyncExternalStore:Si,useId:Gi,unstable_isNewReconciler:!1};function to(e,t){if(e&&e.defaultProps){for(var n in t=L({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}function no(e,t,n,r){n=null==(n=n(r,t=e.memoizedState))?t:L({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var ro={isMounted:function(e){return!!(e=e._reactInternals)&&je(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=Zl(),s=eu(e),a=za(r,s);a.payload=t,null!=n&&(a.callback=n),null!==(t=Pa(e,a,s))&&(tu(t,e,s,r),Ba(t,e,s))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=Zl(),s=eu(e),a=za(r,s);a.tag=1,a.payload=t,null!=n&&(a.callback=n),null!==(t=Pa(e,a,s))&&(tu(t,e,s,r),Ba(t,e,s))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=Zl(),r=eu(e),s=za(n,r);s.tag=2,null!=t&&(s.callback=t),null!==(t=Pa(e,s,r))&&(tu(t,e,r,n),Ba(t,e,r))}};function so(e,t,n,r,s,a,i){return"function"==typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,a,i):!t.prototype||!t.prototype.isPureReactComponent||(!lr(n,r)||!lr(s,a))}function ao(e,t,n){var r=!1,s=Cs,a=t.contextType;return"object"==typeof a&&null!==a?a=_a(a):(s=Rs(t)?_s:Es.current,a=(r=null!=(r=t.contextTypes))?Os(e,s):Cs),t=new t(n,a),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=ro,e.stateNode=t,t._reactInternals=e,r&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=s,e.__reactInternalMemoizedMaskedChildContext=a),t}function io(e,t,n,r){e=t.state,"function"==typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"==typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&ro.enqueueReplaceState(t,t.state,null)}function oo(e,t,n,r){var s=e.stateNode;s.props=n,s.state=e.memoizedState,s.refs={},Ma(e);var a=t.contextType;"object"==typeof a&&null!==a?s.context=_a(a):(a=Rs(t)?_s:Es.current,s.context=Os(e,a)),s.state=e.memoizedState,"function"==typeof(a=t.getDerivedStateFromProps)&&(no(e,t,a,n),s.state=e.memoizedState),"function"==typeof t.getDerivedStateFromProps||"function"==typeof s.getSnapshotBeforeUpdate||"function"!=typeof s.UNSAFE_componentWillMount&&"function"!=typeof s.componentWillMount||(t=s.state,"function"==typeof s.componentWillMount&&s.componentWillMount(),"function"==typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount(),t!==s.state&&ro.enqueueReplaceState(s,s.state,null),ja(e,n,s,r),s.state=e.memoizedState),"function"==typeof s.componentDidMount&&(e.flags|=4194308)}function lo(e,t){try{var n="",r=t;do{n+=U(r),r=r.return}while(r);var s=n}catch(e){s="\nError generating stack: "+e.message+"\n"+e.stack}return{value:e,source:t,stack:s,digest:null}}function uo(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}var co="function"==typeof WeakMap?WeakMap:Map;function ho(e,t,n){(n=za(-1,n)).tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){Wl||(Wl=!0,Vl=r)},n}function po(e,t,n){(n=za(-1,n)).tag=3;var r=e.type.getDerivedStateFromError;if("function"==typeof r){var s=t.value;n.payload=function(){return r(s)},n.callback=function(){}}var a=e.stateNode;return null!==a&&"function"==typeof a.componentDidCatch&&(n.callback=function(){"function"!=typeof r&&(null===Gl?Gl=new Set([this]):Gl.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function fo(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new co;var s=new Set;r.set(t,s)}else void 0===(s=r.get(t))&&(s=new Set,r.set(t,s));s.has(n)||(s.add(n),e=Iu.bind(null,e,t,n),t.then(e,e))}function mo(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function go(e,t,n,r,s){return 1&e.mode?(e.flags|=65536,e.lanes=s,e):(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=za(-1,1)).tag=2,Pa(n,t,1))),n.lanes|=1),e)}var yo=x.ReactCurrentOwner,bo=!1;function vo(e,t,n,r){t.child=null===e?wa(t,null,n,r):xa(t,e.child,n,r)}function xo(e,t,n,r,s){n=n.render;var a=t.ref;return $a(t,s),r=mi(e,t,n,r,a,s),n=gi(),null===e||bo?(sa&&n&&ea(t),t.flags|=1,vo(e,t,r,s),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,Wo(e,t,s))}function wo(e,t,n,r,s){if(null===e){var a=n.type;return"function"!=typeof a||Ou(a)||void 0!==a.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Au(n.type,null,r,t,t.mode,s)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=a,ko(e,t,a,r,s))}if(a=e.child,!(e.lanes&s)){var i=a.memoizedProps;if((n=null!==(n=n.compare)?n:lr)(i,r)&&e.ref===t.ref)return Wo(e,t,s)}return t.flags|=1,(e=Ru(a,r)).ref=t.ref,e.return=t,t.child=e}function ko(e,t,n,r,s){if(null!==e){var a=e.memoizedProps;if(lr(a,r)&&e.ref===t.ref){if(bo=!1,t.pendingProps=r=a,!(e.lanes&s))return t.lanes=e.lanes,Wo(e,t,s);131072&e.flags&&(bo=!0)}}return No(e,t,n,r,s)}function So(e,t,n){var r=t.pendingProps,s=r.children,a=null!==e?e.memoizedState:null;if("hidden"===r.mode)if(1&t.mode){if(!(1073741824&n))return e=null!==a?a.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Ts(Rl,Ol),Ol|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=null!==a?a.baseLanes:n,Ts(Rl,Ol),Ol|=r}else t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Ts(Rl,Ol),Ol|=n;else null!==a?(r=a.baseLanes|n,t.memoizedState=null):r=n,Ts(Rl,Ol),Ol|=r;return vo(e,t,s,n),t.child}function Io(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function No(e,t,n,r,s){var a=Rs(n)?_s:Es.current;return a=Os(t,a),$a(t,s),n=mi(e,t,n,r,a,s),r=gi(),null===e||bo?(sa&&r&&ea(t),t.flags|=1,vo(e,t,n,s),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,Wo(e,t,s))}function To(e,t,n,r,s){if(Rs(n)){var a=!0;Ms(t)}else a=!1;if($a(t,s),null===t.stateNode)jo(e,t),ao(t,n,r),oo(t,n,r,s),r=!0;else if(null===e){var i=t.stateNode,o=t.memoizedProps;i.props=o;var l=i.context,u=n.contextType;"object"==typeof u&&null!==u?u=_a(u):u=Os(t,u=Rs(n)?_s:Es.current);var c=n.getDerivedStateFromProps,d="function"==typeof c||"function"==typeof i.getSnapshotBeforeUpdate;d||"function"!=typeof i.UNSAFE_componentWillReceiveProps&&"function"!=typeof i.componentWillReceiveProps||(o!==r||l!==u)&&io(t,i,r,u),Fa=!1;var h=t.memoizedState;i.state=h,ja(t,r,i,s),l=t.memoizedState,o!==r||h!==l||$s.current||Fa?("function"==typeof c&&(no(t,n,c,r),l=t.memoizedState),(o=Fa||so(t,n,o,r,h,l,u))?(d||"function"!=typeof i.UNSAFE_componentWillMount&&"function"!=typeof i.componentWillMount||("function"==typeof i.componentWillMount&&i.componentWillMount(),"function"==typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount()),"function"==typeof i.componentDidMount&&(t.flags|=4194308)):("function"==typeof i.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),i.props=r,i.state=l,i.context=u,r=o):("function"==typeof i.componentDidMount&&(t.flags|=4194308),r=!1)}else{i=t.stateNode,La(e,t),o=t.memoizedProps,u=t.type===t.elementType?o:to(t.type,o),i.props=u,d=t.pendingProps,h=i.context,"object"==typeof(l=n.contextType)&&null!==l?l=_a(l):l=Os(t,l=Rs(n)?_s:Es.current);var p=n.getDerivedStateFromProps;(c="function"==typeof p||"function"==typeof i.getSnapshotBeforeUpdate)||"function"!=typeof i.UNSAFE_componentWillReceiveProps&&"function"!=typeof i.componentWillReceiveProps||(o!==d||h!==l)&&io(t,i,r,l),Fa=!1,h=t.memoizedState,i.state=h,ja(t,r,i,s);var f=t.memoizedState;o!==d||h!==f||$s.current||Fa?("function"==typeof p&&(no(t,n,p,r),f=t.memoizedState),(u=Fa||so(t,n,u,r,h,f,l)||!1)?(c||"function"!=typeof i.UNSAFE_componentWillUpdate&&"function"!=typeof i.componentWillUpdate||("function"==typeof i.componentWillUpdate&&i.componentWillUpdate(r,f,l),"function"==typeof i.UNSAFE_componentWillUpdate&&i.UNSAFE_componentWillUpdate(r,f,l)),"function"==typeof i.componentDidUpdate&&(t.flags|=4),"function"==typeof i.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!=typeof i.componentDidUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!=typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=f),i.props=r,i.state=f,i.context=l,r=u):("function"!=typeof i.componentDidUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!=typeof i.getSnapshotBeforeUpdate||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),r=!1)}return Co(e,t,n,r,a,s)}function Co(e,t,n,r,s,a){Io(e,t);var i=!!(128&t.flags);if(!r&&!i)return s&&Ls(t,n,!1),Wo(e,t,a);r=t.stateNode,yo.current=t;var o=i&&"function"!=typeof n.getDerivedStateFromError?null:r.render();return t.flags|=1,null!==e&&i?(t.child=xa(t,e.child,null,a),t.child=xa(t,null,o,a)):vo(e,t,o,a),t.memoizedState=r.state,s&&Ls(t,n,!0),t.child}function Eo(e){var t=e.stateNode;t.pendingContext?Ds(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Ds(0,t.context,!1),Xa(e,t.containerInfo)}function $o(e,t,n,r,s){return pa(),fa(s),t.flags|=256,vo(e,t,n,r),t.child}var _o,Oo,Ro,Ao,Do={dehydrated:null,treeContext:null,retryLane:0};function Fo(e){return{baseLanes:e,cachePool:null,transitions:null}}function Mo(e,t,n){var r,s=t.pendingProps,i=Za.current,o=!1,l=!!(128&t.flags);if((r=l)||(r=(null===e||null!==e.memoizedState)&&!!(2&i)),r?(o=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(i|=1),Ts(Za,1&i),null===e)return ua(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(1&t.mode?"$!"===e.data?t.lanes=8:t.lanes=1073741824:t.lanes=1,null):(l=s.children,e=s.fallback,o?(s=t.mode,o=t.child,l={mode:"hidden",children:l},1&s||null===o?o=Fu(l,s,0,null):(o.childLanes=0,o.pendingProps=l),e=Du(e,s,n,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=Fo(n),t.memoizedState=Do,e):Lo(t,l));if(null!==(i=e.memoizedState)&&null!==(r=i.dehydrated))return function(e,t,n,r,s,i,o){if(n)return 256&t.flags?(t.flags&=-257,zo(e,t,o,r=uo(Error(a(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(i=r.fallback,s=t.mode,r=Fu({mode:"visible",children:r.children},s,0,null),(i=Du(i,s,o,null)).flags|=2,r.return=t,i.return=t,r.sibling=i,t.child=r,1&t.mode&&xa(t,e.child,null,o),t.child.memoizedState=Fo(o),t.memoizedState=Do,i);if(!(1&t.mode))return zo(e,t,o,null);if("$!"===s.data){if(r=s.nextSibling&&s.nextSibling.dataset)var l=r.dgst;return r=l,zo(e,t,o,r=uo(i=Error(a(419)),r,void 0))}if(l=!!(o&e.childLanes),bo||l){if(null!==(r=El)){switch(o&-o){case 4:s=2;break;case 16:s=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:s=32;break;case 536870912:s=268435456;break;default:s=0}0!==(s=s&(r.suspendedLanes|o)?0:s)&&s!==i.retryLane&&(i.retryLane=s,Da(e,s),tu(r,e,s,-1))}return fu(),zo(e,t,o,r=uo(Error(a(421))))}return"$?"===s.data?(t.flags|=128,t.child=e.child,t=Tu.bind(null,e),s._reactRetry=t,null):(e=i.treeContext,ra=us(s.nextSibling),na=t,sa=!0,aa=null,null!==e&&(qs[Ks++]=Ys,qs[Ks++]=Qs,qs[Ks++]=Xs,Ys=e.id,Qs=e.overflow,Xs=t),t=Lo(t,r.children),t.flags|=4096,t)}(e,t,l,s,r,i,n);if(o){o=s.fallback,l=t.mode,r=(i=e.child).sibling;var u={mode:"hidden",children:s.children};return 1&l||t.child===i?(s=Ru(i,u)).subtreeFlags=14680064&i.subtreeFlags:((s=t.child).childLanes=0,s.pendingProps=u,t.deletions=null),null!==r?o=Ru(r,o):(o=Du(o,l,n,null)).flags|=2,o.return=t,s.return=t,s.sibling=o,t.child=s,s=o,o=t.child,l=null===(l=e.child.memoizedState)?Fo(n):{baseLanes:l.baseLanes|n,cachePool:null,transitions:l.transitions},o.memoizedState=l,o.childLanes=e.childLanes&~n,t.memoizedState=Do,s}return e=(o=e.child).sibling,s=Ru(o,{mode:"visible",children:s.children}),!(1&t.mode)&&(s.lanes=n),s.return=t,s.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=s,t.memoizedState=null,s}function Lo(e,t){return(t=Fu({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function zo(e,t,n,r){return null!==r&&fa(r),xa(t,e.child,null,n),(e=Lo(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Po(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),Ea(e.return,t,n)}function Bo(e,t,n,r,s){var a=e.memoizedState;null===a?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:s}:(a.isBackwards=t,a.rendering=null,a.renderingStartTime=0,a.last=r,a.tail=n,a.tailMode=s)}function Uo(e,t,n){var r=t.pendingProps,s=r.revealOrder,a=r.tail;if(vo(e,t,r.children,n),2&(r=Za.current))r=1&r|2,t.flags|=128;else{if(null!==e&&128&e.flags)e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Po(e,n,t);else if(19===e.tag)Po(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(Ts(Za,r),1&t.mode)switch(s){case"forwards":for(n=t.child,s=null;null!==n;)null!==(e=n.alternate)&&null===ei(e)&&(s=n),n=n.sibling;null===(n=s)?(s=t.child,t.child=null):(s=n.sibling,n.sibling=null),Bo(t,!1,s,n,a);break;case"backwards":for(n=null,s=t.child,t.child=null;null!==s;){if(null!==(e=s.alternate)&&null===ei(e)){t.child=s;break}e=s.sibling,s.sibling=n,n=s,s=e}Bo(t,!0,n,null,a);break;case"together":Bo(t,!1,null,null,void 0);break;default:t.memoizedState=null}else t.memoizedState=null;return t.child}function jo(e,t){!(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Wo(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Fl|=t.lanes,!(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(a(153));if(null!==t.child){for(n=Ru(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Ru(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Vo(e,t){if(!sa)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function Go(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var s=e.child;null!==s;)n|=s.lanes|s.childLanes,r|=14680064&s.subtreeFlags,r|=14680064&s.flags,s.return=e,s=s.sibling;else for(s=e.child;null!==s;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags,r|=s.flags,s.return=e,s=s.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function Ho(e,t,n){var r=t.pendingProps;switch(ta(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Go(t),null;case 1:case 17:return Rs(t.type)&&As(),Go(t),null;case 3:return r=t.stateNode,Ya(),Ns($s),Ns(Es),ni(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==e&&null!==e.child||(da(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&!(256&t.flags)||(t.flags|=1024,null!==aa&&(au(aa),aa=null))),Oo(e,t),Go(t),null;case 5:Ja(t);var s=Ka(qa.current);if(n=t.type,null!==e&&null!=t.stateNode)Ro(e,t,n,r,s),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(null===t.stateNode)throw Error(a(166));return Go(t),null}if(e=Ka(Ga.current),da(t)){r=t.stateNode,n=t.type;var i=t.memoizedProps;switch(r[hs]=t,r[ps]=i,e=!!(1&t.mode),n){case"dialog":Pr("cancel",r),Pr("close",r);break;case"iframe":case"object":case"embed":Pr("load",r);break;case"video":case"audio":for(s=0;s<Fr.length;s++)Pr(Fr[s],r);break;case"source":Pr("error",r);break;case"img":case"image":case"link":Pr("error",r),Pr("load",r);break;case"details":Pr("toggle",r);break;case"input":Y(r,i),Pr("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!i.multiple},Pr("invalid",r);break;case"textarea":se(r,i),Pr("invalid",r)}for(var l in be(n,i),s=null,i)if(i.hasOwnProperty(l)){var u=i[l];"children"===l?"string"==typeof u?r.textContent!==u&&(!0!==i.suppressHydrationWarning&&Jr(r.textContent,u,e),s=["children",u]):"number"==typeof u&&r.textContent!==""+u&&(!0!==i.suppressHydrationWarning&&Jr(r.textContent,u,e),s=["children",""+u]):o.hasOwnProperty(l)&&null!=u&&"onScroll"===l&&Pr("scroll",r)}switch(n){case"input":H(r),Z(r,i,!0);break;case"textarea":H(r),ie(r);break;case"select":case"option":break;default:"function"==typeof i.onClick&&(r.onclick=Zr)}r=s,t.updateQueue=r,null!==r&&(t.flags|=4)}else{l=9===s.nodeType?s:s.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=oe(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=l.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"==typeof r.is?e=l.createElement(n,{is:r.is}):(e=l.createElement(n),"select"===n&&(l=e,r.multiple?l.multiple=!0:r.size&&(l.size=r.size))):e=l.createElementNS(e,n),e[hs]=t,e[ps]=r,_o(e,t,!1,!1),t.stateNode=e;e:{switch(l=ve(n,r),n){case"dialog":Pr("cancel",e),Pr("close",e),s=r;break;case"iframe":case"object":case"embed":Pr("load",e),s=r;break;case"video":case"audio":for(s=0;s<Fr.length;s++)Pr(Fr[s],e);s=r;break;case"source":Pr("error",e),s=r;break;case"img":case"image":case"link":Pr("error",e),Pr("load",e),s=r;break;case"details":Pr("toggle",e),s=r;break;case"input":Y(e,r),s=X(e,r),Pr("invalid",e);break;case"option":default:s=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},s=L({},r,{value:void 0}),Pr("invalid",e);break;case"textarea":se(e,r),s=re(e,r),Pr("invalid",e)}for(i in be(n,s),u=s)if(u.hasOwnProperty(i)){var c=u[i];"style"===i?ge(e,c):"dangerouslySetInnerHTML"===i?null!=(c=c?c.__html:void 0)&&de(e,c):"children"===i?"string"==typeof c?("textarea"!==n||""!==c)&&he(e,c):"number"==typeof c&&he(e,""+c):"suppressContentEditableWarning"!==i&&"suppressHydrationWarning"!==i&&"autoFocus"!==i&&(o.hasOwnProperty(i)?null!=c&&"onScroll"===i&&Pr("scroll",e):null!=c&&v(e,i,c,l))}switch(n){case"input":H(e),Z(e,r,!1);break;case"textarea":H(e),ie(e);break;case"option":null!=r.value&&e.setAttribute("value",""+V(r.value));break;case"select":e.multiple=!!r.multiple,null!=(i=r.value)?ne(e,!!r.multiple,i,!1):null!=r.defaultValue&&ne(e,!!r.multiple,r.defaultValue,!0);break;default:"function"==typeof s.onClick&&(e.onclick=Zr)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return Go(t),null;case 6:if(e&&null!=t.stateNode)Ao(e,t,e.memoizedProps,r);else{if("string"!=typeof r&&null===t.stateNode)throw Error(a(166));if(n=Ka(qa.current),Ka(Ga.current),da(t)){if(r=t.stateNode,n=t.memoizedProps,r[hs]=t,(i=r.nodeValue!==n)&&null!==(e=na))switch(e.tag){case 3:Jr(r.nodeValue,n,!!(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Jr(r.nodeValue,n,!!(1&e.mode))}i&&(t.flags|=4)}else(r=(9===n.nodeType?n:n.ownerDocument).createTextNode(r))[hs]=t,t.stateNode=r}return Go(t),null;case 13:if(Ns(Za),r=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(sa&&null!==ra&&1&t.mode&&!(128&t.flags))ha(),pa(),t.flags|=98560,i=!1;else if(i=da(t),null!==r&&null!==r.dehydrated){if(null===e){if(!i)throw Error(a(318));if(!(i=null!==(i=t.memoizedState)?i.dehydrated:null))throw Error(a(317));i[hs]=t}else pa(),!(128&t.flags)&&(t.memoizedState=null),t.flags|=4;Go(t),i=!1}else null!==aa&&(au(aa),aa=null),i=!0;if(!i)return 65536&t.flags?t:null}return 128&t.flags?(t.lanes=n,t):((r=null!==r)!==(null!==e&&null!==e.memoizedState)&&r&&(t.child.flags|=8192,1&t.mode&&(null===e||1&Za.current?0===Al&&(Al=3):fu())),null!==t.updateQueue&&(t.flags|=4),Go(t),null);case 4:return Ya(),Oo(e,t),null===e&&jr(t.stateNode.containerInfo),Go(t),null;case 10:return Ca(t.type._context),Go(t),null;case 19:if(Ns(Za),null===(i=t.memoizedState))return Go(t),null;if(r=!!(128&t.flags),null===(l=i.rendering))if(r)Vo(i,!1);else{if(0!==Al||null!==e&&128&e.flags)for(e=t.child;null!==e;){if(null!==(l=ei(e))){for(t.flags|=128,Vo(i,!1),null!==(r=l.updateQueue)&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;null!==n;)e=r,(i=n).flags&=14680066,null===(l=i.alternate)?(i.childLanes=0,i.lanes=e,i.child=null,i.subtreeFlags=0,i.memoizedProps=null,i.memoizedState=null,i.updateQueue=null,i.dependencies=null,i.stateNode=null):(i.childLanes=l.childLanes,i.lanes=l.lanes,i.child=l.child,i.subtreeFlags=0,i.deletions=null,i.memoizedProps=l.memoizedProps,i.memoizedState=l.memoizedState,i.updateQueue=l.updateQueue,i.type=l.type,e=l.dependencies,i.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Ts(Za,1&Za.current|2),t.child}e=e.sibling}null!==i.tail&&Qe()>Ul&&(t.flags|=128,r=!0,Vo(i,!1),t.lanes=4194304)}else{if(!r)if(null!==(e=ei(l))){if(t.flags|=128,r=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),Vo(i,!0),null===i.tail&&"hidden"===i.tailMode&&!l.alternate&&!sa)return Go(t),null}else 2*Qe()-i.renderingStartTime>Ul&&1073741824!==n&&(t.flags|=128,r=!0,Vo(i,!1),t.lanes=4194304);i.isBackwards?(l.sibling=t.child,t.child=l):(null!==(n=i.last)?n.sibling=l:t.child=l,i.last=l)}return null!==i.tail?(t=i.tail,i.rendering=t,i.tail=t.sibling,i.renderingStartTime=Qe(),t.sibling=null,n=Za.current,Ts(Za,r?1&n|2:1&n),t):(Go(t),null);case 22:case 23:return cu(),r=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==r&&(t.flags|=8192),r&&1&t.mode?!!(1073741824&Ol)&&(Go(t),6&t.subtreeFlags&&(t.flags|=8192)):Go(t),null;case 24:case 25:return null}throw Error(a(156,t.tag))}function qo(e,t){switch(ta(t),t.tag){case 1:return Rs(t.type)&&As(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Ya(),Ns($s),Ns(Es),ni(),65536&(e=t.flags)&&!(128&e)?(t.flags=-65537&e|128,t):null;case 5:return Ja(t),null;case 13:if(Ns(Za),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(a(340));pa()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Ns(Za),null;case 4:return Ya(),null;case 10:return Ca(t.type._context),null;case 22:case 23:return cu(),null;default:return null}}_o=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Oo=function(){},Ro=function(e,t,n,r){var s=e.memoizedProps;if(s!==r){e=t.stateNode,Ka(Ga.current);var a,i=null;switch(n){case"input":s=X(e,s),r=X(e,r),i=[];break;case"select":s=L({},s,{value:void 0}),r=L({},r,{value:void 0}),i=[];break;case"textarea":s=re(e,s),r=re(e,r),i=[];break;default:"function"!=typeof s.onClick&&"function"==typeof r.onClick&&(e.onclick=Zr)}for(c in be(n,r),n=null,s)if(!r.hasOwnProperty(c)&&s.hasOwnProperty(c)&&null!=s[c])if("style"===c){var l=s[c];for(a in l)l.hasOwnProperty(a)&&(n||(n={}),n[a]="")}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(o.hasOwnProperty(c)?i||(i=[]):(i=i||[]).push(c,null));for(c in r){var u=r[c];if(l=null!=s?s[c]:void 0,r.hasOwnProperty(c)&&u!==l&&(null!=u||null!=l))if("style"===c)if(l){for(a in l)!l.hasOwnProperty(a)||u&&u.hasOwnProperty(a)||(n||(n={}),n[a]="");for(a in u)u.hasOwnProperty(a)&&l[a]!==u[a]&&(n||(n={}),n[a]=u[a])}else n||(i||(i=[]),i.push(c,n)),n=u;else"dangerouslySetInnerHTML"===c?(u=u?u.__html:void 0,l=l?l.__html:void 0,null!=u&&l!==u&&(i=i||[]).push(c,u)):"children"===c?"string"!=typeof u&&"number"!=typeof u||(i=i||[]).push(c,""+u):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(o.hasOwnProperty(c)?(null!=u&&"onScroll"===c&&Pr("scroll",e),i||l===u||(i=[])):(i=i||[]).push(c,u))}n&&(i=i||[]).push("style",n);var c=i;(t.updateQueue=c)&&(t.flags|=4)}},Ao=function(e,t,n,r){n!==r&&(t.flags|=4)};var Ko=!1,Xo=!1,Yo="function"==typeof WeakSet?WeakSet:Set,Qo=null;function Jo(e,t){var n=e.ref;if(null!==n)if("function"==typeof n)try{n(null)}catch(n){Su(e,t,n)}else n.current=null}function Zo(e,t,n){try{n()}catch(n){Su(e,t,n)}}var el=!1;function tl(e,t,n){var r=t.updateQueue;if(null!==(r=null!==r?r.lastEffect:null)){var s=r=r.next;do{if((s.tag&e)===e){var a=s.destroy;s.destroy=void 0,void 0!==a&&Zo(t,n,a)}s=s.next}while(s!==r)}}function nl(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function rl(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"==typeof t?t(e):t.current=e}}function sl(e){var t=e.alternate;null!==t&&(e.alternate=null,sl(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[hs],delete t[ps],delete t[ms],delete t[gs],delete t[ys])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function al(e){return 5===e.tag||3===e.tag||4===e.tag}function il(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||al(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function ol(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!=(n=n._reactRootContainer)||null!==t.onclick||(t.onclick=Zr));else if(4!==r&&null!==(e=e.child))for(ol(e,t,n),e=e.sibling;null!==e;)ol(e,t,n),e=e.sibling}function ll(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&null!==(e=e.child))for(ll(e,t,n),e=e.sibling;null!==e;)ll(e,t,n),e=e.sibling}var ul=null,cl=!1;function dl(e,t,n){for(n=n.child;null!==n;)hl(e,t,n),n=n.sibling}function hl(e,t,n){if(at&&"function"==typeof at.onCommitFiberUnmount)try{at.onCommitFiberUnmount(st,n)}catch(e){}switch(n.tag){case 5:Xo||Jo(n,t);case 6:var r=ul,s=cl;ul=null,dl(e,t,n),cl=s,null!==(ul=r)&&(cl?(e=ul,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):ul.removeChild(n.stateNode));break;case 18:null!==ul&&(cl?(e=ul,n=n.stateNode,8===e.nodeType?ls(e.parentNode,n):1===e.nodeType&&ls(e,n),jt(e)):ls(ul,n.stateNode));break;case 4:r=ul,s=cl,ul=n.stateNode.containerInfo,cl=!0,dl(e,t,n),ul=r,cl=s;break;case 0:case 11:case 14:case 15:if(!Xo&&(null!==(r=n.updateQueue)&&null!==(r=r.lastEffect))){s=r=r.next;do{var a=s,i=a.destroy;a=a.tag,void 0!==i&&(2&a||4&a)&&Zo(n,t,i),s=s.next}while(s!==r)}dl(e,t,n);break;case 1:if(!Xo&&(Jo(n,t),"function"==typeof(r=n.stateNode).componentWillUnmount))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(e){Su(n,t,e)}dl(e,t,n);break;case 21:dl(e,t,n);break;case 22:1&n.mode?(Xo=(r=Xo)||null!==n.memoizedState,dl(e,t,n),Xo=r):dl(e,t,n);break;default:dl(e,t,n)}}function pl(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Yo),t.forEach((function(t){var r=Cu.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}}function fl(e,t){var n=t.deletions;if(null!==n)for(var r=0;r<n.length;r++){var s=n[r];try{var i=e,o=t,l=o;e:for(;null!==l;){switch(l.tag){case 5:ul=l.stateNode,cl=!1;break e;case 3:case 4:ul=l.stateNode.containerInfo,cl=!0;break e}l=l.return}if(null===ul)throw Error(a(160));hl(i,o,s),ul=null,cl=!1;var u=s.alternate;null!==u&&(u.return=null),s.return=null}catch(e){Su(s,t,e)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)ml(t,e),t=t.sibling}function ml(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(fl(t,e),gl(e),4&r){try{tl(3,e,e.return),nl(3,e)}catch(t){Su(e,e.return,t)}try{tl(5,e,e.return)}catch(t){Su(e,e.return,t)}}break;case 1:fl(t,e),gl(e),512&r&&null!==n&&Jo(n,n.return);break;case 5:if(fl(t,e),gl(e),512&r&&null!==n&&Jo(n,n.return),32&e.flags){var s=e.stateNode;try{he(s,"")}catch(t){Su(e,e.return,t)}}if(4&r&&null!=(s=e.stateNode)){var i=e.memoizedProps,o=null!==n?n.memoizedProps:i,l=e.type,u=e.updateQueue;if(e.updateQueue=null,null!==u)try{"input"===l&&"radio"===i.type&&null!=i.name&&Q(s,i),ve(l,o);var c=ve(l,i);for(o=0;o<u.length;o+=2){var d=u[o],h=u[o+1];"style"===d?ge(s,h):"dangerouslySetInnerHTML"===d?de(s,h):"children"===d?he(s,h):v(s,d,h,c)}switch(l){case"input":J(s,i);break;case"textarea":ae(s,i);break;case"select":var p=s._wrapperState.wasMultiple;s._wrapperState.wasMultiple=!!i.multiple;var f=i.value;null!=f?ne(s,!!i.multiple,f,!1):p!==!!i.multiple&&(null!=i.defaultValue?ne(s,!!i.multiple,i.defaultValue,!0):ne(s,!!i.multiple,i.multiple?[]:"",!1))}s[ps]=i}catch(t){Su(e,e.return,t)}}break;case 6:if(fl(t,e),gl(e),4&r){if(null===e.stateNode)throw Error(a(162));s=e.stateNode,i=e.memoizedProps;try{s.nodeValue=i}catch(t){Su(e,e.return,t)}}break;case 3:if(fl(t,e),gl(e),4&r&&null!==n&&n.memoizedState.isDehydrated)try{jt(t.containerInfo)}catch(t){Su(e,e.return,t)}break;case 4:default:fl(t,e),gl(e);break;case 13:fl(t,e),gl(e),8192&(s=e.child).flags&&(i=null!==s.memoizedState,s.stateNode.isHidden=i,!i||null!==s.alternate&&null!==s.alternate.memoizedState||(Bl=Qe())),4&r&&pl(e);break;case 22:if(d=null!==n&&null!==n.memoizedState,1&e.mode?(Xo=(c=Xo)||d,fl(t,e),Xo=c):fl(t,e),gl(e),8192&r){if(c=null!==e.memoizedState,(e.stateNode.isHidden=c)&&!d&&1&e.mode)for(Qo=e,d=e.child;null!==d;){for(h=Qo=d;null!==Qo;){switch(f=(p=Qo).child,p.tag){case 0:case 11:case 14:case 15:tl(4,p,p.return);break;case 1:Jo(p,p.return);var m=p.stateNode;if("function"==typeof m.componentWillUnmount){r=p,n=p.return;try{t=r,m.props=t.memoizedProps,m.state=t.memoizedState,m.componentWillUnmount()}catch(e){Su(r,n,e)}}break;case 5:Jo(p,p.return);break;case 22:if(null!==p.memoizedState){xl(h);continue}}null!==f?(f.return=p,Qo=f):xl(h)}d=d.sibling}e:for(d=null,h=e;;){if(5===h.tag){if(null===d){d=h;try{s=h.stateNode,c?"function"==typeof(i=s.style).setProperty?i.setProperty("display","none","important"):i.display="none":(l=h.stateNode,o=null!=(u=h.memoizedProps.style)&&u.hasOwnProperty("display")?u.display:null,l.style.display=me("display",o))}catch(t){Su(e,e.return,t)}}}else if(6===h.tag){if(null===d)try{h.stateNode.nodeValue=c?"":h.memoizedProps}catch(t){Su(e,e.return,t)}}else if((22!==h.tag&&23!==h.tag||null===h.memoizedState||h===e)&&null!==h.child){h.child.return=h,h=h.child;continue}if(h===e)break e;for(;null===h.sibling;){if(null===h.return||h.return===e)break e;d===h&&(d=null),h=h.return}d===h&&(d=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:fl(t,e),gl(e),4&r&&pl(e);case 21:}}function gl(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(al(n)){var r=n;break e}n=n.return}throw Error(a(160))}switch(r.tag){case 5:var s=r.stateNode;32&r.flags&&(he(s,""),r.flags&=-33),ll(e,il(e),s);break;case 3:case 4:var i=r.stateNode.containerInfo;ol(e,il(e),i);break;default:throw Error(a(161))}}catch(t){Su(e,e.return,t)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function yl(e,t,n){Qo=e,bl(e,t,n)}function bl(e,t,n){for(var r=!!(1&e.mode);null!==Qo;){var s=Qo,a=s.child;if(22===s.tag&&r){var i=null!==s.memoizedState||Ko;if(!i){var o=s.alternate,l=null!==o&&null!==o.memoizedState||Xo;o=Ko;var u=Xo;if(Ko=i,(Xo=l)&&!u)for(Qo=s;null!==Qo;)l=(i=Qo).child,22===i.tag&&null!==i.memoizedState?wl(s):null!==l?(l.return=i,Qo=l):wl(s);for(;null!==a;)Qo=a,bl(a,t,n),a=a.sibling;Qo=s,Ko=o,Xo=u}vl(e)}else 8772&s.subtreeFlags&&null!==a?(a.return=s,Qo=a):vl(e)}}function vl(e){for(;null!==Qo;){var t=Qo;if(8772&t.flags){var n=t.alternate;try{if(8772&t.flags)switch(t.tag){case 0:case 11:case 15:Xo||nl(5,t);break;case 1:var r=t.stateNode;if(4&t.flags&&!Xo)if(null===n)r.componentDidMount();else{var s=t.elementType===t.type?n.memoizedProps:to(t.type,n.memoizedProps);r.componentDidUpdate(s,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var i=t.updateQueue;null!==i&&Wa(t,i,r);break;case 3:var o=t.updateQueue;if(null!==o){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Wa(t,o,n)}break;case 5:var l=t.stateNode;if(null===n&&4&t.flags){n=l;var u=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":u.autoFocus&&n.focus();break;case"img":u.src&&(n.src=u.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var c=t.alternate;if(null!==c){var d=c.memoizedState;if(null!==d){var h=d.dehydrated;null!==h&&jt(h)}}}break;default:throw Error(a(163))}Xo||512&t.flags&&rl(t)}catch(e){Su(t,t.return,e)}}if(t===e){Qo=null;break}if(null!==(n=t.sibling)){n.return=t.return,Qo=n;break}Qo=t.return}}function xl(e){for(;null!==Qo;){var t=Qo;if(t===e){Qo=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Qo=n;break}Qo=t.return}}function wl(e){for(;null!==Qo;){var t=Qo;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{nl(4,t)}catch(e){Su(t,n,e)}break;case 1:var r=t.stateNode;if("function"==typeof r.componentDidMount){var s=t.return;try{r.componentDidMount()}catch(e){Su(t,s,e)}}var a=t.return;try{rl(t)}catch(e){Su(t,a,e)}break;case 5:var i=t.return;try{rl(t)}catch(e){Su(t,i,e)}}}catch(e){Su(t,t.return,e)}if(t===e){Qo=null;break}var o=t.sibling;if(null!==o){o.return=t.return,Qo=o;break}Qo=t.return}}var kl,Sl=Math.ceil,Il=x.ReactCurrentDispatcher,Nl=x.ReactCurrentOwner,Tl=x.ReactCurrentBatchConfig,Cl=0,El=null,$l=null,_l=0,Ol=0,Rl=Is(0),Al=0,Dl=null,Fl=0,Ml=0,Ll=0,zl=null,Pl=null,Bl=0,Ul=1/0,jl=null,Wl=!1,Vl=null,Gl=null,Hl=!1,ql=null,Kl=0,Xl=0,Yl=null,Ql=-1,Jl=0;function Zl(){return 6&Cl?Qe():-1!==Ql?Ql:Ql=Qe()}function eu(e){return 1&e.mode?2&Cl&&0!==_l?_l&-_l:null!==ma.transition?(0===Jl&&(Jl=mt()),Jl):0!==(e=vt)?e:e=void 0===(e=window.event)?16:Yt(e.type):1}function tu(e,t,n,r){if(50<Xl)throw Xl=0,Yl=null,Error(a(185));yt(e,n,r),2&Cl&&e===El||(e===El&&(!(2&Cl)&&(Ml|=n),4===Al&&iu(e,_l)),nu(e,r),1===n&&0===Cl&&!(1&t.mode)&&(Ul=Qe()+500,Ps&&js()))}function nu(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,s=e.expirationTimes,a=e.pendingLanes;0<a;){var i=31-it(a),o=1<<i,l=s[i];-1===l?o&n&&!(o&r)||(s[i]=pt(o,t)):l<=t&&(e.expiredLanes|=o),a&=~o}}(e,t);var r=ht(e,e===El?_l:0);if(0===r)null!==n&&Ke(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(null!=n&&Ke(n),1===t)0===e.tag?function(e){Ps=!0,Us(e)}(ou.bind(null,e)):Us(ou.bind(null,e)),is((function(){!(6&Cl)&&js()})),n=null;else{switch(xt(r)){case 1:n=Ze;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=rt}n=Eu(n,ru.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function ru(e,t){if(Ql=-1,Jl=0,6&Cl)throw Error(a(327));var n=e.callbackNode;if(wu()&&e.callbackNode!==n)return null;var r=ht(e,e===El?_l:0);if(0===r)return null;if(30&r||r&e.expiredLanes||t)t=mu(e,r);else{t=r;var s=Cl;Cl|=2;var i=pu();for(El===e&&_l===t||(jl=null,Ul=Qe()+500,du(e,t));;)try{yu();break}catch(t){hu(e,t)}Ta(),Il.current=i,Cl=s,null!==$l?t=0:(El=null,_l=0,t=Al)}if(0!==t){if(2===t&&(0!==(s=ft(e))&&(r=s,t=su(e,s))),1===t)throw n=Dl,du(e,0),iu(e,r),nu(e,Qe()),n;if(6===t)iu(e,r);else{if(s=e.current.alternate,!(30&r||function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var r=0;r<n.length;r++){var s=n[r],a=s.getSnapshot;s=s.value;try{if(!or(a(),s))return!1}catch(e){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(s)||(t=mu(e,r),2===t&&(i=ft(e),0!==i&&(r=i,t=su(e,i))),1!==t)))throw n=Dl,du(e,0),iu(e,r),nu(e,Qe()),n;switch(e.finishedWork=s,e.finishedLanes=r,t){case 0:case 1:throw Error(a(345));case 2:case 5:xu(e,Pl,jl);break;case 3:if(iu(e,r),(130023424&r)===r&&10<(t=Bl+500-Qe())){if(0!==ht(e,0))break;if(((s=e.suspendedLanes)&r)!==r){Zl(),e.pingedLanes|=e.suspendedLanes&s;break}e.timeoutHandle=rs(xu.bind(null,e,Pl,jl),t);break}xu(e,Pl,jl);break;case 4:if(iu(e,r),(4194240&r)===r)break;for(t=e.eventTimes,s=-1;0<r;){var o=31-it(r);i=1<<o,(o=t[o])>s&&(s=o),r&=~i}if(r=s,10<(r=(120>(r=Qe()-r)?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*Sl(r/1960))-r)){e.timeoutHandle=rs(xu.bind(null,e,Pl,jl),r);break}xu(e,Pl,jl);break;default:throw Error(a(329))}}}return nu(e,Qe()),e.callbackNode===n?ru.bind(null,e):null}function su(e,t){var n=zl;return e.current.memoizedState.isDehydrated&&(du(e,t).flags|=256),2!==(e=mu(e,t))&&(t=Pl,Pl=n,null!==t&&au(t)),e}function au(e){null===Pl?Pl=e:Pl.push.apply(Pl,e)}function iu(e,t){for(t&=~Ll,t&=~Ml,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-it(t),r=1<<n;e[n]=-1,t&=~r}}function ou(e){if(6&Cl)throw Error(a(327));wu();var t=ht(e,0);if(!(1&t))return nu(e,Qe()),null;var n=mu(e,t);if(0!==e.tag&&2===n){var r=ft(e);0!==r&&(t=r,n=su(e,r))}if(1===n)throw n=Dl,du(e,0),iu(e,t),nu(e,Qe()),n;if(6===n)throw Error(a(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,xu(e,Pl,jl),nu(e,Qe()),null}function lu(e,t){var n=Cl;Cl|=1;try{return e(t)}finally{0===(Cl=n)&&(Ul=Qe()+500,Ps&&js())}}function uu(e){null!==ql&&0===ql.tag&&!(6&Cl)&&wu();var t=Cl;Cl|=1;var n=Tl.transition,r=vt;try{if(Tl.transition=null,vt=1,e)return e()}finally{vt=r,Tl.transition=n,!(6&(Cl=t))&&js()}}function cu(){Ol=Rl.current,Ns(Rl)}function du(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,ss(n)),null!==$l)for(n=$l.return;null!==n;){var r=n;switch(ta(r),r.tag){case 1:null!=(r=r.type.childContextTypes)&&As();break;case 3:Ya(),Ns($s),Ns(Es),ni();break;case 5:Ja(r);break;case 4:Ya();break;case 13:case 19:Ns(Za);break;case 10:Ca(r.type._context);break;case 22:case 23:cu()}n=n.return}if(El=e,$l=e=Ru(e.current,null),_l=Ol=t,Al=0,Dl=null,Ll=Ml=Fl=0,Pl=zl=null,null!==Oa){for(t=0;t<Oa.length;t++)if(null!==(r=(n=Oa[t]).interleaved)){n.interleaved=null;var s=r.next,a=n.pending;if(null!==a){var i=a.next;a.next=s,r.next=i}n.pending=r}Oa=null}return e}function hu(e,t){for(;;){var n=$l;try{if(Ta(),ri.current=Qi,ui){for(var r=ii.memoizedState;null!==r;){var s=r.queue;null!==s&&(s.pending=null),r=r.next}ui=!1}if(ai=0,li=oi=ii=null,ci=!1,di=0,Nl.current=null,null===n||null===n.return){Al=1,Dl=t,$l=null;break}e:{var i=e,o=n.return,l=n,u=t;if(t=_l,l.flags|=32768,null!==u&&"object"==typeof u&&"function"==typeof u.then){var c=u,d=l,h=d.tag;if(!(1&d.mode||0!==h&&11!==h&&15!==h)){var p=d.alternate;p?(d.updateQueue=p.updateQueue,d.memoizedState=p.memoizedState,d.lanes=p.lanes):(d.updateQueue=null,d.memoizedState=null)}var f=mo(o);if(null!==f){f.flags&=-257,go(f,o,l,0,t),1&f.mode&&fo(i,c,t),u=c;var m=(t=f).updateQueue;if(null===m){var g=new Set;g.add(u),t.updateQueue=g}else m.add(u);break e}if(!(1&t)){fo(i,c,t),fu();break e}u=Error(a(426))}else if(sa&&1&l.mode){var y=mo(o);if(null!==y){!(65536&y.flags)&&(y.flags|=256),go(y,o,l,0,t),fa(lo(u,l));break e}}i=u=lo(u,l),4!==Al&&(Al=2),null===zl?zl=[i]:zl.push(i),i=o;do{switch(i.tag){case 3:i.flags|=65536,t&=-t,i.lanes|=t,Ua(i,ho(0,u,t));break e;case 1:l=u;var b=i.type,v=i.stateNode;if(!(128&i.flags||"function"!=typeof b.getDerivedStateFromError&&(null===v||"function"!=typeof v.componentDidCatch||null!==Gl&&Gl.has(v)))){i.flags|=65536,t&=-t,i.lanes|=t,Ua(i,po(i,l,t));break e}}i=i.return}while(null!==i)}vu(n)}catch(e){t=e,$l===n&&null!==n&&($l=n=n.return);continue}break}}function pu(){var e=Il.current;return Il.current=Qi,null===e?Qi:e}function fu(){0!==Al&&3!==Al&&2!==Al||(Al=4),null===El||!(268435455&Fl)&&!(268435455&Ml)||iu(El,_l)}function mu(e,t){var n=Cl;Cl|=2;var r=pu();for(El===e&&_l===t||(jl=null,du(e,t));;)try{gu();break}catch(t){hu(e,t)}if(Ta(),Cl=n,Il.current=r,null!==$l)throw Error(a(261));return El=null,_l=0,Al}function gu(){for(;null!==$l;)bu($l)}function yu(){for(;null!==$l&&!Xe();)bu($l)}function bu(e){var t=kl(e.alternate,e,Ol);e.memoizedProps=e.pendingProps,null===t?vu(e):$l=t,Nl.current=null}function vu(e){var t=e;do{var n=t.alternate;if(e=t.return,32768&t.flags){if(null!==(n=qo(n,t)))return n.flags&=32767,void($l=n);if(null===e)return Al=6,void($l=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}else if(null!==(n=Ho(n,t,Ol)))return void($l=n);if(null!==(t=t.sibling))return void($l=t);$l=t=e}while(null!==t);0===Al&&(Al=5)}function xu(e,t,n){var r=vt,s=Tl.transition;try{Tl.transition=null,vt=1,function(e,t,n,r){do{wu()}while(null!==ql);if(6&Cl)throw Error(a(327));n=e.finishedWork;var s=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(a(177));e.callbackNode=null,e.callbackPriority=0;var i=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var s=31-it(n),a=1<<s;t[s]=0,r[s]=-1,e[s]=-1,n&=~a}}(e,i),e===El&&($l=El=null,_l=0),!(2064&n.subtreeFlags)&&!(2064&n.flags)||Hl||(Hl=!0,Eu(tt,(function(){return wu(),null}))),i=!!(15990&n.flags),!!(15990&n.subtreeFlags)||i){i=Tl.transition,Tl.transition=null;var o=vt;vt=1;var l=Cl;Cl|=4,Nl.current=null,function(e,t){if(es=Vt,pr(e=hr())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var r=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var s=r.anchorOffset,i=r.focusNode;r=r.focusOffset;try{n.nodeType,i.nodeType}catch(e){n=null;break e}var o=0,l=-1,u=-1,c=0,d=0,h=e,p=null;t:for(;;){for(var f;h!==n||0!==s&&3!==h.nodeType||(l=o+s),h!==i||0!==r&&3!==h.nodeType||(u=o+r),3===h.nodeType&&(o+=h.nodeValue.length),null!==(f=h.firstChild);)p=h,h=f;for(;;){if(h===e)break t;if(p===n&&++c===s&&(l=o),p===i&&++d===r&&(u=o),null!==(f=h.nextSibling))break;p=(h=p).parentNode}h=f}n=-1===l||-1===u?null:{start:l,end:u}}else n=null}n=n||{start:0,end:0}}else n=null;for(ts={focusedElem:e,selectionRange:n},Vt=!1,Qo=t;null!==Qo;)if(e=(t=Qo).child,1028&t.subtreeFlags&&null!==e)e.return=t,Qo=e;else for(;null!==Qo;){t=Qo;try{var m=t.alternate;if(1024&t.flags)switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==m){var g=m.memoizedProps,y=m.memoizedState,b=t.stateNode,v=b.getSnapshotBeforeUpdate(t.elementType===t.type?g:to(t.type,g),y);b.__reactInternalSnapshotBeforeUpdate=v}break;case 3:var x=t.stateNode.containerInfo;1===x.nodeType?x.textContent="":9===x.nodeType&&x.documentElement&&x.removeChild(x.documentElement);break;default:throw Error(a(163))}}catch(e){Su(t,t.return,e)}if(null!==(e=t.sibling)){e.return=t.return,Qo=e;break}Qo=t.return}m=el,el=!1}(e,n),ml(n,e),fr(ts),Vt=!!es,ts=es=null,e.current=n,yl(n,e,s),Ye(),Cl=l,vt=o,Tl.transition=i}else e.current=n;if(Hl&&(Hl=!1,ql=e,Kl=s),i=e.pendingLanes,0===i&&(Gl=null),function(e){if(at&&"function"==typeof at.onCommitFiberRoot)try{at.onCommitFiberRoot(st,e,void 0,!(128&~e.current.flags))}catch(e){}}(n.stateNode),nu(e,Qe()),null!==t)for(r=e.onRecoverableError,n=0;n<t.length;n++)s=t[n],r(s.value,{componentStack:s.stack,digest:s.digest});if(Wl)throw Wl=!1,e=Vl,Vl=null,e;!!(1&Kl)&&0!==e.tag&&wu(),i=e.pendingLanes,1&i?e===Yl?Xl++:(Xl=0,Yl=e):Xl=0,js()}(e,t,n,r)}finally{Tl.transition=s,vt=r}return null}function wu(){if(null!==ql){var e=xt(Kl),t=Tl.transition,n=vt;try{if(Tl.transition=null,vt=16>e?16:e,null===ql)var r=!1;else{if(e=ql,ql=null,Kl=0,6&Cl)throw Error(a(331));var s=Cl;for(Cl|=4,Qo=e.current;null!==Qo;){var i=Qo,o=i.child;if(16&Qo.flags){var l=i.deletions;if(null!==l){for(var u=0;u<l.length;u++){var c=l[u];for(Qo=c;null!==Qo;){var d=Qo;switch(d.tag){case 0:case 11:case 15:tl(8,d,i)}var h=d.child;if(null!==h)h.return=d,Qo=h;else for(;null!==Qo;){var p=(d=Qo).sibling,f=d.return;if(sl(d),d===c){Qo=null;break}if(null!==p){p.return=f,Qo=p;break}Qo=f}}}var m=i.alternate;if(null!==m){var g=m.child;if(null!==g){m.child=null;do{var y=g.sibling;g.sibling=null,g=y}while(null!==g)}}Qo=i}}if(2064&i.subtreeFlags&&null!==o)o.return=i,Qo=o;else e:for(;null!==Qo;){if(2048&(i=Qo).flags)switch(i.tag){case 0:case 11:case 15:tl(9,i,i.return)}var b=i.sibling;if(null!==b){b.return=i.return,Qo=b;break e}Qo=i.return}}var v=e.current;for(Qo=v;null!==Qo;){var x=(o=Qo).child;if(2064&o.subtreeFlags&&null!==x)x.return=o,Qo=x;else e:for(o=v;null!==Qo;){if(2048&(l=Qo).flags)try{switch(l.tag){case 0:case 11:case 15:nl(9,l)}}catch(e){Su(l,l.return,e)}if(l===o){Qo=null;break e}var w=l.sibling;if(null!==w){w.return=l.return,Qo=w;break e}Qo=l.return}}if(Cl=s,js(),at&&"function"==typeof at.onPostCommitFiberRoot)try{at.onPostCommitFiberRoot(st,e)}catch(e){}r=!0}return r}finally{vt=n,Tl.transition=t}}return!1}function ku(e,t,n){e=Pa(e,t=ho(0,t=lo(n,t),1),1),t=Zl(),null!==e&&(yt(e,1,t),nu(e,t))}function Su(e,t,n){if(3===e.tag)ku(e,e,n);else for(;null!==t;){if(3===t.tag){ku(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"==typeof t.type.getDerivedStateFromError||"function"==typeof r.componentDidCatch&&(null===Gl||!Gl.has(r))){t=Pa(t,e=po(t,e=lo(n,e),1),1),e=Zl(),null!==t&&(yt(t,1,e),nu(t,e));break}}t=t.return}}function Iu(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),t=Zl(),e.pingedLanes|=e.suspendedLanes&n,El===e&&(_l&n)===n&&(4===Al||3===Al&&(130023424&_l)===_l&&500>Qe()-Bl?du(e,0):Ll|=n),nu(e,t)}function Nu(e,t){0===t&&(1&e.mode?(t=ct,!(130023424&(ct<<=1))&&(ct=4194304)):t=1);var n=Zl();null!==(e=Da(e,t))&&(yt(e,t,n),nu(e,n))}function Tu(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Nu(e,n)}function Cu(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,s=e.memoizedState;null!==s&&(n=s.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(a(314))}null!==r&&r.delete(t),Nu(e,n)}function Eu(e,t){return qe(e,t)}function $u(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function _u(e,t,n,r){return new $u(e,t,n,r)}function Ou(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Ru(e,t){var n=e.alternate;return null===n?((n=_u(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Au(e,t,n,r,s,i){var o=2;if(r=e,"function"==typeof e)Ou(e)&&(o=1);else if("string"==typeof e)o=5;else e:switch(e){case S:return Du(n.children,s,i,t);case I:o=8,s|=8;break;case N:return(e=_u(12,n,t,2|s)).elementType=N,e.lanes=i,e;case $:return(e=_u(13,n,t,s)).elementType=$,e.lanes=i,e;case _:return(e=_u(19,n,t,s)).elementType=_,e.lanes=i,e;case A:return Fu(n,s,i,t);default:if("object"==typeof e&&null!==e)switch(e.$$typeof){case T:o=10;break e;case C:o=9;break e;case E:o=11;break e;case O:o=14;break e;case R:o=16,r=null;break e}throw Error(a(130,null==e?e:typeof e,""))}return(t=_u(o,n,t,s)).elementType=e,t.type=r,t.lanes=i,t}function Du(e,t,n,r){return(e=_u(7,e,r,t)).lanes=n,e}function Fu(e,t,n,r){return(e=_u(22,e,r,t)).elementType=A,e.lanes=n,e.stateNode={isHidden:!1},e}function Mu(e,t,n){return(e=_u(6,e,null,t)).lanes=n,e}function Lu(e,t,n){return(t=_u(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function zu(e,t,n,r,s){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gt(0),this.expirationTimes=gt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gt(0),this.identifierPrefix=r,this.onRecoverableError=s,this.mutableSourceEagerHydrationData=null}function Pu(e,t,n,r,s,a,i,o,l){return e=new zu(e,t,n,o,l),1===t?(t=1,!0===a&&(t|=8)):t=0,a=_u(3,null,null,t),e.current=a,a.stateNode=e,a.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Ma(a),e}function Bu(e){if(!e)return Cs;e:{if(je(e=e._reactInternals)!==e||1!==e.tag)throw Error(a(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Rs(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(a(171))}if(1===e.tag){var n=e.type;if(Rs(n))return Fs(e,n,t)}return t}function Uu(e,t,n,r,s,a,i,o,l){return(e=Pu(n,r,!0,e,0,a,0,o,l)).context=Bu(null),n=e.current,(a=za(r=Zl(),s=eu(n))).callback=null!=t?t:null,Pa(n,a,s),e.current.lanes=s,yt(e,s,r),nu(e,r),e}function ju(e,t,n,r){var s=t.current,a=Zl(),i=eu(s);return n=Bu(n),null===t.context?t.context=n:t.pendingContext=n,(t=za(a,i)).payload={element:e},null!==(r=void 0===r?null:r)&&(t.callback=r),null!==(e=Pa(s,t,i))&&(tu(e,s,i,a),Ba(e,s,i)),i}function Wu(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Vu(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Gu(e,t){Vu(e,t),(e=e.alternate)&&Vu(e,t)}kl=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||$s.current)bo=!0;else{if(!(e.lanes&n||128&t.flags))return bo=!1,function(e,t,n){switch(t.tag){case 3:Eo(t),pa();break;case 5:Qa(t);break;case 1:Rs(t.type)&&Ms(t);break;case 4:Xa(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,s=t.memoizedProps.value;Ts(ka,r._currentValue),r._currentValue=s;break;case 13:if(null!==(r=t.memoizedState))return null!==r.dehydrated?(Ts(Za,1&Za.current),t.flags|=128,null):n&t.child.childLanes?Mo(e,t,n):(Ts(Za,1&Za.current),null!==(e=Wo(e,t,n))?e.sibling:null);Ts(Za,1&Za.current);break;case 19:if(r=!!(n&t.childLanes),128&e.flags){if(r)return Uo(e,t,n);t.flags|=128}if(null!==(s=t.memoizedState)&&(s.rendering=null,s.tail=null,s.lastEffect=null),Ts(Za,Za.current),r)break;return null;case 22:case 23:return t.lanes=0,So(e,t,n)}return Wo(e,t,n)}(e,t,n);bo=!!(131072&e.flags)}else bo=!1,sa&&1048576&t.flags&&Zs(t,Hs,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;jo(e,t),e=t.pendingProps;var s=Os(t,Es.current);$a(t,n),s=mi(null,t,r,e,s,n);var i=gi();return t.flags|=1,"object"==typeof s&&null!==s&&"function"==typeof s.render&&void 0===s.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Rs(r)?(i=!0,Ms(t)):i=!1,t.memoizedState=null!==s.state&&void 0!==s.state?s.state:null,Ma(t),s.updater=ro,t.stateNode=s,s._reactInternals=t,oo(t,r,e,n),t=Co(null,t,r,!0,i,n)):(t.tag=0,sa&&i&&ea(t),vo(null,t,s,n),t=t.child),t;case 16:r=t.elementType;e:{switch(jo(e,t),e=t.pendingProps,r=(s=r._init)(r._payload),t.type=r,s=t.tag=function(e){if("function"==typeof e)return Ou(e)?1:0;if(null!=e){if((e=e.$$typeof)===E)return 11;if(e===O)return 14}return 2}(r),e=to(r,e),s){case 0:t=No(null,t,r,e,n);break e;case 1:t=To(null,t,r,e,n);break e;case 11:t=xo(null,t,r,e,n);break e;case 14:t=wo(null,t,r,to(r.type,e),n);break e}throw Error(a(306,r,""))}return t;case 0:return r=t.type,s=t.pendingProps,No(e,t,r,s=t.elementType===r?s:to(r,s),n);case 1:return r=t.type,s=t.pendingProps,To(e,t,r,s=t.elementType===r?s:to(r,s),n);case 3:e:{if(Eo(t),null===e)throw Error(a(387));r=t.pendingProps,s=(i=t.memoizedState).element,La(e,t),ja(t,r,null,n);var o=t.memoizedState;if(r=o.element,i.isDehydrated){if(i={element:r,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=i,t.memoizedState=i,256&t.flags){t=$o(e,t,r,n,s=lo(Error(a(423)),t));break e}if(r!==s){t=$o(e,t,r,n,s=lo(Error(a(424)),t));break e}for(ra=us(t.stateNode.containerInfo.firstChild),na=t,sa=!0,aa=null,n=wa(t,null,r,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(pa(),r===s){t=Wo(e,t,n);break e}vo(e,t,r,n)}t=t.child}return t;case 5:return Qa(t),null===e&&ua(t),r=t.type,s=t.pendingProps,i=null!==e?e.memoizedProps:null,o=s.children,ns(r,s)?o=null:null!==i&&ns(r,i)&&(t.flags|=32),Io(e,t),vo(e,t,o,n),t.child;case 6:return null===e&&ua(t),null;case 13:return Mo(e,t,n);case 4:return Xa(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=xa(t,null,r,n):vo(e,t,r,n),t.child;case 11:return r=t.type,s=t.pendingProps,xo(e,t,r,s=t.elementType===r?s:to(r,s),n);case 7:return vo(e,t,t.pendingProps,n),t.child;case 8:case 12:return vo(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,s=t.pendingProps,i=t.memoizedProps,o=s.value,Ts(ka,r._currentValue),r._currentValue=o,null!==i)if(or(i.value,o)){if(i.children===s.children&&!$s.current){t=Wo(e,t,n);break e}}else for(null!==(i=t.child)&&(i.return=t);null!==i;){var l=i.dependencies;if(null!==l){o=i.child;for(var u=l.firstContext;null!==u;){if(u.context===r){if(1===i.tag){(u=za(-1,n&-n)).tag=2;var c=i.updateQueue;if(null!==c){var d=(c=c.shared).pending;null===d?u.next=u:(u.next=d.next,d.next=u),c.pending=u}}i.lanes|=n,null!==(u=i.alternate)&&(u.lanes|=n),Ea(i.return,n,t),l.lanes|=n;break}u=u.next}}else if(10===i.tag)o=i.type===t.type?null:i.child;else if(18===i.tag){if(null===(o=i.return))throw Error(a(341));o.lanes|=n,null!==(l=o.alternate)&&(l.lanes|=n),Ea(o,n,t),o=i.sibling}else o=i.child;if(null!==o)o.return=i;else for(o=i;null!==o;){if(o===t){o=null;break}if(null!==(i=o.sibling)){i.return=o.return,o=i;break}o=o.return}i=o}vo(e,t,s.children,n),t=t.child}return t;case 9:return s=t.type,r=t.pendingProps.children,$a(t,n),r=r(s=_a(s)),t.flags|=1,vo(e,t,r,n),t.child;case 14:return s=to(r=t.type,t.pendingProps),wo(e,t,r,s=to(r.type,s),n);case 15:return ko(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:to(r,s),jo(e,t),t.tag=1,Rs(r)?(e=!0,Ms(t)):e=!1,$a(t,n),ao(t,r,s),oo(t,r,s,n),Co(null,t,r,!0,e,n);case 19:return Uo(e,t,n);case 22:return So(e,t,n)}throw Error(a(156,t.tag))};var Hu="function"==typeof reportError?reportError:function(e){};function qu(e){this._internalRoot=e}function Ku(e){this._internalRoot=e}function Xu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Yu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Qu(){}function Ju(e,t,n,r,s){var a=n._reactRootContainer;if(a){var i=a;if("function"==typeof s){var o=s;s=function(){var e=Wu(i);o.call(e)}}ju(t,i,e,s)}else i=function(e,t,n,r,s){if(s){if("function"==typeof r){var a=r;r=function(){var e=Wu(i);a.call(e)}}var i=Uu(t,r,e,0,null,!1,0,"",Qu);return e._reactRootContainer=i,e[fs]=i.current,jr(8===e.nodeType?e.parentNode:e),uu(),i}for(;s=e.lastChild;)e.removeChild(s);if("function"==typeof r){var o=r;r=function(){var e=Wu(l);o.call(e)}}var l=Pu(e,0,!1,null,0,!1,0,"",Qu);return e._reactRootContainer=l,e[fs]=l.current,jr(8===e.nodeType?e.parentNode:e),uu((function(){ju(t,l,n,r)})),l}(n,t,e,s,r);return Wu(i)}Ku.prototype.render=qu.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(a(409));ju(e,t,null,null)},Ku.prototype.unmount=qu.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;uu((function(){ju(null,e,null,null)})),t[fs]=null}},Ku.prototype.unstable_scheduleHydration=function(e){if(e){var t=It();e={blockedOn:null,target:e,priority:t};for(var n=0;n<At.length&&0!==t&&t<At[n].priority;n++);At.splice(n,0,e),0===n&&Lt(e)}},wt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=dt(t.pendingLanes);0!==n&&(bt(t,1|n),nu(t,Qe()),!(6&Cl)&&(Ul=Qe()+500,js()))}break;case 13:uu((function(){var t=Da(e,1);if(null!==t){var n=Zl();tu(t,e,1,n)}})),Gu(e,1)}},kt=function(e){if(13===e.tag){var t=Da(e,134217728);if(null!==t)tu(t,e,134217728,Zl());Gu(e,134217728)}},St=function(e){if(13===e.tag){var t=eu(e),n=Da(e,t);if(null!==n)tu(n,e,t,Zl());Gu(e,t)}},It=function(){return vt},Nt=function(e,t){var n=vt;try{return vt=e,t()}finally{vt=n}},ke=function(e,t,n){switch(t){case"input":if(J(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var s=ws(r);if(!s)throw Error(a(90));q(r),J(r,s)}}}break;case"textarea":ae(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Ee=lu,$e=uu;var Zu={usingClientEntryPoint:!1,Events:[vs,xs,ws,Te,Ce,lu]},ec={findFiberByHostInstance:bs,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},tc={bundleType:ec.bundleType,version:ec.version,rendererPackageName:ec.rendererPackageName,rendererConfig:ec.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:x.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Ge(e))?null:e.stateNode},findFiberByHostInstance:ec.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var nc=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!nc.isDisabled&&nc.supportsFiber)try{st=nc.inject(tc),at=nc}catch(ce){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Zu,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Xu(t))throw Error(a(200));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Xu(e))throw Error(a(299));var n=!1,r="",s=Hu;return null!=t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onRecoverableError&&(s=t.onRecoverableError)),t=Pu(e,1,!1,null,0,n,0,r,s),e[fs]=t.current,jr(8===e.nodeType?e.parentNode:e),new qu(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"==typeof e.render)throw Error(a(188));throw e=Object.keys(e).join(","),Error(a(268,e))}return e=null===(e=Ge(t))?null:e.stateNode},t.flushSync=function(e){return uu(e)},t.hydrate=function(e,t,n){if(!Yu(t))throw Error(a(200));return Ju(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Xu(e))throw Error(a(405));var r=null!=n&&n.hydratedSources||null,s=!1,i="",o=Hu;if(null!=n&&(!0===n.unstable_strictMode&&(s=!0),void 0!==n.identifierPrefix&&(i=n.identifierPrefix),void 0!==n.onRecoverableError&&(o=n.onRecoverableError)),t=Uu(t,null,e,1,null!=n?n:null,s,0,i,o),e[fs]=t.current,jr(e),r)for(e=0;e<r.length;e++)s=(s=(n=r[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,s]:t.mutableSourceEagerHydrationData.push(n,s);return new Ku(t)},t.render=function(e,t,n){if(!Yu(t))throw Error(a(200));return Ju(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Yu(e))throw Error(a(40));return!!e._reactRootContainer&&(uu((function(){Ju(null,null,e,!1,(function(){e._reactRootContainer=null,e[fs]=null}))})),!0)},t.unstable_batchedUpdates=lu,t.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!Yu(n))throw Error(a(200));if(null==e||void 0===e._reactInternals)throw Error(a(38));return Ju(e,t,n,!1,r)},t.version="18.3.1-next-f1338f8080-20240426"},570:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},a={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=a[e])?r:(n=l(e,(0|e)<0?-1:0,!0),i&&(a[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=l(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function o(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?o(-e,t).neg():l(e%h|0,e/h|0,t)}function l(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var s=o(u(n,8)),a=g,i=0;i<e.length;i+=8){var l=Math.min(8,e.length-i),d=parseInt(e.substring(i,i+l),n);if(l<8){var h=o(u(n,l));a=a.mul(h).add(o(d))}else a=(a=a.mul(s)).add(o(d))}return a.unsigned=t,a}function d(e,t){return"number"==typeof e?o(e,t):"string"==typeof e?c(e,t):l(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=d;var h=4294967296,p=h*h,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var b=i(1);n.ONE=b;var v=i(1,!0);n.UONE=v;var x=i(-1);n.NEG_ONE=x;var w=l(-1,2147483647,!1);n.MAX_VALUE=w;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},I.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=o(u(e,6),this.unsigned),a=this,i="";;){var l=a.div(s),c=(a.sub(l.mul(s)).toInt()>>>0).toString(e);if((a=l).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return!(1&~this.low)},I.isEven=function(){return!(1&this.low)},I.equals=function(e){return r(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&(this.high===e.high&&this.low===e.low)},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(r(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},I.neg=I.negate,I.add=function(e){r(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,s=this.low>>>16,a=65535&this.low,i=e.high>>>16,o=65535&e.high,u=e.low>>>16,c=0,h=0,p=0,f=0;return p+=(f+=a+(65535&e.low))>>>16,h+=(p+=s+u)>>>16,c+=(h+=n+o)>>>16,c+=t+i,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(h&=65535),this.unsigned)},I.subtract=function(e){return r(e)||(e=d(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=d(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,a=this.low>>>16,i=65535&this.low,u=e.high>>>16,c=65535&e.high,h=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,v=0;return b+=(v+=i*p)>>>16,y+=(b+=a*p)>>>16,b&=65535,y+=(b+=i*h)>>>16,f+=(y+=s*p)>>>16,y&=65535,f+=(y+=a*h)>>>16,y&=65535,f+=(y+=i*c)>>>16,f+=n*p+s*h+a*c+i*u,l((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(r(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,s,a;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return v;a=y}else{if(this.eq(S))return e.eq(b)||e.eq(x)?S:e.eq(S)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:x:(s=this.sub(e.mul(n)),a=n.add(s.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:u(2,i-48),h=o(n),p=h.mul(e);p.isNegative()||p.gt(s);)p=(h=o(n-=c,this.unsigned)).mul(e);h.isZero()&&(h=b),a=a.add(h),s=s.sub(p)}return a},I.div=I.divide,I.modulo=function(e){return r(e)||(e=d(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return l(~this.low,~this.high,this.unsigned)},I.and=function(e){return r(e)||(e=d(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return r(e)||(e=d(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return r(e)||(e=d(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},590:()=>{},717:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.tychei=o}(0,e=n.nmd(e),n.amdD)},801:function(e,t,n){var r;!function(s,a,i){var o,l=256,u=i.pow(l,6),c=i.pow(2,52),d=2*c,h=255;function p(e,t,n){var r=[],h=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(a)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(l):(e=new Uint8Array(l),(s.crypto||s.msCrypto).getRandomValues(e)),b(e)}catch(e){var t=s.navigator,n=t&&t.plugins;return[+new Date,s,n,s.screen,b(a)]}}():e,3),r),p=new f(r),v=function(){for(var e=p.g(6),t=u,n=0;e<c;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,y(b(p.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(v,h,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,s=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);s<l;)i[s]=s++;for(s=0;s<l;s++)i[s]=i[a=h&a+e[s%n]+(t=i[s])],i[a]=t;(r.g=function(e){for(var t,n=0,s=r.i,a=r.j,i=r.S;e--;)t=i[s=h&s+1],n=n*l+i[h&(i[s]=i[a=h&a+t])+(i[a]=t)];return r.i=s,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(e){}return r.length?r:"string"==s?e:e+"\0"}function y(e,t){for(var n,r=e+"",s=0;s<r.length;)t[h&s]=h&(n^=19*t[h&s])+r.charCodeAt(s++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(i.random(),a),e.exports){e.exports=p;try{o=n(234)}catch(e){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},817:()=>{},833:function(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,a=t.i;return t.w=r=r+1640531527|0,n=s[a+34&127],e=s[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,s,a,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),s=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,s=0==(n=o[127&a]^=r+i)?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,a=512;a>0;--a)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;e.w=i,e.X=o,e.i=s}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor4096=o}(0,e=n.nmd(e),n.amdD)},848:(e,t,n)=>{"use strict";e.exports=n(20)},888:(e,t,n)=>{"use strict";e.exports=n(493)},932:()=>{},942:(e,t)=>{var n;!function(){"use strict";var r={}.hasOwnProperty;function s(){for(var e="",t=0;t<arguments.length;t++){var n=arguments[t];n&&(e=i(e,a(n)))}return e}function a(e){if("string"==typeof e||"number"==typeof e)return e;if("object"!=typeof e)return"";if(Array.isArray(e))return s.apply(null,e);if(e.toString!==Object.prototype.toString&&!e.toString.toString().includes("[native code]"))return e.toString();var t="";for(var n in e)r.call(e,n)&&e[n]&&(t=i(t,n));return t}function i(e,t){return t?e?e+" "+t:e+t:e}e.exports?(s.default=s,e.exports=s):void 0===(n=function(){return s}.apply(t,[]))||(e.exports=n)}()},961:(e,t,n)=>{"use strict";!function e(){if("undefined"!=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(e){}}(),e.exports=n(551)},982:(e,t,n)=>{"use strict";e.exports=n(463)}},t={};function n(r){var s=t[r];if(void 0!==s)return s.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e);var r={};return(()=>{"use strict";n.r(r),n.d(r,{default:()=>TK});var e={};n.r(e),n.d(e,{arraysEqual:()=>zn,arraysEqualWithNull:()=>Ln,assert:()=>Rn,assertNonNegativeIntegerDimensions:()=>fr,assertNonNull:()=>Dn,assertShapesMatch:()=>An,bytesFromStringArray:()=>er,bytesPerElement:()=>Zn,checkConversionForErrors:()=>Yn,clamp:()=>Tn,computeStrides:()=>or,convertBackendValuesAndArrayBuffer:()=>cr,createScalarValue:()=>vo,createShuffledIndices:()=>jn,decodeString:()=>Io,distSquared:()=>On,encodeString:()=>So,fetch:()=>ko,fingerPrint64:()=>bo,flatten:()=>To,getArrayFromDType:()=>Xn,getTypedArrayFromDType:()=>Kn,hasEncodingLoss:()=>Jn,hexToLong:()=>io,indexToLoc:()=>gr,inferDtype:()=>sr,inferFromImplicitShape:()=>Gn,isBoolean:()=>nr,isFunction:()=>ar,isInt:()=>Pn,isNumber:()=>rr,isPromise:()=>yr,isScalarShape:()=>Mn,isString:()=>tr,isTypedArray:()=>No,isValidDtype:()=>Qn,locToIndex:()=>mr,makeOnesTypedArray:()=>dr,makeZerosNestedTypedArray:()=>pr,makeZerosTypedArray:()=>hr,nearestDivisor:()=>ir,nearestLargerEven:()=>Cn,now:()=>wo,parseAxisParam:()=>Hn,randUniform:()=>_n,repeatedTry:()=>Vn,rightPad:()=>Wn,shuffle:()=>In,shuffleCombo:()=>Nn,sizeFromShape:()=>Fn,sizeToSquarishShape:()=>Un,squeezeShape:()=>qn,sum:()=>$n,swap:()=>En,tanh:()=>Bn,toNestedArray:()=>ur,toTypedArray:()=>xo});var t={};n.r(t),n.d(t,{assertTypesMatch:()=>Zo,getTensorsInContainer:()=>tl,isTensorInList:()=>el,makeTypesMatch:()=>Jo});var s={};n.r(s),n.d(s,{isBrowser:()=>hl,isMobile:()=>dl,mockIsMobile:()=>cl});var a={};n.r(a),n.d(a,{Serializable:()=>gc,SerializationMap:()=>yc,getRegisteredName:()=>vc,registerClass:()=>bc});var i={};n.r(i),n.d(i,{assertAndGetBroadcastShape:()=>_c,getBroadcastDims:()=>Ec,getReductionAxes:()=>$c});var o={};n.r(o),n.d(o,{CompositeArrayBuffer:()=>Nl,browserFiles:()=>Bc,browserHTTPRequest:()=>Xc,concatenateArrayBuffers:()=>su,copyModel:()=>Wu,decodeWeights:()=>Xl,decodeWeightsStream:()=>eu,encodeWeights:()=>Kl,fromMemory:()=>Zc,fromMemorySync:()=>ed,getLoadHandlers:()=>mu,getModelArtifactsForJSON:()=>lu,getModelArtifactsForJSONSync:()=>ou,getModelArtifactsInfoForJSON:()=>uu,getSaveHandlers:()=>fu,getWeightSpecs:()=>cu,http:()=>Kc,isHTTPScheme:()=>Hc,listModels:()=>Uu,loadWeights:()=>Wc,moveModel:()=>Vu,registerLoadRouter:()=>pu,registerSaveRouter:()=>hu,removeModel:()=>ju,weightsLoaderFactory:()=>Vc,withSaveHandler:()=>td,withSaveHandlerSync:()=>nd});var l={};n.r(l),n.d(l,{confusionMatrix:()=>ud});var u={};n.r(u),n.d(u,{draw:()=>bd,fromPixels:()=>vd,fromPixelsAsync:()=>md,toPixels:()=>yd});var c={};n.r(c),n.d(c,{prepareAndValidate:()=>xd});var d={};n.r(d),n.d(d,{calculateShapes:()=>Sd,validateInput:()=>kd,validateUpdateShape:()=>wd});var h={};n.r(h),n.d(h,{assertParamsValid:()=>Td,computeFlatOffset:()=>Pd,computeOutShape:()=>Ed,getNormalizedAxes:()=>Rd,isSliceContinous:()=>zd,maskToAxes:()=>Cd,parseSliceParams:()=>Bd,sliceInfo:()=>Ud,startForAxis:()=>Md,startIndicesWithElidedDims:()=>Ad,stopForAxis:()=>Ld,stopIndicesWithElidedDims:()=>Dd,stridesForAxis:()=>Fd,stridesWithElidedDims:()=>$d});var p={};n.r(p),n.d(p,{TEST_EPSILON_FLOAT16:()=>Vd,createVideoElement:()=>th,encodeStrings:()=>eh,expectArrayBuffersEqual:()=>Zd,expectArraysClose:()=>Gd,expectArraysEqual:()=>Xd,expectNumbersClose:()=>Yd,expectPromiseToFail:()=>Kd,expectValuesInRange:()=>Jd,play:()=>nh,testEpsilon:()=>Hd});var f={};n.r(f),n.d(f,{conv2d:()=>lg,depthwiseConv2d:()=>dg,matMul:()=>hg});var m={};n.r(m),n.d(m,{collectGatherOpShapeInfo:()=>kb,computeOutShape:()=>wb,segOpComputeOptimalWindowSize:()=>xb});var g={};n.r(g),n.d(g,{ERF_A1:()=>zy,ERF_A2:()=>Py,ERF_A3:()=>By,ERF_A4:()=>Uy,ERF_A5:()=>jy,ERF_P:()=>Ly,PARALLELIZE_THRESHOLD:()=>Cy,RowPartitionType:()=>ky,SELU_SCALE:()=>My,SELU_SCALEALPHA:()=>Fy,applyActivation:()=>ig,assertAndGetBroadcastShape:()=>_c,assertAxesAreInnerMostDims:()=>$p,assertParamsConsistent:()=>xy,assignToTypedArray:()=>Ky,axesAreInnerMostDims:()=>Np,calculateShapes:()=>Sd,checkEinsumDimSizes:()=>rb,checkPadOnDimRoundingMode:()=>Oh,combineLocations:()=>Tp,combineRaggedTensorToTensorShapes:()=>Sy,complexWithEvenIndex:()=>Gy,complexWithOddIndex:()=>Hy,computeConv2DInfo:()=>xh,computeConv3DInfo:()=>wh,computeDefaultPad:()=>kh,computeDilation2DInfo:()=>yh,computeOptimalWindowSize:()=>Ey,computeOutAndReduceShapes:()=>Cp,computeOutShape:()=>wy,computePool2DInfo:()=>bh,computePool3DInfo:()=>vh,convertConv2DDataFormat:()=>_h,decodeEinsumEquation:()=>tb,eitherStridesOrDilationsAreOne:()=>Eh,expandShapeToKeepDim:()=>Ep,exponent:()=>Yy,exponents:()=>Xy,fromStringArrayToUint8:()=>Ib,fromUint8ToStringArray:()=>Sb,getAxesPermutation:()=>_p,getBroadcastDims:()=>Ec,getComplexWithIndex:()=>qy,getEinsumComputePath:()=>sb,getEinsumPermutation:()=>nb,getFusedBiasGradient:()=>ag,getFusedDyActivation:()=>sg,getImageCenter:()=>$y,getInnerMostAxes:()=>Rp,getPermuted:()=>Oy,getRaggedRank:()=>Ny,getReductionAxes:()=>$c,getReshaped:()=>_y,getReshapedPermuted:()=>Ry,getRowPartitionTypesHelper:()=>Iy,getSliceBeginCoords:()=>Ay,getSliceSize:()=>Dy,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>lb,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>ub,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>cb,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>pb,getSparseReshapeInputOutputMismatchErrorMessage:()=>mb,getSparseReshapeInputOutputMultipleErrorMessage:()=>fb,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>db,getSparseReshapeNegativeOutputDimErrorMessage:()=>hb,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>vb,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>gb,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>yb,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>bb,getUndoAxesPermutation:()=>Op,isIdentityPermutation:()=>ab,log:()=>Gi,mergeRealAndImagArrays:()=>Wy,prepareAndValidate:()=>xd,prepareSplitSize:()=>ob,segment_util:()=>m,shouldFuse:()=>og,slice_util:()=>h,splitRealAndImagArrays:()=>Vy,stridesOrDilationsArePositive:()=>$h,tupleValuesAreOne:()=>Ch,upcastType:()=>Ko,validateDefaultValueShape:()=>Ty,validateInput:()=>kd,validateUpdateShape:()=>wd,warn:()=>Vi});var y={};n.r(y),n.d(y,{nonMaxSuppressionV3Impl:()=>Tg,nonMaxSuppressionV4Impl:()=>Cg,nonMaxSuppressionV5Impl:()=>Eg,whereImpl:()=>Hm});var b={};n.r(b),n.d(b,{Abs:()=>Tr,Acos:()=>Cr,Acosh:()=>Er,AdadeltaOptimizer:()=>wc,AdagradOptimizer:()=>Sc,AdamOptimizer:()=>Tc,AdamaxOptimizer:()=>Rc,Add:()=>$r,AddN:()=>_r,All:()=>Or,Any:()=>Rr,ArgMax:()=>Ar,ArgMin:()=>Dr,Asin:()=>Fr,Asinh:()=>Mr,Atan:()=>Lr,Atan2:()=>Pr,Atanh:()=>zr,AvgPool:()=>Br,AvgPool3D:()=>jr,AvgPool3DGrad:()=>Wr,AvgPoolGrad:()=>Ur,BatchMatMul:()=>Vr,BatchToSpaceND:()=>Gr,Bincount:()=>Hr,BitwiseAnd:()=>qr,BroadcastArgs:()=>Xr,BroadcastTo:()=>Kr,Cast:()=>Yr,Ceil:()=>Qr,ClipByValue:()=>Jr,Complex:()=>Zr,ComplexAbs:()=>es,Concat:()=>ts,Conv2D:()=>ns,Conv2DBackpropFilter:()=>rs,Conv2DBackpropInput:()=>ss,Conv3D:()=>as,Conv3DBackpropFilterV2:()=>is,Conv3DBackpropInputV2:()=>os,Cos:()=>ls,Cosh:()=>us,CropAndResize:()=>hs,Cumprod:()=>cs,Cumsum:()=>ds,DataStorage:()=>wn,DenseBincount:()=>ps,DepthToSpace:()=>fs,DepthwiseConv2dNative:()=>ms,DepthwiseConv2dNativeBackpropFilter:()=>gs,DepthwiseConv2dNativeBackpropInput:()=>ys,Diag:()=>bs,Dilation2D:()=>vs,Dilation2DBackpropFilter:()=>ws,Dilation2DBackpropInput:()=>xs,Draw:()=>ks,ENV:()=>Sr,Einsum:()=>Is,Elu:()=>Ns,EluGrad:()=>Ts,Environment:()=>vr,Equal:()=>Es,Erf:()=>Cs,Exp:()=>$s,ExpandDims:()=>_s,Expm1:()=>Os,FFT:()=>Rs,Fill:()=>As,FlipLeftRight:()=>Ds,Floor:()=>Fs,FloorDiv:()=>Ms,FromPixels:()=>Pi,FusedBatchNorm:()=>Ls,FusedConv2D:()=>ji,FusedDepthwiseConv2D:()=>Wi,GatherNd:()=>Ps,GatherV2:()=>zs,Greater:()=>Bs,GreaterEqual:()=>Us,IFFT:()=>Ws,Identity:()=>js,Imag:()=>Vs,IsFinite:()=>Gs,IsInf:()=>Hs,IsNan:()=>qs,KernelBackend:()=>kn,LRN:()=>ia,LRNGrad:()=>oa,LeakyRelu:()=>Ks,Less:()=>Xs,LessEqual:()=>Ys,LinSpace:()=>Qs,Log:()=>Js,Log1p:()=>Zs,LogSoftmax:()=>sa,LogicalAnd:()=>ea,LogicalNot:()=>ta,LogicalOr:()=>na,LogicalXor:()=>ra,LowerBound:()=>aa,MatrixBandPart:()=>la,Max:()=>ua,MaxPool:()=>da,MaxPool3D:()=>pa,MaxPool3DGrad:()=>fa,MaxPoolGrad:()=>ha,MaxPoolWithArgmax:()=>ma,Maximum:()=>ca,Mean:()=>ga,Min:()=>ya,Minimum:()=>ba,MirrorPad:()=>va,Mod:()=>xa,MomentumOptimizer:()=>Dc,Multinomial:()=>wa,Multiply:()=>ka,Neg:()=>Sa,NonMaxSuppressionV3:()=>Na,NonMaxSuppressionV4:()=>Ta,NonMaxSuppressionV5:()=>Ca,NotEqual:()=>Ia,OP_SCOPE_SUFFIX:()=>vl,OneHot:()=>$a,OnesLike:()=>Ea,Optimizer:()=>xc,OptimizerConstructors:()=>sh,Pack:()=>_a,PadV2:()=>Oa,Pool:()=>Ra,Pow:()=>Aa,Prelu:()=>Da,Prod:()=>Fa,RMSPropOptimizer:()=>Fc,RaggedGather:()=>Ma,RaggedRange:()=>La,RaggedTensorToTensor:()=>za,Range:()=>Pa,Rank:()=>jo,Real:()=>Ba,RealDiv:()=>Ss,Reciprocal:()=>Ua,Reduction:()=>Hg,Relu:()=>ja,Relu6:()=>Ka,Reshape:()=>Wa,ResizeBilinear:()=>Ha,ResizeBilinearGrad:()=>qa,ResizeNearestNeighbor:()=>Va,ResizeNearestNeighborGrad:()=>Ga,Reverse:()=>Xa,RotateWithOffset:()=>Bi,Round:()=>Ya,Rsqrt:()=>Qa,SGDOptimizer:()=>Ac,ScatterNd:()=>Ja,SearchSorted:()=>ei,Select:()=>ti,Selu:()=>ni,Sigmoid:()=>oi,Sign:()=>ii,Sin:()=>si,Sinh:()=>ai,Slice:()=>ri,Softmax:()=>pi,Softplus:()=>li,SpaceToBatchND:()=>di,SparseFillEmptyRows:()=>fi,SparseReshape:()=>mi,SparseSegmentMean:()=>gi,SparseSegmentSum:()=>yi,SparseToDense:()=>bi,SplitV:()=>hi,Sqrt:()=>ui,Square:()=>xi,SquaredDifference:()=>vi,StaticRegexReplace:()=>wi,Step:()=>zi,StridedSlice:()=>ki,StringNGrams:()=>Si,StringSplit:()=>Ii,StringToHashBucketFast:()=>Ni,Sub:()=>Ti,Sum:()=>ci,Tan:()=>Ci,Tanh:()=>Ei,Tensor:()=>Po,TensorBuffer:()=>Fo,TensorScatterUpdate:()=>Za,Tile:()=>$i,TopK:()=>_i,Transform:()=>Oi,Transpose:()=>Ri,Unique:()=>Ai,Unpack:()=>Di,UnsortedSegmentSum:()=>Fi,UpperBound:()=>Mi,Variable:()=>Uo,ZerosLike:()=>Li,_FusedMatMul:()=>Ui,abs:()=>Cc,acos:()=>ah,acosh:()=>ih,add:()=>Zu,addN:()=>oh,all:()=>lh,any:()=>uh,argMax:()=>ch,argMin:()=>dh,asin:()=>hh,asinh:()=>ph,atan:()=>fh,atan2:()=>mh,atanh:()=>gh,avgPool:()=>Ah,avgPool3d:()=>Dh,backend:()=>Gl,backend_util:()=>g,basicLSTMCell:()=>Ph,batchNorm:()=>Uh,batchNorm2d:()=>jh,batchNorm3d:()=>Wh,batchNorm4d:()=>Vh,batchToSpaceND:()=>Bh,bincount:()=>Gh,bitwiseAnd:()=>Hh,booleanMaskAsync:()=>Km,broadcastArgs:()=>qh,broadcastTo:()=>Kh,broadcast_util:()=>i,browser:()=>u,buffer:()=>Xu,cast:()=>Yu,ceil:()=>Xh,clipByValue:()=>Yh,clone:()=>Qu,complex:()=>wl,concat:()=>Fh,concat1d:()=>Qh,concat2d:()=>Jh,concat3d:()=>Zh,concat4d:()=>ep,conv1d:()=>np,conv2d:()=>tp,conv2dTranspose:()=>sp,conv3d:()=>ap,conv3dTranspose:()=>op,copyRegisteredKernels:()=>to,cos:()=>lp,cosh:()=>up,cosineWindow:()=>tg,cumprod:()=>cp,cumsum:()=>dp,customGrad:()=>dc,denseBincount:()=>hp,deprecationWarn:()=>$l,depthToSpace:()=>pp,depthwiseConv2d:()=>fp,device_util:()=>s,diag:()=>mp,dilation2d:()=>gp,disableDeprecationWarnings:()=>El,dispose:()=>Fl,disposeVariables:()=>_l,div:()=>tc,divNoNan:()=>vp,dot:()=>xp,dropout:()=>Zm,einsum:()=>wp,elu:()=>kp,enableDebugMode:()=>Cl,enableProdMode:()=>Tl,enclosingPowerOfTwo:()=>eg,engine:()=>Ol,ensureShape:()=>Sp,env:()=>wr,equal:()=>yp,erf:()=>Ip,euclideanNorm:()=>zp,exp:()=>Pp,expandDims:()=>Bp,expm1:()=>Up,eye:()=>Wp,fft:()=>km,fill:()=>kc,findBackend:()=>jl,findBackendFactory:()=>Wl,floor:()=>Vp,floorDiv:()=>ec,fused:()=>f,gather:()=>Gp,gatherND:()=>Jm,gather_util:()=>c,getBackend:()=>Bl,getGradient:()=>Xi,getKernel:()=>Ki,getKernelsForBackend:()=>Yi,grad:()=>ic,grads:()=>oc,greater:()=>Hp,greaterEqual:()=>qp,ifft:()=>Sm,imag:()=>ad,image:()=>hy,inTopKAsync:()=>ng,io:()=>o,irfft:()=>Im,isFinite:()=>Kp,isInf:()=>Xp,isNaN:()=>Yp,keep:()=>Ml,kernel_impls:()=>y,leakyRelu:()=>Qp,less:()=>Jp,lessEqual:()=>Zp,linalg:()=>py,linspace:()=>ef,localResponseNormalization:()=>tf,log:()=>nf,log1p:()=>rf,logSigmoid:()=>af,logSoftmax:()=>of,logSumExp:()=>lf,logicalAnd:()=>uf,logicalNot:()=>cf,logicalOr:()=>df,logicalXor:()=>hf,losses:()=>fy,lowerBound:()=>mf,matMul:()=>rd,math:()=>l,max:()=>Ap,maxPool:()=>gf,maxPool3d:()=>yf,maxPoolWithArgmax:()=>bf,maximum:()=>Oc,mean:()=>vf,memory:()=>Rl,meshgrid:()=>kf,min:()=>Dp,minimum:()=>Sf,mirrorPad:()=>If,mod:()=>Nf,moments:()=>Tf,movingAverage:()=>Xm,mul:()=>nc,multiRNNCell:()=>Cf,multinomial:()=>Ef,neg:()=>id,nextFrame:()=>vy,norm:()=>Lp,notEqual:()=>$f,oneHot:()=>sd,ones:()=>wf,onesLike:()=>_f,op:()=>xl,outerProduct:()=>Of,pad:()=>Rf,pad1d:()=>Af,pad2d:()=>Df,pad3d:()=>Ff,pad4d:()=>Mf,pool:()=>zf,pow:()=>Ic,prelu:()=>Pf,print:()=>Ju,prod:()=>Bf,profile:()=>Al,raggedGather:()=>Uf,raggedRange:()=>jf,raggedTensorToTensor:()=>Wf,rand:()=>Vf,randomGamma:()=>Xf,randomNormal:()=>Yf,randomStandardNormal:()=>Qf,randomUniform:()=>Jf,randomUniformInt:()=>Zf,range:()=>em,ready:()=>Pl,real:()=>od,reciprocal:()=>tm,registerBackend:()=>Vl,registerGradient:()=>Ji,registerKernel:()=>Qi,relu:()=>nm,relu6:()=>rm,removeBackend:()=>Ul,reshape:()=>Rh,reverse:()=>sm,reverse1d:()=>am,reverse2d:()=>im,reverse3d:()=>om,reverse4d:()=>lm,rfft:()=>Tm,round:()=>um,rsqrt:()=>cm,scalar:()=>pc,scatterND:()=>Ym,scatter_util:()=>d,searchSorted:()=>ff,selu:()=>dm,separableConv2d:()=>hm,serialization:()=>a,setBackend:()=>zl,setPlatform:()=>Hl,setdiff1dAsync:()=>pm,sigmoid:()=>Mh,sign:()=>fm,signal:()=>dy,sin:()=>mm,sinh:()=>gm,slice:()=>Lh,slice1d:()=>ym,slice2d:()=>bm,slice3d:()=>vm,slice4d:()=>xm,slice_util:()=>h,softmax:()=>wm,softplus:()=>sf,spaceToBatchND:()=>Lf,sparse:()=>my,sparseToDense:()=>Qm,spectral:()=>cy,split:()=>Nm,sqrt:()=>rc,square:()=>sc,squaredDifference:()=>Cm,squeeze:()=>Em,stack:()=>$m,step:()=>_m,stridedSlice:()=>Om,string:()=>gy,sub:()=>Nc,sum:()=>Fp,sumOutType:()=>Xo,tan:()=>Rm,tanh:()=>zh,tensor:()=>Sl,tensor1d:()=>Am,tensor2d:()=>Dm,tensor3d:()=>cd,tensor4d:()=>Fm,tensor5d:()=>Mm,tensor6d:()=>Lm,tensorScatterUpdate:()=>zm,tensor_util:()=>t,test_util:()=>p,tidy:()=>Dl,tile:()=>jp,time:()=>Ll,topk:()=>Pm,train:()=>yy,transpose:()=>ld,truncatedNormal:()=>Bm,unique:()=>Um,unregisterGradient:()=>eo,unregisterKernel:()=>Zi,unsortedSegmentSum:()=>jm,unstack:()=>Wm,upcastType:()=>Ko,upperBound:()=>Vm,util:()=>e,valueAndGrad:()=>lc,valueAndGrads:()=>uc,variable:()=>Gm,variableGrads:()=>cc,version_core:()=>rh,where:()=>bp,whereAsync:()=>qm,zeros:()=>xf,zerosLike:()=>ac});var v={};n.r(v),n.d(v,{json:()=>XN});var x={};n.r(x),n.d(x,{json:()=>YN});var w={};n.r(w),n.d(w,{json:()=>QN});var k={};n.r(k),n.d(k,{json:()=>JN});var S={};n.r(S),n.d(S,{json:()=>ZN});var I={};n.r(I),n.d(I,{json:()=>eT});var N={};n.r(N),n.d(N,{json:()=>tT});var T={};n.r(T),n.d(T,{json:()=>nT});var C={};n.r(C),n.d(C,{json:()=>rT});var E={};n.r(E),n.d(E,{json:()=>sT});var $={};n.r($),n.d($,{json:()=>aT});var _={};n.r(_),n.d(_,{json:()=>iT});var O={};n.r(O),n.d(O,{json:()=>oT});var R={};n.r(R),n.d(R,{json:()=>lT});var A={};n.r(A),n.d(A,{json:()=>uT});var D={};n.r(D),n.d(D,{json:()=>cT});var F={};n.r(F),n.d(F,{json:()=>dT});var M={};n.r(M),n.d(M,{json:()=>hT});var L={};n.r(L),n.d(L,{json:()=>pT});var z={};n.r(z),n.d(z,{OP_SCOPE_SUFFIX:()=>vl,abs:()=>Cc,acos:()=>ah,acosh:()=>ih,add:()=>Zu,addN:()=>oh,all:()=>lh,any:()=>uh,argMax:()=>ch,argMin:()=>dh,asin:()=>hh,asinh:()=>ph,atan:()=>fh,atan2:()=>mh,atanh:()=>gh,avgPool:()=>Ah,avgPool3d:()=>Dh,basicLSTMCell:()=>Ph,batchNorm:()=>Uh,batchNorm2d:()=>jh,batchNorm3d:()=>Wh,batchNorm4d:()=>Vh,batchToSpaceND:()=>Bh,bincount:()=>Gh,bitwiseAnd:()=>Hh,booleanMaskAsync:()=>Km,broadcastArgs:()=>qh,broadcastTo:()=>Kh,buffer:()=>Xu,cast:()=>Yu,ceil:()=>Xh,clipByValue:()=>Yh,clone:()=>Qu,complex:()=>wl,concat:()=>Fh,concat1d:()=>Qh,concat2d:()=>Jh,concat3d:()=>Zh,concat4d:()=>ep,conv1d:()=>np,conv2d:()=>tp,conv2dTranspose:()=>sp,conv3d:()=>ap,conv3dTranspose:()=>op,cos:()=>lp,cosh:()=>up,cosineWindow:()=>tg,cumprod:()=>cp,cumsum:()=>dp,denseBincount:()=>hp,depthToSpace:()=>pp,depthwiseConv2d:()=>fp,diag:()=>mp,dilation2d:()=>gp,div:()=>tc,divNoNan:()=>vp,dot:()=>xp,dropout:()=>Zm,einsum:()=>wp,elu:()=>kp,enclosingPowerOfTwo:()=>eg,ensureShape:()=>Sp,equal:()=>yp,erf:()=>Ip,euclideanNorm:()=>zp,exp:()=>Pp,expandDims:()=>Bp,expm1:()=>Up,eye:()=>Wp,fft:()=>km,fill:()=>kc,floor:()=>Vp,floorDiv:()=>ec,fused:()=>f,gather:()=>Gp,gatherND:()=>Jm,greater:()=>Hp,greaterEqual:()=>qp,ifft:()=>Sm,imag:()=>ad,image:()=>hy,inTopKAsync:()=>ng,irfft:()=>Im,isFinite:()=>Kp,isInf:()=>Xp,isNaN:()=>Yp,leakyRelu:()=>Qp,less:()=>Jp,lessEqual:()=>Zp,linalg:()=>py,linspace:()=>ef,localResponseNormalization:()=>tf,log:()=>nf,log1p:()=>rf,logSigmoid:()=>af,logSoftmax:()=>of,logSumExp:()=>lf,logicalAnd:()=>uf,logicalNot:()=>cf,logicalOr:()=>df,logicalXor:()=>hf,losses:()=>fy,lowerBound:()=>mf,matMul:()=>rd,max:()=>Ap,maxPool:()=>gf,maxPool3d:()=>yf,maxPoolWithArgmax:()=>bf,maximum:()=>Oc,mean:()=>vf,meshgrid:()=>kf,min:()=>Dp,minimum:()=>Sf,mirrorPad:()=>If,mod:()=>Nf,moments:()=>Tf,movingAverage:()=>Xm,mul:()=>nc,multiRNNCell:()=>Cf,multinomial:()=>Ef,neg:()=>id,norm:()=>Lp,notEqual:()=>$f,oneHot:()=>sd,ones:()=>wf,onesLike:()=>_f,op:()=>xl,outerProduct:()=>Of,pad:()=>Rf,pad1d:()=>Af,pad2d:()=>Df,pad3d:()=>Ff,pad4d:()=>Mf,pool:()=>zf,pow:()=>Ic,prelu:()=>Pf,print:()=>Ju,prod:()=>Bf,raggedGather:()=>Uf,raggedRange:()=>jf,raggedTensorToTensor:()=>Wf,rand:()=>Vf,randomGamma:()=>Xf,randomNormal:()=>Yf,randomStandardNormal:()=>Qf,randomUniform:()=>Jf,randomUniformInt:()=>Zf,range:()=>em,real:()=>od,reciprocal:()=>tm,relu:()=>nm,relu6:()=>rm,reshape:()=>Rh,reverse:()=>sm,reverse1d:()=>am,reverse2d:()=>im,reverse3d:()=>om,reverse4d:()=>lm,rfft:()=>Tm,round:()=>um,rsqrt:()=>cm,scalar:()=>pc,scatterND:()=>Ym,searchSorted:()=>ff,selu:()=>dm,separableConv2d:()=>hm,setdiff1dAsync:()=>pm,sigmoid:()=>Mh,sign:()=>fm,signal:()=>dy,sin:()=>mm,sinh:()=>gm,slice:()=>Lh,slice1d:()=>ym,slice2d:()=>bm,slice3d:()=>vm,slice4d:()=>xm,softmax:()=>wm,softplus:()=>sf,spaceToBatchND:()=>Lf,sparse:()=>my,sparseToDense:()=>Qm,spectral:()=>cy,split:()=>Nm,sqrt:()=>rc,square:()=>sc,squaredDifference:()=>Cm,squeeze:()=>Em,stack:()=>$m,step:()=>_m,stridedSlice:()=>Om,string:()=>gy,sub:()=>Nc,sum:()=>Fp,tan:()=>Rm,tanh:()=>zh,tensor:()=>Sl,tensor1d:()=>Am,tensor2d:()=>Dm,tensor3d:()=>cd,tensor4d:()=>Fm,tensor5d:()=>Mm,tensor6d:()=>Lm,tensorScatterUpdate:()=>zm,tile:()=>jp,topk:()=>Pm,transpose:()=>ld,truncatedNormal:()=>Bm,unique:()=>Um,unsortedSegmentSum:()=>jm,unstack:()=>Wm,upperBound:()=>Vm,variable:()=>Gm,where:()=>bp,whereAsync:()=>qm,zeros:()=>xf,zerosLike:()=>ac});var P={};n.r(P),n.d(P,{mx:()=>fE,XI:()=>i$,Nk:()=>o$,f6:()=>u$,ct:()=>uE,YG:()=>p$,hH:()=>v$,z3:()=>r_,sG:()=>f_,uM:()=>v_,vS:()=>M_,qB:()=>V_,GG:()=>H_,lg:()=>Q_,rq:()=>K_,cu:()=>cO,WR:()=>oO,GE:()=>pO,px:()=>mO,jC:()=>_O,He:()=>AO,hE:()=>WO,BF:()=>X$,Dk:()=>ZO,cl:()=>oR,_B:()=>xR,ub:()=>NR,_f:()=>ER,Ku:()=>DR,qy:()=>MR,Zy:()=>KR,bu:()=>QR,zv:()=>eE,dH:()=>SE,HS:()=>n$,yH:()=>yA,l3:()=>vA,z9:()=>wA,x6:()=>TA,_m:()=>AA,eW:()=>zA,GK:()=>UA,SP:()=>VA,yr:()=>HA,dl:()=>N_,Dw:()=>JA,xT:()=>nD,_X:()=>_E,wz:()=>uD});var B={};n.r(B),n.d(B,{hasBrowserEnv:()=>FH,hasStandardBrowserEnv:()=>LH,hasStandardBrowserWebWorkerEnv:()=>zH,navigator:()=>MH,origin:()=>PH});var U=n(848),j=n(540),W=n(338);const V=e=>{let t;const n=new Set,r=(e,r)=>{const s="function"==typeof e?e(t):e;if(!Object.is(s,t)){const e=t;t=(null!=r?r:"object"!=typeof s||null===s)?s:Object.assign({},t,s),n.forEach((n=>n(t,e)))}},s=()=>t,a={setState:r,getState:s,getInitialState:()=>i,subscribe:e=>(n.add(e),()=>n.delete(e)),destroy:()=>{n.clear()}},i=t=e(r,s,a);return a},G=e=>e?V(e):V;var H=n(242);const{useDebugValue:q}=j,{useSyncExternalStoreWithSelector:K}=H;let X=!1;const Y=e=>e;const Q=e=>{const t="function"==typeof e?G(e):e,n=(e,n)=>function(e,t=Y,n){n&&!X&&(X=!0);const r=K(e.subscribe,e.getState,e.getServerState||e.getInitialState,t,n);return q(r),r}(t,e,n);return Object.assign(n,t),n},J=e=>e?Q(e):Q;const Z={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};let ee;const te=new Uint8Array(16);const ne=[];for(let e=0;e<256;++e)ne.push((e+256).toString(16).slice(1));function re(e,t=0){return(ne[e[t+0]]+ne[e[t+1]]+ne[e[t+2]]+ne[e[t+3]]+"-"+ne[e[t+4]]+ne[e[t+5]]+"-"+ne[e[t+6]]+ne[e[t+7]]+"-"+ne[e[t+8]]+ne[e[t+9]]+"-"+ne[e[t+10]]+ne[e[t+11]]+ne[e[t+12]]+ne[e[t+13]]+ne[e[t+14]]+ne[e[t+15]]).toLowerCase()}const se=function(e,t,n){if(Z.randomUUID&&!t&&!e)return Z.randomUUID();const r=(e=e||{}).random??e.rng?.()??function(){if(!ee){if("undefined"==typeof crypto||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");ee=crypto.getRandomValues.bind(crypto)}return ee(te)}();if(r.length<16)throw new Error("Random bytes length must be >= 16");if(r[6]=15&r[6]|64,r[8]=63&r[8]|128,t){if((n=n||0)<0||n+16>t.length)throw new RangeError(`UUID byte range ${n}:${n+15} is out of buffer bounds`);for(let e=0;e<16;++e)t[n+e]=r[e];return t}return re(r)};var ae,ie;!function(e){e.TEXT="text",e.RECOMMENDATION="recommendation",e.OUTFIT="outfit",e.QUIZ="quiz",e.LOADING="loading",e.ERROR="error"}(ae||(ae={})),function(e){e.USER="user",e.ASSISTANT="assistant",e.SYSTEM="system"}(ie||(ie={}));const oe=J(((e,t)=>({messages:[],isOpen:!0,isMinimized:!1,isLoading:!1,error:null,currentView:"chat",addMessage:t=>{const n=se(),r=new Date,s=Object.assign(Object.assign({},t),{id:n,timestamp:r});return e((e=>({messages:[...e.messages,s]}))),n},addTextMessage:(e,n)=>{const r=n,s={type:ae.TEXT,sender:r,text:e};return t().addMessage(s)},updateMessage:(t,n)=>{e((e=>({messages:e.messages.map((e=>e.id===t?Object.assign(Object.assign({},e),n):e))})))},removeMessage:t=>{e((e=>({messages:e.messages.filter((e=>e.id!==t))})))},clearMessages:()=>{e({messages:[]})},toggleOpen:()=>{const n=t().isOpen;e({isOpen:!n,isMinimized:!1})},toggleMinimize:()=>{const n=t().isMinimized;e({isMinimized:!n})},setLoading:t=>{e({isLoading:t})},setError:t=>{e({error:t})},setCurrentView:t=>{e({currentView:t})}}))),le=new Map,ue=e=>{const t=le.get(e);return t?Object.fromEntries(Object.entries(t.stores).map((([e,t])=>[e,t.getState()]))):{}},ce=(e,t={})=>(n,r,s)=>{const{enabled:a,anonymousActionType:i,store:o,...l}=t;let u;try{u=(null==a||a)&&window.__REDUX_DEVTOOLS_EXTENSION__}catch(e){}if(!u)return e(n,r,s);const{connection:c,...d}=((e,t,n)=>{if(void 0===e)return{type:"untracked",connection:t.connect(n)};const r=le.get(n.name);if(r)return{type:"tracked",store:e,...r};const s={connection:t.connect(n),stores:{}};return le.set(n.name,s),{type:"tracked",store:e,...s}})(o,u,l);let h=!0;s.setState=(e,t,a)=>{const u=n(e,t);if(!h)return u;const d=void 0===a?{type:i||"anonymous"}:"string"==typeof a?{type:a}:a;return void 0===o?(null==c||c.send(d,r()),u):(null==c||c.send({...d,type:`${o}/${d.type}`},{...ue(l.name),[o]:s.getState()}),u)};const p=(...e)=>{const t=h;h=!1,n(...e),h=t},f=e(s.setState,r,s);if("untracked"===d.type?null==c||c.init(f):(d.stores[d.store]=s,null==c||c.init(Object.fromEntries(Object.entries(d.stores).map((([e,t])=>[e,e===d.store?f:t.getState()]))))),s.dispatchFromDevtools&&"function"==typeof s.dispatch){let e=!1;const t=s.dispatch;s.dispatch=(...n)=>{"__setState"!==n[0].type||e||(e=!0),t(...n)}}return c.subscribe((e=>{var t;switch(e.type){case"ACTION":if("string"!=typeof e.payload)return;return de(e.payload,(e=>{if("__setState"!==e.type)s.dispatchFromDevtools&&"function"==typeof s.dispatch&&s.dispatch(e);else{if(void 0===o)return void p(e.state);Object.keys(e.state).length;const t=e.state[o];if(null==t)return;JSON.stringify(s.getState())!==JSON.stringify(t)&&p(t)}}));case"DISPATCH":switch(e.payload.type){case"RESET":return p(f),void 0===o?null==c?void 0:c.init(s.getState()):null==c?void 0:c.init(ue(l.name));case"COMMIT":return void 0===o?void(null==c||c.init(s.getState())):null==c?void 0:c.init(ue(l.name));case"ROLLBACK":return de(e.state,(e=>{if(void 0===o)return p(e),void(null==c||c.init(s.getState()));p(e[o]),null==c||c.init(ue(l.name))}));case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return de(e.state,(e=>{void 0!==o?JSON.stringify(s.getState())!==JSON.stringify(e[o])&&p(e[o]):p(e)}));case"IMPORT_STATE":{const{nextLiftedState:n}=e.payload,r=null==(t=n.computedStates.slice(-1)[0])?void 0:t.state;if(!r)return;return p(void 0===o?r:r[o]),void(null==c||c.send(null,n))}case"PAUSE_RECORDING":return h=!h}return}})),f},de=(e,t)=>{let n;try{n=JSON.parse(e)}catch(e){}void 0!==n&&t(n)};function he(e,t){let n;try{n=e()}catch(e){return}const r={getItem:e=>{var r;const s=e=>null===e?null:JSON.parse(e,null==t?void 0:t.reviver),a=null!=(r=n.getItem(e))?r:null;return a instanceof Promise?a.then(s):s(a)},setItem:(e,r)=>n.setItem(e,JSON.stringify(r,null==t?void 0:t.replacer)),removeItem:e=>n.removeItem(e)};return r}const pe=e=>t=>{try{const n=e(t);return n instanceof Promise?n:{then:e=>pe(e)(n),catch(e){return this}}}catch(e){return{then(e){return this},catch:t=>pe(t)(e)}}},fe=(e,t)=>"getStorage"in t||"serialize"in t||"deserialize"in t?((e,t)=>(n,r,s)=>{let a={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:e=>e,version:0,merge:(e,t)=>({...t,...e}),...t},i=!1;const o=new Set,l=new Set;let u;try{u=a.getStorage()}catch(e){}if(!u)return e(((...e)=>{n(...e)}),r,s);const c=pe(a.serialize),d=()=>{const e=a.partialize({...r()});let t;const n=c({state:e,version:a.version}).then((e=>u.setItem(a.name,e))).catch((e=>{t=e}));if(t)throw t;return n},h=s.setState;s.setState=(e,t)=>{h(e,t),d()};const p=e(((...e)=>{n(...e),d()}),r,s);let f;const m=()=>{var e;if(!u)return;i=!1,o.forEach((e=>e(r())));const t=(null==(e=a.onRehydrateStorage)?void 0:e.call(a,r()))||void 0;return pe(u.getItem.bind(u))(a.name).then((e=>{if(e)return a.deserialize(e)})).then((e=>{if(e){if("number"!=typeof e.version||e.version===a.version)return e.state;if(a.migrate)return a.migrate(e.state,e.version)}})).then((e=>{var t;return f=a.merge(e,null!=(t=r())?t:p),n(f,!0),d()})).then((()=>{null==t||t(f,void 0),i=!0,l.forEach((e=>e(f)))})).catch((e=>{null==t||t(void 0,e)}))};return s.persist={setOptions:e=>{a={...a,...e},e.getStorage&&(u=e.getStorage())},clearStorage:()=>{null==u||u.removeItem(a.name)},getOptions:()=>a,rehydrate:()=>m(),hasHydrated:()=>i,onHydrate:e=>(o.add(e),()=>{o.delete(e)}),onFinishHydration:e=>(l.add(e),()=>{l.delete(e)})},m(),f||p})(e,t):((e,t)=>(n,r,s)=>{let a={storage:he((()=>localStorage)),partialize:e=>e,version:0,merge:(e,t)=>({...t,...e}),...t},i=!1;const o=new Set,l=new Set;let u=a.storage;if(!u)return e(((...e)=>{n(...e)}),r,s);const c=()=>{const e=a.partialize({...r()});return u.setItem(a.name,{state:e,version:a.version})},d=s.setState;s.setState=(e,t)=>{d(e,t),c()};const h=e(((...e)=>{n(...e),c()}),r,s);let p;s.getInitialState=()=>h;const f=()=>{var e,t;if(!u)return;i=!1,o.forEach((e=>{var t;return e(null!=(t=r())?t:h)}));const s=(null==(t=a.onRehydrateStorage)?void 0:t.call(a,null!=(e=r())?e:h))||void 0;return pe(u.getItem.bind(u))(a.name).then((e=>{if(e){if("number"!=typeof e.version||e.version===a.version)return[!1,e.state];if(a.migrate)return[!0,a.migrate(e.state,e.version)]}return[!1,void 0]})).then((e=>{var t;const[s,i]=e;if(p=a.merge(i,null!=(t=r())?t:h),n(p,!0),s)return c()})).then((()=>{null==s||s(p,void 0),p=r(),i=!0,l.forEach((e=>e(p)))})).catch((e=>{null==s||s(void 0,e)}))};return s.persist={setOptions:e=>{a={...a,...e},e.storage&&(u=e.storage)},clearStorage:()=>{null==u||u.removeItem(a.name)},getOptions:()=>a,rehydrate:()=>f(),hasHydrated:()=>i,onHydrate:e=>(o.add(e),()=>{o.delete(e)}),onFinishHydration:e=>(l.add(e),()=>{l.delete(e)})},a.skipHydration||f(),p||h})(e,t),me=J()(fe(((e,t)=>({user:null,styleQuizResult:null,isLoading:!1,error:null,setUser:t=>{e({user:t})},updateUser:n=>{const r=t().user;r&&e({user:Object.assign(Object.assign({},r),n)})},setStyleQuizResult:t=>{e({styleQuizResult:t})},addToCloset:n=>{const r=t().user;r&&e({user:Object.assign(Object.assign({},r),{closet:[...r.closet,n]})})},removeFromCloset:n=>{const r=t().user;r&&e({user:Object.assign(Object.assign({},r),{closet:r.closet.filter((e=>e.id!==n))})})},toggleItemFavorite:(n,r)=>{const s=t().user;s&&e({user:Object.assign(Object.assign({},s),{closet:s.closet.map((e=>e.id===n?Object.assign(Object.assign({},e),{favorite:r}):e))})})},addLikedItem:n=>{const r=t().user;r&&(r.feedback.likedItems.includes(n)||e({user:Object.assign(Object.assign({},r),{feedback:Object.assign(Object.assign({},r.feedback),{likedItems:[...r.feedback.likedItems,n],dislikedItems:r.feedback.dislikedItems.filter((e=>e!==n)),lastInteraction:new Date})})}))},addDislikedItem:n=>{const r=t().user;r&&(r.feedback.dislikedItems.includes(n)||e({user:Object.assign(Object.assign({},r),{feedback:Object.assign(Object.assign({},r.feedback),{dislikedItems:[...r.feedback.dislikedItems,n],likedItems:r.feedback.likedItems.filter((e=>e!==n)),lastInteraction:new Date})})}))},removeLikedItem:n=>{const r=t().user;r&&e({user:Object.assign(Object.assign({},r),{feedback:Object.assign(Object.assign({},r.feedback),{likedItems:r.feedback.likedItems.filter((e=>e!==n)),lastInteraction:new Date})})})},removeDislikedItem:n=>{const r=t().user;r&&e({user:Object.assign(Object.assign({},r),{feedback:Object.assign(Object.assign({},r.feedback),{dislikedItems:r.feedback.dislikedItems.filter((e=>e!==n)),lastInteraction:new Date})})})},addViewedItem:n=>{const r=t().user;r&&(r.feedback.viewedItems.includes(n)||e({user:Object.assign(Object.assign({},r),{feedback:Object.assign(Object.assign({},r.feedback),{viewedItems:[...r.feedback.viewedItems,n],lastInteraction:new Date})})}))},setLoading:t=>{e({isLoading:t})},setError:t=>{e({error:t})},logout:()=>{e({user:null,styleQuizResult:null})}})),{name:"stylist-user-storage",partialize:e=>({user:e.user,styleQuizResult:e.styleQuizResult})}));var ge,ye,be,ve;!function(e){e.TOP="top",e.BOTTOM="bottom",e.DRESS="dress",e.OUTERWEAR="outerwear",e.SHOES="shoes",e.ACCESSORY="accessory"}(ge||(ge={})),function(e){e.UPPER_BODY="upper_body",e.LOWER_BODY="lower_body",e.FULL_BODY="full_body",e.HEAD="head",e.FEET="feet",e.HANDS="hands",e.NECK="neck",e.WAIST="waist"}(ye||(ye={})),function(e){e.IDLE="idle",e.UPLOADING="uploading",e.PROCESSING="processing",e.REMOVING_BACKGROUND="removing_background",e.COMPLETED="completed",e.FAILED="failed"}(be||(be={})),function(e){e.REMOVE_BG_API="remove_bg_api",e.TENSORFLOW="tensorflow",e.MANUAL="manual"}(ve||(ve={}));const xe=e=>{switch(e){case ge.TOP:return ye.UPPER_BODY;case ge.BOTTOM:return ye.LOWER_BODY;case ge.DRESS:return ye.FULL_BODY;case ge.OUTERWEAR:return ye.UPPER_BODY;case ge.SHOES:return ye.FEET;case ge.ACCESSORY:return ye.HEAD;default:return ye.FULL_BODY}},we=e=>{switch(e){case ge.TOP:return 10;case ge.BOTTOM:return 5;case ge.DRESS:return 10;case ge.OUTERWEAR:return 15;case ge.SHOES:return 5;case ge.ACCESSORY:return 20;default:return 10}},ke={preferredBackgroundRemovalMethod:ve.TENSORFLOW,removeBackgroundAutomatically:!0,showGuidelines:!0,highQualityRendering:!0,defaultGarmentScale:{[ge.TOP]:.8,[ge.BOTTOM]:.7,[ge.DRESS]:.9,[ge.OUTERWEAR]:.85,[ge.SHOES]:.5,[ge.ACCESSORY]:.4},defaultGarmentOffset:{[ge.TOP]:{x:0,y:-50},[ge.BOTTOM]:{x:0,y:100},[ge.DRESS]:{x:0,y:0},[ge.OUTERWEAR]:{x:0,y:-30},[ge.SHOES]:{x:0,y:200},[ge.ACCESSORY]:{x:0,y:-150}}},Se=J()(ce(fe(((e,t)=>({currentOutfit:null,userImage:null,isLoading:!1,error:null,settings:ke,savedResults:[],canvasWidth:600,canvasHeight:800,isTryOnModalOpen:!1,isUploadModalOpen:!1,setCurrentOutfit:t=>{e({currentOutfit:t})},addGarmentToOutfit:n=>{const{currentOutfit:r}=t();if(r){const t=r.garments.filter((e=>!(e.type===n.type&&e.bodyPosition===n.bodyPosition)));e({currentOutfit:Object.assign(Object.assign({},r),{garments:[...t,n]})})}else{const t={id:`outfit_${Date.now()}`,garments:[n],createdAt:new Date};e({currentOutfit:t})}},removeGarmentFromOutfit:n=>{const{currentOutfit:r}=t();if(r){const t=r.garments.filter((e=>e.id!==n));e({currentOutfit:Object.assign(Object.assign({},r),{garments:t})})}},updateGarment:(n,r)=>{const{currentOutfit:s}=t();if(s){const t=s.garments.map((e=>e.id===n?Object.assign(Object.assign({},e),r):e));e({currentOutfit:Object.assign(Object.assign({},s),{garments:t})})}},setUserImage:n=>{e({userImage:n});const{currentOutfit:r}=t();if(r){const t=n;e({currentOutfit:Object.assign(Object.assign({},r),{userImage:t})})}},updateUserImage:n=>{const{userImage:r}=t();if(r){const s=Object.assign(Object.assign({},r),n);e({userImage:s});const{currentOutfit:a}=t();a&&e({currentOutfit:Object.assign(Object.assign({},a),{userImage:s})})}},clearUserImage:()=>{e({userImage:null});const{currentOutfit:n}=t();if(n){const t=Object.assign(Object.assign({},n),{userImage:void 0});e({currentOutfit:t})}},updateOutfit:n=>{const{currentOutfit:r}=t();r&&e({currentOutfit:Object.assign(Object.assign({},r),n)})},setSettings:n=>{e({settings:Object.assign(Object.assign({},t().settings),n)})},setLoading:t=>{e({isLoading:t})},setError:t=>{e({error:t})},saveResult:n=>{const r=[...t().savedResults],s=r.findIndex((e=>e.id===n.id));s>=0?r[s]=n:r.push(n),e({savedResults:r})},deleteSavedResult:n=>{const r=t().savedResults.filter((e=>e.id!==n));e({savedResults:r})},setCanvasDimensions:(t,n)=>{e({canvasWidth:t,canvasHeight:n})},openTryOnModal:()=>{e({isTryOnModalOpen:!0})},closeTryOnModal:()=>{e({isTryOnModalOpen:!1})},openUploadModal:()=>{e({isUploadModalOpen:!0})},closeUploadModal:()=>{e({isUploadModalOpen:!1})},reset:()=>{e({currentOutfit:null,userImage:null,isLoading:!1,error:null})},startNewTryOn:(n,r)=>{const{settings:s}=t(),a=t().currentOutfit||{id:crypto.randomUUID(),garments:[],createdAt:new Date},i={id:crypto.randomUUID(),type:r,url:"string"==typeof n?n:URL.createObjectURL(n),bodyPosition:xe(r),zIndex:a.garments.length+1,layerIndex:a.garments.length,scale:s.defaultGarmentScale[r]||1,offset:s.defaultGarmentOffset[r]||{x:0,y:0},rotation:0,withoutBackground:!0},o=[...a.garments||[],i];e({currentOutfit:Object.assign(Object.assign({},a),{garments:o})})},tryOnOutfit:t=>{e({currentOutfit:t})}})),{name:"stylist-try-on-storage",partialize:e=>({settings:e.settings,savedResults:e.savedResults})}),{name:"try-on-store"})),Ie=J(((e,t)=>({recommendedItems:[],recommendedOutfits:[],savedOutfits:[],wishlistItems:[],cartItems:[],viewedItems:[],context:null,loading:!1,error:null,setRecommendedItems:t=>{e({recommendedItems:t})},setRecommendedOutfits:t=>{e({recommendedOutfits:t})},setSavedOutfits:t=>{e({savedOutfits:t})},addRecommendedItem:t=>{e((e=>({recommendedItems:[...e.recommendedItems,t]})))},addRecommendedOutfit:t=>{e((e=>({recommendedOutfits:[...e.recommendedOutfits,t]})))},addToWishlist:n=>{t().wishlistItems.some((e=>e.itemId===n.itemId))||e((e=>({wishlistItems:[...e.wishlistItems,n]})))},removeFromWishlist:t=>{e((e=>({wishlistItems:e.wishlistItems.filter((e=>e.itemId!==t))})))},addToCart:n=>{const r=t().cartItems.findIndex((e=>e.itemId===n.itemId));e(r>=0?e=>{const t=[...e.cartItems];return t[r].quantity+=n.quantity,{cartItems:t}}:e=>({cartItems:[...e.cartItems,n]}))},removeFromCart:t=>{e((e=>({cartItems:e.cartItems.filter((e=>e.itemId!==t))})))},updateCartItemQuantity:(t,n)=>{e((e=>({cartItems:e.cartItems.map((e=>e.itemId===t?Object.assign(Object.assign({},e),{quantity:n}):e))})))},addViewedItem:n=>{t().viewedItems.includes(n)||e((e=>({viewedItems:[...e.viewedItems,n]})))},saveOutfit:n=>{t().savedOutfits.some((e=>e.outfitId===n.outfitId))||e((e=>({savedOutfits:[...e.savedOutfits,n]})))},removeSavedOutfit:t=>{e((e=>({savedOutfits:e.savedOutfits.filter((e=>e.outfitId!==t))})))},setContext:t=>{e({context:t})},clearRecommendations:()=>{e({recommendedItems:[],recommendedOutfits:[],context:null})},setLoading:t=>{e({loading:t})},setError:t=>{e({error:t})},getItemsByCategory:e=>t().recommendedItems.filter((t=>t.category===e)),getItemsSortedByMatchScore:()=>[...t().recommendedItems].sort(((e,t)=>t.matchScore-e.matchScore)),getOutfitById:e=>t().recommendedOutfits.find((t=>t.id===e)),getItemById:e=>t().recommendedItems.find((t=>t.id===e)),updateItem:(t,n)=>{e((e=>({recommendedItems:e.recommendedItems.map((e=>e.id===t?Object.assign(Object.assign({},e),n):e))})))}}))),Ne=Ie,Te=()=>{const e="test";try{return localStorage.setItem(e,e),localStorage.removeItem(e),!0}catch(e){return!1}},Ce=()=>{if(!Te())return`anonymous_${Date.now()}`;let e=localStorage.getItem("stylist_user_id");return e||(e=`user_${Date.now()}_${Math.random().toString(36).substring(2,9)}`,localStorage.setItem("stylist_user_id",e)),e},Ee=e=>Array.from(e),$e=e=>new Set(e),_e=J()(fe(((e,t)=>({likedItems:new Set,dislikedItems:new Set,likedOutfits:new Set,dislikedOutfits:new Set,thumbsUpMessages:new Set,feedbackHistory:[],pendingSync:[],isSyncing:!1,lastSyncedAt:null,addItemFeedback:(t,n)=>{const r=Ce(),s=new Date,a={id:`item_${n}_${t}_${s.getTime()}`,type:n,timestamp:s,entityType:"item",metadata:{itemId:t,userId:r}};e("like"===n?e=>({likedItems:new Set(e.likedItems).add(t),dislikedItems:new Set(e.dislikedItems).delete(t)?new Set(e.dislikedItems):e.dislikedItems,feedbackHistory:[...e.feedbackHistory,a],pendingSync:[...e.pendingSync,a]}):e=>({dislikedItems:new Set(e.dislikedItems).add(t),likedItems:new Set(e.likedItems).delete(t)?new Set(e.likedItems):e.likedItems,feedbackHistory:[...e.feedbackHistory,a],pendingSync:[...e.pendingSync,a]}))},addOutfitFeedback:(t,n)=>{const r=Ce(),s=new Date,a={id:`outfit_${n}_${t}_${s.getTime()}`,type:n,timestamp:s,entityType:"outfit",metadata:{outfitId:t,userId:r}};e("like"===n?e=>({likedOutfits:new Set(e.likedOutfits).add(t),dislikedOutfits:new Set(e.dislikedOutfits).delete(t)?new Set(e.dislikedOutfits):e.dislikedOutfits,feedbackHistory:[...e.feedbackHistory,a],pendingSync:[...e.pendingSync,a]}):e=>({dislikedOutfits:new Set(e.dislikedOutfits).add(t),likedOutfits:new Set(e.likedOutfits).delete(t)?new Set(e.likedOutfits):e.likedOutfits,feedbackHistory:[...e.feedbackHistory,a],pendingSync:[...e.pendingSync,a]}))},addMessageThumbsUp:t=>{const n=Ce(),r=new Date,s={id:`message_thumbsUp_${t}_${r.getTime()}`,type:"thumbsUp",timestamp:r,entityType:"recommendation",metadata:{messageId:t,userId:n}};e((e=>({thumbsUpMessages:new Set(e.thumbsUpMessages).add(t),feedbackHistory:[...e.feedbackHistory,s],pendingSync:[...e.pendingSync,s]})))},removeItemFeedback:t=>{e((e=>({likedItems:new Set(e.likedItems).delete(t)?new Set(e.likedItems):e.likedItems,dislikedItems:new Set(e.dislikedItems).delete(t)?new Set(e.dislikedItems):e.dislikedItems})))},removeOutfitFeedback:t=>{e((e=>({likedOutfits:new Set(e.likedOutfits).delete(t)?new Set(e.likedOutfits):e.likedOutfits,dislikedOutfits:new Set(e.dislikedOutfits).delete(t)?new Set(e.dislikedOutfits):e.dislikedOutfits})))},removeMessageThumbsUp:t=>{e((e=>({thumbsUpMessages:new Set(e.thumbsUpMessages).delete(t)?new Set(e.thumbsUpMessages):e.thumbsUpMessages})))},markAsSynced:t=>{e((e=>({pendingSync:e.pendingSync.filter((e=>!t.includes(e.id))),lastSyncedAt:new Date})))},setIsSyncing:t=>{e({isSyncing:t})},getItemFeedbackStatus:e=>{const n=t();return{liked:n.likedItems.has(e),disliked:n.dislikedItems.has(e)}},getOutfitFeedbackStatus:e=>{const n=t();return{liked:n.likedOutfits.has(e),disliked:n.dislikedOutfits.has(e)}},isMessageThumbedUp:e=>t().thumbsUpMessages.has(e),getPendingSyncItems:()=>t().pendingSync,clearSyncedItems:()=>{e({pendingSync:[],lastSyncedAt:new Date})}})),{name:"stylist-feedback-storage",partialize:e=>({likedItems:Ee(e.likedItems),dislikedItems:Ee(e.dislikedItems),likedOutfits:Ee(e.likedOutfits),dislikedOutfits:Ee(e.dislikedOutfits),thumbsUpMessages:Ee(e.thumbsUpMessages),feedbackHistory:e.feedbackHistory,pendingSync:e.pendingSync,lastSyncedAt:e.lastSyncedAt}),onRehydrateStorage:()=>e=>{e&&(e.likedItems=$e(e.likedItems),e.dislikedItems=$e(e.dislikedItems),e.likedOutfits=$e(e.likedOutfits),e.dislikedOutfits=$e(e.dislikedOutfits),e.thumbsUpMessages=$e(e.thumbsUpMessages))}})),Oe=({title:e="The Stylist",logo:t,primaryColor:n,currentView:r="chat",onSwitchView:s})=>{const{toggleMinimize:a,toggleOpen:i,isMinimized:o}=oe();return(0,U.jsxs)("div",Object.assign({className:"stylist-chat-header",style:{backgroundColor:n}},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-chat-header__logo"},{children:t?(0,U.jsx)("img",{src:t,alt:e,className:"stylist-chat-header__logo-img"}):(0,U.jsx)("div",Object.assign({className:"stylist-chat-header__logo-placeholder"},{children:"chat"===r?(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"24",height:"24",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M12 1a9 9 0 019 9c0 4.56-3.37 8.33-7.76 8.95l-.19-.47a7.99 7.99 0 002.93-10.57A8.02 8.02 0 004.06 13.1A9 9 0 0112 1zm7.12 13.93l.37.37-.36.36.01-.73zm1.36-1.55a2.83 2.83 0 00-.5-.31l.36-.74c.28.12.54.29.78.48l-.64.57zm-14.81.19l.36.73c-.29.16-.57.35-.8.57l-.57-.64c.31-.3.65-.54 1.01-.66zM6.66 22l1.93-3.1c-.47-.55-.85-1.16-1.14-1.8L2.8 19.13V22h3.86zm10.46-2.91L19 21.99v-2.86l-1.14-.93c.12-.39.19-.8.19-1.22l.08-.04A8.96 8.96 0 0022 10 10 10 0 002 10a9 9 0 003.34 7.03L1.94 20.5A1 1 0 002.86 22h16.28a1 1 0 00.92-1.5l-2.94-3.41z"})})):(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"24",height:"24",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-3 2v5l-1-.75L15 9V4h2zm3 12H8V4h5v9l3-2.25L19 13V4h1v12z"})}))}))})),(0,U.jsx)("div",Object.assign({className:"stylist-chat-header__title"},{children:e})),(0,U.jsxs)("div",Object.assign({className:"stylist-chat-header__controls"},{children:[s&&!o&&(0,U.jsx)("button",Object.assign({className:"stylist-chat-header__button stylist-chat-header__button--switch",onClick:()=>{s&&s("chat"===r?"lookbook":"chat")},"aria-label":"chat"===r?"View Lookbook":"Return to Chat"},{children:"chat"===r?(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-3 2v5l-1-.75L15 9V4h2zm3 12H8V4h5v9l3-2.25L19 13V4h1v12z"})})):(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"})}))})),(0,U.jsx)("button",Object.assign({className:"stylist-chat-header__button stylist-chat-header__button--minimize",onClick:()=>{a()},"aria-label":o?"Maximize":"Minimize"},{children:o?(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"})})):(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M19 13H5v-2h14v2z"})}))})),(0,U.jsx)("button",Object.assign({className:"stylist-chat-header__button stylist-chat-header__button--close",onClick:()=>{i()},"aria-label":"Close"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"18",height:"18",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"})}))}))]}))]}))};var Re=n(942),Ae=n.n(Re);function De(e){return De="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},De(e)}function Fe(e,t){if(t.length<e)throw new TypeError(e+" argument"+(e>1?"s":"")+" required, but only "+t.length+" present")}function Me(e){Fe(1,arguments);var t=Object.prototype.toString.call(e);return e instanceof Date||"object"===De(e)&&"[object Date]"===t?new Date(e.getTime()):"number"==typeof e||"[object Number]"===t?new Date(e):new Date(NaN)}function Le(e){if(Fe(1,arguments),!function(e){return Fe(1,arguments),e instanceof Date||"object"===De(e)&&"[object Date]"===Object.prototype.toString.call(e)}(e)&&"number"!=typeof e)return!1;var t=Me(e);return!isNaN(Number(t))}function ze(e){if(null===e||!0===e||!1===e)return NaN;var t=Number(e);return isNaN(t)?t:t<0?Math.ceil(t):Math.floor(t)}function Pe(e,t){return Fe(2,arguments),function(e,t){Fe(2,arguments);var n=Me(e).getTime(),r=ze(t);return new Date(n+r)}(e,-ze(t))}function Be(e){Fe(1,arguments);var t=Me(e),n=t.getUTCDay(),r=(n<1?7:0)+n-1;return t.setUTCDate(t.getUTCDate()-r),t.setUTCHours(0,0,0,0),t}function Ue(e){Fe(1,arguments);var t=Me(e),n=t.getUTCFullYear(),r=new Date(0);r.setUTCFullYear(n+1,0,4),r.setUTCHours(0,0,0,0);var s=Be(r),a=new Date(0);a.setUTCFullYear(n,0,4),a.setUTCHours(0,0,0,0);var i=Be(a);return t.getTime()>=s.getTime()?n+1:t.getTime()>=i.getTime()?n:n-1}function je(e){Fe(1,arguments);var t=Me(e),n=Be(t).getTime()-function(e){Fe(1,arguments);var t=Ue(e),n=new Date(0);return n.setUTCFullYear(t,0,4),n.setUTCHours(0,0,0,0),Be(n)}(t).getTime();return Math.round(n/6048e5)+1}var We={};function Ve(){return We}function Ge(e,t){var n,r,s,a,i,o,l,u;Fe(1,arguments);var c=Ve(),d=ze(null!==(n=null!==(r=null!==(s=null!==(a=null==t?void 0:t.weekStartsOn)&&void 0!==a?a:null==t||null===(i=t.locale)||void 0===i||null===(o=i.options)||void 0===o?void 0:o.weekStartsOn)&&void 0!==s?s:c.weekStartsOn)&&void 0!==r?r:null===(l=c.locale)||void 0===l||null===(u=l.options)||void 0===u?void 0:u.weekStartsOn)&&void 0!==n?n:0);if(!(d>=0&&d<=6))throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");var h=Me(e),p=h.getUTCDay(),f=(p<d?7:0)+p-d;return h.setUTCDate(h.getUTCDate()-f),h.setUTCHours(0,0,0,0),h}function He(e,t){var n,r,s,a,i,o,l,u;Fe(1,arguments);var c=Me(e),d=c.getUTCFullYear(),h=Ve(),p=ze(null!==(n=null!==(r=null!==(s=null!==(a=null==t?void 0:t.firstWeekContainsDate)&&void 0!==a?a:null==t||null===(i=t.locale)||void 0===i||null===(o=i.options)||void 0===o?void 0:o.firstWeekContainsDate)&&void 0!==s?s:h.firstWeekContainsDate)&&void 0!==r?r:null===(l=h.locale)||void 0===l||null===(u=l.options)||void 0===u?void 0:u.firstWeekContainsDate)&&void 0!==n?n:1);if(!(p>=1&&p<=7))throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");var f=new Date(0);f.setUTCFullYear(d+1,0,p),f.setUTCHours(0,0,0,0);var m=Ge(f,t),g=new Date(0);g.setUTCFullYear(d,0,p),g.setUTCHours(0,0,0,0);var y=Ge(g,t);return c.getTime()>=m.getTime()?d+1:c.getTime()>=y.getTime()?d:d-1}function qe(e,t){Fe(1,arguments);var n=Me(e),r=Ge(n,t).getTime()-function(e,t){var n,r,s,a,i,o,l,u;Fe(1,arguments);var c=Ve(),d=ze(null!==(n=null!==(r=null!==(s=null!==(a=null==t?void 0:t.firstWeekContainsDate)&&void 0!==a?a:null==t||null===(i=t.locale)||void 0===i||null===(o=i.options)||void 0===o?void 0:o.firstWeekContainsDate)&&void 0!==s?s:c.firstWeekContainsDate)&&void 0!==r?r:null===(l=c.locale)||void 0===l||null===(u=l.options)||void 0===u?void 0:u.firstWeekContainsDate)&&void 0!==n?n:1),h=He(e,t),p=new Date(0);return p.setUTCFullYear(h,0,d),p.setUTCHours(0,0,0,0),Ge(p,t)}(n,t).getTime();return Math.round(r/6048e5)+1}function Ke(e,t){for(var n=e<0?"-":"",r=Math.abs(e).toString();r.length<t;)r="0"+r;return n+r}const Xe={y:function(e,t){var n=e.getUTCFullYear(),r=n>0?n:1-n;return Ke("yy"===t?r%100:r,t.length)},M:function(e,t){var n=e.getUTCMonth();return"M"===t?String(n+1):Ke(n+1,2)},d:function(e,t){return Ke(e.getUTCDate(),t.length)},a:function(e,t){var n=e.getUTCHours()/12>=1?"pm":"am";switch(t){case"a":case"aa":return n.toUpperCase();case"aaa":return n;case"aaaaa":return n[0];default:return"am"===n?"a.m.":"p.m."}},h:function(e,t){return Ke(e.getUTCHours()%12||12,t.length)},H:function(e,t){return Ke(e.getUTCHours(),t.length)},m:function(e,t){return Ke(e.getUTCMinutes(),t.length)},s:function(e,t){return Ke(e.getUTCSeconds(),t.length)},S:function(e,t){var n=t.length,r=e.getUTCMilliseconds();return Ke(Math.floor(r*Math.pow(10,n-3)),t.length)}};var Ye="midnight",Qe="noon",Je="morning",Ze="afternoon",et="evening",tt="night",nt={G:function(e,t,n){var r=e.getUTCFullYear()>0?1:0;switch(t){case"G":case"GG":case"GGG":return n.era(r,{width:"abbreviated"});case"GGGGG":return n.era(r,{width:"narrow"});default:return n.era(r,{width:"wide"})}},y:function(e,t,n){if("yo"===t){var r=e.getUTCFullYear(),s=r>0?r:1-r;return n.ordinalNumber(s,{unit:"year"})}return Xe.y(e,t)},Y:function(e,t,n,r){var s=He(e,r),a=s>0?s:1-s;return"YY"===t?Ke(a%100,2):"Yo"===t?n.ordinalNumber(a,{unit:"year"}):Ke(a,t.length)},R:function(e,t){return Ke(Ue(e),t.length)},u:function(e,t){return Ke(e.getUTCFullYear(),t.length)},Q:function(e,t,n){var r=Math.ceil((e.getUTCMonth()+1)/3);switch(t){case"Q":return String(r);case"QQ":return Ke(r,2);case"Qo":return n.ordinalNumber(r,{unit:"quarter"});case"QQQ":return n.quarter(r,{width:"abbreviated",context:"formatting"});case"QQQQQ":return n.quarter(r,{width:"narrow",context:"formatting"});default:return n.quarter(r,{width:"wide",context:"formatting"})}},q:function(e,t,n){var r=Math.ceil((e.getUTCMonth()+1)/3);switch(t){case"q":return String(r);case"qq":return Ke(r,2);case"qo":return n.ordinalNumber(r,{unit:"quarter"});case"qqq":return n.quarter(r,{width:"abbreviated",context:"standalone"});case"qqqqq":return n.quarter(r,{width:"narrow",context:"standalone"});default:return n.quarter(r,{width:"wide",context:"standalone"})}},M:function(e,t,n){var r=e.getUTCMonth();switch(t){case"M":case"MM":return Xe.M(e,t);case"Mo":return n.ordinalNumber(r+1,{unit:"month"});case"MMM":return n.month(r,{width:"abbreviated",context:"formatting"});case"MMMMM":return n.month(r,{width:"narrow",context:"formatting"});default:return n.month(r,{width:"wide",context:"formatting"})}},L:function(e,t,n){var r=e.getUTCMonth();switch(t){case"L":return String(r+1);case"LL":return Ke(r+1,2);case"Lo":return n.ordinalNumber(r+1,{unit:"month"});case"LLL":return n.month(r,{width:"abbreviated",context:"standalone"});case"LLLLL":return n.month(r,{width:"narrow",context:"standalone"});default:return n.month(r,{width:"wide",context:"standalone"})}},w:function(e,t,n,r){var s=qe(e,r);return"wo"===t?n.ordinalNumber(s,{unit:"week"}):Ke(s,t.length)},I:function(e,t,n){var r=je(e);return"Io"===t?n.ordinalNumber(r,{unit:"week"}):Ke(r,t.length)},d:function(e,t,n){return"do"===t?n.ordinalNumber(e.getUTCDate(),{unit:"date"}):Xe.d(e,t)},D:function(e,t,n){var r=function(e){Fe(1,arguments);var t=Me(e),n=t.getTime();t.setUTCMonth(0,1),t.setUTCHours(0,0,0,0);var r=n-t.getTime();return Math.floor(r/864e5)+1}(e);return"Do"===t?n.ordinalNumber(r,{unit:"dayOfYear"}):Ke(r,t.length)},E:function(e,t,n){var r=e.getUTCDay();switch(t){case"E":case"EE":case"EEE":return n.day(r,{width:"abbreviated",context:"formatting"});case"EEEEE":return n.day(r,{width:"narrow",context:"formatting"});case"EEEEEE":return n.day(r,{width:"short",context:"formatting"});default:return n.day(r,{width:"wide",context:"formatting"})}},e:function(e,t,n,r){var s=e.getUTCDay(),a=(s-r.weekStartsOn+8)%7||7;switch(t){case"e":return String(a);case"ee":return Ke(a,2);case"eo":return n.ordinalNumber(a,{unit:"day"});case"eee":return n.day(s,{width:"abbreviated",context:"formatting"});case"eeeee":return n.day(s,{width:"narrow",context:"formatting"});case"eeeeee":return n.day(s,{width:"short",context:"formatting"});default:return n.day(s,{width:"wide",context:"formatting"})}},c:function(e,t,n,r){var s=e.getUTCDay(),a=(s-r.weekStartsOn+8)%7||7;switch(t){case"c":return String(a);case"cc":return Ke(a,t.length);case"co":return n.ordinalNumber(a,{unit:"day"});case"ccc":return n.day(s,{width:"abbreviated",context:"standalone"});case"ccccc":return n.day(s,{width:"narrow",context:"standalone"});case"cccccc":return n.day(s,{width:"short",context:"standalone"});default:return n.day(s,{width:"wide",context:"standalone"})}},i:function(e,t,n){var r=e.getUTCDay(),s=0===r?7:r;switch(t){case"i":return String(s);case"ii":return Ke(s,t.length);case"io":return n.ordinalNumber(s,{unit:"day"});case"iii":return n.day(r,{width:"abbreviated",context:"formatting"});case"iiiii":return n.day(r,{width:"narrow",context:"formatting"});case"iiiiii":return n.day(r,{width:"short",context:"formatting"});default:return n.day(r,{width:"wide",context:"formatting"})}},a:function(e,t,n){var r=e.getUTCHours()/12>=1?"pm":"am";switch(t){case"a":case"aa":return n.dayPeriod(r,{width:"abbreviated",context:"formatting"});case"aaa":return n.dayPeriod(r,{width:"abbreviated",context:"formatting"}).toLowerCase();case"aaaaa":return n.dayPeriod(r,{width:"narrow",context:"formatting"});default:return n.dayPeriod(r,{width:"wide",context:"formatting"})}},b:function(e,t,n){var r,s=e.getUTCHours();switch(r=12===s?Qe:0===s?Ye:s/12>=1?"pm":"am",t){case"b":case"bb":return n.dayPeriod(r,{width:"abbreviated",context:"formatting"});case"bbb":return n.dayPeriod(r,{width:"abbreviated",context:"formatting"}).toLowerCase();case"bbbbb":return n.dayPeriod(r,{width:"narrow",context:"formatting"});default:return n.dayPeriod(r,{width:"wide",context:"formatting"})}},B:function(e,t,n){var r,s=e.getUTCHours();switch(r=s>=17?et:s>=12?Ze:s>=4?Je:tt,t){case"B":case"BB":case"BBB":return n.dayPeriod(r,{width:"abbreviated",context:"formatting"});case"BBBBB":return n.dayPeriod(r,{width:"narrow",context:"formatting"});default:return n.dayPeriod(r,{width:"wide",context:"formatting"})}},h:function(e,t,n){if("ho"===t){var r=e.getUTCHours()%12;return 0===r&&(r=12),n.ordinalNumber(r,{unit:"hour"})}return Xe.h(e,t)},H:function(e,t,n){return"Ho"===t?n.ordinalNumber(e.getUTCHours(),{unit:"hour"}):Xe.H(e,t)},K:function(e,t,n){var r=e.getUTCHours()%12;return"Ko"===t?n.ordinalNumber(r,{unit:"hour"}):Ke(r,t.length)},k:function(e,t,n){var r=e.getUTCHours();return 0===r&&(r=24),"ko"===t?n.ordinalNumber(r,{unit:"hour"}):Ke(r,t.length)},m:function(e,t,n){return"mo"===t?n.ordinalNumber(e.getUTCMinutes(),{unit:"minute"}):Xe.m(e,t)},s:function(e,t,n){return"so"===t?n.ordinalNumber(e.getUTCSeconds(),{unit:"second"}):Xe.s(e,t)},S:function(e,t){return Xe.S(e,t)},X:function(e,t,n,r){var s=(r._originalDate||e).getTimezoneOffset();if(0===s)return"Z";switch(t){case"X":return st(s);case"XXXX":case"XX":return at(s);default:return at(s,":")}},x:function(e,t,n,r){var s=(r._originalDate||e).getTimezoneOffset();switch(t){case"x":return st(s);case"xxxx":case"xx":return at(s);default:return at(s,":")}},O:function(e,t,n,r){var s=(r._originalDate||e).getTimezoneOffset();switch(t){case"O":case"OO":case"OOO":return"GMT"+rt(s,":");default:return"GMT"+at(s,":")}},z:function(e,t,n,r){var s=(r._originalDate||e).getTimezoneOffset();switch(t){case"z":case"zz":case"zzz":return"GMT"+rt(s,":");default:return"GMT"+at(s,":")}},t:function(e,t,n,r){var s=r._originalDate||e;return Ke(Math.floor(s.getTime()/1e3),t.length)},T:function(e,t,n,r){return Ke((r._originalDate||e).getTime(),t.length)}};function rt(e,t){var n=e>0?"-":"+",r=Math.abs(e),s=Math.floor(r/60),a=r%60;if(0===a)return n+String(s);var i=t||"";return n+String(s)+i+Ke(a,2)}function st(e,t){return e%60==0?(e>0?"-":"+")+Ke(Math.abs(e)/60,2):at(e,t)}function at(e,t){var n=t||"",r=e>0?"-":"+",s=Math.abs(e);return r+Ke(Math.floor(s/60),2)+n+Ke(s%60,2)}const it=nt;var ot=function(e,t){switch(e){case"P":return t.date({width:"short"});case"PP":return t.date({width:"medium"});case"PPP":return t.date({width:"long"});default:return t.date({width:"full"})}},lt=function(e,t){switch(e){case"p":return t.time({width:"short"});case"pp":return t.time({width:"medium"});case"ppp":return t.time({width:"long"});default:return t.time({width:"full"})}},ut={p:lt,P:function(e,t){var n,r=e.match(/(P+)(p+)?/)||[],s=r[1],a=r[2];if(!a)return ot(e,t);switch(s){case"P":n=t.dateTime({width:"short"});break;case"PP":n=t.dateTime({width:"medium"});break;case"PPP":n=t.dateTime({width:"long"});break;default:n=t.dateTime({width:"full"})}return n.replace("{{date}}",ot(s,t)).replace("{{time}}",lt(a,t))}};const ct=ut;var dt=["D","DD"],ht=["YY","YYYY"];function pt(e,t,n){if("YYYY"===e)throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(t,"`) for formatting years to the input `").concat(n,"`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));if("YY"===e)throw new RangeError("Use `yy` instead of `YY` (in `".concat(t,"`) for formatting years to the input `").concat(n,"`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));if("D"===e)throw new RangeError("Use `d` instead of `D` (in `".concat(t,"`) for formatting days of the month to the input `").concat(n,"`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));if("DD"===e)throw new RangeError("Use `dd` instead of `DD` (in `".concat(t,"`) for formatting days of the month to the input `").concat(n,"`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"))}var ft={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXWeeks:{one:"about 1 week",other:"about {{count}} weeks"},xWeeks:{one:"1 week",other:"{{count}} weeks"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}};const mt=function(e,t,n){var r,s=ft[e];return r="string"==typeof s?s:1===t?s.one:s.other.replace("{{count}}",t.toString()),null!=n&&n.addSuffix?n.comparison&&n.comparison>0?"in "+r:r+" ago":r};function gt(e){return function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=t.width?String(t.width):e.defaultWidth;return e.formats[n]||e.formats[e.defaultWidth]}}const yt={date:gt({formats:{full:"EEEE, MMMM do, y",long:"MMMM do, y",medium:"MMM d, y",short:"MM/dd/yyyy"},defaultWidth:"full"}),time:gt({formats:{full:"h:mm:ss a zzzz",long:"h:mm:ss a z",medium:"h:mm:ss a",short:"h:mm a"},defaultWidth:"full"}),dateTime:gt({formats:{full:"{{date}} 'at' {{time}}",long:"{{date}} 'at' {{time}}",medium:"{{date}}, {{time}}",short:"{{date}}, {{time}}"},defaultWidth:"full"})};var bt={lastWeek:"'last' eeee 'at' p",yesterday:"'yesterday at' p",today:"'today at' p",tomorrow:"'tomorrow at' p",nextWeek:"eeee 'at' p",other:"P"};const vt=function(e,t,n,r){return bt[e]};function xt(e){return function(t,n){var r;if("formatting"===(null!=n&&n.context?String(n.context):"standalone")&&e.formattingValues){var s=e.defaultFormattingWidth||e.defaultWidth,a=null!=n&&n.width?String(n.width):s;r=e.formattingValues[a]||e.formattingValues[s]}else{var i=e.defaultWidth,o=null!=n&&n.width?String(n.width):e.defaultWidth;r=e.values[o]||e.values[i]}return r[e.argumentCallback?e.argumentCallback(t):t]}}const wt={ordinalNumber:function(e,t){var n=Number(e),r=n%100;if(r>20||r<10)switch(r%10){case 1:return n+"st";case 2:return n+"nd";case 3:return n+"rd"}return n+"th"},era:xt({values:{narrow:["B","A"],abbreviated:["BC","AD"],wide:["Before Christ","Anno Domini"]},defaultWidth:"wide"}),quarter:xt({values:{narrow:["1","2","3","4"],abbreviated:["Q1","Q2","Q3","Q4"],wide:["1st quarter","2nd quarter","3rd quarter","4th quarter"]},defaultWidth:"wide",argumentCallback:function(e){return e-1}}),month:xt({values:{narrow:["J","F","M","A","M","J","J","A","S","O","N","D"],abbreviated:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],wide:["January","February","March","April","May","June","July","August","September","October","November","December"]},defaultWidth:"wide"}),day:xt({values:{narrow:["S","M","T","W","T","F","S"],short:["Su","Mo","Tu","We","Th","Fr","Sa"],abbreviated:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],wide:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"]},defaultWidth:"wide"}),dayPeriod:xt({values:{narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"morning",afternoon:"afternoon",evening:"evening",night:"night"}},defaultWidth:"wide",formattingValues:{narrow:{am:"a",pm:"p",midnight:"mi",noon:"n",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},abbreviated:{am:"AM",pm:"PM",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"},wide:{am:"a.m.",pm:"p.m.",midnight:"midnight",noon:"noon",morning:"in the morning",afternoon:"in the afternoon",evening:"in the evening",night:"at night"}},defaultFormattingWidth:"wide"})};function kt(e){return function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=n.width,s=r&&e.matchPatterns[r]||e.matchPatterns[e.defaultMatchWidth],a=t.match(s);if(!a)return null;var i,o=a[0],l=r&&e.parsePatterns[r]||e.parsePatterns[e.defaultParseWidth],u=Array.isArray(l)?function(e,t){for(var n=0;n<e.length;n++)if(t(e[n]))return n;return}(l,(function(e){return e.test(o)})):function(e,t){for(var n in e)if(e.hasOwnProperty(n)&&t(e[n]))return n;return}(l,(function(e){return e.test(o)}));return i=e.valueCallback?e.valueCallback(u):u,{value:i=n.valueCallback?n.valueCallback(i):i,rest:t.slice(o.length)}}}var St,It={ordinalNumber:(St={matchPattern:/^(\d+)(th|st|nd|rd)?/i,parsePattern:/\d+/i,valueCallback:function(e){return parseInt(e,10)}},function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=e.match(St.matchPattern);if(!n)return null;var r=n[0],s=e.match(St.parsePattern);if(!s)return null;var a=St.valueCallback?St.valueCallback(s[0]):s[0];return{value:a=t.valueCallback?t.valueCallback(a):a,rest:e.slice(r.length)}}),era:kt({matchPatterns:{narrow:/^(b|a)/i,abbreviated:/^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,wide:/^(before christ|before common era|anno domini|common era)/i},defaultMatchWidth:"wide",parsePatterns:{any:[/^b/i,/^(a|c)/i]},defaultParseWidth:"any"}),quarter:kt({matchPatterns:{narrow:/^[1234]/i,abbreviated:/^q[1234]/i,wide:/^[1234](th|st|nd|rd)? quarter/i},defaultMatchWidth:"wide",parsePatterns:{any:[/1/i,/2/i,/3/i,/4/i]},defaultParseWidth:"any",valueCallback:function(e){return e+1}}),month:kt({matchPatterns:{narrow:/^[jfmasond]/i,abbreviated:/^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,wide:/^(january|february|march|april|may|june|july|august|september|october|november|december)/i},defaultMatchWidth:"wide",parsePatterns:{narrow:[/^j/i,/^f/i,/^m/i,/^a/i,/^m/i,/^j/i,/^j/i,/^a/i,/^s/i,/^o/i,/^n/i,/^d/i],any:[/^ja/i,/^f/i,/^mar/i,/^ap/i,/^may/i,/^jun/i,/^jul/i,/^au/i,/^s/i,/^o/i,/^n/i,/^d/i]},defaultParseWidth:"any"}),day:kt({matchPatterns:{narrow:/^[smtwf]/i,short:/^(su|mo|tu|we|th|fr|sa)/i,abbreviated:/^(sun|mon|tue|wed|thu|fri|sat)/i,wide:/^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i},defaultMatchWidth:"wide",parsePatterns:{narrow:[/^s/i,/^m/i,/^t/i,/^w/i,/^t/i,/^f/i,/^s/i],any:[/^su/i,/^m/i,/^tu/i,/^w/i,/^th/i,/^f/i,/^sa/i]},defaultParseWidth:"any"}),dayPeriod:kt({matchPatterns:{narrow:/^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,any:/^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i},defaultMatchWidth:"any",parsePatterns:{any:{am:/^a/i,pm:/^p/i,midnight:/^mi/i,noon:/^no/i,morning:/morning/i,afternoon:/afternoon/i,evening:/evening/i,night:/night/i}},defaultParseWidth:"any"})};const Nt={code:"en-US",formatDistance:mt,formatLong:yt,formatRelative:vt,localize:wt,match:It,options:{weekStartsOn:0,firstWeekContainsDate:1}};var Tt=/[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,Ct=/P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,Et=/^'([^]*?)'?$/,$t=/''/g,_t=/[a-zA-Z]/;function Ot(e,t,n){var r,s,a,i,o,l,u,c,d,h,p,f,m,g,y,b,v,x;Fe(2,arguments);var w=String(t),k=Ve(),S=null!==(r=null!==(s=null==n?void 0:n.locale)&&void 0!==s?s:k.locale)&&void 0!==r?r:Nt,I=ze(null!==(a=null!==(i=null!==(o=null!==(l=null==n?void 0:n.firstWeekContainsDate)&&void 0!==l?l:null==n||null===(u=n.locale)||void 0===u||null===(c=u.options)||void 0===c?void 0:c.firstWeekContainsDate)&&void 0!==o?o:k.firstWeekContainsDate)&&void 0!==i?i:null===(d=k.locale)||void 0===d||null===(h=d.options)||void 0===h?void 0:h.firstWeekContainsDate)&&void 0!==a?a:1);if(!(I>=1&&I<=7))throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");var N=ze(null!==(p=null!==(f=null!==(m=null!==(g=null==n?void 0:n.weekStartsOn)&&void 0!==g?g:null==n||null===(y=n.locale)||void 0===y||null===(b=y.options)||void 0===b?void 0:b.weekStartsOn)&&void 0!==m?m:k.weekStartsOn)&&void 0!==f?f:null===(v=k.locale)||void 0===v||null===(x=v.options)||void 0===x?void 0:x.weekStartsOn)&&void 0!==p?p:0);if(!(N>=0&&N<=6))throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");if(!S.localize)throw new RangeError("locale must contain localize property");if(!S.formatLong)throw new RangeError("locale must contain formatLong property");var T=Me(e);if(!Le(T))throw new RangeError("Invalid time value");var C=function(e){var t=new Date(Date.UTC(e.getFullYear(),e.getMonth(),e.getDate(),e.getHours(),e.getMinutes(),e.getSeconds(),e.getMilliseconds()));return t.setUTCFullYear(e.getFullYear()),e.getTime()-t.getTime()}(T),E=Pe(T,C),$={firstWeekContainsDate:I,weekStartsOn:N,locale:S,_originalDate:T},_=w.match(Ct).map((function(e){var t=e[0];return"p"===t||"P"===t?(0,ct[t])(e,S.formatLong):e})).join("").match(Tt).map((function(r){if("''"===r)return"'";var s=r[0];if("'"===s)return function(e){var t=e.match(Et);if(!t)return e;return t[1].replace($t,"'")}(r);var a,i=it[s];if(i)return null!=n&&n.useAdditionalWeekYearTokens||(a=r,-1===ht.indexOf(a))||pt(r,t,String(e)),null!=n&&n.useAdditionalDayOfYearTokens||!function(e){return-1!==dt.indexOf(e)}(r)||pt(r,t,String(e)),i(E,r,S.localize,$);if(s.match(_t))throw new RangeError("Format string contains an unescaped latin alphabet character `"+s+"`");return r})).join("");return _}const Rt=(e,t="USD",n="en-US")=>new Intl.NumberFormat(n,{style:"currency",currency:t}).format(e),At=(e,t="MMM d, yyyy")=>Ot("string"==typeof e?new Date(e):e,t),Dt=({onLike:e,onDislike:t,itemId:n,outfitId:r,liked:s=!1,disliked:a=!1,primaryColor:i})=>{const[o,l]=(0,j.useState)(s),[u,c]=(0,j.useState)(a),d=_e(),h=d.addItemFeedback,p=d.addOutfitFeedback,f=d.getItemFeedbackStatus,m=d.getOutfitFeedbackStatus;(0,j.useEffect)((()=>{if(n){const e=f(n);l(e.liked),c(e.disliked)}else if(r){const e=m(r);l(e.liked),c(e.disliked)}else l(s),c(a)}),[n,r,s,a,f,m]);const g=o&&i?{color:i,borderColor:i}:void 0,y=u&&i?{color:i,borderColor:i}:void 0;return(0,U.jsxs)("div",Object.assign({className:"stylist-feedback-controls"},{children:[(0,U.jsx)("button",Object.assign({className:"stylist-feedback-controls__button "+(o?"stylist-feedback-controls__button--active":""),onClick:()=>{l(!0),c(!1),e(),n?h(n,"like"):r&&p(r,"like")},style:g,"aria-label":"Like"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"20",height:"20",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-1.91l-.01-.01L23 10z"})}))})),(0,U.jsx)("button",Object.assign({className:"stylist-feedback-controls__button "+(u?"stylist-feedback-controls__button--active":""),onClick:()=>{l(!1),c(!0),t(),n?h(n,"dislike"):r&&p(r,"dislike")},style:y,"aria-label":"Dislike"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"20",height:"20",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v1.91l.01.01L1 14c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"})}))}))]}))},Ft=({messageId:e,onThumbsUp:t,primaryColor:n})=>{const[r,s]=(0,j.useState)(!1),{addMessageThumbsUp:a,isMessageThumbedUp:i}=_e();(0,j.useEffect)((()=>{s(i(e))}),[e,i]);const o=r&&n?{color:n,borderColor:n}:void 0;return(0,U.jsx)("div",Object.assign({className:"stylist-feedback-controls stylist-feedback-controls--thumbs-up"},{children:(0,U.jsxs)("button",Object.assign({className:"stylist-feedback-controls__button "+(r?"stylist-feedback-controls__button--active":""),onClick:()=>{s(!0),t(),a(e)},style:o,"aria-label":"This was helpful",disabled:r},{children:[(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"20",height:"20",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-1.91l-.01-.01L23 10z"})})),(0,U.jsx)("span",Object.assign({className:"stylist-feedback-controls__button-text"},{children:r?"Thanks for your feedback!":"Was this helpful?"}))]}))}))},Mt=Dt;var Lt,zt=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};!function(e){e.WIDGET_OPEN="widget_open",e.WIDGET_CLOSE="widget_close",e.WIDGET_MINIMIZE="widget_minimize",e.MESSAGE_SENT="message_sent",e.ITEM_VIEW="item_view",e.ITEM_LIKE="item_like",e.ITEM_DISLIKE="item_dislike",e.OUTFIT_VIEW="outfit_view",e.OUTFIT_LIKE="outfit_like",e.OUTFIT_DISLIKE="outfit_dislike",e.OUTFIT_SAVE="outfit_save",e.ADD_TO_WISHLIST="add_to_wishlist",e.ADD_TO_CART="add_to_cart",e.STYLE_QUIZ_START="style_quiz_start",e.STYLE_QUIZ_COMPLETE="style_quiz_complete",e.STYLE_QUIZ_PARTIAL="style_quiz_partial",e.STYLE_QUIZ_ABANDON="style_quiz_abandon",e.TRY_ON_START="try_on_start",e.TRY_ON_COMPLETE="try_on_complete",e.TRY_ON_SAVED="try_on_saved",e.VIEW_LOOKBOOK="view_lookbook",e.ERROR="error",e.MESSAGE_THUMBS_UP="message_thumbs_up",e.RECOMMENDATION_THUMBS_UP="recommendation_thumbs_up",e.FEEDBACK_SYNCED="feedback_synced"}(Lt||(Lt={}));const Pt=()=>{let e=sessionStorage.getItem("stylist_session_id");return e||(e=`session_${Date.now()}_${Math.random().toString(36).substring(2,9)}`,sessionStorage.setItem("stylist_session_id",e)),e},Bt=(e,t,n)=>{const r={type:e,timestamp:new Date,userId:t,sessionId:Pt(),data:n};Wt(r)};let Ut=[],jt=!1;const Wt=e=>{Ut.push(e),jt||Vt()},Vt=()=>zt(void 0,void 0,void 0,(function*(){if(0===Ut.length)return void(jt=!1);jt=!0;const e=Ut.slice(0,10);try{(yield fetch("https://api.thestylist.ai/api/v1/analytics/events",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({events:e})})).ok?Ut=Ut.slice(e.length):yield new Promise((e=>setTimeout(e,5e3)))}catch(e){0,yield new Promise((e=>setTimeout(e,5e3)))}Vt()})),Gt=({message:e,primaryColor:t,onFeedback:n})=>{const{id:r,sender:s,text:a,timestamp:i}=e,[o,l]=(0,j.useState)(!1),u=s===ie.USER,c=s===ie.ASSISTANT,d=s===ie.SYSTEM,h=c&&a.length>20&&!a.includes("Would you like")&&n,p=Ae()("stylist-message-bubble",{"stylist-message-bubble--user":u,"stylist-message-bubble--assistant":c,"stylist-message-bubble--system":d,"stylist-message-bubble--with-feedback":h}),f=u&&t?{backgroundColor:t}:void 0;return(0,U.jsxs)("div",Object.assign({className:p},{children:[!u&&(0,U.jsx)("div",Object.assign({className:"stylist-message-bubble__avatar"},{children:c?(0,U.jsx)("div",Object.assign({className:"stylist-message-bubble__avatar-icon"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"20",height:"20",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M12 1a9 9 0 019 9c0 4.56-3.37 8.33-7.76 8.95l-.19-.47a7.99 7.99 0 002.93-10.57A8.02 8.02 0 004.06 13.1 9 9 0 0112 1zm7.12 13.93l.37.37-.36.36.01-.73zm1.36-1.55a2.83 2.83 0 00-.5-.31l.36-.74c.28.12.54.29.78.48l-.64.57zm-14.81.19l.36.73c-.29.16-.57.35-.8.57l-.57-.64c.31-.3.65-.54 1.01-.66zM6.66 22l1.93-3.1c-.47-.55-.85-1.16-1.14-1.8L2.8 19.13V22h3.86zm10.46-2.91L19 21.99v-2.86l-1.14-.93c.12-.39.19-.8.19-1.22l.08-.04A8.96 8.96 0 0022 10 10 10 0 002 10a9 9 0 003.34 7.03L1.94 20.5A1 1 0 002.86 22h16.28a1 1 0 00.92-1.5l-2.94-3.41z"})}))})):(0,U.jsx)("div",Object.assign({className:"stylist-message-bubble__avatar-info"},{children:"i"}))})),(0,U.jsxs)("div",Object.assign({className:"stylist-message-bubble__content",style:f},{children:[a.split("\n").map(((e,t)=>(0,U.jsxs)(j.Fragment,{children:[e,t<a.split("\n").length-1&&(0,U.jsx)("br",{})]},t))),h&&(0,U.jsx)("div",Object.assign({className:"stylist-message-bubble__feedback"},{children:(0,U.jsx)(Ft,{messageId:r,onThumbsUp:()=>{l(!0),n&&(n(r,!0),Bt("ASSISTANT_RESPONSE_THUMBS_UP",Ce(),{messageId:r,messageContent:a.substring(0,100)}))},primaryColor:t})}))]})),(0,U.jsx)("div",Object.assign({className:"stylist-message-bubble__time"},{children:At(i,"h:mm a")}))]}))},Ht=({item:e,onFeedback:t,onAddToWishlist:n,onAddToCart:r,onTryOn:s,onFavorite:a,onRemove:i,showDetails:o=!1,primaryColor:l,onClick:u,isClosetItem:c=!1,isFavorite:d=!1})=>{const h=e.id,p=e.name,f=e.brand,m=e.price,g="salePrice"in e?e.salePrice:void 0,y="matchScore"in e?e.matchScore:void 0,b="matchReasons"in e?e.matchReasons:[],v="category"in e?e.category:void 0,[x,w]=(0,j.useState)(null),[k,S]=(0,j.useState)(!1),[I,N]=(0,j.useState)(d),T=c?"image"in e?e.image:"":"imageUrls"in e&&e.imageUrls&&e.imageUrls.length>0?e.imageUrls[0]:"",C=()=>{u?u(e):!c&&"url"in e&&window.open(e.url,"_blank")},E=e=>{if(t){t(h,e);w(e?"Added to your liked items":"Noted - not your style"),S(!0),setTimeout((()=>{S(!1),setTimeout((()=>{w(null)}),300)}),1500)}},$=t=>{t.stopPropagation(),s&&s(e)},_=g&&m>0?Math.round((m-g)/m*100):null,O=v&&["top","bottom","dress","outerwear","shoes","accessory"].includes(v.toLowerCase());(e=>{const t=e.toLowerCase();t.includes("shirt")||t.includes("top")||t.includes("tee")||t.includes("blouse")?ge.TOP:t.includes("pant")||t.includes("jean")||t.includes("bottom")||t.includes("skirt")||t.includes("short")?ge.BOTTOM:t.includes("dress")?ge.DRESS:t.includes("jacket")||t.includes("coat")||t.includes("sweater")||t.includes("cardigan")||t.includes("hoodie")?ge.OUTERWEAR:t.includes("shoe")||t.includes("sneaker")||t.includes("boot")||t.includes("sandal")?ge.SHOES:t.includes("accessory")||t.includes("hat")||t.includes("bag")||t.includes("jewelry")||t.includes("watch")||t.includes("scarf")?ge.ACCESSORY:ge.TOP})(v);return(0,U.jsxs)("div",Object.assign({className:"stylist-item-card "+(k?"stylist-item-card--animate":"")},{children:[(0,U.jsxs)("div",Object.assign({className:"stylist-item-card__image-container",onClick:C},{children:[T?(0,U.jsx)("img",{src:T,alt:p,className:"stylist-item-card__image",loading:"lazy"}):(0,U.jsx)("div",Object.assign({className:"stylist-item-card__image-placeholder"},{children:"No Image"})),_&&(0,U.jsxs)("div",Object.assign({className:"stylist-item-card__discount"},{children:[_,"% OFF"]})),x&&(0,U.jsx)("div",Object.assign({className:"stylist-item-card__feedback-text",style:{backgroundColor:`${l}ee`}},{children:x})),O&&T&&s&&(0,U.jsx)("div",Object.assign({className:"stylist-item-card__try-on-overlay"},{children:(0,U.jsxs)("button",Object.assign({className:"stylist-item-card__try-on-button",onClick:$,style:{backgroundColor:l}},{children:[(0,U.jsx)("span",Object.assign({className:"stylist-item-card__try-on-icon"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"16",height:"16",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"})}))})),(0,U.jsx)("span",Object.assign({className:"stylist-item-card__try-on-text"},{children:"Try On"}))]}))}))]})),(0,U.jsxs)("div",Object.assign({className:"stylist-item-card__content",onClick:C},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-item-card__brand"},{children:f})),(0,U.jsx)("div",Object.assign({className:"stylist-item-card__name"},{children:p})),(0,U.jsx)("div",Object.assign({className:"stylist-item-card__price"},{children:g?(0,U.jsxs)(U.Fragment,{children:[(0,U.jsx)("span",Object.assign({className:"stylist-item-card__price--sale"},{children:Rt(g)})),(0,U.jsx)("span",Object.assign({className:"stylist-item-card__price--original"},{children:Rt(m)}))]}):(0,U.jsx)("span",{children:Rt(m)})}))]})),o&&b.length>0&&(0,U.jsxs)("div",Object.assign({className:"stylist-item-card__match-reasons"},{children:[(0,U.jsxs)("div",Object.assign({className:"stylist-item-card__match-score",style:{color:l}},{children:[Math.round(100*y),"% Match"]})),(0,U.jsx)("ul",Object.assign({className:"stylist-item-card__reason-list"},{children:b.map(((e,t)=>(0,U.jsx)("li",Object.assign({className:"stylist-item-card__reason-item"},{children:e}),t)))}))]})),(0,U.jsx)("div",Object.assign({className:"stylist-item-card__actions"},{children:c?(0,U.jsxs)(U.Fragment,{children:[a&&(0,U.jsx)("button",Object.assign({className:"stylist-item-card__favorite-btn "+(I?"stylist-item-card__favorite-btn--active":""),onClick:e=>{e.stopPropagation();const t=!I;N(t),a(t)},"aria-label":I?"Remove from favorites":"Add to favorites"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"20",height:"20",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"})}))})),i&&(0,U.jsx)("button",Object.assign({className:"stylist-item-card__remove-btn",onClick:e=>{e.stopPropagation(),i()},"aria-label":"Remove from closet"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"20",height:"20",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"})}))}))]}):(0,U.jsxs)(U.Fragment,{children:[(0,U.jsx)(Mt,{itemId:h,onLike:()=>E(!0),onDislike:()=>E(!1),primaryColor:l}),O&&T&&s&&(0,U.jsxs)("button",Object.assign({className:"stylist-item-card__try-on-btn",onClick:$,"aria-label":"Try on this item",style:{backgroundColor:l}},{children:[(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"16",height:"16",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"})})),"Try On"]})),n&&(0,U.jsx)("button",Object.assign({className:"stylist-item-card__wishlist-btn",onClick:e=>{e.stopPropagation(),n&&(n(h),w("Added to wishlist"),setTimeout((()=>{w(null)}),1800))},"aria-label":"Add to wishlist"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"20",height:"20",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"})}))})),r&&(0,U.jsx)("button",Object.assign({className:"stylist-item-card__cart-btn",onClick:e=>{e.stopPropagation(),r&&(r(h),w("Added to cart"),setTimeout((()=>{w(null)}),1800))},"aria-label":"Add to cart"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"20",height:"20",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M11 9h2V6h3V4h-3V1h-2v3H8v2h3v3zm-4 9c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2zm-9.83-3.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.86-7.01L19.42 4h-.01l-1.1 2-2.76 5H8.53l-.13-.27L6.16 6l-.95-2-.94-2H1v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.13 0-.25-.11-.25-.25z"})}))}))]})}))]}))},qt=({onClick:e,isSaved:t=!1,label:n="Save",primaryColor:r})=>{const s=r?{backgroundColor:r}:void 0;return(0,U.jsxs)("button",Object.assign({className:"stylist-wishlist-button "+(t?"stylist-wishlist-button--saved":""),onClick:e,style:t?void 0:s},{children:[(0,U.jsx)("span",Object.assign({className:"stylist-wishlist-button__icon"},{children:t?(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"20",height:"20",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"})})):(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"20",height:"20",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zm-4.4 15.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z"})}))})),(0,U.jsx)("span",Object.assign({className:"stylist-wishlist-button__label"},{children:t?"Saved":n}))]}))},Kt=({outfit:e,onFeedback:t,onSaveOutfit:n,onItemClick:r,primaryColor:s})=>{const{id:a,items:i,occasion:o,matchScore:l,matchReasons:u}=e,c=e=>{t&&t(a,e)};return(0,U.jsxs)("div",Object.assign({className:"stylist-outfit-display"},{children:[(0,U.jsxs)("div",Object.assign({className:"stylist-outfit-display__header"},{children:[(0,U.jsxs)("div",Object.assign({className:"stylist-outfit-display__title"},{children:["Complete Outfit for ",o]})),(0,U.jsxs)("div",Object.assign({className:"stylist-outfit-display__score",style:{color:s}},{children:[Math.round(100*l),"% Match"]}))]})),(0,U.jsx)("div",Object.assign({className:"stylist-outfit-display__items"},{children:i.map((e=>(0,U.jsxs)("div",Object.assign({className:"stylist-outfit-display__item",onClick:()=>{return t=e.id,void(r&&r(t));var t}},{children:[e.imageUrl?(0,U.jsx)("img",{src:e.imageUrl,alt:e.name,className:"stylist-outfit-display__item-image"}):(0,U.jsx)("div",Object.assign({className:"stylist-outfit-display__item-placeholder"},{children:e.category})),(0,U.jsxs)("div",Object.assign({className:"stylist-outfit-display__item-info"},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-outfit-display__item-brand"},{children:e.brand})),(0,U.jsx)("div",Object.assign({className:"stylist-outfit-display__item-name"},{children:e.name}))]}))]}),e.id)))})),u.length>0&&(0,U.jsxs)("div",Object.assign({className:"stylist-outfit-display__reasons"},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-outfit-display__reasons-title"},{children:"Why this outfit works:"})),(0,U.jsx)("ul",Object.assign({className:"stylist-outfit-display__reasons-list"},{children:u.map(((e,t)=>(0,U.jsx)("li",Object.assign({className:"stylist-outfit-display__reason-item"},{children:e}),t)))}))]})),(0,U.jsxs)("div",Object.assign({className:"stylist-outfit-display__actions"},{children:[(0,U.jsx)(Mt,{onLike:()=>c(!0),onDislike:()=>c(!1),primaryColor:s}),(0,U.jsx)(qt,{onClick:()=>{n&&n(a)},primaryColor:s,label:"Save Outfit"})]}))]}))},Xt=[{id:"q1",questionText:"How would you describe your overall fashion style?",type:"image",options:[{id:"classic",text:"Classic & Timeless",value:"classic",imageUrl:"https://images.unsplash.com/photo-1603189343302-e603f7add05a?w=400&h=300&fit=crop"},{id:"minimalist",text:"Minimalist & Clean",value:"minimalist",imageUrl:"https://images.unsplash.com/photo-1512621776951-a57141f2eefd?w=400&h=300&fit=crop"},{id:"trendy",text:"Trendy & Fashion-Forward",value:"trendy",imageUrl:"https://images.unsplash.com/photo-1523359346063-d879354c0ea5?w=400&h=300&fit=crop"},{id:"edgy",text:"Edgy & Alternative",value:"edgy",imageUrl:"https://images.unsplash.com/photo-1536243298747-ea8874136d64?w=400&h=300&fit=crop"},{id:"sporty",text:"Sporty & Casual",value:"sporty",imageUrl:"https://images.unsplash.com/photo-1517466787929-bc90951d0974?w=400&h=300&fit=crop"},{id:"bohemian",text:"Bohemian & Free-Spirited",value:"bohemian",imageUrl:"https://images.unsplash.com/photo-1534777620591-29eb7d8d7563?w=400&h=300&fit=crop"}],category:"style"},{id:"q2",questionText:"Which color palette do you prefer for your wardrobe?",type:"image",options:[{id:"neutrals",text:"Neutrals (Black, White, Grey, Beige)",value:"neutrals",imageUrl:"https://images.unsplash.com/photo-1518895949257-7621c3c786d7?w=400&h=300&fit=crop"},{id:"earthy",text:"Earthy Tones (Brown, Olive, Rust)",value:"earthy",imageUrl:"https://images.unsplash.com/photo-1514362453360-8f94243c9996?w=400&h=300&fit=crop"},{id:"pastels",text:"Pastels (Light Pink, Baby Blue, Lavender)",value:"pastels",imageUrl:"https://images.unsplash.com/photo-1499781350541-7783f6c6a0c8?w=400&h=300&fit=crop"},{id:"bold",text:"Bold & Bright Colors (Red, Yellow, Electric Blue)",value:"bold",imageUrl:"https://images.unsplash.com/photo-1535639818669-c059d2f038e6?w=400&h=300&fit=crop"},{id:"monochrome",text:"Monochrome or All-Black",value:"monochrome",imageUrl:"https://images.unsplash.com/photo-1550330550-36e5c4d9b0c3?w=400&h=300&fit=crop"}],category:"color"},{id:"q3",questionText:"What type of outfits do you need the most recommendations for?",type:"multiple",options:[{id:"casual",text:"Everyday Casual",value:"casual"},{id:"work",text:"Workwear & Business Casual",value:"work"},{id:"street",text:"Streetwear & Trendy Looks",value:"street"},{id:"date",text:"Date Night & Going Out",value:"date"},{id:"formal",text:"Formal & Special Events",value:"formal"}],category:"occasion"},{id:"q4",questionText:"Which patterns do you typically wear?",type:"multiple",options:[{id:"solid",text:"Solid Colors (No Pattern)",value:"solid"},{id:"stripes",text:"Stripes",value:"stripes"},{id:"floral",text:"Floral",value:"floral"},{id:"geometric",text:"Geometric",value:"geometric"},{id:"animal",text:"Animal Print",value:"animal"},{id:"plaid",text:"Plaid/Check",value:"plaid"}],category:"pattern"},{id:"q5",questionText:"How do you prefer your tops to fit?",type:"image",options:[{id:"oversized",text:"Oversized & Relaxed",value:"oversized",imageUrl:"https://images.unsplash.com/photo-1542837209-3bd9538b3a96?w=400&h=300&fit=crop"},{id:"fitted",text:"Slim & Fitted",value:"fitted",imageUrl:"https://images.unsplash.com/photo-1570727624862-3008fe67a6f9?w=400&h=300&fit=crop"},{id:"cropped",text:"Cropped",value:"cropped",imageUrl:"https://images.unsplash.com/photo-1515886657613-9f3515b0c78f?w=400&h=300&fit=crop"},{id:"structured",text:"Boxy & Structured",value:"structured",imageUrl:"https://images.unsplash.com/photo-1603252109303-2751441dd157?w=400&h=300&fit=crop"}],category:"fit"},{id:"q6",questionText:"How do you prefer your bottoms to fit?",type:"image",options:[{id:"skinny",text:"Skinny/Slim",value:"skinny",imageUrl:"https://images.unsplash.com/photo-1598808503824-9725718f223d?w=400&h=300&fit=crop"},{id:"relaxed",text:"Relaxed/Regular",value:"relaxed",imageUrl:"https://images.unsplash.com/photo-1581985673473-0784a7a44e39?w=400&h=300&fit=crop"},{id:"wide",text:"Wide Leg",value:"wide",imageUrl:"https://images.unsplash.com/photo-1593030103066-0093718efeb9?w=400&h=300&fit=crop"},{id:"straight",text:"Straight Cut",value:"straight",imageUrl:"https://images.unsplash.com/photo-1582418702059-97ebafb35d09?w=400&h=300&fit=crop"}],category:"fit"},{id:"q7",questionText:"What size do you typically wear for tops?",type:"single",options:[{id:"xs",text:"XS",value:"xs"},{id:"s",text:"S",value:"s"},{id:"m",text:"M",value:"m"},{id:"l",text:"L",value:"l"},{id:"xl",text:"XL",value:"xl"},{id:"xxl",text:"XXL+",value:"xxl"}],category:"size"},{id:"q8",questionText:"What size do you typically wear for bottoms/pants?",type:"single",options:[{id:"0-2",text:"0-2",value:"0-2"},{id:"4-6",text:"4-6",value:"4-6"},{id:"8-10",text:"8-10",value:"8-10"},{id:"12-14",text:"12-14",value:"12-14"},{id:"16-18",text:"16-18",value:"16-18"},{id:"20+",text:"20+",value:"20+"}],category:"size"},{id:"q9",questionText:"What's your typical budget for a single clothing item?",type:"single",options:[{id:"budget_low",text:"Under $50",value:"Under $50"},{id:"budget_medium_low",text:"$50 - $100",value:"$50 - $100"},{id:"budget_medium_high",text:"$100 - $250",value:"$100 - $250"},{id:"budget_high",text:"$250+",value:"$250+"}],category:"budget"},{id:"q10",questionText:"Which brands do you typically shop?",type:"multiple",options:[{id:"zara",text:"Zara",value:"zara"},{id:"hm",text:"H&M",value:"hm"},{id:"uniqlo",text:"Uniqlo",value:"uniqlo"},{id:"gap",text:"Gap",value:"gap"},{id:"jcrew",text:"J.Crew",value:"jcrew"},{id:"madewell",text:"Madewell",value:"madewell"},{id:"nike",text:"Nike",value:"nike"},{id:"adidas",text:"Adidas",value:"adidas"},{id:"lululemon",text:"Lululemon",value:"lululemon"},{id:"anthropologie",text:"Anthropologie",value:"anthropologie"},{id:"other",text:"Other",value:"other"}],category:"brand"},{id:"q11",questionText:"Which celebrity's style do you most admire?",type:"image",options:[{id:"audrey",text:"Audrey Hepburn (Classic Elegance)",value:"audrey",imageUrl:"https://www.fillmurray.com/400/300"},{id:"harry",text:"Harry Styles (Bold & Eclectic)",value:"harry",imageUrl:"https://www.fillmurray.com/401/300"},{id:"zendaya",text:"Zendaya (Fashion-Forward)",value:"zendaya",imageUrl:"https://www.fillmurray.com/400/301"},{id:"pharrell",text:"Pharrell Williams (Streetwear)",value:"pharrell",imageUrl:"https://www.fillmurray.com/401/301"},{id:"jlo",text:"Jennifer Lopez (Glamorous)",value:"jlo",imageUrl:"https://www.fillmurray.com/402/300"},{id:"timothee",text:"Timothe Chalamet (Modern Minimal)",value:"timothee",imageUrl:"https://www.fillmurray.com/400/302"}],category:"inspiration"},{id:"q12",questionText:"What types of shoes do you wear most often?",type:"multiple",options:[{id:"sneakers",text:"Sneakers",value:"sneakers"},{id:"boots",text:"Boots",value:"boots"},{id:"flats",text:"Flats/Loafers",value:"flats"},{id:"heels",text:"Heels",value:"heels"},{id:"sandals",text:"Sandals",value:"sandals"},{id:"athletic",text:"Athletic Shoes",value:"athletic"}],category:"footwear"},{id:"q13",questionText:"Which accessories do you typically wear?",type:"multiple",options:[{id:"none",text:"Minimal/No Accessories",value:"none"},{id:"earrings",text:"Earrings",value:"earrings"},{id:"necklaces",text:"Necklaces",value:"necklaces"},{id:"bracelets",text:"Bracelets/Watches",value:"bracelets"},{id:"rings",text:"Rings",value:"rings"},{id:"scarves",text:"Scarves/Bandanas",value:"scarves"},{id:"hats",text:"Hats",value:"hats"},{id:"belts",text:"Belts",value:"belts"}],category:"accessories"},{id:"q14",questionText:"Which season do you most enjoy dressing for?",type:"image",options:[{id:"spring",text:"Spring",value:"spring",imageUrl:"https://images.unsplash.com/photo-1497942304796-b8bc2cc898f3?w=400&h=300&fit=crop"},{id:"summer",text:"Summer",value:"summer",imageUrl:"https://images.unsplash.com/photo-1517206577696-6ce38fb787a3?w=400&h=300&fit=crop"},{id:"fall",text:"Fall/Autumn",value:"fall",imageUrl:"https://images.unsplash.com/photo-1551843073-4a9a5b6fcd5f?w=400&h=300&fit=crop"},{id:"winter",text:"Winter",value:"winter",imageUrl:"https://images.unsplash.com/photo-1515311320503-6591cade8414?w=400&h=300&fit=crop"}],category:"seasonal"},{id:"q15",questionText:"How do you feel about layering clothes?",type:"single",options:[{id:"love",text:"Love it - the more layers the better",value:"love"},{id:"sometimes",text:"Sometimes - when appropriate for weather",value:"sometimes"},{id:"minimal",text:"Prefer minimal layers",value:"minimal"},{id:"avoid",text:"Avoid layering when possible",value:"avoid"}],category:"styling"},{id:"q16",questionText:"How often do you shop for clothes?",type:"single",options:[{id:"weekly",text:"Weekly",value:"weekly"},{id:"monthly",text:"Monthly",value:"monthly"},{id:"seasonally",text:"Seasonally",value:"seasonally"},{id:"rarely",text:"Rarely/As needed",value:"rarely"}],category:"shopping"},{id:"q17",questionText:"How do you approach fashion trends?",type:"single",options:[{id:"early",text:"Early adopter - always trying new trends",value:"early"},{id:"selective",text:"Selective - adopt trends that match my style",value:"selective"},{id:"wait",text:"Wait and see - adopt trends after they're established",value:"wait"},{id:"avoid",text:"Avoid trends - prefer timeless styles",value:"avoid"}],category:"styling"},{id:"q18",questionText:"When it comes to choosing clothes, you prioritize:",type:"slider",minValue:0,maxValue:100,step:1,category:"priorities"},{id:"q19",questionText:"How important is sustainability in your clothing choices?",type:"single",options:[{id:"very",text:"Very important - I prioritize sustainable brands",value:"very"},{id:"somewhat",text:"Somewhat important - I consider it when convenient",value:"somewhat"},{id:"neutral",text:"Neutral - I don't specifically seek it out",value:"neutral"},{id:"not",text:"Not important to me",value:"not"}],category:"values"},{id:"q20",questionText:"Do you shop secondhand/vintage clothing?",type:"single",options:[{id:"frequently",text:"Frequently",value:"frequently"},{id:"sometimes",text:"Sometimes",value:"sometimes"},{id:"rarely",text:"Rarely",value:"rarely"},{id:"never",text:"Never",value:"never"}],category:"shopping"},{id:"q21",questionText:"What best describes your work environment dress code?",type:"single",options:[{id:"formal",text:"Formal/Business Professional",value:"formal"},{id:"business",text:"Business Casual",value:"business"},{id:"casual",text:"Casual",value:"casual"},{id:"creative",text:"Creative/No Dress Code",value:"creative"},{id:"uniform",text:"Uniform Required",value:"uniform"},{id:"na",text:"Not Applicable",value:"na"}],category:"lifestyle"},{id:"q22",questionText:"How active is your lifestyle?",type:"single",options:[{id:"very",text:"Very active - I need clothes for frequent exercise",value:"very"},{id:"moderately",text:"Moderately active - occasional exercise",value:"moderately"},{id:"somewhat",text:"Somewhat active - light activity",value:"somewhat"},{id:"not",text:"Not very active",value:"not"}],category:"lifestyle"},{id:"q23",questionText:"Which fabric types do you prefer?",type:"multiple",options:[{id:"cotton",text:"Cotton",value:"cotton"},{id:"linen",text:"Linen",value:"linen"},{id:"silk",text:"Silk",value:"silk"},{id:"wool",text:"Wool",value:"wool"},{id:"synthetic",text:"Synthetic/Technical Fabrics",value:"synthetic"},{id:"leather",text:"Leather",value:"leather"},{id:"denim",text:"Denim",value:"denim"},{id:"knit",text:"Knits",value:"knit"}],category:"fabrics"},{id:"q24",questionText:"Do you have any special clothing requirements or preferences?",type:"multiple",options:[{id:"none",text:"None",value:"none"},{id:"pockets",text:"Must have pockets",value:"pockets"},{id:"petite",text:"Petite sizes",value:"petite"},{id:"tall",text:"Tall sizes",value:"tall"},{id:"plus",text:"Plus sizes",value:"plus"},{id:"adaptable",text:"Adaptable/Accessible clothing",value:"adaptable"},{id:"allergy",text:"Hypoallergenic fabrics",value:"allergy"}],category:"requirements"},{id:"q25",questionText:"What's your main style goal right now?",type:"single",options:[{id:"refresh",text:"Refresh my everyday wardrobe",value:"refresh"},{id:"special",text:"Find outfits for special occasions",value:"special"},{id:"transition",text:"Transition to a new style",value:"transition"},{id:"minimize",text:"Build a capsule wardrobe",value:"minimize"},{id:"experiment",text:"Experiment with new styles",value:"experiment"},{id:"confidence",text:"Gain confidence in my clothing choices",value:"confidence"}],category:"goals"}],Yt="stylist_quiz_progress",Qt=({quizId:e,title:t,description:n,onSubmit:r,primaryColor:s})=>{const[a]=(0,j.useState)(Xt),{currentQuestionIndex:i,savedAnswers:o}=(()=>{try{const t=localStorage.getItem(`${Yt}_${e}`);if(t){const e=JSON.parse(t);if(e.answers&&Array.isArray(e.answers))return{currentQuestionIndex:e.currentQuestion||0,savedAnswers:e.answers}}}catch(e){}return{currentQuestionIndex:0,savedAnswers:[]}})(),[l,u]=(0,j.useState)(i),[c,d]=(0,j.useState)(o),[h,p]=(0,j.useState)(!1),[f,m]=(0,j.useState)(!1);(0,j.useEffect)((()=>{try{const t={currentQuestion:l,answers:c};localStorage.setItem(`${Yt}_${e}`,JSON.stringify(t))}catch(e){}}),[l,c,e]),(0,j.useEffect)((()=>{0!==c.length&&(h||r(c))}),[c,h,r]);const g=(e,t)=>{const n=[...c],r=c.findIndex((t=>t.questionId===e)),s={questionId:e,answerId:t,answered:new Date};r>=0?n[r]=s:n.push(s),d(n),l<a.length-1&&setTimeout((()=>{u(l+1)}),300)};if(f)return(0,U.jsx)("div",Object.assign({className:"stylist-style-quiz stylist-style-quiz--loading"},{children:(0,U.jsx)("div",Object.assign({className:"stylist-style-quiz__loader"},{children:"Loading quiz..."}))}));if(0===a.length)return(0,U.jsx)("div",Object.assign({className:"stylist-style-quiz stylist-style-quiz--error"},{children:(0,U.jsx)("div",Object.assign({className:"stylist-style-quiz__error"},{children:"Sorry, we couldn't load the style quiz. Please try again later."}))}));const y=a[l],b=l===a.length-1;return(0,U.jsxs)("div",Object.assign({className:"stylist-style-quiz"},{children:[(0,U.jsxs)("div",Object.assign({className:"stylist-style-quiz__header"},{children:[(0,U.jsx)("h3",Object.assign({className:"stylist-style-quiz__title"},{children:t})),n&&(0,U.jsx)("p",Object.assign({className:"stylist-style-quiz__description"},{children:n}))]})),(0,U.jsx)("div",Object.assign({className:"stylist-style-quiz__progress"},{children:(0,U.jsx)("div",{className:"stylist-style-quiz__progress-bar",style:{width:(l+1)/a.length*100+"%",backgroundColor:s}})})),(0,U.jsxs)("div",Object.assign({className:"stylist-style-quiz__question"},{children:[(0,U.jsxs)("div",Object.assign({className:"stylist-style-quiz__question-number"},{children:["Question ",l+1," of ",a.length]})),(0,U.jsx)("h4",Object.assign({className:"stylist-style-quiz__question-text"},{children:y.questionText}))]})),(()=>{var e,t,n;if(!y)return null;const r=c.find((e=>e.questionId===y.id));switch(y.type){case"single":return(0,U.jsx)("div",Object.assign({className:"stylist-style-quiz__options"},{children:null===(e=y.options)||void 0===e?void 0:e.map((e=>(0,U.jsx)("button",Object.assign({className:"stylist-style-quiz__option "+((null==r?void 0:r.answerId)===e.id?"stylist-style-quiz__option--selected":""),onClick:()=>g(y.id,e.id),style:(null==r?void 0:r.answerId)===e.id?{borderColor:s,backgroundColor:`${s}20`}:void 0},{children:e.text}),e.id)))}));case"image":return(0,U.jsx)("div",Object.assign({className:"stylist-style-quiz__image-options"},{children:null===(t=y.options)||void 0===t?void 0:t.map((e=>(0,U.jsxs)("button",Object.assign({className:"stylist-style-quiz__image-option "+((null==r?void 0:r.answerId)===e.id?"stylist-style-quiz__image-option--selected":""),onClick:()=>g(y.id,e.id),style:(null==r?void 0:r.answerId)===e.id?{borderColor:s}:void 0},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-style-quiz__image-container",style:{backgroundImage:e.imageUrl?`url(${e.imageUrl})`:void 0}},{children:!e.imageUrl&&(0,U.jsx)("div",{className:"stylist-style-quiz__image-placeholder"})})),(0,U.jsx)("div",Object.assign({className:"stylist-style-quiz__image-label",style:(null==r?void 0:r.answerId)===e.id?{color:s}:void 0},{children:e.text}))]}),e.id)))}));case"multiple":return(0,U.jsx)("div",Object.assign({className:"stylist-style-quiz__options"},{children:null===(n=y.options)||void 0===n?void 0:n.map((e=>{var t;const n=null===(t=null==r?void 0:r.answerIds)||void 0===t?void 0:t.includes(e.id);return(0,U.jsx)("button",Object.assign({className:"stylist-style-quiz__option "+(n?"stylist-style-quiz__option--selected":""),onClick:()=>{const t=(null==r?void 0:r.answerIds)||[],s=n?t.filter((t=>t!==e.id)):[...t,e.id];((e,t)=>{const n=[...c],r=c.findIndex((t=>t.questionId===e)),s={questionId:e,answerIds:t,answered:new Date};r>=0?n[r]=s:n.push(s),d(n)})(y.id,s)},style:n?{borderColor:s,backgroundColor:`${s}20`}:void 0},{children:e.text}),e.id)}))}));case"slider":const a=(e=>"q18"===e?{left:"Comfort",right:"Style"}:{left:"Low",right:"High"})(y.id);return(0,U.jsxs)("div",Object.assign({className:"stylist-style-quiz__slider"},{children:[(0,U.jsx)("input",{type:"range",min:y.minValue||0,max:y.maxValue||100,step:y.step||1,value:(null==r?void 0:r.answerValue)||50,onChange:e=>((e,t)=>{const n=[...c],r=c.findIndex((t=>t.questionId===e)),s={questionId:e,answerValue:t,answered:new Date};r>=0?n[r]=s:n.push(s),d(n)})(y.id,parseInt(e.target.value)),style:{accentColor:s}}),(0,U.jsxs)("div",Object.assign({className:"stylist-style-quiz__slider-labels"},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-style-quiz__slider-label-left"},{children:a.left})),(0,U.jsx)("div",Object.assign({className:"stylist-style-quiz__slider-label-right"},{children:a.right}))]}))]}));default:return null}})(),(0,U.jsxs)("div",Object.assign({className:"stylist-style-quiz__actions"},{children:[l>0&&(0,U.jsx)("button",Object.assign({className:"stylist-style-quiz__button stylist-style-quiz__button--secondary",onClick:()=>u(l-1)},{children:"Previous"})),b?(0,U.jsx)("button",Object.assign({className:"stylist-style-quiz__button stylist-style-quiz__button--primary",onClick:()=>{h||(p(!0),r(c))},style:{backgroundColor:s},disabled:c.length<a.length||h},{children:h?"Submitting...":"Submit"})):(0,U.jsx)("button",Object.assign({className:"stylist-style-quiz__button stylist-style-quiz__button--primary",onClick:()=>u(l+1),style:{backgroundColor:s},disabled:!c.find((e=>e.questionId===y.id))},{children:"Next"}))]}))]}))},Jt=Qt,Zt=({messages:e,onItemFeedback:t,onOutfitFeedback:n,onMessageFeedback:r,onQuizSubmit:s,isLoading:a=!1,primaryColor:i})=>{const o=(0,j.useRef)(null),l=(0,j.useRef)(null);(0,j.useEffect)((()=>{u()}),[e]);const u=()=>{o.current&&o.current.scrollIntoView({behavior:"smooth"})};return(0,U.jsx)("div",Object.assign({className:"stylist-chat-body",ref:l},{children:(0,U.jsxs)("div",Object.assign({className:"stylist-chat-body__messages"},{children:[e.map((e=>(e=>{switch(e.type){case"text":return(0,U.jsx)(Gt,{message:e,primaryColor:i,onFeedback:r},e.id);case"recommendation":return(0,U.jsxs)("div",Object.assign({className:"stylist-chat-body__recommendation"},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-chat-body__recommendation-title"},{children:"Here are some recommendations for you:"})),(0,U.jsx)("div",Object.assign({className:"stylist-chat-body__recommendation-items"},{children:e.items.map((e=>{const n={id:e.id,retailerId:"default",name:e.name,brand:e.brand,category:e.category,price:e.price,salePrice:e.salePrice,colors:[],sizes:[],imageUrls:[e.imageUrl],url:e.url,matchScore:e.matchScore,matchReasons:e.matchReasons,inStock:!0};return(0,U.jsx)(Ht,{item:n,onFeedback:t,primaryColor:i},e.id)}))}))]}),e.id);case"outfit":return(0,U.jsx)(Kt,{outfit:e.outfit,onFeedback:n,primaryColor:i},e.id);case"quiz":return(0,U.jsx)(Jt,{quizId:e.quizId,title:e.title,description:e.description,onSubmit:s||(()=>{}),primaryColor:i},e.id);case"loading":return(0,U.jsx)("div",Object.assign({className:"stylist-chat-body__loading"},{children:(0,U.jsxs)("div",Object.assign({className:"stylist-chat-body__loading-dots"},{children:[(0,U.jsx)("span",{}),(0,U.jsx)("span",{}),(0,U.jsx)("span",{})]}))}),e.id);case"error":return(0,U.jsxs)("div",Object.assign({className:"stylist-chat-body__error"},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-chat-body__error-icon"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"24",height:"24",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"})}))})),(0,U.jsx)("div",Object.assign({className:"stylist-chat-body__error-message"},{children:e.error}))]}),e.id);default:return null}})(e))),a&&(0,U.jsx)("div",Object.assign({className:"stylist-chat-body__loading"},{children:(0,U.jsxs)("div",Object.assign({className:"stylist-chat-body__loading-dots"},{children:[(0,U.jsx)("span",{}),(0,U.jsx)("span",{}),(0,U.jsx)("span",{})]}))})),(0,U.jsx)("div",{ref:o})]}))}))},en=({onSendMessage:e,placeholder:t="Type a message...",disabled:n=!1,primaryColor:r})=>{const[s,a]=(0,j.useState)(""),i=(0,j.useRef)(null),{isLoading:o}=oe();(0,j.useEffect)((()=>{i.current&&i.current.focus()}),[]),(0,j.useEffect)((()=>{i.current&&(i.current.style.height="auto",i.current.style.height=`${Math.min(i.current.scrollHeight,120)}px`)}),[s]);const l=()=>{const t=s.trim();!t||n||o||(e(t),a(""),i.current&&(i.current.style.height="auto"))},u={backgroundColor:r||void 0};return(0,U.jsxs)("div",Object.assign({className:"stylist-chat-input"},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-chat-input__container"},{children:(0,U.jsx)("textarea",{ref:i,className:"stylist-chat-input__textarea",placeholder:t,value:s,onChange:e=>{a(e.target.value)},onKeyDown:e=>{"Enter"!==e.key||e.shiftKey||(e.preventDefault(),l())},disabled:n||o,rows:1,"aria-label":"Message input"})})),(0,U.jsx)("button",Object.assign({className:"stylist-chat-input__send-button",onClick:l,disabled:!s.trim()||n||o,style:u,"aria-label":"Send message"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"20",height:"20",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"})}))}))]}))};var tn=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const nn=e=>new Promise(((t,n)=>{const r=new Image;r.crossOrigin="anonymous",r.onload=()=>{t(r)},r.onerror=e=>{n(new Error(`Failed to load image: ${e}`))},r.src=e})),rn=e=>tn(void 0,void 0,void 0,(function*(){const t=yield nn(e);return{width:t.width,height:t.height}})),sn=e=>new Promise(((t,n)=>{const r=new FileReader;r.onload=e=>{var r;(null===(r=e.target)||void 0===r?void 0:r.result)?t(e.target.result):n(new Error("Failed to convert file to data URL"))},r.onerror=e=>{n(e)},r.readAsDataURL(e)})),an=e=>e<1024?`${e} bytes`:e<1048576?`${(e/1024).toFixed(1)} KB`:`${(e/1048576).toFixed(1)} MB`;var on=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const ln=(e,t,n,r=0,s=!1,a=!1)=>{e.save();const i=n.x+n.width/2,o=n.y+n.height/2;e.translate(i,o),0!==r&&e.rotate(r*Math.PI/180);const l=s?-1:1,u=a?-1:1;e.scale(l,u),e.drawImage(t,-n.width/2,-n.height/2,n.width,n.height),e.restore()},un=({width:e,height:t,activePosition:n})=>(0,U.jsxs)("div",Object.assign({className:"stylist-body-guide",style:{width:e,height:t}},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-body-guide__region stylist-body-guide__region--head "+(n===ye.HEAD?"stylist-body-guide__region--active":"")},{children:(0,U.jsx)("span",Object.assign({className:"stylist-body-guide__label"},{children:"Head"}))})),(0,U.jsx)("div",Object.assign({className:"stylist-body-guide__region stylist-body-guide__region--neck "+(n===ye.NECK?"stylist-body-guide__region--active":"")},{children:(0,U.jsx)("span",Object.assign({className:"stylist-body-guide__label"},{children:"Neck"}))})),(0,U.jsx)("div",Object.assign({className:"stylist-body-guide__region stylist-body-guide__region--upper-body "+(n===ye.UPPER_BODY?"stylist-body-guide__region--active":"")},{children:(0,U.jsx)("span",Object.assign({className:"stylist-body-guide__label"},{children:"Upper Body"}))})),(0,U.jsx)("div",Object.assign({className:"stylist-body-guide__region stylist-body-guide__region--waist "+(n===ye.WAIST?"stylist-body-guide__region--active":"")},{children:(0,U.jsx)("span",Object.assign({className:"stylist-body-guide__label"},{children:"Waist"}))})),(0,U.jsx)("div",Object.assign({className:"stylist-body-guide__region stylist-body-guide__region--lower-body "+(n===ye.LOWER_BODY?"stylist-body-guide__region--active":"")},{children:(0,U.jsx)("span",Object.assign({className:"stylist-body-guide__label"},{children:"Lower Body"}))})),(0,U.jsx)("div",Object.assign({className:"stylist-body-guide__region stylist-body-guide__region--feet "+(n===ye.FEET?"stylist-body-guide__region--active":"")},{children:(0,U.jsx)("span",Object.assign({className:"stylist-body-guide__label"},{children:"Feet"}))})),(0,U.jsx)("div",Object.assign({className:"stylist-body-guide__region stylist-body-guide__region--full-body "+(n===ye.FULL_BODY?"stylist-body-guide__region--active":"")},{children:(0,U.jsx)("span",Object.assign({className:"stylist-body-guide__label"},{children:"Full Body"}))}))]}));var cn=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const dn=({outfit:e,userImage:t,setCanvasRef:n,onGarmentSelect:r,showBodyGuide:s=!1})=>{var a;const i=(0,j.useRef)(null),[o,l]=(0,j.useState)(null),[u,c]=(0,j.useState)(!1),[d,h]=(0,j.useState)(null),p=Se((e=>e.canvasWidth)),f=Se((e=>e.canvasHeight)),m=Se((e=>e.settings.showGuidelines)),g=Se((e=>e.updateGarment));(0,j.useEffect)((()=>{i.current&&n(i.current)}),[n]),(0,j.useEffect)((()=>{cn(void 0,void 0,void 0,(function*(){const n=i.current;if(!n)return;const r=n.getContext("2d");if(r)if(r.clearRect(0,0,n.width,n.height),!m||t){if(t)try{const s=yield nn(t.url);r.drawImage(s,0,0,n.width,n.height),(null==e?void 0:e.garments.length)&&(yield((e,t,n,r)=>on(void 0,void 0,void 0,(function*(){const s=e.getContext("2d");if(!s)return;s.clearRect(0,0,e.width,e.height),s.drawImage(t,0,0,e.width,e.height);const a=[...n].sort(((e,t)=>e.zIndex-t.zIndex));for(const t of a)try{const n=yield r(t.url),a=t.dimensions||{width:n.width,height:n.height},i=t.scale||1,o={width:a.width*i,height:a.height*i},l=t.offset||{x:0,y:0},u={x:(e.width-o.width)/2+l.x,y:(e.height-o.height)/2+l.y,width:o.width,height:o.height};ln(s,n,u,t.rotation||0,t.flipHorizontal||!1,t.flipVertical||!1)}catch(e){}})))(n,s,e.garments,nn))}catch(e){}}else((e,t="rgba(0, 0, 255, 0.2)",n=1)=>{const r=e.getContext("2d");if(r){r.save(),r.strokeStyle=t,r.lineWidth=n;for(let t=1;t<3;t++){const n=e.height/3*t;r.beginPath(),r.moveTo(0,n),r.lineTo(e.width,n),r.stroke()}for(let t=1;t<3;t++){const n=e.width/3*t;r.beginPath(),r.moveTo(n,0),r.lineTo(n,e.height),r.stroke()}r.beginPath(),r.moveTo(e.width/2,0),r.lineTo(e.width/2,e.height),r.moveTo(0,e.height/2),r.lineTo(e.width,e.height/2),r.stroke(),r.restore()}})(n)}))}),[e,t,p,f,m,o,s]);return(0,j.useEffect)((()=>{const e=()=>{c(!1),h(null)};return document.addEventListener("mouseup",e),()=>{document.removeEventListener("mouseup",e)}}),[]),(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-canvas"},{children:[(0,U.jsx)("canvas",{ref:i,width:p,height:f,className:"stylist-try-on-canvas__canvas "+(u?"stylist-try-on-canvas__canvas--dragging":""),onClick:t=>cn(void 0,void 0,void 0,(function*(){if(!r||!e||!e.garments.length)return;const n=i.current;if(!n)return;const s=n.getBoundingClientRect(),a=t.clientX-s.left,o=t.clientY-s.top,u=[...e.garments].sort(((e,t)=>t.zIndex-e.zIndex));for(const e of u)try{const{dimensions:t,offset:s,scale:i}=e;if(!t||!s)continue;const u=n.width/2+s.x,c=n.height/2+s.y,d=t.width*(i||1),h=t.height*(i||1),p=u-d/2,f=c-h/2;if(a>=p&&a<=p+d&&o>=f&&o<=f+h)return r(e.id),void l(e.id)}catch(e){}r(null),l(null)})),onMouseDown:e=>{if(!o)return;const t=i.current;if(!t)return;const n=t.getBoundingClientRect(),r=e.clientX-n.left,s=e.clientY-n.top;c(!0),h({x:r,y:s})},onMouseMove:t=>{if(!(u&&d&&o&&e))return;const n=i.current;if(!n)return;const r=n.getBoundingClientRect(),s=t.clientX-r.left,a=t.clientY-r.top,l=s-d.x,c=a-d.y;h({x:s,y:a});const p=e.garments.find((e=>e.id===o));if(!p||!p.offset)return;const f={x:p.offset.x+l,y:p.offset.y+c};g(o,{offset:f})},onMouseUp:()=>{c(!1),h(null)}}),s&&!t&&(0,U.jsx)(un,{width:p,height:f,activePosition:o?xe((null===(a=null==e?void 0:e.garments.find((e=>e.id===o)))||void 0===a?void 0:a.type)||ge.TOP):void 0}),!t&&(0,U.jsx)("div",Object.assign({className:"stylist-try-on-canvas__placeholder"},{children:(0,U.jsx)("div",Object.assign({className:"stylist-try-on-canvas__placeholder-text"},{children:"Upload a photo to start the virtual try-on"}))}))]}))},hn=dn,pn=({outfit:e,activeGarmentId:t,onGarmentSelect:n,onGarmentRemove:r,onGarmentUpdate:s,onGarmentAdd:a,onChangePhoto:i,disabled:o=!1})=>{var l,u,c,d;const[h,p]=(0,j.useState)(!0),[f,m]=(0,j.useState)(!0),[g,y]=(0,j.useState)(!1),b=(0,j.useRef)(null),[v,x]=(0,j.useState)(null),w=null==e?void 0:e.garments.find((e=>e.id===t)),k=e=>{x(e),b.current&&b.current.click()},S=(e,n)=>{if(t&&(null==w?void 0:w.offset)){const r=Object.assign({},w.offset);r[e]=n,s(t,{offset:r})}};return(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls"},{children:[(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__section"},{children:[(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__section-header",onClick:()=>p(!h)},{children:[(0,U.jsx)("h3",Object.assign({className:"stylist-try-on-controls__section-title"},{children:"Garments"})),(0,U.jsx)("span",Object.assign({className:"stylist-try-on-controls__section-toggle"},{children:h?"":"+"}))]})),h&&(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__section-content"},{children:[(null==e?void 0:e.garments)&&0!==e.garments.length?(0,U.jsx)("div",Object.assign({className:"stylist-try-on-controls__garment-list"},{children:e.garments.map((e=>(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__garment-thumbnail "+(t===e.id?"stylist-try-on-controls__garment-thumbnail--active":""),onClick:()=>n(e.id)},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-try-on-controls__garment-image"},{children:(0,U.jsx)("img",{src:e.url,alt:e.type})})),(0,U.jsx)("div",Object.assign({className:"stylist-try-on-controls__garment-type"},{children:e.type})),(0,U.jsx)("button",Object.assign({className:"stylist-try-on-controls__garment-remove",onClick:t=>{t.stopPropagation(),r(e.id)},"aria-label":"Remove garment"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"16",height:"16",fill:"currentColor"},{children:(0,U.jsx)("path",{d:"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"})}))}))]}),e.id)))})):(0,U.jsx)("div",Object.assign({className:"stylist-try-on-controls__empty"},{children:"No garments added yet. Add a garment below."})),(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__add-garment"},{children:[(0,U.jsx)("button",Object.assign({className:"stylist-try-on-controls__button stylist-try-on-controls__button--full-width",onClick:()=>y(!g),disabled:o},{children:g?"Cancel":"+ Add Garment"})),g&&(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__garment-types",style:{marginTop:"8px"}},{children:[(0,U.jsx)("span",Object.assign({className:"stylist-try-on-controls__label"},{children:"Select garment type:"})),(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__button-group"},{children:[(0,U.jsx)("button",Object.assign({className:"stylist-try-on-controls__button",onClick:()=>k(ge.TOP),disabled:o},{children:"Top"})),(0,U.jsx)("button",Object.assign({className:"stylist-try-on-controls__button",onClick:()=>k(ge.BOTTOM),disabled:o},{children:"Bottom"})),(0,U.jsx)("button",Object.assign({className:"stylist-try-on-controls__button",onClick:()=>k(ge.DRESS),disabled:o},{children:"Dress"})),(0,U.jsx)("button",Object.assign({className:"stylist-try-on-controls__button",onClick:()=>k(ge.OUTERWEAR),disabled:o},{children:"Outerwear"})),(0,U.jsx)("button",Object.assign({className:"stylist-try-on-controls__button",onClick:()=>k(ge.SHOES),disabled:o},{children:"Shoes"})),(0,U.jsx)("button",Object.assign({className:"stylist-try-on-controls__button",onClick:()=>k(ge.ACCESSORY),disabled:o},{children:"Accessory"}))]})),(0,U.jsx)("input",{ref:b,type:"file",accept:"image/*",className:"stylist-try-on-controls__input",style:{display:"none"},onChange:e=>{var t;const n=null===(t=e.target.files)||void 0===t?void 0:t[0];n&&v&&(a(n,v),x(null),y(!1),b.current&&(b.current.value=""))},disabled:o})]}))]}))]}))]})),w&&(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__section"},{children:[(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__section-header",onClick:()=>m(!f)},{children:[(0,U.jsx)("h3",Object.assign({className:"stylist-try-on-controls__section-title"},{children:"Adjustments"})),(0,U.jsx)("span",Object.assign({className:"stylist-try-on-controls__section-toggle"},{children:f?"":"+"}))]})),f&&(0,U.jsx)("div",Object.assign({className:"stylist-try-on-controls__section-content"},{children:(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__garment-controls"},{children:[(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__control-group"},{children:[(0,U.jsxs)("label",Object.assign({className:"stylist-try-on-controls__label"},{children:["Size",(0,U.jsxs)("span",Object.assign({className:"stylist-try-on-controls__value"},{children:[Math.round(100*(w.scale||1)),"%"]}))]})),(0,U.jsx)("input",{type:"range",min:"0.1",max:"2",step:"0.05",value:w.scale||1,onChange:e=>{if(t){const n=parseFloat(e.target.value);s(t,{scale:n})}},className:"stylist-try-on-controls__slider",disabled:o})]})),(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__control-group"},{children:[(0,U.jsxs)("label",Object.assign({className:"stylist-try-on-controls__label"},{children:["Position X",(0,U.jsxs)("span",Object.assign({className:"stylist-try-on-controls__value"},{children:[(null===(l=w.offset)||void 0===l?void 0:l.x)||0,"px"]}))]})),(0,U.jsx)("input",{type:"range",min:"-200",max:"200",step:"1",value:(null===(u=w.offset)||void 0===u?void 0:u.x)||0,onChange:e=>S("x",parseInt(e.target.value)),className:"stylist-try-on-controls__slider",disabled:o})]})),(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__control-group"},{children:[(0,U.jsxs)("label",Object.assign({className:"stylist-try-on-controls__label"},{children:["Position Y",(0,U.jsxs)("span",Object.assign({className:"stylist-try-on-controls__value"},{children:[(null===(c=w.offset)||void 0===c?void 0:c.y)||0,"px"]}))]})),(0,U.jsx)("input",{type:"range",min:"-200",max:"200",step:"1",value:(null===(d=w.offset)||void 0===d?void 0:d.y)||0,onChange:e=>S("y",parseInt(e.target.value)),className:"stylist-try-on-controls__slider",disabled:o})]})),(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__control-group"},{children:[(0,U.jsxs)("label",Object.assign({className:"stylist-try-on-controls__label"},{children:["Rotation",(0,U.jsxs)("span",Object.assign({className:"stylist-try-on-controls__value"},{children:[w.rotation||0,""]}))]})),(0,U.jsx)("input",{type:"range",min:"-180",max:"180",step:"1",value:w.rotation||0,onChange:e=>{if(t){const n=parseFloat(e.target.value);s(t,{rotation:n})}},className:"stylist-try-on-controls__slider",disabled:o})]})),(0,U.jsx)("div",Object.assign({className:"stylist-try-on-controls__control-group"},{children:(0,U.jsx)("button",Object.assign({className:"stylist-try-on-controls__button "+(w.flipHorizontal?"stylist-try-on-controls__button--active":""),onClick:()=>{t&&s(t,{flipHorizontal:!(null==w?void 0:w.flipHorizontal)})},disabled:o},{children:"Flip Horizontal"}))}))]}))}))]})),(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-controls__section"},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-try-on-controls__section-header"},{children:(0,U.jsx)("h3",Object.assign({className:"stylist-try-on-controls__section-title"},{children:"Photo"}))})),(0,U.jsx)("div",Object.assign({className:"stylist-try-on-controls__section-content"},{children:(0,U.jsx)("button",Object.assign({className:"stylist-try-on-controls__button stylist-try-on-controls__button--full-width",onClick:i,disabled:o},{children:"Change Photo"}))}))]}))]}))},fn=pn;var mn=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const gn=({onUpload:e,maxSize:t=10485760,acceptedTypes:n=["image/jpeg","image/png","image/webp"],title:r="Upload your photo",description:s="Take a photo or upload one to try on clothes"})=>{const[a,i]=(0,j.useState)(!1),[o,l]=(0,j.useState)(null),[u,c]=(0,j.useState)(null),[d,h]=(0,j.useState)(null),[p,f]=(0,j.useState)(!1),[m,g]=(0,j.useState)(!0),y=(0,j.useRef)(null),b=(0,j.useRef)(null),v=(0,j.useRef)(null);(0,j.useEffect)((()=>{navigator.mediaDevices&&navigator.mediaDevices.getUserMedia||g(!1)}),[]);const x=(0,j.useCallback)((e=>{e.preventDefault(),e.stopPropagation(),i(!0)}),[]),w=(0,j.useCallback)((e=>{e.preventDefault(),e.stopPropagation(),i(!1)}),[]),k=(0,j.useCallback)((e=>{if(l(null),!e)return c(null),void h(null);if(!(e=>e.type.startsWith("image/"))(e)||!n.includes(e.type))return void l(`Invalid file type. Accepted types: ${n.join(", ")}`);if(e.size>t)return void l(`File size exceeds maximum allowed size of ${an(t)}`);c(e);const r=new FileReader;r.onload=()=>{h(r.result)},r.readAsDataURL(e)}),[n,t]),S=(0,j.useCallback)((e=>{var t;e.preventDefault(),e.stopPropagation(),i(!1);const n=(null===(t=e.dataTransfer.files)||void 0===t?void 0:t[0])||null;k(n)}),[k]),I=(0,j.useCallback)((e=>{var t;const n=(null===(t=e.target.files)||void 0===t?void 0:t[0])||null;k(n)}),[k]),N=(0,j.useCallback)((()=>{y.current&&y.current.click()}),[]),T=(0,j.useCallback)((()=>{u&&e(u)}),[u,e]),C=(0,j.useCallback)((()=>mn(void 0,void 0,void 0,(function*(){l(null),f(!0);try{const e=yield navigator.mediaDevices.getUserMedia({video:{facingMode:"user",width:{ideal:1280},height:{ideal:720}}});b.current&&(b.current.srcObject=e)}catch(e){l("Could not access webcam. Please check permissions and try again."),f(!1)}}))),[]),E=(0,j.useCallback)((()=>{if(b.current&&b.current.srcObject){b.current.srcObject.getTracks().forEach((e=>e.stop())),b.current.srcObject=null}f(!1)}),[]),$=(0,j.useCallback)((()=>{if(b.current&&v.current){const e=b.current,t=v.current;t.width=e.videoWidth,t.height=e.videoHeight;const n=t.getContext("2d");n&&(n.drawImage(e,0,0,t.width,t.height),t.toBlob((e=>{if(e){const n=new File([e],`webcam-photo-${Date.now()}.jpg`,{type:"image/jpeg"});c(n),h(t.toDataURL("image/jpeg")),E()}}),"image/jpeg",.95))}}),[E]);return(0,j.useEffect)((()=>()=>{p&&E()}),[p,E]),(0,U.jsxs)("div",Object.assign({className:"stylist-image-uploader"},{children:[(0,U.jsxs)("div",Object.assign({className:"stylist-image-uploader__header"},{children:[(0,U.jsx)("h3",Object.assign({className:"stylist-image-uploader__title"},{children:r})),(0,U.jsx)("p",Object.assign({className:"stylist-image-uploader__description"},{children:s}))]})),p?(0,U.jsxs)("div",Object.assign({className:"stylist-image-uploader__webcam"},{children:[(0,U.jsx)("video",{ref:b,autoPlay:!0,playsInline:!0,className:"stylist-image-uploader__video"}),(0,U.jsx)("canvas",{ref:v,style:{display:"none"}}),(0,U.jsxs)("div",Object.assign({className:"stylist-image-uploader__webcam-controls"},{children:[(0,U.jsx)("button",Object.assign({type:"button",className:"stylist-image-uploader__capture-btn",onClick:$},{children:"Take Photo"})),(0,U.jsx)("button",Object.assign({type:"button",className:"stylist-image-uploader__cancel-btn",onClick:E},{children:"Cancel"}))]}))]})):(0,U.jsxs)("div",Object.assign({className:`stylist-image-uploader__dropzone ${a?"stylist-image-uploader__dropzone--active":""} ${d?"stylist-image-uploader__dropzone--has-preview":""}`,onDragOver:x,onDragLeave:w,onDrop:S,onClick:d?void 0:N},{children:[d?(0,U.jsx)("div",Object.assign({className:"stylist-image-uploader__preview"},{children:(0,U.jsx)("img",{src:d,alt:"Upload preview"})})):(0,U.jsxs)("div",Object.assign({className:"stylist-image-uploader__placeholder"},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-image-uploader__icon"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"48",height:"48"},{children:(0,U.jsx)("path",{d:"M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"})}))})),(0,U.jsxs)("p",Object.assign({className:"stylist-image-uploader__message"},{children:["Drag & drop your photo here or"," ",(0,U.jsx)("span",Object.assign({className:"stylist-image-uploader__browse"},{children:"browse"}))]})),(0,U.jsxs)("p",Object.assign({className:"stylist-image-uploader__info"},{children:["Accepted formats: ",n.map((e=>e.replace("image/","."))).join(", "),(0,U.jsx)("br",{}),"Max size: ",an(t)]}))]})),(0,U.jsx)("input",{ref:y,type:"file",className:"stylist-image-uploader__input",accept:n.join(","),onChange:I})]})),o&&(0,U.jsx)("div",Object.assign({className:"stylist-image-uploader__error"},{children:o})),(0,U.jsx)("div",Object.assign({className:"stylist-image-uploader__actions"},{children:!p&&(0,U.jsxs)(U.Fragment,{children:[d?(0,U.jsx)("button",Object.assign({className:"stylist-image-uploader__change-btn",onClick:N},{children:"Change Photo"})):m&&(0,U.jsx)("button",Object.assign({className:"stylist-image-uploader__webcam-btn",onClick:C},{children:"Use Webcam"})),(0,U.jsx)("button",Object.assign({className:"stylist-image-uploader__upload-btn",onClick:T,disabled:!u},{children:u?"Continue":"Upload a Photo"}))]})}))]}))},yn=gn;var bn=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const vn={outputFormat:"png",size:"auto",type:"person",semitransparency:!0,channels:"rgba"},xn=(e,t)=>bn(void 0,void 0,void 0,(function*(){var n,r;try{if(!(null==t?void 0:t.apiKey))throw new Error("API key is required for Remove.bg API");const s=Object.assign(Object.assign(Object.assign({},vn),t),{apiKey:t.apiKey}),a=new FormData;if("string"==typeof e)if(e.startsWith("data:")){const t=function(e,t){const n=atob(e),r=[];for(let e=0;e<n.length;e+=1024){const t=n.slice(e,e+1024),s=new Array(t.length);for(let e=0;e<t.length;e++)s[e]=t.charCodeAt(e);const a=new Uint8Array(s);r.push(a)}return new Blob(r,{type:t})}(e.split(",")[1],"image/png");a.append("image_file",t)}else a.append("image_url",e);else a.append("image_file",e);a.append("size",s.size||"auto"),s.outputFormat&&a.append("format",s.outputFormat),s.type&&a.append("type",s.type),void 0!==s.crop&&a.append("crop",s.crop?"true":"false"),s.cropMargin&&a.append("crop_margin",s.cropMargin),s.roi&&a.append("roi",s.roi),s.scale&&a.append("scale",s.scale),void 0!==s.semitransparency&&a.append("semitransparency",s.semitransparency?"true":"false"),s.channels&&a.append("channels",s.channels);const i=yield fetch("https://api.remove.bg/v1.0/removebg",{method:"POST",body:a,headers:{"X-Api-Key":s.apiKey}});if(!i.ok){const e=yield i.json().catch((()=>({})));throw new Error(`Remove.bg API error (${i.status}): ${(null===(r=null===(n=e.errors)||void 0===n?void 0:n[0])||void 0===r?void 0:r.title)||i.statusText}`)}const o=yield i.blob();return{success:!0,imageUrl:URL.createObjectURL(o),method:ve.REMOVE_BG_API}}catch(e){return{success:!1,error:e instanceof Error?e.message:String(e),method:ve.REMOVE_BG_API}}}));class wn{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class kn{refCount(e){return Sn("refCount")}incRef(e){return Sn("incRef")}timerAvailable(){return!0}time(e){return Sn("time")}read(e){return Sn("read")}readSync(e){return Sn("readSync")}readToGPU(e,t){return Sn("readToGPU")}numDataIds(){return Sn("numDataIds")}disposeData(e,t){return Sn("disposeData")}write(e,t,n){return Sn("write")}move(e,t,n,r,s){return Sn("move")}createTensorFromGPUData(e,t,n){return Sn("createTensorFromGPUData")}memory(){return Sn("memory")}floatPrecision(){return Sn("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Sn("dispose")}}function Sn(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function In(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,En(e,t,n)}function Nn(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,En(e,n,r),En(t,n,r)}function Tn(e,t,n){return Math.max(e,Math.min(t,n))}function Cn(e){return e%2==0?e:e+1}function En(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function $n(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function _n(e,t){const n=Math.random();return t*n+(1-n)*e}function On(e,t){let n=0;for(let r=0;r<e.length;r++){const s=Number(e[r])-Number(t[r]);n+=s*s}return n}function Rn(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function An(e,t,n=""){Rn(zn(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function Dn(e){Rn(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Fn(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Mn(e){return 0===e.length}function Ln(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function zn(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Pn(e){return e%1==0}function Bn(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function Un(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function jn(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return In(t),t}function Wn(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Vn(e,t=e=>0,n,r){return new Promise(((s,a)=>{let i=0;const o=()=>{if(e())return void s();i++;const l=t(i);null!=n&&i>=n?a():null!=r?r(o,l):setTimeout(o,l)};o()}))}function Gn(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function Hn(e,t){const n=t.length;return Rn((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),Rn(e.every((e=>Pn(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function qn(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:Hn(t,e).sort();let i=0;for(let t=0;t<e.length;++t){if(null!=a){if(a[i]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==a[i]||a[i]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),a[i]<=t&&i++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function Kn(e,t){return Xn(e,t)}function Xn(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function Yn(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function Qn(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function Jn(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function Zn(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function er(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function tr(e){return"string"==typeof e||e instanceof String}function nr(e){return"boolean"==typeof e}function rr(e){return"number"==typeof e}function sr(e){return Array.isArray(e)?sr(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":rr(e)?"float32":tr(e)?"string":nr(e)?"bool":"float32"}function ar(e){return!!(e&&e.constructor&&e.call&&e.apply)}function ir(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function or(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function lr(e,t,n,r=!1){const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++)s[t]=lr(e+t*o,i,n,r)}return s}function ur(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return lr(0,e,t,n)}function cr(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function dr(e,t){const n=hr(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function hr(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function pr(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return ur(e,new Float32Array(n));if("int32"===t)return ur(e,new Int32Array(n));if("bool"===t)return ur(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function fr(e){e.forEach((t=>{Rn(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function mr(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function gr(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function yr(e){return e&&e.then&&"function"==typeof e.then}const br="tfjsflags";class vr{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=xr,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&!wr().getBool("IS_TEST")&&wr().getBool("PROD"),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];!wr().getBool("IS_TEST")&&wr().getBool("PROD"),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(yr(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(br in e){e[br].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}}function xr(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("=")))),t}function wr(){return Sr}let kr,Sr=null;function Ir(){if(null==kr){let e;if("undefined"!=typeof window)e=window;else if(void 0!==n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}kr=e}return kr}function Nr(e,t){const n=function(){const e=Ir();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const Tr="Abs",Cr="Acos",Er="Acosh",$r="Add",_r="AddN",Or="All",Rr="Any",Ar="ArgMax",Dr="ArgMin",Fr="Asin",Mr="Asinh",Lr="Atan",zr="Atanh",Pr="Atan2",Br="AvgPool",Ur="AvgPoolGrad",jr="AvgPool3D",Wr="AvgPool3DGrad",Vr="BatchMatMul",Gr="BatchToSpaceND",Hr="Bincount",qr="BitwiseAnd",Kr="BroadcastTo",Xr="BroadcastArgs",Yr="Cast",Qr="Ceil",Jr="ClipByValue",Zr="Complex",es="ComplexAbs",ts="Concat",ns="Conv2D",rs="Conv2DBackpropFilter",ss="Conv2DBackpropInput",as="Conv3D",is="Conv3DBackpropFilterV2",os="Conv3DBackpropInputV2",ls="Cos",us="Cosh",cs="Cumprod",ds="Cumsum",hs="CropAndResize",ps="DenseBincount",fs="DepthToSpace",ms="DepthwiseConv2dNative",gs="DepthwiseConv2dNativeBackpropFilter",ys="DepthwiseConv2dNativeBackpropInput",bs="Diag",vs="Dilation2D",xs="Dilation2DBackpropInput",ws="Dilation2DBackpropFilter",ks="Draw",Ss="RealDiv",Is="Einsum",Ns="Elu",Ts="EluGrad",Cs="Erf",Es="Equal",$s="Exp",_s="ExpandDims",Os="Expm1",Rs="FFT",As="Fill",Ds="FlipLeftRight",Fs="Floor",Ms="FloorDiv",Ls="FusedBatchNorm",zs="GatherV2",Ps="GatherNd",Bs="Greater",Us="GreaterEqual",js="Identity",Ws="IFFT",Vs="Imag",Gs="IsFinite",Hs="IsInf",qs="IsNan",Ks="LeakyRelu",Xs="Less",Ys="LessEqual",Qs="LinSpace",Js="Log",Zs="Log1p",ea="LogicalAnd",ta="LogicalNot",na="LogicalOr",ra="LogicalXor",sa="LogSoftmax",aa="LowerBound",ia="LRN",oa="LRNGrad",la="MatrixBandPart",ua="Max",ca="Maximum",da="MaxPool",ha="MaxPoolGrad",pa="MaxPool3D",fa="MaxPool3DGrad",ma="MaxPoolWithArgmax",ga="Mean",ya="Min",ba="Minimum",va="MirrorPad",xa="Mod",wa="Multinomial",ka="Multiply",Sa="Neg",Ia="NotEqual",Na="NonMaxSuppressionV3",Ta="NonMaxSuppressionV4",Ca="NonMaxSuppressionV5",Ea="OnesLike",$a="OneHot",_a="Pack",Oa="PadV2",Ra="Pool",Aa="Pow",Da="Prelu",Fa="Prod",Ma="RaggedGather",La="RaggedRange",za="RaggedTensorToTensor",Pa="Range",Ba="Real",Ua="Reciprocal",ja="Relu",Wa="Reshape",Va="ResizeNearestNeighbor",Ga="ResizeNearestNeighborGrad",Ha="ResizeBilinear",qa="ResizeBilinearGrad",Ka="Relu6",Xa="Reverse",Ya="Round",Qa="Rsqrt",Ja="ScatterNd",Za="TensorScatterUpdate",ei="SearchSorted",ti="Select",ni="Selu",ri="Slice",si="Sin",ai="Sinh",ii="Sign",oi="Sigmoid",li="Softplus",ui="Sqrt",ci="Sum",di="SpaceToBatchND",hi="SplitV",pi="Softmax",fi="SparseFillEmptyRows",mi="SparseReshape",gi="SparseSegmentMean",yi="SparseSegmentSum",bi="SparseToDense",vi="SquaredDifference",xi="Square",wi="StaticRegexReplace",ki="StridedSlice",Si="StringNGrams",Ii="StringSplit",Ni="StringToHashBucketFast",Ti="Sub",Ci="Tan",Ei="Tanh",$i="Tile",_i="TopK",Oi="Transform",Ri="Transpose",Ai="Unique",Di="Unpack",Fi="UnsortedSegmentSum",Mi="UpperBound",Li="ZerosLike",zi="Step",Pi="FromPixels",Bi="RotateWithOffset",Ui="_FusedMatMul",ji="FusedConv2D",Wi="FusedDepthwiseConv2D";function Vi(...e){!wr().getBool("IS_TEST")&&wr().getBool("PROD")}function Gi(...e){!wr().getBool("IS_TEST")&&wr().getBool("PROD")}const Hi=Nr("kernelRegistry",(()=>new Map)),qi=Nr("gradRegistry",(()=>new Map));function Ki(e,t){const n=no(e,t);return Hi.get(n)}function Xi(e){return qi.get(e)}function Yi(e){const t=Hi.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function Qi(e){const{kernelName:t,backendName:n}=e,r=no(t,n);Hi.has(r)&&Vi(),Hi.set(r,e)}function Ji(e){const{kernelName:t}=e;qi.has(t)&&wr().getBool("DEBUG")&&Vi(),qi.set(t,e)}function Zi(e,t){const n=no(e,t);if(!Hi.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Hi.delete(n)}function eo(e){if(!qi.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);qi.delete(e)}function to(e,t){Yi(e).forEach((e=>{Qi(Object.assign({},e,{backendName:t}))}))}function no(e,t){return`${t}_${e}`}function ro(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var so=n(570);const ao=n.n(so)()||so;function io(e){return ao.fromString(e,!0,16)}const oo=io("c3a5c85c97cb3127"),lo=io("b492b66fbe98f273"),uo=io("9ae16a3b2f90404f");function co(e){return e.xor(e.shru(47))}function ho(e,t,n){const r=e.slice(t,t+n);return ao.fromBytes(Array.from(r),!0,!0)}function po(e,t){return ho(e,t,8)}function fo(e,t){return ho(e,t,4)}function mo(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function go(e,t,n=io("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function yo(e,t,n,r){return function(e,t,n,r,s,a){s=s.add(e),a=mo(a.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(n),a=a.add(mo(s,44)),[s.add(r),a.add(i)]}(po(e,t),po(e,t+8),po(e,t+16),po(e,t+24),n,r)}function bo(e,t=e.length){const n=ao.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=uo.add(2*t),r=po(e,0).add(uo),s=po(e,t-8);return go(mo(s,37).mul(n).add(r),mo(r,25).add(s).mul(n),n)}if(t>=4){const n=uo.add(2*t);return go(fo(e,0).shl(3).add(t),fo(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return co(uo.mul(n).xor(oo.mul(r))).mul(uo)}return uo}(e,t):function(e,t=e.length){const n=uo.add(2*t),r=po(e,0).mul(lo),s=po(e,8),a=po(e,t-8).mul(n),i=po(e,t-16).mul(uo);return go(mo(r.add(s),43).add(mo(a,30)).add(i),r.add(mo(s.add(uo),18)).add(a),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=uo.add(2*t),r=po(e,0).mul(uo),s=po(e,8),a=po(e,t-8).mul(n),i=po(e,t-16).mul(uo),o=mo(r.add(s),43).add(mo(a,30)).add(i),l=go(o,r.add(mo(s.add(uo),18)).add(a),n),u=po(e,16).mul(n),c=po(e,24),d=o.add(po(e,t-32)).mul(n),h=l.add(po(e,t-24)).mul(n);return go(mo(u.add(c),43).add(mo(d,30)).add(h),u.add(mo(c.add(r),18)).add(d),n)}(e,t);let r=n,s=n.mul(lo).add(113),a=co(s.mul(uo).add(113)).mul(uo),i=[ao.UZERO,ao.UZERO],o=[ao.UZERO,ao.UZERO];r=r.mul(uo).add(po(e,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=mo(r.add(s).add(i[0]).add(po(e,l+8)),37).mul(lo),s=mo(s.add(i[1]).add(po(e,l+48)),42).mul(lo),r=r.xor(o[1]),s=s.add(i[0]).add(po(e,l+40)),a=mo(a.add(o[0]),33).mul(lo),i=yo(e,l,i[1].mul(lo),r.add(o[0])),o=yo(e,l+32,a.add(o[1]),s.add(po(e,l+16))),[a,r]=[r,a],l+=64}while(l!==u);const d=lo.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=mo(r.add(s).add(i[0]).add(po(e,l+8)),37).mul(d),s=mo(s.add(i[1]).add(po(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(po(e,l+40))),a=mo(a.add(o[0]),33).mul(d),i=yo(e,l,i[1].mul(d),r.add(o[0])),o=yo(e,l+32,a.add(o[1]),s.add(po(e,l+16))),[a,r]=[r,a],go(go(i[0],o[0],d).add(co(s).mul(oo)).add(a),go(i[1],o[1],d).add(r),d)}function vo(e,t){return"string"===t?So(e):xo([e],t)}function xo(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=To(e)),wr().getBool("DEBUG")&&Yn(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function wo(){return wr().platform.now()}function ko(e,t){return wr().platform.fetch(e,t)}function So(e,t="utf-8"){return t=t||"utf-8",wr().platform.encode(e,t)}function Io(e,t="utf-8"){return t=t||"utf-8",wr().platform.decode(e,t)}function No(e){return null!=wr().platform.isTypedArray?wr().platform.isTypedArray(e):ro(e)}function To(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||yr(e)||null==e||No(e)&&n)t.push(e);else if(Array.isArray(e)||No(e))for(let r=0;r<e.length;++r)To(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)To(e[s],t,n)}return t}class Co{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new $o)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let a;const i=wo();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:wo()-i})}if(wr().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){const n=r[t];n.data().then((t=>{Eo(t,n.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function Eo(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const n=e[t];if(isNaN(n)||!isFinite(n))return!0}return!1}class $o{logKernelProfile(e,t,n,r,s,a){"number"==typeof r?Wn(`${r}ms`,9):r.error,Wn(e,25),t.rank,t.size,Wn(t.shape.toString(),14);let i="";for(const e in s){const n=s[e];if(null!=n){const r=n.shape||t.shape,s=r.length;i+=`${e}: ${s}D ${s>0?r:""} `}}}}function _o(e,t,n,r){const s=or(t),a=function(e,t,n,r){const s=Fn(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,l="complex64"===n?Do(e):e;if(o>1)for(let e=0;e<s/a;e++){const t=e*a;for(let e=0;e<a;e++)i[e]=Math.max(i[e],Oo(l[t+e],0,n).length)}return i}(e,t,n,s),i=t.length,o=Ao(e,t,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function Oo(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:tr(e)?`'${e}'`:"bool"===n?Ro(e):parseFloat(e.toFixed(7)).toString(),Wn(r,t)}function Ro(e){return 0===e?"false":"true"}function Ao(e,t,n,r,s,a=!0){const i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){return[Oo(Do(e)[0],0,n)]}return"bool"===n?[Ro(e[0])]:[e[0].toString()]}if(1===l){if(o>20){const t=3*i;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(r=Do(r),a=Do(a)),["["+r.map(((e,t)=>Oo(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>Oo(e,s[o-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?Do(e):Array.from(e)).map(((e,t)=>Oo(e,s[t],n))).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(o>20){for(let t=0;t<3;t++){const r=t*d,a=r+d;h.push(...Ao(e.slice(r,a),u,n,c,s,!1))}h.push("...");for(let t=o-3;t<o;t++){const r=t*d,a=r+d;h.push(...Ao(e.slice(r,a),u,n,c,s,t===o-1))}}else for(let t=0;t<o;t++){const r=t*d,a=r+d;h.push(...Ao(e.slice(r,a),u,n,c,s,t===o-1))}const p=2===l?",":"";h[0]="["+(o>0?h[0]+p:"");for(let e=1;e<h.length-1;e++)h[e]=" "+h[e]+p;let f=",\n";for(let e=2;e<l;e++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(a?"":f),h}function Do(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class Fo{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Fn(e),null!=n){const e=n.length;Rn(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Xn(t,this.size),this.strides=or(e)}set(e,...t){0===t.length&&(t=[0]),Rn(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Mo().makeTensor(this.values,this.shape,this.dtype)}}let Mo=null,Lo=null,zo=null;class Po{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Fn(e),this.strides=or(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Lo.buffer(this.shape,this.dtype,e)}bufferSync(){return Lo.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ur(this.shape,e,"complex64"===this.dtype)}arraySync(){return ur(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=Mo().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>Io(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Mo().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Mo().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>Io(e)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Mo().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Mo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Lo.print(this,e)}clone(){return this.throwIfDisposed(),Lo.clone(this)}toString(e=!1){return _o(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Lo.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Mo().makeVariable(this,e,t,n)}}function Bo(){return Nr("Tensor",(()=>Po))}Object.defineProperty(Po,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Bo();class Uo extends Po{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!zn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Mo().disposeTensor(this),this.dataId=e.dataId,Mo().incRef(this,null)}dispose(){Mo().disposeVariable(this),this.isDisposedInternal=!0}}var jo,Wo,Vo,Go,Ho;Object.defineProperty(Uo,Symbol.hasInstance,{value:e=>e instanceof Po&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(jo||(jo={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Wo||(Wo={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(Vo||(Vo={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Go||(Go={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Ho||(Ho={}));const qo={float32:Go,int32:Wo,bool:Vo,complex64:Ho};function Ko(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return qo[e][t]}function Xo(e){return Ko(e,"int32")}function Yo(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function Qo(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Jo(e,t){if(e.dtype===t.dtype)return[e,t];const n=Ko(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Zo(e,t){Rn(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function el(e,t){return t.some((t=>t.id===e.id))}function tl(e){const t=[];return nl(e,t,new Set),t}function nl(e,t,n){if(null==e)return;if(e instanceof Po)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=e;for(const e in s){const r=s[e];n.has(r)||(n.add(r),nl(r,t,n))}}function rl(e){return null!=e.kernelName}class sl{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class al{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new sl}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(Vi(),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Co(this.backendInstance),!0}setupRegisteredKernels(){Yi(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Yi(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof kn||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((e=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,Vi(),Vi(e.stack||e.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(e){return Vi(),Vi(e.stack||e.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return al.nextTensorId++}nextVariableId(){return al.nextVariableId++}clone(e){const t=ol.runKernel(js,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return ol.runKernel(Yr,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=Ki(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach((e=>{s+="complex64"===e.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=rl(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(rl(e)){const{kernelName:t,inputs:s,attrs:a}=e;null==this.backendName&&this.backend;const l=Ki(t,this.backendName);Rn(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:a,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const u=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,s,u);n=this.saveTensorsForBackwardMode(e)}return u}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:u,attrs:c}=e,d=rl(e)?null:e.backwardsFunc;let h;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(l,u,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=i()})),r&&this.addTapeNode(l,u,t,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((e=>null!=u[e]?u[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=Xi(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(Rn(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),a=Object.keys(t).map((e=>t[e]))):a=e.map((e=>t[e]));const i=n.filter(((e,t)=>s[t]));return a.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&tr(e[0])&&(s=e.map((e=>So(e))));const a=r.write(s,t,n),i=new Po(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=er(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:s}=e,a=new Po(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new Uo(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Zn(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Uo||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Zn(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=Xi(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=hr(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=tl(e),n=new Set(t.map((e=>e.id)));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n,r=!1){if(Rn(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Rn(s instanceof Po,(()=>"The result y returned by f() must be a tensor."));const a=function(e,t,n){const r={},s={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const a=e[n],i=a.inputs;for(const e in i){const n=i[e];let o=!1;for(let e=0;e<t.length;e++)if(r[n.id]){a.outputs.forEach((e=>r[e.id]=!0)),o=!0,s[a.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(a[n.outputs[e].id]){for(const e in r)a[r[e].id]=!0,i[n.id]=!0;break}}const o=[];for(let t=0;t<e.length;t++){const n=e[t];if(s[n.id]&&i[n.id]){const e={};for(const t in n.inputs){const s=n.inputs[t];r[s.id]&&(e[t]=s)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,o.push(t)}}return o}(this.state.activeTape,t,s);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[s.id]=null==n?function(e){const t=dr(Fn(e),"float32");return ol.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const s=n((()=>o[t]()));if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=a.inputs[t];if(!zn(s.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,a,(e=>this.tidy(e)),ll);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:s,grads:r}}))}customGrad(e){return Rn(ar(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{let n;Rn(t.every((e=>e instanceof Po)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const r={};t.forEach(((e,t)=>{r[t]=e}));return this.runKernelFunc({forwardFunc:(r,s)=>(n=e(...t,s),Rn(n.value instanceof Po,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Rn(ar(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),backwardsFunc:(e,r)=>{const s=n.gradFunc(e,r),a=Array.isArray(s)?s:[s];Rn(a.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Rn(a.every((e=>e instanceof Po)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return a.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=wo(),n=await this.backend.time(e);return n.wallMs=wo()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new sl;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function il(){const e=Ir();if(null==e._tfengine){const t=new vr(e);e._tfengine=new al(t)}var t;return t=e._tfengine.ENV,Sr=t,Mo=()=>e._tfengine,e._tfengine}al.nextTensorId=0,al.nextVariableId=0;const ol=il();function ll(e,t){const n={a:e,b:t};return ol.runKernel($r,n)}let ul;function cl(e){ul=e}function dl(e){if(void 0!==ul)return ul;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function hl(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const pl=wr();function fl(e,t){let n=e;if(No(e))return"string"===t?[]:[e.length];if(Yo(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(Qo(e))return[e.buffer.size/(null==t?4:Zn(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||No(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&wr().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ml(e,r,[]),r}function ml(e,t,n){if(n=n||[],!Array.isArray(e)&&!No(e))return void Rn(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));Rn(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),Rn(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let t=0;t<e.length;++t)ml(e[t],r,n.concat(t))}function gl(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function yl(e,t,n,r="numeric"){if(e instanceof Bo())return gl(r,e.dtype,t,n),e;let s=sr(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),gl(r,s,t,n),null==e||!No(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=fl(e,s);No(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?xo(e,s):To(e,[],!0);return ol.makeTensor(i,a,s)}function bl(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,s)=>yl(e,`${t}[${s}]`,n,r)))}pl.registerFlag("DEBUG",(()=>!1),(e=>{})),pl.registerFlag("IS_BROWSER",(()=>hl())),pl.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node)),pl.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),pl.registerFlag("IS_SAFARI",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),pl.registerFlag("PROD",(()=>!1)),pl.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>pl.getBool("DEBUG"))),pl.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),pl.registerFlag("IS_TEST",(()=>!1)),pl.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>pl.getBool("DEBUG"))),pl.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),pl.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),pl.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const vl="__op";function xl(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=vl;const s=(...e)=>{ol.startScope(n);try{const t=r(...e);return yr(t),ol.endScope(t),t}catch(e){throw ol.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}const wl=xl({complex_:function(e,t){const n=yl(e,"real","complex"),r=yl(t,"imag","complex");An(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return ol.runKernel(Zr,s)}});function kl(e,t,n,r){if(null==r)r=sr(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Qo(e)||Yo(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return ol.backend.createTensorFromGPUData(e,t||n,r)}if(!No(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){fr(t);const e=Fn(t),r=Fn(n);Rn(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let e=0;e<n.length;++e){const r=n[e],s=e!==n.length-1||r!==Fn(t.slice(e));Rn(n[e]===t[e]||!s,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return No(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?xo(e,r):To(e,[],!0),ol.makeTensor(e,t,r)}function Sl(e,t,n){return kl(e,t,fl(e,n),n)}const Il={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Nl{static join(e){return new Nl(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>No(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+r.byteLength;this.shards.push({buffer:r,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),s=new Uint8Array(r);let a=0;for(let r=n;r<this.shards.length;r++){const n=this.shards[r],i=e+a-n.start,o=a,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,i,l-i);if(s.set(u,o),a+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(0===a)return s;a<0?r=s:n=s+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function Tl(){wr().set("PROD",!0)}function Cl(){wr().set("DEBUG",!0)}function El(){wr().set("DEPRECATION_WARNINGS_ENABLED",!1)}function $l(e){wr().getBool("DEPRECATION_WARNINGS_ENABLED")}function _l(){ol.disposeVariables()}function Ol(){return ol}function Rl(){return ol.memory()}function Al(e){return ol.profile(e)}function Dl(e,t){return ol.tidy(e,t)}function Fl(e){tl(e).forEach((e=>e.dispose()))}function Ml(e){return ol.keep(e)}function Ll(e){return ol.time(e)}function zl(e){return ol.setBackend(e)}function Pl(){return ol.ready()}function Bl(){return ol.backendName}function Ul(e){ol.removeBackend(e)}function jl(e){return ol.findBackend(e)}function Wl(e){return ol.findBackendFactory(e)}function Vl(e,t,n=1){return ol.registerBackend(e,t,n)}function Gl(){return ol.backend}function Hl(e,t){wr().setPlatform(e,t)}zo=$l;const ql=4;async function Kl(e,t){const n=[],r=[],s=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let a=0;a<s.length;++a){const i=s[a],o=Array.isArray(e)?e[a].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+ql*t.length,r=new Uint8Array(n);let s=0;for(let e=0;e<t.length;e++){const n=t[e],a=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(a,s),s+=ql,r.set(n,s),s+=n.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:tu(await Promise.all(r)),specs:n}}function Xl(e,t){const n=new Nl(e),r={};let s=0;for(const e of t){const t=Yl(e,((e,t)=>n.slice(s+e,s+t)));r[e.name]=Jl(e,n.slice(s,s+t)),s+=t}return r}function Yl(e,t){const n=Fn(e.shape);let r;if("quantization"in e){const t=e.quantization;r=Il[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=ql+new Uint32Array(t(e,e+ql))[0];return e}r=Il[e.dtype]}return n*r}async function Ql(e,t){const n=Fn(e.shape);let r;if("quantization"in e){const t=e.quantization;r=Il[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=ql+new Uint32Array(await t(e,e+ql))[0];return e}r=Il[e.dtype]}return n*r}function Jl(e,t){const n=e.name,r=e.dtype,s=e.shape,a=Fn(s);let i,o=0;if("quantization"in e){const s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==s.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${r}.`)}const l=Il[s.dtype],u="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===r)if("uint8"===s.dtype||"uint16"===s.dtype){i=new Float32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;!(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let s=0;s<r.length;s++){const i=r[s],o=e[n[i>>10]+(1023&i)]+t[i>>10];a[s]=o}return new Float32Array(s)}}();i=e(u)}}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${n}': ${r}`);if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=Math.round(t*s.scale+s.min)}}o+=a*l}else if("string"===r){const n=Fn(e.shape);i=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(o,o+ql))[0];o+=ql;const n=new Uint8Array(t.slice(o,o+e));i.push(n),o+=e}}else{const e=Il[r];if("float32"===r)i=new Float32Array(t);else if("int32"===r)i=new Int32Array(t);else{if("bool"!==r){if("complex64"===r){i=new Float32Array(t);const e=new Float32Array(i.length/2),n=new Float32Array(i.length/2);for(let t=0;t<e.length;t++)e[t]=i[2*t],n[t]=i[2*t+1];const r=Sl(e,s,"float32"),a=Sl(n,s,"float32"),o=wl(r,a);return r.dispose(),a.dispose(),o}throw new Error(`Unsupported dtype in weight '${n}': ${r}`)}i=new Uint8Array(t)}o+=a*e}return Sl(i,s,r)}async function Zl(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){const{done:t,value:s}=await e.read();if(t&&null==s){const e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}const a=new Uint8Array(r.length+s.byteLength);a.set(r,0),a.set(new Uint8Array(s),r.length),r=a}return r.buffer}async function eu(e,t){const n={},r=e.getReader();let s=new ArrayBuffer(0);for(const e of t){const t=await Ql(e,(async(e,t)=>(s=await Zl(r,s,t),s.slice(e,t))));s=await Zl(r,s,t);const a=s.slice(0,t);s=s.slice(t);const i=Jl(e,a);if(n[e.name]=i,"webgpu"===Bl()){const e=Gl();"uploadToGPU"in e&&Fn(i.shape)>=wr().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function tu(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let s=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength})),r.buffer}const nu="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function ru(e){return nu?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function su(e){return Nl.join(e)}function au(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function iu(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function ou(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function lu(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),ou(e,n,r)}function uu(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:ru(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:ru(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Nl(e.weightData).byteLength}}function cu(e){const t=[];for(const n of e)t.push(...n.weights);return t}class du{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==du.instance&&(du.instance=new du),du.instance}static registerSaveRouter(e){du.getInstance().saveRouters.push(e)}static registerLoadRouter(e){du.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return du.getHandlers(e,"save")}static getLoadHandlers(e,t){return du.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?du.getInstance().loadRouters:du.getInstance().saveRouters).forEach((t=>{const s=t(e,n);null!==s&&r.push(s)})),r}}const hu=e=>du.registerSaveRouter(e),pu=e=>du.registerLoadRouter(e),fu=e=>du.getSaveHandlers(e),mu=(e,t)=>du.getLoadHandlers(e,t),gu="tensorflowjs",yu="models_store",bu="model_info_store";function vu(){if(!wr().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function xu(e){const t=e.result;t.createObjectStore(yu,{keyPath:"modelPath"}),t.createObjectStore(bu,{keyPath:"modelPath"})}class wu{constructor(e){if(this.indexedDB=vu(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(gu,1);r.onupgradeneeded=()=>xu(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(yu,"readonly"),r=t.objectStore(yu).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{t.weightData=Nl.join(t.weightData);const r=uu(t),a=s.transaction(bu,"readwrite");let i,o,l=a.objectStore(bu);try{i=l.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(e){return n(e)}i.onsuccess=()=>{o=s.transaction(yu,"readwrite");const i=o.objectStore(yu);let u;try{u=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(e){return n(e)}u.onsuccess=()=>e({modelArtifactsInfo:r}),u.onerror=e=>{l=a.objectStore(bu);const t=l.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(u.error)),t.onerror=e=>(s.close(),n(u.error))}},i.onerror=e=>(s.close(),n(i.error)),a.oncomplete=()=>{null==o?s.close():o.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)}))}}wu.URL_SCHEME="indexeddb://";const ku=e=>{return wr().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(wu.URL_SCHEME)?(t=e.slice(wu.URL_SCHEME.length),new wu(t)):null;var t};du.registerSaveRouter(ku),du.registerLoadRouter(ku);class Su{constructor(){this.indexedDB=vu()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(gu,1);n.onupgradeneeded=()=>xu(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(bu,"readonly"),a=s.objectStore(bu).getAll();a.onsuccess=()=>{const t={};for(const e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(wu.URL_SCHEME)?t.slice(wu.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(gu,1);r.onupgradeneeded=()=>xu(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(bu,"readwrite"),i=a.objectStore(bu),o=i.get(e);let l;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{l=s.transaction(yu,"readwrite");const r=l.objectStore(yu).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=a,r.onerror=e=>(a(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}}const Iu="/",Nu="tensorflowjs_models",Tu="info",Cu="model_topology",Eu="weight_specs",$u="weight_data",_u="model_metadata";function Ou(e){return{info:[Nu,e,Tu].join(Iu),topology:[Nu,e,Cu].join(Iu),weightSpecs:[Nu,e,Eu].join(Iu),weightData:[Nu,e,$u].join(Iu),modelMetadata:[Nu,e,_u].join(Iu)}}function Ru(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Au(e){const t=e.split(Iu);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Iu)}class Du{constructor(e){if(!wr().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Ou(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=uu(e),s=Nl.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(nu)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(s));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch(e){throw Ru(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(nu){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(a),t}}Du.URL_SCHEME="localstorage://";const Fu=e=>{return wr().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Du.URL_SCHEME)?(t=e.slice(Du.URL_SCHEME.length),new Du(t)):null;var t};du.registerSaveRouter(Fu),du.registerLoadRouter(Fu);class Mu{constructor(){Rn(wr().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Rn("undefined"==typeof window||void 0!==window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=Nu+Iu,n=Iu+Tu;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){e[Au(s)]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){var t;const n=Ou(e=(t=e).startsWith(Du.URL_SCHEME)?t.slice(Du.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return Ru(n),r}}const Lu="://";class zu{constructor(){this.managers={}}static getInstance(){return null==zu.instance&&(zu.instance=new zu),zu.instance}static registerManager(e,t){Rn(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Lu)&&(e=e.slice(0,e.indexOf(Lu))),Rn(e.length>0,(()=>"scheme must not be an empty string."));const n=zu.getInstance();Rn(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=zu.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(zu.getInstance().managers)}}function Pu(e){if(-1===e.indexOf(Lu))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${zu.getSchemes().join(",")}`);return{scheme:e.split(Lu)[0],path:e.split(Lu)[1]}}async function Bu(e,t,n=!1){Rn(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=du.getLoadHandlers(e);Rn(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),Rn(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const s=r[0],a=du.getSaveHandlers(t);Rn(a.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),Rn(a.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const i=a[0],o=Pu(e).scheme,l=Pu(e).path,u=o===Pu(e).scheme,c=await s.load();n&&u&&await zu.getManager(o).removeModel(l);const d=await i.save(c);return n&&!u&&await zu.getManager(o).removeModel(l),d.modelArtifactsInfo}async function Uu(){const e=zu.getSchemes(),t={};for(const n of e){const e=await zu.getManager(n).listModels();for(const r in e){t[n+Lu+r]=e[r]}}return t}async function ju(e){const t=Pu(e);return zu.getManager(t.scheme).removeModel(t.path)}async function Wu(e,t){return Bu(e,t,!1)}async function Vu(e,t){return Bu(e,t,!0)}class Gu{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&wr().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return ro(e)}}if(wr().get("IS_BROWSER")){wr().setPlatform("browser",new Gu);try{zu.registerManager(Du.URL_SCHEME,new Mu)}catch(e){}try{zu.registerManager(wu.URL_SCHEME,new Su)}catch(e){}}const Hu=()=>n(817);let qu;class Ku{constructor(){this.util=n(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=wr().global.fetch?wr().global.fetch(e,t):(null==qu&&(qu=Hu()),qu(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function Xu(e,t="float32",n){return t=t||"float32",fr(e),new Fo(e,t,n)}wr().get("IS_NODE")&&!wr().get("IS_BROWSER")&&wr().setPlatform("node",new Ku);const Yu=xl({cast_:function(e,t){const n=yl(e,"x","cast");if(!Qn(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return ol.runKernel(Yr,r,s)}});const Qu=xl({clone_:function(e){const t={x:yl(e,"x","clone","string_or_numeric")};return ol.runKernel(js,t)}});function Ju(e,t=!1){}il();Lo={buffer:Xu,cast:Yu,clone:Qu,print:Ju};const Zu=xl({add_:function(e,t){let n=yl(e,"a","add"),r=yl(t,"b","add");[n,r]=Jo(n,r);const s={a:n,b:r};return ol.runKernel($r,s)}});const ec=xl({floorDiv_:function(e,t){let n=yl(e,"a","floorDiv"),r=yl(t,"b","floorDiv");[n,r]=Jo(n,r);const s={a:n,b:r};return ol.runKernel(Ms,s)}});const tc=xl({div_:function(e,t){let n=yl(e,"a","div"),r=yl(t,"b","div");if([n,r]=Jo(n,r),"int32"===n.dtype&&"int32"===r.dtype)return ec(n,r);const s={a:n,b:r};return ol.runKernel(Ss,s,{})}});const nc=xl({mul_:function(e,t){let n=yl(e,"a","mul"),r=yl(t,"b","mul");[n,r]=Jo(n,r);const s={a:n,b:r};return ol.runKernel(ka,s)}});const rc=xl({sqrt_:function(e){const t={x:yl(e,"x","sqrt","float32")};return ol.runKernel(ui,t)}});const sc=xl({square_:function(e){const t=yl(e,"x","square");return ol.runKernel("Square",{x:t},{})}});const ac=xl({zerosLike_:function(e){const t={x:yl(e,"x","zerosLike")};return ol.runKernel(Li,t)}});function ic(e){return Rn(ar(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{const r=yl(t,"x","tf.grad","string_or_numeric"),s=null!=n?yl(n,"dy","tf.grad"):null;return ol.tidy((()=>{const{value:t,grads:n}=ol.gradients((()=>e(r)),[r],s);return null!=s&&An(t.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),hc(n),n[0]}))}}function oc(e){return Rn(ar(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{Rn(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const r=bl(t,"args","tf.grads","string_or_numeric"),s=null!=n?yl(n,"dy","tf.grads"):null;return ol.tidy((()=>{const{value:t,grads:n}=ol.gradients((()=>e(...r)),r,s);return null!=s&&An(t.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),hc(n),n}))}}function lc(e){return Rn(ar(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{Rn(t instanceof Po,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),Rn(null==n||n instanceof Po,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:r,value:s}=ol.gradients((()=>e(t)),[t],n);return hc(r),{grad:r[0],value:s}}}function uc(e){return Rn(ar(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{Rn(Array.isArray(t)&&t.every((e=>e instanceof Po)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),Rn(null==n||n instanceof Po,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const r=ol.gradients((()=>e(...t)),t,n);return null!=n&&An(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),hc(r.grads),r}}function cc(e,t){Rn(ar(e),(()=>"The f passed in variableGrads(f) must be a function")),Rn(null==t||Array.isArray(t)&&t.every((e=>e instanceof Uo)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in ol.registeredVariables)t.push(ol.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,s=t.length;t=t.filter((e=>e.trainable)),Rn(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`));const{value:a,grads:i}=ol.gradients(e,t,null,!0);Rn(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Rn(0===a.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`));const o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:a,grads:o}}function dc(e){return ol.customGrad(e)}function hc(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function pc(e,t){if((No(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&No(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return kl(e,[],[],t)}const fc=new Map,mc=new Map;class gc{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class yc{constructor(){this.classNameMap={}}static getMap(){return null==yc.instance&&(yc.instance=new yc),yc.instance}static register(e){yc.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function bc(e,t,n){Rn(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Rn("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Rn(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),void 0===t&&(t="Custom"),void 0===n&&(n=e.className);const r=t+">"+n;return yc.register(e),fc.set(r,e),mc.set(e,r),e}function vc(e){return mc.has(e)?mc.get(e):e.className}class xc extends gc{minimize(e,t=!1,n){const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:s[e.name]})));this.applyGradients(e)}else this.applyGradients(s);return Fl(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return cc(e,t)}dispose(){null!=this.iterations_&&Fl(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:pc(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(xc,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class wc extends xc{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=ol.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=ol.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:Dl((()=>ac(r).variable(s)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:Dl((()=>ac(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;Dl((()=>{const e=Zu(nc(i,this.rho),nc(sc(a),1-this.rho)),t=nc(tc(rc(Zu(o,this.epsilon)),rc(Zu(i,this.epsilon))),a),n=Zu(nc(o,this.rho),nc(sc(t),1-this.rho));i.assign(e),o.assign(n);const s=Zu(nc(t,-this.learningRate),r);r.assign(s)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Fl(this.accumulatedGrads.map((e=>e.variable))),Fl(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function kc(e,t,n){fr(e);const r={shape:e,value:t,dtype:n=n||sr(t)};return ol.runKernel(As,{},r)}class Sc extends xc{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=ol.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:Dl((()=>kc(r.shape,this.initialAccumulatorValue).variable(e)))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;Dl((()=>{const e=Zu(a,sc(s));a.assign(e);const t=Zu(nc(tc(s,rc(Zu(e,ol.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Fl(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const Ic=xl({pow_:function(e,t){let n=yl(e,"base","pow"),r=yl(t,"exp","pow");[n,r]=Jo(n,r);const s={a:n,b:r};return ol.runKernel(Aa,s)}});const Nc=xl({sub_:function(e,t){let n=yl(e,"a","sub"),r=yl(t,"b","sub");[n,r]=Jo(n,r);const s={a:n,b:r};return ol.runKernel(Ti,s)}});class Tc extends xc{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Dl((()=>{this.accBeta1=pc(t).variable(),this.accBeta2=pc(n).variable()})),null==r&&(this.epsilon=ol.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Dl((()=>{const n=Nc(1,this.accBeta1),r=Nc(1,this.accBeta2);t.forEach(((t,s)=>{const a=ol.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:Dl((()=>ac(a).variable(i)))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:Dl((()=>ac(a).variable(i)))});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,c=Zu(nc(l,this.beta1),nc(o,1-this.beta1)),d=Zu(nc(u,this.beta2),nc(sc(o),1-this.beta2)),h=tc(c,n),p=tc(d,r);l.assign(c),u.assign(d);const f=Zu(nc(tc(h,Zu(rc(p),this.epsilon)),-this.learningRate),a);a.assign(f)})),this.accBeta1.assign(nc(this.accBeta1,this.beta1)),this.accBeta2.assign(nc(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Fl(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&Fl(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),Dl((()=>{this.accBeta1.assign(Ic(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ic(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const Cc=xl({abs_:function(e){const t=yl(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return ol.runKernel(es,e)}{const e={x:t};return ol.runKernel(Tr,e)}}});function Ec(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}function $c(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}function _c(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];null==a&&(a=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===a)r[n-s-1]=i;else if(1===i)r[n-s-1]=a;else{if(a!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-s-1]=a}}return r}const Oc=xl({maximum_:function(e,t){let n=yl(e,"a","maximum"),r=yl(t,"b","maximum");[n,r]=Jo(n,r),"bool"===n.dtype&&(n=Yu(n,"int32"),r=Yu(r,"int32")),_c(n.shape,r.shape);const s={a:n,b:r};return ol.runKernel(ca,s)}});class Rc extends xc{static get className(){return"Adamax"}constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Dl((()=>{this.iteration=pc(0).variable(),this.accBeta1=pc(t).variable()})),null==r&&(this.epsilon=ol.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Dl((()=>{const n=Nc(1,this.accBeta1),r=tc(-this.learningRate,Zu(nc(this.iteration,this.decay),1));t.forEach(((t,s)=>{const a=ol.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:ac(a).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:ac(a).variable(i)});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,c=Zu(nc(l,this.beta1),nc(o,1-this.beta1)),d=nc(u,this.beta2),h=Cc(o),p=Oc(d,h);l.assign(c),u.assign(p);const f=Zu(nc(tc(r,n),tc(c,Zu(p,this.epsilon))),a);a.assign(f)})),this.iteration.assign(Zu(this.iteration,1)),this.accBeta1.assign(nc(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Fl(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&Fl(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Ac extends xc{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=ol.registeredVariables[t];Dl((()=>{const e=Zu(nc(this.c,r),s);s.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Ml(pc(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class Dc extends Ac{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=pc(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=ol.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:Dl((()=>ac(r).variable(e)))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&Dl((()=>{let e;const t=Zu(nc(this.m,s),a);e=this.useNesterov?Zu(nc(this.c,Zu(a,nc(t,this.m))),r):Zu(nc(this.c,t),r),s.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Fl(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Fc extends xc{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=ol.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=ol.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:Dl((()=>ac(r).variable(s)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:Dl((()=>ac(r).variable(s)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:Dl((()=>ac(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Dl((()=>{const e=Zu(nc(i,this.decay),nc(sc(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=Zu(nc(t,this.decay),nc(a,1-this.decay)),l=tc(nc(a,this.learningRate),rc(Nc(e,Zu(sc(s),this.epsilon)))),u=Zu(nc(o,this.momentum),l);i.assign(e),t.assign(s),o.assign(u);const c=Nc(r,u);r.assign(c)}else{const e=Zu(nc(i,this.decay),nc(sc(a),1-this.decay)),t=Zu(nc(o,this.momentum),tc(nc(a,this.learningRate),rc(Zu(e,this.epsilon))));i.assign(e),o.assign(t);const n=Nc(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Fl(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&Fl(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&Fl(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Mc=[wc,Sc,Tc,Rc,Dc,Fc,Ac];function Lc(e){return new Promise((e=>setTimeout(e))).then(e)}class zc{constructor(e){if(!wr().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(zc.URL_SCHEME)&&(e=e.slice(zc.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Nl.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=iu(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=r,await Lc((()=>s.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Lc((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:uu(e)}}}}zc.URL_SCHEME="downloads://";class Pc{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),s=r.modelTopology;if(null==s)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:s});const a=lu(r,(e=>this.loadWeights(e)));e(a)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const r of e)t.push(...r.weights),n.push(...r.paths);const r=this.checkManifestAndWeightFiles(e),s=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(s).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{const s=new FileReader;s.onload=e=>{const t=e.target.result;n(t)},s.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>au(e.name))),r={};for(const s of e)s.paths.forEach((e=>{const s=au(e);if(-1!==t.indexOf(s))throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(t.push(s),-1===n.indexOf(s))throw new Error(`Weight file with basename '${s}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(s)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function Bc(e){return new Pc(e)}function Uc(e,t,n,r){!function(e){Rn(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){Rn(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),Rn(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),Rn(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map((a=>(a.then((a=>{const i=n+ ++s/e.length*(r-n);return t(i),a})),a))))}async function jc(e,t){null==t&&(t={});const n=null==t.fetchFunc?wr().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),s=(null==t.onProgress?await Promise.all(r):await Uc(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(s):await Uc(s,t.onProgress,.5,1)}async function Wc(e,t="",n,r){return Vc((e=>jc(e,{requestInit:r})))(e,t,n)}function Vc(e){return async(t,n="",r)=>{const s=t.map((()=>!1)),a={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const l="quantization"in e?e.quantization.dtype:e.dtype,u=Il[l]*Fn(e.shape),c=()=>{s[t]=!0,null==a[t]&&(a[t]=[]),a[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=u}))})),!i.every((e=>e))){const e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const l=s.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));const c=await e(u),d={};let h=0;return l.forEach((e=>{const n=t[e].paths.length,r=new Nl(c.slice(h,h+n));a[e].forEach((e=>{const t=Xl(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const e in t)d[e]=t[e]})),h+=n})),d}}du.registerSaveRouter((e=>wr().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(zc.URL_SCHEME)?function(e="model"){return new zc(e)}(e.slice(zc.URL_SCHEME.length)):null));class Gc{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Rn("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=wr().platform.fetch,Rn(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Rn(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=iu(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=Nl.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:uu(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return lu(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=cu(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?wr().platform.fetch:t.fetchFunc;let s,a=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;a<e.length;){if(!s){const n=(await r(e[a],t.requestInit,{isBinary:!0})).body;s=n.getReader()}const{done:o,value:l}=await s.read();if(!o)return void n.enqueue(l);a++,s=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,a/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}(t),s=this.weightPathPrefix||n,a=[],i=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):a.push(s+e+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){const t=await this.getWeightUrls(e);return[cu(e),await jc(t,this.loadOptions)]}}function Hc(e){return null!=e.match(Gc.URL_SCHEME_REGEX)}Gc.URL_SCHEME_REGEX=/^https?:\/\//;const qc=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Hc(e))):Hc(e),n)return Kc(e,t)}return null};function Kc(e,t){return new Gc(e,t)}function Xc(e,t){return Kc(e,t)}du.registerSaveRouter(qc),du.registerLoadRouter(qc);class Yc{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Qc{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Jc{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function Zc(e,t,n,r){return new Jc(ed(...arguments))}function ed(e,t,n,r){if(1===arguments.length){const t=null!=e.modelTopology||null!=e.weightSpecs;return new Yc(t?e:{modelTopology:e})}return new Yc({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})}function td(e){return new Qc(e)}function nd(e){return new Qc(e)}const rd=xl({matMul_:function(e,t,n=!1,r=!1){let s=yl(e,"a","matMul"),a=yl(t,"b","matMul");[s,a]=Jo(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return ol.runKernel(Vr,i,o)}});const sd=xl({oneHot_:function(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:yl(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return ol.runKernel($a,a,i)}});const ad=xl({imag_:function(e){const t={input:yl(e,"input","imag")};return ol.runKernel(Vs,t)}});const id=xl({neg_:function(e){const t={x:yl(e,"x","neg")};return ol.runKernel(Sa,t)}});const od=xl({real_:function(e){const t={input:yl(e,"input","real")};return ol.runKernel(Ba,t)}});const ld=xl({transpose_:function(e,t,n){const r=yl(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),Rn(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{Rn(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`))})),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return"complex64"===r.dtype?Dl((()=>{let e=od(r),t=ad(r);return e=ol.runKernel(Ri,{x:e},a),t=ol.runKernel(Ri,{x:t},a),n&&(t=id(t)),wl(e,t)})):ol.runKernel(Ri,s,a)}});const ud=xl({confusionMatrix_:function(e,t,n){const r=yl(e,"labels","confusionMatrix"),s=yl(t,"predictions","confusionMatrix");Rn(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),Rn(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),Rn(1===s.rank,(()=>`Expected the rank of predictions to be 1, but got ${s.rank}`)),Rn(r.shape[0]===s.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`)),Rn(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));const a=sd(Yu(r,"int32"),n),i=sd(Yu(s,"int32"),n),o=ld(a),l=rd(o,i);return Yu(l,"int32")}});function cd(e,t,n){if(Dn(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=fl(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return kl(e,t,r,n)}let dd,hd=!1;function pd(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)a=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=Ki(Pi,ol.backendName)){const n={pixels:e},r={numChannels:t};return ol.runKernel(Pi,n,r)}const[l,u]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,d;if(i)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=e.data;else if(a||s||o){if(null==dd)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");dd=new OffscreenCanvas(1,1).getContext("2d")}else dd=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});dd.canvas.width=l,dd.canvas.height=u,dd.drawImage(e,0,0,l,u),c=dd.getImageData(0,0,l,u).data}if(4===t)d=new Int32Array(c);else{const e=l*u;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=c[4*n+e]}return cd(d,[u,l,t],"int32")}function fd(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function md(e,t=3){let n=null;if(wr().getBool("WRAP_TO_IMAGEBITMAP")&&fd(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return pd(n,t)}function gd(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function yd(e,t){let n=yl(e,"img","toPixels");if(!(e instanceof Po)){const e=n;n=Yu(e,"int32"),e.dispose()}gd(n);const[r,s]=n.shape.slice(0,2),a=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(s*r*4);for(let e=0;e<r*s;++e){const t=[0,0,0,255];for(let r=0;r<a;r++){const s=i[e*a+r];if("float32"===n.dtype){if(s<0||s>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${s}.`)}else if("int32"===n.dtype&&(s<0||s>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${s}.`);1===a?(t[0]=s*o,t[1]=s*o,t[2]=s*o):t[r]=s*o}const r=4*e;l[r+0]=Math.round(t[0]),l[r+1]=Math.round(t[1]),l[r+2]=Math.round(t[2]),l[r+3]=Math.round(t[3])}if(null!=t){if(!hd){null!=Ki(ks,ol.backendName)&&(hd=!0)}t.width=s,t.height=r;const e=t.getContext("2d"),n=new ImageData(l,s,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}function bd(e,t,n){let r=yl(e,"img","draw");if(!(e instanceof Po)){const e=r;r=Yu(e,"int32"),e.dispose()}gd(r),function(e){const t=(null==e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(null==n?void 0:n.imageOptions);const s={image:r},a={canvas:t,options:n};ol.runKernel(ks,s,a)}const vd=xl({fromPixels_:pd});function xd(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Fn(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let e=0;e<s.length-1;++e)i*=s[e];const o=e.shape,l=s.slice();l.pop();let u=1;for(let e=a;e<n;++e)u*=o[e],l.push(o[e]);const c=[...or(e.shape).map((e=>e/u)),1].slice(0,a);return[l,i,u,c]}function wd(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let e=0;e<s;++e)if(n.shape[e]!==t.shape[e])throw new Error(a+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-s;++t)if(n.shape[t+s]!==e[t+r])throw new Error(a+` updates.shape[${t+s}] (${n.shape[t+s]}) != shape[${t+s}] (${e[t+s]})`)}function kd(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}wd(n,t,e)}function Sd(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let e=s;e<a;++e)i*=n[e];const o=s<1?1:s;return{sliceRank:s,numUpdates:Fn(t.shape)/o,sliceSize:i,strides:[...or(n.slice(0,s)),1],outputSize:Fn(n)}}const Id=-2,Nd=-1;function Td(e,t,n){const r=e.shape.length;Rn(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),Rn(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let s=0;s<r;++s)Rn(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`))}function Cd(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function Ed(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function $d(e,t,n,r){const s=[...e];for(let e=s.length;e<r.length;e++)s.push(1);for(let e=0;e<n;e++)0===e?s[t]=1:(s.splice(t,0,1),s.pop());return s}function _d(e,t,n){return n<=e?n:n-(t-1)}function Od(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Rd(e,t,n,r,s,a,i,o,l){const u=e.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;c=Ad(i,l,u,r,e),d=Dd(o,l,u,s,e),h=$d(a,l,u,e)}else for(let t=0;t<u;t++)c[t]=Md(i,r,a,e,t,l),d[t]=Ld(o,s,a,e,t,l),h[t]=Fd(a,t,l);return{begin:c,end:d,strides:h}}function Ad(e,t,n,r,s){const a=[...s],i=Od(n,t);for(let s=0;s<a.length;s++)if(i.indexOf(s)>-1)a[s]=0;else{const i=_d(t,n,s);let o=r[i];e&1<<i&&(o=0),a[s]=o}return a}function Dd(e,t,n,r,s){const a=[...s],i=Od(n,t);for(let s=0;s<a.length;s++)if(i.indexOf(s)>-1)a[s]=Number.MAX_SAFE_INTEGER;else{const i=_d(t,n,s);let o=r[i];e&1<<i&&(o=Number.MAX_SAFE_INTEGER),a[s]=o}for(let e=0;e<a.length;e++){const t=s[e];a[e]<0&&(a[e]+=t),a[e]=Tn(0,a[e],s[e])}return a}function Fd(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function Md(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=Tn(0,i,l-1),i}function Ld(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=o>0?Tn(0,i,l):Tn(-1,i,l-1),i}function zd(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function Pd(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Bd(e,t,n){let r;const s=e.shape.length;let a;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{Rn(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(Rn(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function Ud(e,t,n,r,s,a,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let e=0;e<d.dims;e++)c&&1<<e&o&&d.numAddAxisAfterEllipsis++,1<<e&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(Id),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(Nd),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,h);let p=!0,f=!0,m=!0;const g=[],y=[];for(let t=0;t<e.length;++t){if(0===h.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(h.shrinkAxisMask&1<<t),r=e[t];if(-1===r){g.push(n?1:-1);continue}const s=[h.beginMask&1<<t,h.endMask&1<<t],a=[h.strides[t]>0?0:-1,h.strides[t]>0?r:r-1];if(n&&h.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[t];const i=!!(h.beginMask&1<<t&&h.endMask&1<<t);if(h.beginValid&&h.endValid){if(n){const e=h.begin[t]<0?r+h.begin[t]:h.begin[t];if(h.begin[t]=e,h.end[t]=h.begin[t]+1,e<0||e>=r)throw Error(`slice index ${h.begin[t]} of dimension ${t} out of bounds.`)}else h.begin[t]=jd(h.begin[t],0,h.strides[t],r,s,a),h.end[t]=jd(h.end[t],1,h.strides[t],r,s,a);const e=1===h.strides[t]&&0===h.begin[t]&&h.end[t]===r;p=p&&e,f=f&&(0===t&&1===h.strides[t]||e)}else p=p&&1===h.strides[t]&&i,f=f&&(0===t&&1===h.strides[t]||i);let o,l=!1;if(h.beginValid&&h.endValid?(o=h.end[t]-h.begin[t],l=!0):n?(o=1,l=!0):i&&r>=0&&(o=h.strides[t]<0?-r:r,l=!0),l){let e;e=0===o||o<0!=h.strides[t]<0?0:Math.trunc(o/h.strides[t])+(o%h.strides[t]!=0?1:0),g.push(e)}else g.push(-1)}for(let e=0;e<h.finalShapeGatherIndices.length;++e){const t=h.finalShapeGatherIndices[e];t>=0?y.push(g[t]):t===Id&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>h.finalShapeGatherIndices[t]!==Id)),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function jd(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}const Wd=.001,Vd=.1;function Gd(e,t,n){return null==n&&(n=Hd()),qd(e,t,((e,t)=>Qd(e,t,n)))}function Hd(){return 32===ol.backend.floatPrecision()?Wd:Vd}function qd(e,t,n){let r=!0;if((No(e)||No(t))&&(r=!1),No(e)&&No(t)&&(r=!0),r){const n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){const n=fl(e),r=fl(t);if(!zn(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}const s=No(e)?e:To(e),a=No(t)?t:To(t);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.\nActual:   ${s}.\nExpected: ${a}.`);for(let e=0;e<a.length;++e){const t=s[e],r=a[e];if(!n(t,r))throw new Error(`Arrays differ: actual[${e}] = ${t}, expected[${e}] = ${r}.\nActual:   ${s}.\nExpected: ${a}.`)}"undefined"!=typeof expect&&expect().nothing()}function Kd(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!=typeof expect&&expect().nothing()}function Xd(e,t){const n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return tr(e)||tr(e[0])||tr(t)||tr(t[0])?qd(e,n,((e,t)=>e==t)):qd(e,t,((e,t)=>Qd(e,t,0)))}function Yd(e,t,n){if(null==n&&(n=Hd()),!Qd(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function Qd(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Jd(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function Zd(e,t){const n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let e=0;e<r.length;e++)if(n[e]!==r[e])throw new Error(`Expected ArrayBuffer value at ${e} to be ${r[e]} but got ${n[e]} instead`)}function eh(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?eh(n):e[t]=So(n)}return e}function th(e){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise((e=>{t.addEventListener("loadeddata",(n=>e(t))),t.load()}))}async function nh(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise((t=>{e.requestVideoFrameCallback(t)}))}const rh="4.22.0";class sh{static sgd(e){return new Ac(e)}static momentum(e,t,n=!1){return new Dc(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new Fc(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new Tc(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new wc(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new Rc(e,t,n,r,s)}static adagrad(e,t=.1){return new Sc(e,t)}}const ah=xl({acos_:function(e){const t={x:yl(e,"x","acos")};return ol.runKernel(Cr,t)}});const ih=xl({acosh_:function(e){const t={x:yl(e,"x","acosh")};return ol.runKernel(Er,t)}});const oh=xl({addN_:function(e){Rn(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),Rn(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>yl(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!zn(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=t;return ol.runKernel(_r,r)}});const lh=xl({all_:function(e,t=null,n=!1){const r={x:yl(e,"x","all","bool")},s={axis:t,keepDims:n};return ol.runKernel(Or,r,s)}});const uh=xl({any_:function(e,t=null,n=!1){const r={x:yl(e,"x","any","bool")},s={axis:t,keepDims:n};return ol.runKernel(Rr,r,s)}});const ch=xl({argMax_:function(e,t=0){const n={x:yl(e,"x","argMax")},r={axis:t};return ol.runKernel(Ar,n,r)}});const dh=xl({argMin_:function(e,t=0){const n={x:yl(e,"x","argMin")},r={axis:t};return ol.runKernel(Dr,n,r)}});const hh=xl({asin_:function(e){const t={x:yl(e,"x","asin")};return ol.runKernel(Fr,t)}});const ph=xl({asinh_:function(e){const t={x:yl(e,"x","asinh")};return ol.runKernel(Mr,t)}});const fh=xl({atan_:function(e){const t={x:yl(e,"x","atan")};return ol.runKernel(Lr,t)}});const mh=xl({atan2_:function(e,t){let n=yl(e,"a","atan2"),r=yl(t,"b","atan2");[n,r]=Jo(n,r);const s={a:n,b:r};return ol.runKernel(Pr,s)}});const gh=xl({atanh_:function(e){const t={x:yl(e,"x","atanh")};return ol.runKernel(zr,t)}});function yh(e,t,n,r,s="NHWC",a){return xh(e,[...t,e[3]],n,a,r,null,null,_h(s))}function bh(e,t,n,r,s,a,i="channelsLast"){const[o,l]=Sh(t);let u;if("channelsLast"===i)u=[o,l,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[o,l,e[1],e[1]]}return xh(e,u,n,r,s,a,!1,i)}function vh(e,t,n,r,s,a,i="NDHWC"){const[o,l,u]=Ih(t);let c,d;if("NDHWC"===i)d="channelsLast",c=[o,l,u,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[o,l,u,e[1],e[1]]}return wh(e,c,n,r,s,!1,d,a)}function xh(e,t,n,r,s,a,i=!1,o="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,d]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,u,c]=e}const[h,p,,f]=t,[m,g]=Sh(n),[y,b]=Sh(r),v=Nh(h,y),x=Nh(p,b),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,r,s,a,i,o,l){let u,c,d;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=kh(e,t,n));const a=e[0],i=e[1],o=Th((a-t+2*r)/n+1,s),l=Th((i-t+2*r)/n+1,s);return[o,l]}([t,n],a,r,e,o);c=s[0],d=s[1]}else if("same"===e){c=Math.ceil(t/r),d=Math.ceil(n/s);const e=Math.max(0,(c-1)*r+a-t),o=Math.max(0,(d-1)*s+i-n),l=Math.floor(e/2),h=e-l,p=Math.floor(o/2);u={top:l,bottom:h,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),d=Math.ceil((n-i+1)/s);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const h="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=Th((t-a+h+p)/r+1,o),d=Th((n-i+f+m)/s+1,o)}}return{padInfo:u,outHeight:c,outWidth:d}}(s,u,c,m,g,v,x,a,o),I=i?f*d:f;let N;return"channelsFirst"===o?N=[l,I,k,S]:"channelsLast"===o&&(N=[l,k,S,I]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:k,outWidth:S,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:e,outShape:N,filterShape:t}}function wh(e,t,n,r,s,a=!1,i="channelsLast",o){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=e}const[p,f,m,,g]=t,[y,b,v]=Ih(n),[x,w,k]=Ih(r),S=Nh(p,x),I=Nh(f,w),N=Nh(m,k),{padInfo:T,outDepth:C,outHeight:E,outWidth:$}=function(e,t,n,r,s,a,i,o,l,u,c){let d,h,p,f;"valid"===e&&(e=0);if("number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,r,s,a){null==s&&(s=kh(e,t[0],r[0]));const i=[0,0,0,n];for(let n=0;n<3;n++)e[n]+2*s>=t[n]&&(i[n]=Th((e[n]-t[n]+2*s)/r[n]+1,a));return i}([t,n,r,1],[o,l,u],1,[s,a,i],e,c);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{h=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);const e=(h-1)*s+o-t,c=(p-1)*a+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),v=c-b,x=Math.floor(m/2);d={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(s,u,c,d,y,b,v,S,I,N,o),_=a?g*h:g;let O;return"channelsFirst"===i?O=[l,_,C,E,$]:"channelsLast"===i&&(O=[l,C,E,$,_]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:C,outHeight:E,outWidth:$,outChannels:_,padInfo:T,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:e,outShape:O,filterShape:t}}function kh(e,t,n,r=1){const s=Nh(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function Sh(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Ih(e){return"number"==typeof e?[e,e,e]:e}function Nh(e,t){return t<=1?e:e+(e-1)*(t-1)}function Th(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Ch(e){const[t,n,r]=Sh(e);return 1===t&&1===n&&1===r}function Eh(e,t){return Ch(e)||Ch(t)}function $h(e){return Sh(e).every((e=>e>0))}function _h(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Oh(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)Rn(Pn(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{Rn(Pn(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const Rh=xl({reshape_:function(e,t){const n={x:yl(e,"x","reshape","string_or_numeric")},r={shape:t};return ol.runKernel(Wa,n,r)}});const Ah=xl({avgPool_:function(e,t,n,r,s){const a=yl(e,"x","avgPool","float32");Rn(Eh(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=a,o=!1;3===a.rank&&(o=!0,i=Rh(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Rn(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),Oh("avgPool",r,s);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let c=ol.runKernel(Br,l,u);return c=Yu(c,a.dtype),o?Rh(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Dh=xl({avgPool3d_:function(e,t,n,r,s,a="NDHWC"){const i=yl(e,"x","avgPool3d","float32");let o=i,l=!1;4===i.rank&&(l=!0,o=Rh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Rn(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),Rn("NDHWC"===a,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),Rn("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),Oh("avgPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let d=ol.runKernel(jr,u,c);return d=Yu(d,o.dtype),l?Rh(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Fh=xl({concat_:function(e,t=0){Rn(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=bl(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return Qu(n[0]);const r=n,s={axis:t};return ol.runKernel(ts,r,s)}});const Mh=xl({sigmoid_:function(e){const t={x:yl(e,"x","sigmoid","float32")};return ol.runKernel(oi,t)}});const Lh=xl({slice_:function(e,t,n){const r=yl(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return ol.runKernel(ri,s,a)}});const zh=xl({tanh_:function(e){const t={x:yl(e,"x","tanh","float32")};return ol.runKernel(Ei,t)}});const Ph=xl({basicLSTMCell_:function(e,t,n,r,s,a){const i=yl(e,"forgetBias","basicLSTMCell"),o=yl(t,"lstmKernel","basicLSTMCell"),l=yl(n,"lstmBias","basicLSTMCell"),u=yl(r,"data","basicLSTMCell"),c=yl(s,"c","basicLSTMCell"),d=yl(a,"h","basicLSTMCell"),h=Fh([u,d],1),p=rd(h,o),f=Zu(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Lh(f,[0,0],y),v=Lh(f,[0,g],y),x=Lh(f,[0,2*g],y),w=Lh(f,[0,3*g],y),k=Zu(nc(Mh(b),zh(v)),nc(c,Mh(Zu(i,x))));return[k,nc(zh(k),Mh(w))]}});const Bh=xl({batchToSpaceND_:function(e,t,n){const r=yl(e,"x","batchToSpaceND"),s=t.reduce(((e,t)=>e*t));Rn(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),Rn(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),Rn(r.shape[0]%s==0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`));const a={x:r},i={blockShape:t,crops:n};return ol.runKernel(Gr,a,i)}});const Uh=xl({batchNorm_:function(e,t,n,r,s,a){null==a&&(a=.001);const i=yl(e,"x","batchNorm"),o=yl(t,"mean","batchNorm"),l=yl(n,"variance","batchNorm");let u,c;null!=s&&(u=yl(s,"scale","batchNorm")),null!=r&&(c=yl(r,"offset","batchNorm")),Rn(o.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Rn(null==c||o.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Rn(null==u||o.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d={x:function(e){let t;return t=0===e.rank||1===e.rank?Rh(e,[1,1,1,e.size]):2===e.rank?Rh(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Rh(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),scale:u,offset:c,mean:o,variance:l},h={varianceEpsilon:a},p=ol.runKernel(Ls,d,h);return Rh(p,i.shape)}});const jh=xl({batchNorm2d_:function(e,t,n,r,s,a){const i=yl(e,"x","batchNorm"),o=yl(t,"mean","batchNorm"),l=yl(n,"variance","batchNorm");let u,c;return null!=s&&(u=yl(s,"scale","batchNorm")),null!=r&&(c=yl(r,"offset","batchNorm")),Rn(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),Rn(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),Rn(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&Rn(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=c&&Rn(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),Uh(i,o,l,c,u,a)}});const Wh=xl({batchNorm3d_:function(e,t,n,r,s,a){const i=yl(e,"x","batchNorm"),o=yl(t,"mean","batchNorm"),l=yl(n,"variance","batchNorm");let u,c;return null!=s&&(u=yl(s,"scale","batchNorm")),null!=r&&(c=yl(r,"offset","batchNorm")),Rn(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),Rn(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),Rn(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&Rn(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=c&&Rn(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),Uh(i,o,l,c,u,a)}});const Vh=xl({batchNorm4d_:function(e,t,n,r,s,a){const i=yl(e,"x","batchNorm"),o=yl(t,"mean","batchNorm"),l=yl(n,"variance","batchNorm");let u,c;return null!=s&&(u=yl(s,"scale","batchNorm")),null!=r&&(c=yl(r,"offset","batchNorm")),Rn(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),Rn(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),Rn(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&Rn(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=c&&Rn(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),Uh(i,o,l,c,u,a)}});const Gh=xl({bincount_:function(e,t,n){const r=yl(e,"x","bincount"),s=yl(t,"weights","bincount");Rn("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),Rn(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Rn(s.size===r.size||0===s.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`));const a={x:r,weights:s},i={size:n};return ol.runKernel(Hr,a,i)}});const Hh=xl({bitwiseAnd_:function(e,t){const n=yl(e,"x","bitwiseAnd"),r=yl(t,"y","bitwiseAnd");if(!zn(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return ol.runKernel(qr,s)}});const qh=xl({broadcastArgs_:function(e,t){const n=yl(e,"s0","broadcastArgs","int32"),r=yl(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return ol.runKernel(Xr,s)}});const Kh=xl({broadcastTo_:function(e,t){let n=yl(e,"broadcastTo","x");const r=n.shape;if(fr(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Rh(n,e)}const s=n.shape,a=Array.from(t);for(let e=t.length-1;e>=0;e--)if(s[e]===t[e])a[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===a.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return Qu(n);const i={x:n},o={reps:a};return ol.runKernel($i,i,o)}});const Xh=xl({ceil_:function(e){const t={x:yl(e,"x","ceil","float32")};return ol.runKernel(Qr,t)}});const Yh=xl({clipByValue_:function(e,t,n){const r=yl(e,"x","clipByValue");if(Rn(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return kc(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return ol.runKernel(Jr,s,a)}});const Qh=xl({concat1d_:function(e){return Fh(e,0)}});const Jh=xl({concat2d_:function(e,t){return Fh(e,t)}});const Zh=xl({concat3d_:function(e,t){return Fh(e,t)}});const ep=xl({concat4d_:function(e,t){return Fh(e,t)}});const tp=xl({conv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const o=yl(e,"x","conv2d","float32"),l=yl(t,"filter","conv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Rh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Rn(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),Rn(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),Oh("conv2d",r,i);const d="NHWC"===s?u.shape[3]:u.shape[1];Rn(d===l.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`)),Rn(Eh(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),Rn($h(a),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Rn($h(n),(()=>"Error in conv2D: Strides should be larger than 0."));const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=ol.runKernel(ns,h,p);return c?Rh(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const np=xl({conv1d_:function(e,t,n,r,s="NWC",a=1,i){const o=yl(e,"x","conv1d"),l=yl(t,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=Rh(o,[1,o.shape[0],o.shape[1]])),Rn(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),Rn(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),Oh("conv1d",r,i),Rn(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),Rn(Eh(n,a),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`)),Rn($h(a),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Rn($h(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Rn("NWC"===s,(()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`));const d=Rh(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=Rh(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=tp(h,d,[1,n],r,"NHWC",[1,a],i);return Rh(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const rp=xl({conv2DBackpropInput_:function(e,t,n,r,s,a="NHWC",i){Rn(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=Rh(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Rn(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),Rn(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),Rn(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===a?o[3]:o[1],d="NHWC"===a?l.shape[3]:l.shape[1];Rn(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),Rn(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),Oh("conv2dDerInput",s,i);const h={dy:l,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=ol.runKernel(ss,h,p);return u?Rh(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const sp=xl({conv2dTranspose_:function(e,t,n,r,s,a){const i=yl(e,"x","conv2dTranspose"),o=yl(t,"filter","conv2dTranspose");return rp(n,i,o,r,s,"NHWC",a)}});const ap=xl({conv3d_:function(e,t,n,r,s="NDHWC",a=[1,1,1]){const i=yl(e,"x","conv3d"),o=yl(t,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=Rh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Rn(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),Rn(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),Rn(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),Rn(Eh(n,a),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),Rn("NDHWC"===s,(()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`)),Rn($h(a),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Rn($h(n),(()=>"Error in conv3D: Strides should be larger than 0."));const c={x:l,filter:o},d={strides:n,pad:r,dataFormat:s,dilations:a},h=ol.runKernel(as,c,d);return u?Rh(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const ip=xl({conv3DBackpropInput_:function(e,t,n,r,s){Rn(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let a=e,i=t,o=!1;4===t.rank&&(o=!0,i=Rh(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const l=a[4],u=i.shape[4];Rn(5===a.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`)),Rn(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),Rn(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),Rn(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),Rn(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:i,filter:n},d={pad:s,strides:r,inputShape:a},h=ol.runKernel(os,c,d);return o?Rh(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const op=xl({conv3dTranspose_:function(e,t,n,r,s){const a=yl(e,"x","conv3dTranspose"),i=yl(t,"filter","conv3dTranspose");return ip(n,a,i,r,s)}});const lp=xl({cos_:function(e){const t={x:yl(e,"x","cos","float32")};return ol.runKernel(ls,t)}});const up=xl({cosh_:function(e){const t={x:yl(e,"x","cosh","float32")};return ol.runKernel(us,t)}});const cp=xl({cumprod_:function(e,t=0,n=!1,r=!1){const s={x:yl(e,"x","cumprod")},a={axis:t,exclusive:n,reverse:r};return ol.runKernel(cs,s,a)}});const dp=xl({cumsum_:function(e,t=0,n=!1,r=!1){const s={x:yl(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return ol.runKernel(ds,s,a)}});const hp=xl({denseBincount_:function(e,t,n,r=!1){const s=yl(e,"x","denseBincount"),a=yl(t,"weights","denseBincount");Rn("int32"===s.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`)),Rn(s.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`)),Rn(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Rn(a.size===s.size||0===a.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`));const i={x:s,weights:a},o={size:n,binaryOutput:r};return ol.runKernel(ps,i,o)}});const pp=xl({depthToSpace_:function(e,t,n="NHWC"){const r=yl(e,"x","depthToSpace","float32"),s="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];Rn(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),Rn(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),Rn(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),Rn(i%(t*t)==0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));const o={x:r},l={blockSize:t,dataFormat:n};return ol.runKernel(fs,o,l)}});const fp=xl({depthwiseConv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const o=yl(e,"x","depthwiseConv2d","float32"),l=yl(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Rh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Rn(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),Rn(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));const d="NHWC"===s?u.shape[3]:u.shape[1];Rn(d===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Oh("depthwiseConv2d",r,i);const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=ol.runKernel(ms,h,p);return c?Rh(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const mp=xl({diag_:function(e){const t={x:yl(e,"x","diag")};return ol.runKernel(bs,t)}});const gp=xl({dilation2d_:function(e,t,n,r,s=[1,1],a="NHWC"){const i=yl(e,"x","dilation2d"),o=yl(t,"filter","dilation2d");Rn(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),Rn(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),Rn("NHWC"===a,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`));let l=i,u=!1;3===i.rank&&(l=Rh(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),Rn(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));const c={x:l,filter:o},d={strides:n,pad:r,dilations:s},h=ol.runKernel(vs,c,d);return u?Rh(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const yp=xl({equal_:function(e,t){let n=yl(e,"a","equal","string_or_numeric"),r=yl(t,"b","equal","string_or_numeric");[n,r]=Jo(n,r),_c(n.shape,r.shape);const s={a:n,b:r};return ol.runKernel(Es,s)}});const bp=xl({where_:function(e,t,n){const r=yl(t,"a","where"),s=yl(n,"b","where"),a=yl(e,"condition","where","bool"),i=_c(_c(a.shape,r.shape),s.shape),o={condition:Kh(a,i),t:Kh(r,i),e:Kh(s,i)};return ol.runKernel(ti,o)}});const vp=xl({divNoNan_:function(e,t){let n=yl(e,"a","div"),r=yl(t,"b","div");[n,r]=Jo(n,r);const s=tc(n,r),a=ac(s),i=yp(r,a);return bp(i,a,s)}});const xp=xl({dot_:function(e,t){const n=yl(e,"t1","dot"),r=yl(t,"t2","dot");Rn(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const s=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];if(Rn(s===a,(()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`)),1===n.rank&&1===r.rank){const e=Rh(n,[1,-1]),t=Rh(r,[-1,1]),s=rd(e,t);return Rh(s,[])}if(1===n.rank&&2===r.rank){const e=Rh(n,[1,-1]),t=Rh(r,[r.shape[0],r.shape[1]]),s=rd(e,t);return Rh(s,[s.size])}if(2===n.rank&&1===r.rank){const e=Rh(r,[-1,1]),t=rd(n,e);return Rh(t,[t.size])}{const e=Rh(r,[r.shape[0],r.shape[1]]);return rd(n,e)}}});const wp=xl({einsum_:function(e,...t){const n=t.map(((e,t)=>yl(e,`tensors${t}`,"einsum"))),r={equation:e};return ol.runKernel(Is,n,r)}});const kp=xl({elu_:function(e){const t={x:yl(e,"x","elu","float32")};return ol.runKernel(Ns,t)}});const Sp=xl({ensureShape_:function(e,t){const n=yl(e,"x","ensureShape","string_or_numeric");if(!Ln(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});const Ip=xl({erf_:function(e){let t=yl(e,"x","erf");Rn("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=Yu(t,"float32"));const n={x:t};return ol.runKernel(Cs,n)}});function Np(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Tp(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(e[a++]):s.push(t[i++]);return s}function Cp(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map((t=>e[t]))]}function Ep(e,t){return Tp(e,t.map((e=>1)),t)}function $p(e,t,n){Rn(Np(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function _p(e,t){if(Np(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function Op(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Rp(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const Ap=xl({max_:function(e,t=null,n=!1){const r={x:yl(e,"x","max")},s={reductionIndices:t,keepDims:n};return ol.runKernel(ua,r,s)}});const Dp=xl({min_:function(e,t=null,n=!1){const r={x:yl(e,"x","min")},s={axis:t,keepDims:n};return ol.runKernel(ya,r,s)}});const Fp=xl({sum_:function(e,t=null,n=!1){let r=yl(e,"x","sum");"bool"===r.dtype&&(r=Yu(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return ol.runKernel(ci,s,a)}});function Mp(e,t,n=null){if(0===e.rank)return Cc(e);if(1!==e.rank&&null===n)return Mp(Rh(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Fp(Cc(e),n);if(t===1/0)return Ap(Cc(e),n);if(t===-1/0)return Dp(Cc(e),n);if("euclidean"===t||2===t)return rc(Fp(Ic(Cc(e),pc(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Ap(Fp(Cc(e),n[0]),n[1]-1);if(t===1/0)return Ap(Fp(Cc(e),n[1]),n[0]);if(t===-1/0)return Dp(Fp(Cc(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return rc(Fp(sc(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Lp=xl({norm_:function(e,t="euclidean",n=null,r=!1){const s=Mp(e=yl(e,"x","norm"),t,n);let a=s.shape;if(r){const t=Hn(n,e.shape);a=Ep(s.shape,t)}return Rh(s,a)}});const zp=xl({euclideanNorm_:function(e,t=null,n=!1){return Lp(e,"euclidean",t,n)}});const Pp=xl({exp_:function(e){const t={x:yl(e,"x","exp")};return ol.runKernel($s,t)}});const Bp=xl({expandDims_:function(e,t=0){const n=yl(e,"x","expandDims","string_or_numeric");Rn(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},s={dim:t};return ol.runKernel(_s,r,s)}});const Up=xl({expm1_:function(e){const t={x:yl(e,"x","expm1")};return ol.runKernel(Os,t)}});const jp=xl({tile_:function(e,t){const n=yl(e,"x","tile","string_or_numeric");Rn(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},s={reps:t};return ol.runKernel($i,r,s)}});const Wp=xl({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const s=Xu([e,t],r),a=e<=t?e:t;for(let e=0;e<a;++e)s.set(1,e,e);const i=Rh(s.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return jp(Bp(i,0),[n[0],1,1]);if(2===n.length)return jp(Bp(Bp(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return jp(Bp(Bp(Bp(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});const Vp=xl({floor_:function(e){const t={x:yl(e,"x","floor","float32")};return ol.runKernel(Fs,t)}});const Gp=xl({gather_:function(e,t,n=0,r=0){const s={x:yl(e,"x","gather"),indices:yl(t,"indices","gather","int32")},a={axis:n,batchDims:r};return ol.runKernel(zs,s,a)}});const Hp=xl({greater_:function(e,t){let n=yl(e,"a","greater","string_or_numeric"),r=yl(t,"b","greater","string_or_numeric");[n,r]=Jo(n,r),_c(n.shape,r.shape);const s={a:n,b:r};return ol.runKernel(Bs,s)}});const qp=xl({greaterEqual_:function(e,t){let n=yl(e,"a","greaterEqual","string_or_numeric"),r=yl(t,"b","greaterEqual","string_or_numeric");[n,r]=Jo(n,r),_c(n.shape,r.shape);const s={a:n,b:r};return ol.runKernel(Us,s)}});const Kp=xl({isFinite_:function(e){const t={x:yl(e,"x","isFinite")};return ol.runKernel(Gs,t)}});const Xp=xl({isInf_:function(e){const t={x:yl(e,"x","isInf")};return ol.runKernel(Hs,t)}});const Yp=xl({isNaN_:function(e){const t={x:yl(e,"x","isNaN")};return ol.runKernel(qs,t)}});const Qp=xl({leakyRelu_:function(e,t=.2){const n={x:yl(e,"x","leakyRelu")},r={alpha:t};return ol.runKernel(Ks,n,r)}});const Jp=xl({less_:function(e,t){let n=yl(e,"a","less","string_or_numeric"),r=yl(t,"b","less","string_or_numeric");[n,r]=Jo(n,r),_c(n.shape,r.shape);const s={a:n,b:r};return ol.runKernel(Xs,s)}});const Zp=xl({lessEqual_:function(e,t){let n=yl(e,"a","lessEqual","string_or_numeric"),r=yl(t,"b","lessEqual","string_or_numeric");[n,r]=Jo(n,r),_c(n.shape,r.shape);const s={a:n,b:r};return ol.runKernel(Ys,s)}});function ef(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return ol.runKernel(Qs,{},r)}const tf=xl({localResponseNormalization_:function(e,t=5,n=1,r=1,s=.5){const a=yl(e,"x","localResponseNormalization");Rn(4===a.rank||3===a.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`)),Rn(Pn(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=a,o=!1;3===a.rank&&(o=!0,i=Rh(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:s},c=ol.runKernel(ia,l,u);return o?Rh(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const nf=xl({log_:function(e){const t={x:yl(e,"x","log","float32")};return ol.runKernel(Js,t)}});const rf=xl({log1p_:function(e){const t={x:yl(e,"x","log1p")};return ol.runKernel(Zs,t)}});const sf=xl({softplus_:function(e){const t={x:yl(e,"x","softplus")};return ol.runKernel(li,t)}});const af=xl({logSigmoid_:function(e){const t=yl(e,"x","logSigmoid");return dc((e=>({value:id(sf(id(e))),gradFunc:t=>nc(t,Mh(id(e)))})))(t)}});const of=xl({logSoftmax_:function(e,t=-1){const n=yl(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const r=dc(((e,n)=>{const r=Ap(e,t,!0),s=Nc(e,r),a=Nc(Yu(s,"float32"),nf(Fp(Pp(s),t,!0)));n([a]);return{value:a,gradFunc:(e,n)=>{const[r]=n,s=Pp(r);return Nc(e,nc(Fp(e,t,!0),s))}}}));return r(n)}});const lf=xl({logSumExp_:function(e,t=null,n=!1){const r=yl(e,"x","logSumExp"),s=Hn(t,r.shape),a=Ap(r,s,!0),i=Nc(r,a),o=Pp(i),l=Fp(o,s),u=nf(l),c=Zu(Rh(a,u.shape),u);if(n){const e=Ep(c.shape,s);return Rh(c,e)}return c}});const uf=xl({logicalAnd_:function(e,t){const n=yl(e,"a","logicalAnd","bool"),r=yl(t,"b","logicalAnd","bool");_c(n.shape,r.shape);const s={a:n,b:r};return ol.runKernel(ea,s)}});const cf=xl({logicalNot_:function(e){const t={x:yl(e,"x","logicalNot","bool")};return ol.runKernel(ta,t)}});const df=xl({logicalOr_:function(e,t){const n=yl(e,"a","logicalOr","bool"),r=yl(t,"b","logicalOr","bool");_c(n.shape,r.shape);const s={a:n,b:r};return ol.runKernel(na,s)}});const hf=xl({logicalXor_:function(e,t){const n=yl(e,"a","logicalXor","bool"),r=yl(t,"b","logicalXor","bool");return _c(n.shape,r.shape),uf(df(e,t),cf(uf(e,t)))}}),pf=2147483648;const ff=xl({searchSorted_:function(e,t,n="left"){const r=yl(e,"sortedSequence","searchSorted"),s=yl(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=Rh(r,[-1,a]),l=Rh(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Fn(l.shape)>=pf)throw new Error("values tensor size must less than 2147483648");if(o.shape[1]>=pf)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);const u={sortedSequence:o,values:l},c={side:n};return ol.runKernel(ei,u,c)}});function mf(e,t){return ff(e,t,"left")}const gf=xl({maxPool_:function(e,t,n,r,s){const a=yl(e,"x","maxPool");let i=a,o=!1;3===a.rank&&(o=!0,i=Rh(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Rn(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),Rn(Eh(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),Oh("maxPool",r,s);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s},c=ol.runKernel(da,l,u);return o?Rh(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const yf=xl({maxPool3d_:function(e,t=[1,1,1],n,r,s,a="NDHWC"){const i=yl(e,"x","maxPool3d");let o=i,l=!1;4===i.rank&&(l=!0,o=Rh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Rn(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),Rn("NDHWC"===a,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),Oh("maxPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=ol.runKernel(pa,u,c);return l?Rh(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const bf=xl({maxPoolWithArgmax_:function(e,t,n,r,s=!1){const a={x:yl(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},o=ol.runKernel(ma,a,i);return{result:o[0],indexes:o[1]}}});const vf=xl({mean_:function(e,t=null,n=!1){const r={x:yl(e,"x","mean")},s={axis:t,keepDims:n};return ol.runKernel(ga,r,s)}});function xf(e,t="float32"){if(fr(e),"complex64"===t){const t=xf(e,"float32"),n=xf(e,"float32");return wl(t,n)}const n=hr(Fn(e),t);return ol.makeTensor(n,e,t)}function wf(e,t="float32"){if(fr(e),"complex64"===t){const t=wf(e,"float32"),n=xf(e,"float32");return wl(t,n)}const n=dr(Fn(e),t);return ol.makeTensor(n,e,t)}function kf(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=yl(e,"x","meshgrid",e instanceof Po?e.dtype:"float32");if(void 0===t)return[r];let s=yl(t,"y","meshgrid",t instanceof Po?t.dtype:"float32");const a=Fn(r.shape),i=Fn(s.shape);return"xy"===n?(r=Rh(r,[1,-1]),s=Rh(s,[-1,1]),[rd(wf([i,1],r.dtype),r),rd(s,wf([1,a],s.dtype))]):(r=Rh(r,[-1,1]),s=Rh(s,[1,-1]),[rd(r,wf([1,i],r.dtype)),rd(wf([a,1],s.dtype),s)])}const Sf=xl({minimum_:function(e,t){let n=yl(e,"a","minimum"),r=yl(t,"b","minimum");[n,r]=Jo(n,r),"bool"===n.dtype&&(n=Yu(n,"int32"),r=Yu(r,"int32")),_c(n.shape,r.shape);const s={a:n,b:r};return ol.runKernel(ba,s)}});const If=xl({mirrorPad_:function(e,t,n){Rn("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=yl(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Rn(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const s="reflect"===n?1:0;for(let e=0;e<r.rank;e++)Rn(2===t[e].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Rn(t[e][0]>=0&&t[e][0]<=r.shape[e]-s&&t[e][1]>=0&&t[e][1]<=r.shape[e]-s,(()=>`Padding in dimension ${e} cannot be greater than or equal to ${r.shape[e]-s} or less than 0 for input of shape ${r.shape}`));const a={paddings:t,mode:n},i={x:r};return ol.runKernel(va,i,a)}});const Nf=xl({mod_:function(e,t){let n=yl(e,"a","mod"),r=yl(t,"b","mod");[n,r]=Jo(n,r);const s={a:n,b:r};return ol.runKernel(xa,s)}});const Tf=xl({moments_:function(e,t=null,n=!1){const r=Hn(t,(e=yl(e,"x","moments")).shape),s=vf(e,r,n);let a=s.shape;n||(a=Ep(s.shape,r));const i=sc(Nc(Yu(e,"float32"),Rh(s,a)));return{mean:s,variance:vf(i,r,n)}}});const Cf=xl({multiRNNCell_:function(e,t,n,r){const s=yl(t,"data","multiRNNCell"),a=bl(n,"c","multiRNNCell"),i=bl(r,"h","multiRNNCell");let o=s;const l=[];for(let t=0;t<e.length;t++){const n=e[t](o,a[t],i[t]);l.push(n[0]),l.push(n[1]),o=n[1]}const u=[],c=[];for(let e=0;e<l.length;e+=2)u.push(l[e]),c.push(l[e+1]);return[u,c]}});const Ef=xl({multinomial_:function(e,t,n,r=!1){const s=yl(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o={logits:1===i?Rh(s,[1,-1]):s},l={numSamples:t,seed:n,normalized:r},u=ol.runKernel(wa,o,l);return 1===i?Rh(u,[u.size]):u}});const $f=xl({notEqual_:function(e,t){let n=yl(e,"a","notEqual","string_or_numeric"),r=yl(t,"b","notEqual","string_or_numeric");[n,r]=Jo(n,r),_c(n.shape,r.shape);const s={a:n,b:r};return ol.runKernel(Ia,s)}});const _f=xl({onesLike_:function(e){const t={x:yl(e,"x","onesLike")};return ol.runKernel(Ea,t)}});const Of=xl({outerProduct_:function(e,t){const n=yl(e,"v1","outerProduct"),r=yl(t,"v2","outerProduct");Rn(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const s=Rh(n,[-1,1]),a=Rh(r,[1,-1]);return rd(s,a)}});const Rf=xl({pad_:function(e,t,n=0){const r=yl(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return ol.runKernel(Oa,a,s)}});const Af=xl({pad1d_:function(e,t,n=0){return Rn(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),Rf(e,[t],n)}});const Df=xl({pad2d_:function(e,t,n=0){return Rn(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Rf(e,t,n)}});const Ff=xl({pad3d_:function(e,t,n=0){return Rn(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Rf(e,t,n)}});const Mf=xl({pad4d_:function(e,t,n=0){return Rn(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Rf(e,t,n)}});const Lf=xl({spaceToBatchND_:function(e,t,n){const r=yl(e,"x","spaceToBatchND");Rn(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),Rn(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),Rn(r.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]==0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const s={x:r},a={blockShape:t,paddings:n};return ol.runKernel(di,s,a)}});const zf=xl({pool_:function(e,t,n,r,s,a,i){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const o=yl(e,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=Rh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Rn(Eh(a,s),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`));const c=bh(l.shape,t,a,s,r),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),r=n.map((e=>e-1)),s=r.map((e=>Math.floor(e/2))),a=r.map(((e,t)=>e-s[t]));return r.map(((e,t)=>[s[t],a[t]]))}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,m]=function(e,t,n){const r=n.map((e=>e[0])),s=n.map((e=>e[1])),a=e.concat(r,s),i=t.map(((e,t)=>(e-a[t]%e)%e)),o=s.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}([c.inHeight,c.inWidth],d,h),g=p?r:"valid",y=p?l:Lf(l,d,f),b=("avg"===n?()=>Ah(y,t,a,g,i):()=>gf(y,t,a,g,i))(),v=p?b:Bh(b,d,m);return u?Rh(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});const Pf=xl({prelu_:function(e,t){const n={x:yl(e,"x","prelu"),alpha:yl(t,"alpha","prelu")};return ol.runKernel(Da,n)}});const Bf=xl({prod_:function(e,t=null,n=!1){let r=yl(e,"x","prod");"bool"===r.dtype&&(r=Yu(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return ol.runKernel(Fa,s,a)}});const Uf=xl({raggedGather_:function(e,t,n,r){const s={paramsNestedSplits:e.map(((e,t)=>yl(e,`tensors${t}`,"raggedGather","int32"))),paramsDenseValues:yl(t,"paramsDenseValues","raggedGather"),indices:yl(n,"indices","raggedGather","int32")},a={outputRaggedRank:r},i=ol.runKernel(Ma,s,a);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});const jf=xl({raggedRange_:function(e,t,n){const r=yl(e,"starts","raggedRange"),s={starts:r,limits:yl(t,"limits","raggedRange",r.dtype),deltas:yl(n,"deltas","raggedRange",r.dtype)},a=ol.runKernel(La,s);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}});const Wf=xl({raggedTensorToTensor_:function(e,t,n,r,s){const a=yl(e,"shape","raggedTensorToTensor","int32"),i=yl(t,"values","raggedTensorToTensor"),o={shape:a,values:i,defaultValue:yl(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>yl(e,`tensors${t}`,"raggedTensorToTensor","int32")))},l={rowPartitionTypes:s};return ol.runKernel(za,o,l)}});const Vf=xl({rand_:function(e,t,n){fr(e);const r=Fn(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);s=new Uint8Array(r)}for(let e=0;e<r;e++)s[e]=t();return ol.makeTensor(s,e,n)}});var Gf=n(391);class Hf{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=Gf.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class qf{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const s=r||Math.random();this.randu=Gf.alea(s.toString()),this.randn=new Hf(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class Kf{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Gf.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Xf=xl({randomGamma_:function(e,t,n=1,r="float32",s){if(fr(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const a=new qf(t,n,r,s),i=Xu(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}});const Yf=xl({randomNormal_:function(e,t=0,n=1,r,s){if(fr(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new Hf(t,n,r,!1,s),i=Xu(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}});const Qf=xl({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return Yf(e,0,1,t,n)}});const Jf=xl({randomUniform_:function(e,t=0,n=1,r="float32",s){fr(e);const a=Xu(e,r),i=new Kf(t,n,null,s);for(let e=0;e<a.values.length;e++)a.values[e]=i.nextValue();return a.toTensor()}});const Zf=xl({randomUniformInt_:function(e,t,n,r){return Jf(e,t,n,"int32",r)}});function em(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return ol.runKernel(Pa,{},s)}const tm=xl({reciprocal_:function(e){const t={x:yl(e,"x","reciprocal")};return ol.runKernel(Ua,t)}});const nm=xl({relu_:function(e){const t={x:yl(e,"x","relu")};return ol.runKernel(ja,t)}});const rm=xl({relu6_:function(e){const t={x:yl(e,"x","relu6")};return ol.runKernel(Ka,t)}});const sm=xl({reverse_:function(e,t){const n={x:yl(e,"x","reverse")},r={dims:t};return ol.runKernel(Xa,n,r)}});const am=xl({reverse1d_:function(e){const t=yl(e,"x","reverse");return Rn(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),sm(t,0)}});const im=xl({reverse2d_:function(e,t){const n=yl(e,"x","reverse");return Rn(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),sm(n,t)}});const om=xl({reverse3d_:function(e,t){const n=yl(e,"x","reverse");return Rn(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),sm(n,t)}});const lm=xl({reverse4d_:function(e,t){const n=yl(e,"x","reverse");return Rn(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),sm(n,t)}});const um=xl({round_:function(e){const t={x:yl(e,"x","round")};return ol.runKernel(Ya,t)}});const cm=xl({rsqrt_:function(e){const t={x:yl(e,"x","rsqrt","float32")};return ol.runKernel(Qa,t)}});const dm=xl({selu_:function(e){const t={x:yl(e,"x","selu")};return ol.runKernel(ni,t)}});const hm=xl({separableConv2d_:function(e,t,n,r,s,a=[1,1],i="NHWC"){const o=yl(e,"x","separableConv2d"),l=yl(t,"depthwiseFilter","separableConv2d"),u=yl(n,"pointwiseFilter","separableConv2d");let c=o,d=!1;if(3===o.rank&&(d=!0,c=Rh(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Rn(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),Rn(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),Rn(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),Rn(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),Rn(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const h=l.shape[2],p=l.shape[3];Rn(u.shape[2]===h*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`));const f=fp(c,l,r,s,i,a),m=tp(f,u,1,"valid",i);return d?Rh(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const pm=async function(e,t){const n=yl(e,"x","setdiff1d"),r=yl(t,"y","setdiff1d");Rn(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),Rn(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),Rn(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let e=0;e<s.length;e++)i.has(s[e])||o++;const l=new Fo([o],n.dtype),u=new Fo([o],"int32");for(let e=0,t=0;e<s.length;e++)i.has(s[e])||(l.values[t]=s[e],u.values[t]=e,t++);return[l.toTensor(),u.toTensor()]};const fm=xl({sign_:function(e){const t={x:yl(e,"x","sign")};return ol.runKernel(ii,t)}});const mm=xl({sin_:function(e){const t={x:yl(e,"x","sin","float32")};return ol.runKernel(si,t)}});const gm=xl({sinh_:function(e){const t={x:yl(e,"x","sinh")};return ol.runKernel(ai,t)}});const ym=xl({slice1d_:function(e,t,n){const r=yl(e,"x","slice1d");return Rn(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),Lh(r,[t],[n])}});const bm=xl({slice2d_:function(e,t,n){const r=yl(e,"x","slice2d");return Rn(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),Lh(r,t,n)}});const vm=xl({slice3d_:function(e,t,n){const r=yl(e,"x","slice3d");return Rn(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),Lh(r,t,n)}});const xm=xl({slice4d_:function(e,t,n){const r=yl(e,"x","slice4d");return Rn(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),Lh(r,t,n)}});const wm=xl({softmax_:function(e,t=-1){const n=yl(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return ol.runKernel(pi,r,s)}});const km=xl({fft_:function(e){Rn("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return ol.runKernel(Rs,t)}});const Sm=xl({ifft_:function(e){Rn("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return ol.runKernel(Ws,t)}});const Im=xl({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=Rh(e,[n,t]);r=Sm(s)}else{const s=[n,2*(t-1)],a=Rh(od(e),[n,t]),i=Rh(ad(e),[n,t]),o=sm(Lh(a,[0,1],[n,t-2]),1),l=nc(sm(Lh(i,[0,1],[n,t-2]),1),pc(-1)),u=Fh([a,o],1),c=Fh([i,l],1),d=Rh(wl(u,c),[s[0],s[1]]);r=Sm(d)}if(r=od(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=Rh(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});const Nm=xl({split_:function(e,t,n=0){const r={x:yl(e,"x","split")},s={numOrSizeSplits:t,axis:n};return ol.runKernel(hi,r,s)}});const Tm=xl({rfft_:function(e,t){Rn("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=t,s=Lh(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,s=Fh([e,xf(r)],e.shape.length-1),n=t}else s=e;const a=ac(s),i=Rh(wl(s,a),[r,n]),o=km(i),l=Math.floor(n/2)+1,u=od(o),c=ad(o),d=Nm(u,[l,n-l],u.shape.length-1),h=Nm(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,Rh(wl(d[0],h[0]),p)}});const Cm=xl({squaredDifference_:function(e,t){let n=yl(e,"a","squaredDifference"),r=yl(t,"b","squaredDifference");[n,r]=Jo(n,r),_c(n.shape,r.shape);const s={a:n,b:r};return ol.runKernel(vi,s,{})}});const Em=xl({squeeze_:function(e,t){const n=yl(e,"x","squeeze","string_or_numeric");return Rh(n,qn(n.shape,t).newShape)}});const $m=xl({stack_:function(e,t=0){const n=bl(e,"tensors","stack","string_or_numeric");Rn(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Rn(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,s={axis:t};return ol.runKernel(_a,r,s)}});const _m=xl({step_:function(e,t=0){const n={x:yl(e,"x","step")},r={alpha:t};return ol.runKernel(zi,n,r)}});const Om=xl({stridedSlice_:function(e,t,n,r,s=0,a=0,i=0,o=0,l=0){const u={x:yl(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return ol.runKernel(ki,u,c)}});const Rm=xl({tan_:function(e){const t={x:yl(e,"x","tan","float32")};return ol.runKernel(Ci,t)}});function Am(e,t){Dn(e);const n=fl(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return kl(e,null,n,t)}function Dm(e,t,n){if(Dn(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=fl(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return kl(e,t,r,n)}function Fm(e,t,n){if(Dn(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=fl(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return kl(e,t,r,n)}function Mm(e,t,n){if(Dn(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=fl(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return kl(e,t,r,n)}function Lm(e,t,n){if(Dn(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=fl(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return kl(e,t=t||r,r,n)}const zm=xl({tensorScatterUpdate_:function(e,t,n){const r=yl(e,"tensor","tensorScatterupdate"),s=yl(t,"indices","tensorScatterupdate","int32"),a=yl(n,"updates","tensorScatterupdate");if(kd(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);const i={tensor:r,indices:s,updates:a};return ol.runKernel(Za,i,{})}});const Pm=xl({topk_:function(e,t=1,n=!0){const r=yl(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,l]=ol.runKernel(_i,a,i);return{values:o,indices:l}}});const Bm=xl({truncatedNormal_:function(e,t=0,n=1,r,s){if(fr(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new Hf(t,n,r,!0,s),i=Xu(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}});const Um=xl({unique_:function(e,t=0){const n=yl(e,"x","unique","string_or_numeric");Rn(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},s={axis:t},[a,i]=ol.runKernel(Ai,r,s);return{values:a,indices:i}}});const jm=xl({unsortedSegmentSum_:function(e,t,n){const r=yl(e,"x","unsortedSegmentSum"),s=yl(t,"segmentIds","unsortedSegmentSum","int32");Rn(Pn(n),(()=>"numSegments must be of dtype int"));const a={x:r,segmentIds:s},i={numSegments:n};return ol.runKernel(Fi,a,i)}});const Wm=xl({unstack_:function(e,t=0){const n=yl(e,"x","unstack","string_or_numeric");Rn(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},s={axis:t};return ol.runKernel(Di,r,s)}});function Vm(e,t){return ff(e,t,"right")}function Gm(e,t=!0,n,r){return ol.makeVariable(e,t,n,r)}function Hm(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const r=Xu(e,"int32"),s=Xu([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const a=r.indexToLoc(n[t]),i=t*e.length;s.values.set(a,i)}return s.toTensor()}const qm=async function(e){const t=yl(e,"condition","whereAsync","bool"),n=await t.data(),r=Hm(t.shape,n);return e!==t&&t.dispose(),r};const Km=async function(e,t,n){const r=yl(e,"tensor","boolMask"),s=yl(t,"mask","boolMask","bool"),a=null==n?0:n,i=s.rank,o=r.shape;Rn(i>0,(()=>"mask cannot be scalar")),An(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let e=a;e<a+i;e++)l*=o[e];const u=o.slice(0,a).concat([l],o.slice(a+i)),c=Rh(r,u),d=Rh(s,[-1]),h=await qm(d),p=Em(h,[1]),f=Gp(c,p,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f};const Xm=xl({movingAverage_:function(e,t,n,r,s=!0){const a=yl(e,"v","movingAverage"),i=yl(t,"x","movingAverage"),o=yl(n,"decay","movingAverage");Zo(a,i),Rn(zn(a.shape,i.shape),(()=>"Shape mismatch in v and x"));const l=pc(1),u=Nc(l,o);let c=nc(Nc(i,a),u);if(s){Rn(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=yl(r,"step","movingAverage");c=tc(c,Nc(l,Ic(o,e)))}return Zu(a,c)}});const Ym=xl({scatterND_:function(e,t,n){fr(n);const r=yl(e,"indices","scatterND","int32"),s=yl(t,"updates","scatterND");kd(s,r,n);const a={indices:r,updates:s},i={shape:n};return ol.runKernel(Ja,a,i)}});const Qm=xl({sparseToDense_:function(e,t,n,r=0){fr(n);const s=yl(e,"sparseIndices","sparseToDense","int32"),a=yl(t,"sparseValues","sparseToDense","string_or_numeric"),i=yl(r,"defaultValue","sparseToDense",a.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},l={outputShape:n};return ol.runKernel(bi,o,l)}});const Jm=xl({gatherND_:function(e,t){const n=yl(t,"indices","gatherND","int32"),r={params:yl(e,"x","gatherND","string_or_numeric"),indices:n};return ol.runKernel(Ps,r)}});const Zm=xl({dropout_:function(e,t,n,r){const s=yl(e,"x","dropout");if(Rn("float32"===s.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`)),Rn(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof Po?s.clone():s;const a=function(e,t){if(null==t)return e.shape.slice();if(zn(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(s,n),i=1-t,o=tc(Vp(Zu(Jf(a,0,1,"float32",r),i)),i);return nc(s,o)}});function eg(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function tg(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return Am(s,"float32")}const ng=async function(e,t,n=1){const r=yl(e,"predictions","inTopK"),s=yl(t,"targets","inTopK");Rn(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),Rn(r.rank-1===s.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`)),An(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];Rn(n>0&&n<=a,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`));const i=await r.data(),o=await s.data(),[l,u]=[i.length/a,a],c=Kn("bool",l);for(let e=0;e<l;e++){const t=e*u,r=i.subarray(t,t+u),s=[];for(let e=0;e<r.length;e++)s.push({value:r[e],index:e});s.sort(((e,t)=>t.value-e.value)),c[e]=0;for(let t=0;t<n;t++)if(s[t].index===o[e]){c[e]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),Sl(c,s.shape,"bool")};const rg=xl({conv2DBackpropFilter_:function(e,t,n,r,s,a="NHWC",i){let o=e;3===e.rank&&(o=Rh(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Rh(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Rn(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),Rn(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),Rn(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===a?o.shape[3]:o.shape[1],c="NHWC"===a?l.shape[3]:l.shape[1];Rn(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),Rn(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),Oh("conv2dDerFilter",s,i);const d={x:o,dy:l},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return ol.runKernel(rs,d,h)}});function sg(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return nc(e,_m(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function ag(e,t){let n=t;const r=$c(e.shape,t.shape);return r.length>0&&(n=Fp(n,r)),Rh(n,e.shape)}function ig(e,t,n,r){if("linear"===t)return e;if("relu"===t)return nm(e);if("elu"===t)return kp(e);if("relu6"===t)return rm(e);if("prelu"===t)return Pf(e,n);if("leakyrelu"===t)return Qp(e,r);if("sigmoid"===t)return Mh(e);throw new Error(`Unknown fused activation ${t}.`)}const og=(e,t)=>!(e>0)||"linear"===t;const lg=xl({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",!1===og(ol.state.gradientDepth,l)){Rn("NHWC"===s,(()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let d=tp(e,t,n,r,s,a,i);return null!=o&&(d=Zu(d,o)),ig(d,l,u,c)}const d=yl(e,"x","conv2d","float32"),h=yl(t,"filter","conv2d","float32");let p=d,f=!1;3===d.rank&&(f=!0,p=Rh(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Rn(4===p.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`)),Rn(4===h.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`)),Oh("fused conv2d",r,i);const m="NHWC"===s?p.shape[3]:p.shape[1];Rn(h.shape[2]===m,(()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`)),Rn(Eh(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`));const g=xh(p.shape,h.shape,n,a,r,i);let y,b;if(null!=o&&(y=yl(o,"bias","fused conv2d"),[y]=Jo(y,d),"NHWC"===s?_c(g.outShape,y.shape):(Rn(y.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`)),Rn(0===y.shape.length||y.shape[0]===g.outChannels||1===y.shape[0],(()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)))),null!=u){const e=u.shape;if(Rn(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)Rn(1===e[0]||e[0]===g.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${g.outChannels}).`));else if(3===e.length)try{_c(e,g.outShape)}catch(t){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(n)}b=yl(u,"prelu weights","fused conv2d")}const v=(e,t)=>{Rn("NHWC"===s,(()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`));const[i,o,u,c]=t,d=sg(e,u,l);Rn(Ch(a),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`));const h=[rp(o.shape,d,i,n,r),rg(o,d,i.shape,n,r)];if(null!=c){const e=ag(c,d);h.push(e)}return h},x={x:p,filter:h,bias:y,preluActivationWeights:b},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};if(null==o){const e=dc(((e,t,n)=>{let r=ol.runKernel(ji,x,w);return n([t,e,r]),f&&(r=Rh(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(p,h)}{const e=dc(((e,t,n,r)=>{let s=ol.runKernel(ji,x,w);return r([t,e,s,n]),f&&(s=Rh(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:v}}));return e(p,h,y)}}});const ug=xl({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s,a=[1,1],i){let o=e;3===e.rank&&(o=Rh(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Rh(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return ol.runKernel(gs,u,c)}});const cg=xl({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s,a=[1,1],i){let o=t,l=!1;3===t.rank&&(l=!0,o=Rh(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},d=ol.runKernel(ys,u,c);return l?Rh(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const dg=xl({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===og(ol.state.gradientDepth,l)){let d=fp(e,t,n,r,s,a,i);return null!=o&&(d=Zu(d,o)),ig(d,l,u,c)}const d=yl(e,"x","depthwiseConv2d","float32"),h=yl(t,"filter","depthwiseConv2d","float32");let p=d,f=!1;3===d.rank&&(f=!0,p=Rh(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Rn(4===p.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`)),Rn(4===h.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`)),Rn(p.shape[3]===h.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`)),null==a&&(a=[1,1]),Rn(Eh(n,a),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),Oh("fused depthwiseConv2d",r,i);const m=xh(p.shape,h.shape,n,a,r,i,!0);let g,y;null!=o&&(g=yl(o,"bias","fused conv2d"),[g]=Jo(g,d),_c(m.outShape,g.shape)),null!=u&&(y=yl(u,"prelu weights","fused depthwiseConv2d"));const b=(e,t)=>{Rn(Ch(a),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`));const[s,o,u,c]=t,d=sg(e,u,l),h=cg(o.shape,d,s,n,r,a,i),p=ug(o,d,s.shape,n,r,a,i);if(null!=c){return[h,p,ag(g,d)]}return[h,p]},v={x:p,filter:h,bias:g,preluActivationWeights:y},x={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};if(null==o){const e=dc(((e,t,n)=>{let r=ol.runKernel(Wi,v,x);return n([t,e,r]),f&&(r=Rh(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}}));return e(p,h)}{const e=dc(((e,t,n,r)=>{let s=ol.runKernel(Wi,v,x);return r([t,e,s,n]),f&&(s=Rh(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}}));return e(p,h,g)}}});const hg=xl({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(!1===og(ol.state.gradientDepth,a)){let l=rd(e,t,n,r);return null!=s&&(l=Zu(l,s)),ig(l,a,i,o)}let l=yl(e,"a","fused matMul"),u=yl(t,"b","fused matMul");[l,u]=Jo(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=Fn(f),y=Fn(m);Rn(c===d,(()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`));const b=_c(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,p]),v=Rh(l,n?[g,c,h]:[g,h,c]),x=Rh(u,r?[y,p,d]:[y,d,p]);let w,k;null!=s&&(w=yl(s,"bias","fused matMul"),[w]=Jo(w,l),_c(b,w.shape)),null!=i&&(k=yl(i,"prelu weights","fused matMul"));const S=(e,t)=>{const[i,o,l,u]=t,c=sg(Rh(e,l.shape),l,a);let d,h;if(n||r?!n&&r?(d=rd(c,o,!1,!1),h=rd(c,i,!0,!1)):n&&!r?(d=rd(o,c,!1,!0),h=rd(i,c,!1,!1)):(d=rd(o,c,!0,!0),h=rd(c,i,!0,!0)):(d=rd(c,o,!1,!0),h=rd(i,c,!0,!1)),null!=s){return[d,h,ag(u,c)]}return[d,h]},I={a:v,b:x,bias:w,preluActivationWeights:k},N={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};if(null==s){const e=dc(((e,t,n)=>{const r=ol.runKernel(Ui,I,N);return n([e,t,r]),{value:Rh(r,b),gradFunc:S}}));return e(v,x)}{const e=dc(((e,t,n,r)=>{const s=ol.runKernel(Ui,I,N);return r([e,t,s,n]),{value:Rh(s,b),gradFunc:S}}));return e(v,x,w)}}});const pg=xl({hammingWindow_:function(e){return tg(e,.54,.46)}});const fg=xl({hannWindow_:function(e){return tg(e,.5,.5)}});const mg=xl({frame_:function(e,t,n,r=!1,s=0){let a=0;const i=[];for(;a+t<=e.size;)i.push(Lh(e,a,t)),a+=n;if(r)for(;a<e.size;){const r=a+t-e.size,o=Fh([Lh(e,a,t-r),kc([r],s)]);i.push(o),a+=n}return 0===i.length?Dm([],[0,t]):Rh(Fh(i),[i.length,t])}});const gg=xl({stft_:function(e,t,n,r,s=fg){null==r&&(r=eg(t));const a=mg(e,t,n),i=nc(a,s(t));return Tm(i,r)}});const yg=xl({cropAndResize_:function(e,t,n,r,s="bilinear",a=0){const i=yl(e,"image","cropAndResize"),o=yl(t,"boxes","cropAndResize","float32"),l=yl(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Rn(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),Rn(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),Rn(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),Rn(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),Rn(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),Rn("bilinear"===s||"nearest"===s,(()=>`method must be bilinear or nearest, but was ${s}`));const c={image:i,boxes:o,boxInd:l},d={method:s,extrapolationValue:a,cropSize:r};return ol.runKernel(hs,c,d)}});const bg=xl({flipLeftRight_:function(e){const t=yl(e,"image","flipLeftRight","float32");Rn(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return ol.runKernel(Ds,n,{})}});const vg=xl({grayscaleToRGB_:function(e){const t=yl(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Rn(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),Rn(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,jp(t,s)}});const xg=xl({rgbToGrayscale_:function(e){const t=yl(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Rn(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),Rn(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));const s=t.dtype,a=Yu(t,"float32"),i=Am([.2989,.587,.114]);let o;switch(t.rank){case 2:o=wp("ij,j->i",a,i);break;case 3:o=wp("ijk,k->ij",a,i);break;case 4:o=wp("ijkl,l->ijk",a,i);break;case 5:o=wp("ijklm,m->ijkl",a,i);break;case 6:o=wp("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=Bp(o,-1),Yu(o,s)}});const wg=xl({rotateWithOffset_:function(e,t,n=0,r=.5){const s=yl(e,"image","rotateWithOffset","float32");Rn(4===s.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`));const a={image:s},i={radians:t,fillValue:n,center:r};return ol.runKernel(Bi,a,i)}});function kg(e,t,n,r,s,a){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),Rn(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),Rn(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),Rn(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),Rn(1===t.rank,(()=>"scores must be a 1D tensor")),Rn(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),Rn(0<=a&&a<=1,(()=>`softNmsSigma must be in [0, 1], but was '${a}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}const Sg=xl({nonMaxSuppression_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=yl(e,"boxes","nonMaxSuppression","float32"),i=yl(t,"scores","nonMaxSuppression","float32"),o=kg(a,i,n,r,s),l={maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:s=o.scoreThreshold};return ol.runKernel(Na,{boxes:a,scores:i},l)}});function Ig(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}(e,t,n||Ng)}(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function Ng(e,t){return e>t?1:e<t?-1:0}function Tg(e,t,n,r,s){return $g(e,t,n,r,s,0)}function Cg(e,t,n,r,s,a){return $g(e,t,n,r,s,0,!1,a,!0)}function Eg(e,t,n,r,s,a){return $g(e,t,n,r,s,a,!0)}function $g(e,t,n,r,s,a,i=!1,o=!1,l=!1){const u=[];for(let e=0;e<t.length;e++)t[e]>s&&u.push({score:t[e],boxIndex:e,suppressBeginIndex:0});u.sort(Rg);const c=a>0?-.5/a:0,d=[],h=[];for(;d.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let n=d.length-1;n>=i;--n){const i=_g(e,a,d[n]);if(i>=r){o=!0;break}if(t.score=t.score*Og(r,c,i),t.score<=s)break}t.suppressBeginIndex=d.length,o||(t.score===n?(d.push(a),h.push(t.score)):t.score>s&&Ig(u,t,Rg))}const p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function _g(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(o-a)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(a,u),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(l,h),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function Og(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function Rg(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const Ag=async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=yl(e,"boxes","nonMaxSuppressionAsync"),i=yl(t,"scores","nonMaxSuppressionAsync"),o=kg(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=Tg(u,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),Am(d,"int32")};const Dg=xl({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=yl(e,"boxes","nonMaxSuppression"),o=yl(t,"scores","nonMaxSuppression"),l=kg(i,o,n,r,s,a),u={boxes:i,scores:o},c={maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:a=l.softNmsSigma},d=ol.runKernel(Ca,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}});const Fg=async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=yl(e,"boxes","nonMaxSuppressionAsync"),o=yl(t,"scores","nonMaxSuppressionAsync"),l=kg(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=Eg(c,d,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Am(h,"int32"),selectedScores:Am(p)}};const Mg=xl({nonMaxSuppressionPadded_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=yl(e,"boxes","nonMaxSuppression"),o=yl(t,"scores","nonMaxSuppression"),l=kg(i,o,n,r,s,null),u={boxes:i,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:a},d=ol.runKernel(Ta,u,c);return{selectedIndices:d[0],validOutputs:d[1]}}});const Lg=async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=yl(e,"boxes","nonMaxSuppressionAsync"),o=yl(t,"scores","nonMaxSuppressionAsync"),l=kg(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=Cg(h,p,u,c,d,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Am(f,"int32"),validOutputs:pc(m,"int32")}};const zg=xl({resizeBilinear_:function(e,t,n=!1,r=!1){const s=yl(e,"images","resizeBilinear");Rn(3===s.rank||4===s.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`)),Rn(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),Rn(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Rh(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=ol.runKernel(Ha,o,l);return i?Rh(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Pg=xl({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const s=yl(e,"images","resizeNearestNeighbor");Rn(3===s.rank||4===s.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`)),Rn(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),Rn("float32"===s.dtype||"int32"===s.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Rn(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Rh(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=ol.runKernel(Va,o,l);return i?Rh(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Bg=xl({threshold_:function(e,t="binary",n=!1,r=.5){const s=yl(e,"image","threshold"),a=s.shape[0]*s.shape[1];let i,o,l,u,c=nc(Am([r]),255);if(Rn(3===s.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`)),Rn(3===s.shape[2]||1===s.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`)),Rn("int32"===s.dtype||"float32"===s.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`)),Rn("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===s.shape[2]){[i,o,l]=Nm(s,[1,1,1],-1);const e=nc(i,.2989),t=nc(o,.587),n=nc(l,.114);u=Zu(Zu(e,t),n)}else u=e;if("otsu"===t){c=function(e,t){let n,r,s,a,i,o,l=Am([-1]),u=Am([0]),c=Am([0]);for(let d=0;d<e.size-1;d++){n=Lh(e,0,d+1),r=Lh(e,d+1),i=tc(Fp(n),t),o=tc(Fp(r),t);const h=Fp(nc(n,em(0,n.size)));s=tc(h,Fp(n));const p=kc(r.shape,n.size),f=Zu(em(0,r.size),p),m=nc(r,f);a=tc(Fp(m),Fp(r));const g=Nc(s,a),y=Nc(s,a),b=nc(i,o);c=nc(nc(b,g),y);const v=Hp(c,u);u=bp(v,c,u),l=bp(v,Am([d]),l)}return l}(Gh(Yu(um(u),"int32"),Sl([]),256),a)}const d=n?Zp(u,c):Hp(u,c);return Yu(nc(d,255),"int32")}});const Ug=xl({transform_:function(e,t,n="nearest",r="constant",s=0,a){const i=yl(e,"image","transform","float32"),o=yl(t,"transforms","transform","float32");Rn(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),Rn(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Rn(null==a||2===a.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`));const l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return ol.runKernel(Oi,l,u)}});const jg=xl({bandPart_:function(e,t,n){const r=yl(e,"a","bandPart");Rn(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const s=r.shape,[a,i]=r.shape.slice(-2);let o,l;"number"==typeof t?(Rn(t%1==0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),Rn(t<=a,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`)),o=yl(t<0?a:t,"numLower","bandPart")):(Rn("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),o=bp(Jp(t,0),a,Sf(t,a))),"number"==typeof n?(Rn(n%1==0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),Rn(n<=i,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)),l=yl(n<0?i:n,"numUpper","bandPart")):(Rn("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=bp(Jp(n,0),i,Sf(n,i)));const u=Rh(em(0,a,1,"int32"),[-1,1]),c=em(0,i,1,"int32"),d=Nc(u,c),h=uf(Zp(d,o),qp(d,id(l))),p=xf([a,i],r.dtype);return Rh($m(Wm(Rh(r,[-1,a,i])).map((e=>bp(h,e,p)))),s)}});const Wg=xl({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Rn(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)Rn(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=Nm(e,e.shape[0],0).map((e=>Em(e,[0])));Rn(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let t=0;t<e.length;++t)n.push(ol.tidy((()=>{let e=r[t];if(t>0)for(let r=0;r<t;++r){const t=nc(Fp(nc(n[r],e)),n[r]);e=Nc(e,t)}return tc(e,Lp(e,"euclidean"))})));return t?$m(n,0):n}});function Vg(e,t=!1){return ol.tidy((()=>{Rn(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let s=Wp(n),a=Qu(e);const i=Dm([[1]],[1,1]);let o=Qu(i);const l=n>=r?r:n;for(let e=0;e<l;++e){const t=a,l=o,u=s;[o,a,s]=ol.tidy((()=>{const t=Lh(a,[e,e],[n-e,1]),l=Lp(t),u=Lh(a,[e,e],[1,1]),c=bp(Hp(u,0),Dm([[-1]]),Dm([[1]])),d=Nc(u,nc(c,l)),h=tc(t,d);o=1===h.shape[0]?Qu(i):Fh([i,Lh(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=id(tc(rd(c,d),l)),f=Lh(a,[e,0],[n-e,r]),m=nc(p,o),g=ld(o);if(0===e)a=Nc(f,rd(m,rd(g,f)));else{const t=Nc(f,rd(m,rd(g,f)));a=Fh([Lh(a,[0,0],[e,r]),t],0)}const y=ld(m),b=Lh(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=Nc(b,rd(rd(b,o),y));else{const t=Nc(b,rd(rd(b,o),y));s=Fh([Lh(s,[0,0],[n,e]),t],1)}return[o,a,s]})),Fl([t,l,u])}return!t&&n>r&&(s=Lh(s,[0,0],[n,r]),a=Lh(a,[0,0],[r,r])),[s,a]}))}const Gg=xl({qr_:function(e,t=!1){if(Rn(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Vg(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=Wm(Rh(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach((e=>{const[n,r]=Vg(e,t);s.push(n),a.push(r)}));return[Rh($m(s,0),e.shape),Rh($m(a,0),e.shape)]}}});var Hg;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Hg||(Hg={}));const qg=xl({computeWeightedLoss_:function(e,t,n=Hg.SUM_BY_NONZERO_WEIGHTS){const r=yl(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=yl(t,"weights","computeWeightedLoss"));const a=null==s?r:nc(r,s);if(n===Hg.NONE)return a;if(n===Hg.SUM)return Fp(a);if(n===Hg.MEAN){if(null==s)return vf(a);{const e=r.size/s.size,t=tc(Fp(a),Fp(s));return e>1?tc(t,pc(e)):t}}if(n===Hg.SUM_BY_NONZERO_WEIGHTS){if(null==s)return tc(Fp(a),pc(r.size));{const e=nc(s,wf(r.shape)),t=Yu(Fp($f(e,pc(0))),"float32");return tc(Fp(a),t)}}throw Error(`Unknown reduction: ${n}`)}});const Kg=xl({absoluteDifference_:function(e,t,n,r=Hg.SUM_BY_NONZERO_WEIGHTS){const s=yl(e,"labels","absoluteDifference"),a=yl(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=yl(n,"weights","absoluteDifference")),An(s.shape,a.shape,"Error in absoluteDifference: ");const o=Cc(Nc(s,a));return qg(o,i,r)}});const Xg=xl({cosineDistance_:function(e,t,n,r,s=Hg.SUM_BY_NONZERO_WEIGHTS){const a=yl(e,"labels","cosineDistance"),i=yl(t,"predictions","cosineDistance");let o=null;null!=r&&(o=yl(r,"weights","cosineDistance")),An(a.shape,i.shape,"Error in cosineDistance: ");const l=pc(1),u=Nc(l,Fp(nc(a,i),n,!0));return qg(u,o,s)}});const Yg=xl({hingeLoss_:function(e,t,n,r=Hg.SUM_BY_NONZERO_WEIGHTS){let s=yl(e,"labels","hingeLoss");const a=yl(t,"predictions","hingeLoss");let i=null;null!=n&&(i=yl(n,"weights","hingeLoss")),An(s.shape,a.shape,"Error in hingeLoss: ");const o=pc(1);s=Nc(nc(pc(2),s),o);const l=nm(Nc(o,nc(s,a)));return qg(l,i,r)}});const Qg=xl({huberLoss_:function(e,t,n,r=1,s=Hg.SUM_BY_NONZERO_WEIGHTS){const a=yl(e,"labels","huberLoss"),i=yl(t,"predictions","huberLoss");let o=null;null!=n&&(o=yl(n,"weights","huberLoss")),An(a.shape,i.shape,"Error in huberLoss: ");const l=pc(r),u=Cc(Nc(i,a)),c=Sf(u,l),d=Nc(u,c),h=Zu(nc(pc(.5),sc(c)),nc(l,d));return qg(h,o,s)}});const Jg=xl({logLoss_:function(e,t,n,r=1e-7,s=Hg.SUM_BY_NONZERO_WEIGHTS){const a=yl(e,"labels","logLoss"),i=yl(t,"predictions","logLoss");let o=null;null!=n&&(o=yl(n,"weights","logLoss")),An(a.shape,i.shape,"Error in logLoss: ");const l=pc(1),u=pc(r),c=id(nc(a,nf(Zu(i,u)))),d=nc(Nc(l,a),nf(Zu(Nc(l,i),u))),h=Nc(c,d);return qg(h,o,s)}});const Zg=xl({meanSquaredError_:function(e,t,n,r=Hg.SUM_BY_NONZERO_WEIGHTS){const s=yl(e,"labels","meanSquaredError"),a=yl(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=yl(n,"weights","meanSquaredError")),An(s.shape,a.shape,"Error in meanSquaredError: ");const o=Cm(s,a);return qg(o,i,r)}});const ey=xl({sigmoidCrossEntropy_:function(e,t,n,r=0,s=Hg.SUM_BY_NONZERO_WEIGHTS){let a=yl(e,"multiClassLabels","sigmoidCrossEntropy");const i=yl(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=yl(n,"weights","sigmoidCrossEntropy")),An(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=pc(r),t=pc(1),n=pc(.5);a=Zu(nc(a,Nc(t,e)),nc(n,e))}const l=function(e,t){const n=yl(e,"labels","sigmoidCrossEntropyWithLogits"),r=yl(t,"logits","sigmoidCrossEntropyWithLogits");An(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=nm(r),a=nc(r,n),i=rf(Pp(id(Cc(r))));return Zu(Nc(s,a),i)}(a,i);return qg(l,o,s)}});const ty=xl({softmaxCrossEntropy_:function(e,t,n,r=0,s=Hg.SUM_BY_NONZERO_WEIGHTS){let a=yl(e,"onehotLabels","softmaxCrossEntropy");const i=yl(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=yl(n,"weights","softmaxCrossEntropy")),An(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=pc(r),t=pc(1),n=pc(a.shape[1]);a=Zu(nc(a,Nc(t,e)),tc(e,n))}const l=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=dc(((e,t,r)=>{const s=lf(t,[n],!0),a=Nc(Yu(t,"float32"),s);r([e,a]);const i=id(nc(a,e));return{value:Fp(i,[n]),gradFunc:(e,t)=>{const[r,s]=t,a=Ep(e.shape,[n]);return[nc(Rh(e,a),Nc(Yu(r,"float32"),Pp(s))),nc(Rh(e,a),Nc(Pp(s),Yu(r,"float32")))]}}}));return r(e,t)}(a,i);return qg(l,o,s)}});const ny=xl({sparseFillEmptyRows_:function(e,t,n,r){const s=yl(e,"indices","sparseFillEmptyRows","int32"),a=yl(t,"values","sparseFillEmptyRows"),i=yl(n,"denseShape","sparseFillEmptyRows","int32"),o=yl(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:s,values:a,denseShape:i,defaultValue:o},u=ol.runKernel(fi,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}});const ry=xl({sparseReshape_:function(e,t,n){const r=yl(e,"inputIndices","sparseReshape","int32"),s=yl(t,"inputShape","sparseReshape","int32"),a=yl(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:r,inputShape:s,newShape:a},o=ol.runKernel(mi,i);return{outputIndices:o[0],outputShape:o[1]}}});const sy=xl({sparseSegmentMean_:function(e,t,n){const r=yl(e,"data","sparseSegmentMean"),s=yl(t,"indices","sparseSegmentMean","int32"),a=yl(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return ol.runKernel(gi,i)}});const ay=xl({sparseSegmentSum_:function(e,t,n){const r=yl(e,"data","sparseSegmentSum"),s=yl(t,"indices","sparseSegmentSum","int32"),a=yl(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return ol.runKernel(yi,i)}});const iy=xl({stringNGrams_:function(e,t,n,r,s,a,i,o){const l=yl(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=yl(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},h=ol.runKernel(Si,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}});const oy=xl({stringSplit_:function(e,t,n=!0){const r=yl(e,"input","stringSplit","string"),s=yl(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},i={input:r,delimiter:s},o=ol.runKernel(Ii,i,a);return{indices:o[0],values:o[1],shape:o[2]}}});const ly=xl({stringToHashBucketFast_:function(e,t){const n=yl(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return ol.runKernel(Ni,s,r)}});const uy=xl({staticRegexReplace_:function(e,t,n,r=!0){const s=yl(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return ol.runKernel(wi,{x:s},a)}}),cy={fft:km,ifft:Sm,rfft:Tm,irfft:Im},dy={hammingWindow:pg,hannWindow:fg,frame:mg,stft:gg},hy={flipLeftRight:bg,grayscaleToRGB:vg,resizeNearestNeighbor:Pg,resizeBilinear:zg,rgbToGrayscale:xg,rotateWithOffset:wg,cropAndResize:yg,nonMaxSuppression:Sg,nonMaxSuppressionAsync:Ag,nonMaxSuppressionWithScore:Dg,nonMaxSuppressionWithScoreAsync:Fg,nonMaxSuppressionPadded:Mg,nonMaxSuppressionPaddedAsync:Lg,threshold:Bg,transform:Ug},py={bandPart:jg,gramSchmidt:Wg,qr:Gg},fy={absoluteDifference:Kg,computeWeightedLoss:qg,cosineDistance:Xg,hingeLoss:Yg,huberLoss:Qg,logLoss:Jg,meanSquaredError:Zg,sigmoidCrossEntropy:ey,softmaxCrossEntropy:ty},my={sparseFillEmptyRows:ny,sparseReshape:ry,sparseSegmentMean:sy,sparseSegmentSum:ay},gy={stringNGrams:iy,stringSplit:oy,stringToHashBucketFast:ly,staticRegexReplace:uy},yy=sh,by="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function vy(){return new Promise((e=>by((()=>e()))))}function xy(e,t){const n=e[0].length;e.forEach(((e,t)=>{Rn(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),Rn(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,s)=>{for(let a=0;a<n;a++)Rn(a===t||e[a]===r[a],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`))}))}function wy(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var ky;function Sy(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function Iy(e){const t={FIRST_DIM_SIZE:ky.FIRST_DIM_SIZE,VALUE_ROWIDS:ky.VALUE_ROWIDS,ROW_LENGTHS:ky.ROW_LENGTHS,ROW_SPLITS:ky.ROW_SPLITS,ROW_LIMITS:ky.ROW_LIMITS,ROW_STARTS:ky.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function Ny(e){return 0===e.length?0:e[0]===ky.FIRST_DIM_SIZE?e.length-1:e.length}function Ty(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const n=e[s],r=t[s+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${n} but ragged tensor input.flatValues.shape[${s-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(ky||(ky={}));const Cy=30;function Ey(e){return e<=Cy?e:ir(e,Math.floor(Math.sqrt(e)))}function $y(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function _y(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function Oy(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function Ry(e,t,n,r=!0){const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?s.push(t[n-1]*e[n]):s.push(e[n]/t[n-1]):s.push(e[n]);return s}function Ay(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Dy(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}const Fy=1.7580993408473768,My=1.0507009873554805,Ly=.3275911,zy=.254829592,Py=-.284496736,By=1.421413741,Uy=-1.453152027,jy=1.061405429;function Wy(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Vy(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Gy(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function Hy(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function qy(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Ky(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function Xy(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function Yy(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const Qy="->",Jy=/->/g,Zy=",",eb="...";function tb(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(Jy,"").length)/Qy.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Qy}").`);const[r,s]=e.split(Qy);Rn(-1===r.indexOf(eb),(()=>`The ellipsis notation ("${eb}") is not supported yet.`));const a=r.split(Zy),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let e=0;e<s.length;++e){const t=s[e];if(!a.some((e=>-1!==e.indexOf(t))))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===o.indexOf(t)&&o.push(t)}for(let e=0;e<r.length;++e){const t=r[e];-1===o.indexOf(t)&&t!==Zy&&o.push(t)}const l=new Array(a.length);for(let e=0;e<i;++e){if(new Set(a[e].split("")).size!==a[e].length)throw new Error(`Found duplicate axes in input component ${a[e]}. Support for duplicate axes in input is not implemented yet.`);l[e]=[];for(let t=0;t<a[e].length;++t)l[e].push(o.indexOf(a[e][t]))}const u=o.length,c=[];for(let e=s.length;e<u;++e)c.push(e);return{allDims:o,summedDims:c,idDims:l}}function nb(e,t){let n=new Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;const r=[];for(let t=0;t<e;++t)-1===n[t]&&r.push(t);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function rb(e,t,n){const r=new Array(e);for(let e=0;e<n.length;++e){const s=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===r[t[e][n]]?r[t[e][n]]=s[n]:Rn(r[t[e][n]]===s[n],(()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(s)}, but got dimension ${s[n]}`))}}function sb(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let e=0;e<s;++e)r.push([]);const a=[];for(let e=0;e<n.length;++e){const s=ib(t,n[e]);for(const t of s)-1===a.indexOf(t)&&(r[e].push(t),a.push(t))}return{path:n,steps:r}}function ab(e){return e.every(((e,t)=>e===t))}function ib(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function ob(e,t,n=0){let r=[];if("number"==typeof t)Rn(e.shape[n]%t==0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Rn(s<=1,(()=>"There should be only one negative value in split array."));const a=t.indexOf(-1);if(-1!==a){const r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}Rn(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function lb(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function ub(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function cb(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function db(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function hb(e,t){return`size ${e} must be non-negative, not ${t}`}function pb(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function fb(e,t){return`Input to reshape is a SparseTensor with ${Fn(e)}\n  dense values, but the requested shape requires a multiple of ${Fn(t)}. inputShape=${e} outputShape= ${t}`}function mb(e,t){return`Input to reshape is a tensor with ${Fn(e)} dense values, but the requested shape has ${Fn(t)}. inputShape=${e} outputShape=${t}`}function gb(){return"segment ids must be >= 0"}function yb(){return"segment ids are not increasing"}function bb(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function vb(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function xb(e,t){let n,r=!1;for(e<=Cy?(n=e,r=!0):n=ir(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=ir(e,n+1);return n}function wb(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function kb(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let t=0;t<r;++t)o.push(e.shape[t]),l*=e.shape[t];for(let t=r;t<n;t++)o.push(e.shape[t]),u*=e.shape[t];for(let e=r;e<s;e++)o.push(t.shape[e]);for(let t=n+1;t<a;t++)o.push(e.shape[t]),c*=e.shape[t];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function Sb(e){try{return e.map((e=>Io(e)))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Ib(e){return e.map((e=>So(e)))}!function(){for(const e of Mc)bc(e)}();const Nb={kernelName:Tr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nc(e,_m(Yu(n,"float32"),-1))}}},Tb={kernelName:Cr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=sc(Yu(n,"float32")),r=rc(Nc(pc(1),t));return id(tc(e,r))}}}},Cb={kernelName:Er,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=rc(Nc(sc(Yu(n,"float32")),1));return tc(e,t)}}}},Eb={kernelName:$r,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=_c(n.shape,r.shape);return{a:()=>{let t=e;const r=$c(n.shape,s);return r.length>0&&(t=Fp(t,r)),Rh(t,n.shape)},b:()=>{let t=e;const n=$c(r.shape,s);return n.length>0&&(t=Fp(t,n)),Rh(t,r.shape)}}}},$b={kernelName:_r,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},_b={kernelName:Ar,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(n)}}},Ob={kernelName:Dr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ac(n)}}},Rb={kernelName:Fr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tc(e,rc(Nc(pc(1),sc(Yu(n,"float32")))))}}},Ab={kernelName:Mr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=rc(Zu(pc(1),sc(Yu(n,"float32"))));return tc(e,t)}}}},Db={kernelName:Pr,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=_c(n.shape,r.shape);return{a:()=>{const t=Zu(sc(n),sc(r));let a=nc(e,tc(r,t));const i=$c(n.shape,s);return i.length>0&&(a=Fp(a,i)),Rh(a,n.shape)},b:()=>{const t=Zu(sc(n),sc(r));let a=id(nc(e,tc(n,t)));const i=$c(r.shape,s);return i.length>0&&(a=Fp(a,i)),Rh(a,r.shape)}}}},Fb={kernelName:Lr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tc(e,Zu(sc(Yu(n,"float32")),1))}}},Mb={kernelName:zr,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tc(e,Nc(pc(1),sc(Yu(n,"float32"))))}}};const Lb=xl({avgPool3dGrad_:function(e,t,n,r,s,a){const i=yl(e,"dy","avgPool3dGrad"),o=yl(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;4===o.rank&&(c=!0,l=Rh(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=Rh(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Rn(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),Rn(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),Oh("avgPool3dGrad",s,a);const d={dy:l,input:u},h={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=ol.runKernel(Wr,d,h);return c?Rh(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),zb={kernelName:jr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>Lb(e,r,s,a,i,o)}}};const Pb=xl({avgPoolGrad_:function(e,t,n,r,s){const a=yl(e,"dy","avgPoolGrad"),i=yl(t,"input","avgPoolGrad");Rn(i.rank===a.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`));let o=i,l=a,u=!1;3===i.rank&&(u=!0,o=Rh(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=Rh(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Rn(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),Rn(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:l,input:o},d={filterSize:n,strides:r,pad:s},h=ol.runKernel(Ur,c,d);return u?Rh(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Bb={kernelName:Br,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>Pb(e,r,s,a,i)}}},Ub={kernelName:Vr,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>rd(e,s,!1,!1),b:()=>rd(e,r,!0,!1)}:a&&!i?{a:()=>rd(s,e,!1,!0),b:()=>rd(r,e,!1,!1)}:{a:()=>rd(s,e,!0,!0),b:()=>rd(e,r,!0,!0)}:{a:()=>rd(e,s,!1,!0),b:()=>rd(r,e,!0,!1)}}},jb={kernelName:Gr,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>Lf(e,r,s)}}},Wb={kernelName:Kr,gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let e=s.length-1;e>=0;e--)if(s[e]===a[e])i[e]=1;else if(1!==s[e])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let e=0;e<i.length;e++)i[e]>1&&o.push(e);return{x:()=>Fp(e,o,!0)}}},Vb={kernelName:Yr,gradFunc:e=>({x:()=>e.clone()})},Gb={kernelName:Qr,gradFunc:e=>({x:()=>ac(e)})},Hb={kernelName:Jr,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>bp(uf(qp(r,s),Zp(r,a)),e,ac(e))}}},qb={kernelName:es,inputsToSave:["x"],gradFunc:Nb.gradFunc},Kb={kernelName:ts,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:s}=n,a=Hn(s,t[0].shape)[0],i=r.map((e=>e[a]));return Nm(e,i,a).map((e=>()=>e))}},Xb={kernelName:ns,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return Rn(Ch(a),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`)),{x:()=>rp(r.shape,e,s,i,o,l),filter:()=>rg(r,e,s.shape,i,o,l)}}},Yb={kernelName:ss,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>tp(e,s,a,i,o,1,l),filter:()=>rg(e,r,s.shape,a,i,o,l)}}};const Qb=xl({conv3DBackpropFilter_:function(e,t,n,r,s){let a=e;4===e.rank&&(a=Rh(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=Rh(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Rn(5===a.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`)),Rn(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),Rn(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),Rn(a.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`)),Rn(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return ol.runKernel(is,o,l)}}),Jb={kernelName:as,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;Rn(Ch(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,o]=t;return{x:()=>ip(i.shape,e,o,s,a),filter:()=>Qb(i,e,o.shape,s,a)}}},Zb={kernelName:ls,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nc(id(mm(Yu(n,"float32"))),e)}}},ev={kernelName:us,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nc(gm(Yu(n,"float32")),e)}}},tv={kernelName:ds,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const t=_p([s],r.rank);let n=dp(e,s,a,!i);return null!=t&&(n=ld(n,t)),n}}}},nv={kernelName:ms,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=null==r?[1,1]:r;Rn(Ch(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,u]=t;return Rn(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),Rn(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),Rn(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),Rn(Eh(s,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`)),Oh("depthwiseConv2d",a,i),{x:()=>cg(l.shape,e,u,s,a,o,i),filter:()=>ug(l,e,u.shape,s,a,o,i)}}},rv={kernelName:vs,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>ol.runKernel(xs,a,n),filter:()=>ol.runKernel(ws,i,n)}}},sv={kernelName:Ns,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>ol.runKernel(Ts,r)}}},av={kernelName:Cs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=nc(Pp(id(sc(n))),2/Math.sqrt(Math.PI));return{x:()=>nc(e,r)}}},iv={kernelName:$s,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nc(e,n)}}},ov={kernelName:_s,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Rh(e,n.shape)}}},lv={kernelName:Os,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nc(e,Pp(n))}}},uv={kernelName:Fs,gradFunc:e=>({x:()=>ac(e)})},cv={kernelName:Ms,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=_c(n.shape,r.shape);return{a:()=>{const t=tc(e,Yu(r,"float32")),a=$c(n.shape,s);return a.length>0?Rh(Fp(t,a),n.shape):t},b:()=>{let t=nc(e,Yu(n,"float32"));const a=$c(r.shape,s);a.length>0&&(t=Rh(Fp(t,a),r.shape));const i=sc(r);return id(tc(t,Yu(i,"float32")))}}}},dv={kernelName:Ls,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,l=null==o?pc(1):o,u=$c(a.shape,s.shape),c=[];if(1===a.rank){for(let e=0;e<s.shape.length-1;++e)c.push(s.shape[e]);c.push(1)}const d=Nc(s,a),h=nc(e,l),p=cm(Zu(i,pc(r))),f=nc(nc(nc(p,p),p),pc(-.5));return{x:()=>1===a.rank?Rh(nc(nc(e,jp(Rh(p,[1,1,1,a.shape[0]]),c)),l),s.shape):Rh(nc(nc(e,p),l),s.shape),mean:()=>{let e=nc(nc(p,pc(-1)),h);return 1===a.rank&&(e=Fp(e,u)),Rh(e,a.shape)},variance:()=>{let e=nc(nc(f,d),h);return 1===a.rank&&(e=Fp(e,u)),Rh(e,a.shape)},scale:()=>{const t=nc(d,p);let n=nc(e,t);return 1===a.rank&&(n=Fp(n,u)),Rh(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=Fp(t,u)),Rh(t,a.shape)}}}},hv={kernelName:zs,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a,batchDims:i}=n,o=Hn(a,r.shape)[0],l=(e,t,n)=>()=>{const r=e.shape,s=t.size,i=r.slice(0,o),l=i.length,u=r.slice(a,r.length).slice(1),c=u.length,d=pv(0,l),h=pv(l+1,l+1+c),p=fv([i,[s],u]),f=Rh(n,p),m=Rh(t,[s]),g=fv([[l],d,h]),y=ld(f,g);let b=jm(y,m,e.shape[o]);const v=Op(g);return b=ld(b,v),b};if(1===i){const t=r.shape[0],n=r.split(t,0);return{x:()=>{const t=$m(n.map(((t,n)=>l(t,s.slice(n,1),e.slice(n,1))())));return t.reshape(r.shape)},indices:()=>s}}return{x:l(r,s,e),indices:()=>s}}};function pv(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function fv(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const mv={kernelName:Us,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>ac(n),b:()=>ac(r)}}},gv={kernelName:js,gradFunc:e=>({x:()=>Yu(e,"float32")})},yv={kernelName:Gs,gradFunc:e=>({x:()=>ac(e)})},bv={kernelName:Hs,gradFunc:e=>({x:()=>ac(e)})},vv={kernelName:qs,gradFunc:e=>({x:()=>ac(e)})},xv={kernelName:Ks,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=Hp(r,0);return{x:()=>bp(a,e,nc(e,s))}}},wv={kernelName:Zs,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tc(e,Zu(n,1))}}},kv={kernelName:Js,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tc(e,Yu(n,"float32"))}}},Sv={kernelName:sa,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const t=Pp(r);return Nc(e,nc(Fp(e,s,!0),t))}}}};const Iv=xl({localResponseNormalizationBackprop_:function(e,t,n,r=5,s=1,a=1,i=.5){const o={x:e,y:t,dy:n},l={depthRadius:r,bias:s,alpha:a,beta:i};return ol.runKernel(oa,o,l)}}),Nv={kernelName:ia,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>Iv(r,s,e,a,i,o,l)}}};function Tv(e,t,n,r){return t.rank<n.rank&&(t=Rh(t,Ep(t.shape,r))),e.rank<n.rank&&(e=Rh(e,Ep(e.shape,r))),{x:()=>nc(e,Yu(yp(n,t),e.dtype))}}const Cv={kernelName:ua,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=Tv(e,t[1],a,Hn(s,a.shape));return{x:()=>i.x()}}},Ev={kernelName:ca,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>nc(e,Yu(qp(n,r),"float32")),b:()=>nc(e,Yu(Jp(n,r),"float32"))}}};const $v=xl({maxPool3dGrad_:function(e,t,n,r,s,a,i){const o=yl(e,"dy","maxPool3dGrad"),l=yl(t,"input","maxPool3dGrad"),u=yl(n,"output","maxPool3dGrad");let c=o,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=Rh(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=Rh(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=Rh(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Rn(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),Rn(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),Rn(5===h.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`)),Oh("maxPool3dGrad",a,i);const f={dy:c,input:d,output:h},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=ol.runKernel(fa,f,m);return p?Rh(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),_v={kernelName:pa,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>$v(e,r,s,a,i,o,l)}}};const Ov=xl({maxPoolGrad_:function(e,t,n,r,s,a,i){const o=yl(e,"dy","maxPoolGrad"),l=yl(t,"input","maxPoolGrad"),u=yl(n,"output","maxPoolGrad");Rn(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),Rn(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),Rn(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),Oh("maxPoolGrad",a,i);const c={dy:o,input:l,output:u},d={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return ol.runKernel(ha,c,d)}}),Rv={kernelName:da,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>Ov(e,r,s,a,i,o)}}},Av={kernelName:va,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>Lh(e,a,r.shape)}}},Dv={kernelName:xa,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=_c(n.shape,r.shape);return{a:()=>{const t=$c(n.shape,s);return t.length>0?Rh(Fp(e,t),n.shape):e},b:()=>{const t=nc(e,id(Vp(tc(n,r)))),a=$c(r.shape,s);return a.length>0?Rh(Fp(t,a),r.shape):t}}}},Fv={kernelName:ka,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=_c(n.shape,r.shape);return{a:()=>{const t=nc(e,Yu(r,"float32")),a=$c(n.shape,s);return a.length>0?Rh(Fp(t,a),n.shape):t},b:()=>{const t=nc(e,Yu(n,"float32")),a=$c(r.shape,s);return a.length>0?Rh(Fp(t,a),r.shape):t}}}},Mv={kernelName:Oa,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>Lh(e,a,r.shape)}}},Lv={kernelName:Aa,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=_c(a.shape,i.shape);return{a:()=>{const t=Yu(i,"float32");let n=nc(e,nc(t,Ic(a,Nc(t,pc(1)))));const r=$c(a.shape,o);return r.length>0&&(n=Fp(n,r)),Rh(n,a.shape)},b:()=>{const t=Hp(a,0),n=bp(t,nf(a),ac(a));let r=nc(e,nc(s,n));const l=$c(i.shape,o);return l.length>0&&(r=Fp(r,l)),Rh(r,i.shape)}}}},zv={kernelName:Da,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=Hp(n,0);return{x:()=>bp(s,e,nc(e,r)),alpha:()=>{let t=bp(s,ac(e),nc(e,n));const a=$c(r.shape,e.shape);return a.length>0&&(t=Fp(t,a)),Rh(t,r.shape)}}}};function Pv(e,t,n){const r=e.shape.length,s=r-n.length,a=_p(n,r);let i=e;null!=a&&(i=ld(e,a));const o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){const r=e.shape.slice();r[n]=1;const s=Rh(t,r),a=cp(e,n,!0,!1),i=cp(e,n,!0,!0),o=nc(a,i);return nc(s,o)}(i.reshape(o),t,s);if(u=u.reshape(i.shape),null!=a){const e=Op(a);u=ld(u,e)}return u}const Bv={kernelName:Ss,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=_c(n.shape,r.shape);return{a:()=>{const t=tc(e,Yu(r,"float32")),a=$c(n.shape,s);return a.length>0?Rh(Fp(t,a),n.shape):t},b:()=>{let t=nc(e,Yu(n,"float32"));const a=$c(r.shape,s);a.length>0&&(t=Rh(Fp(t,a),r.shape));const i=sc(r);return id(tc(t,Yu(i,"float32")))}}}},Uv={kernelName:ni,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Hp(n,pc(0)),r=pc(Fy),s=pc(My),a=nc(e,s),i=nc(nc(e,r),Pp(Yu(n,"float32")));return bp(t,a,i)}}}},jv={kernelName:di,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>Bh(e,r,s)}}},Wv={kernelName:hi,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>Fh(e,r)}}},Vv={kernelName:Ti,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=_c(n.shape,r.shape);return{a:()=>{let t=e;const r=$c(n.shape,s);return r.length>0&&(t=Fp(t,r)),Rh(t,n.shape)},b:()=>{let t=e;const n=$c(r.shape,s);return n.length>0&&(t=Fp(t,n)),Rh(id(t),r.shape)}}}};const Gv=[Nb,Tb,Cb,Eb,$b,_b,Ob,Rb,Ab,Db,Fb,Mb,zb,Bb,Ub,jb,Wb,Vb,Gb,Hb,qb,Kb,Yb,Xb,Jb,Zb,ev,tv,nv,rv,Bv,sv,av,iv,ov,lv,cv,uv,dv,hv,mv,gv,yv,bv,vv,xv,wv,kv,Sv,Nv,Cv,Cv,Ev,_v,Rv,{kernelName:ga,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=Hn(s,r.shape),i=Fn(Cp(r.shape,a)[1]);return{x:()=>{const t=r.shape.slice();a.forEach((e=>{t[e]=1}));const n=Rh(e,t);return tc(nc(n,wf(r.shape,"float32")),i)}}}},{kernelName:ya,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=Tv(e,i,a,Hn(s,a.shape));return{x:()=>o.x()}}},{kernelName:ba,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>nc(e,Yu(Zp(n,r),"float32")),b:()=>nc(e,Yu(Hp(n,r),"float32"))}}},Av,Dv,Fv,{kernelName:Sa,gradFunc:e=>({x:()=>id(e)})},{kernelName:$a,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>xf(n.shape,"float32")}}},{kernelName:Ea,gradFunc:e=>({x:()=>ac(e)})},{kernelName:_a,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return Wm(e,r).map((e=>()=>e))}},Mv,Mv,Lv,zv,{kernelName:Fa,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return a=null==s?r.shape.map(((e,t)=>t)):"number"==typeof s?[s]:s,{x:()=>Pv(r,e,a)}}},{kernelName:Ua,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tc(e,id(sc(n)))}}},{kernelName:Ka,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=nc(Zp(n,6),_m(n));return{x:()=>nc(e,Yu(r,"float32"))}}},{kernelName:ja,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nc(e,Yu(_m(n),"float32"))}}},{kernelName:Wa,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Rh(e,n.shape)}}},{kernelName:Ha,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>ol.runKernel(qa,s,n)}}},{kernelName:Va,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>ol.runKernel(Ga,s,n)}}},{kernelName:Xa,gradFunc:(e,t,n)=>{const{dims:r}=n,s=Hn(r,e.shape);return{x:()=>sm(e,s)}}},{kernelName:Ya,gradFunc:e=>({x:()=>ac(e)})},{kernelName:Qa,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>id(tc(e,nc(Ic(n,1.5),2)))}}},{kernelName:ti,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Yu(ac(n),"float32"),t:()=>nc(e,Yu(n,e.dtype)),e:()=>nc(e,Yu(cf(n),e.dtype))}}},Uv,{kernelName:oi,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nc(e,nc(n,Nc(pc(1),n)))}}},{kernelName:ii,gradFunc:e=>({x:()=>ac(e)})},{kernelName:si,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nc(lp(Yu(n,"float32")),e)}}},{kernelName:ai,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nc(up(Yu(n,"float32")),e)}}},{kernelName:ri,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=Bd(r,s,a),u=[];for(let t=0;t<e.rank;t++)u.push([o[t],i[t]-o[t]-l[t]]);return{x:()=>Rf(e,u)}}},{kernelName:pi,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=nc(e,r);return{logits:()=>Nc(a,nc(Fp(a,[s],true),r))}}},{kernelName:li,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nc(e,Mh(n))}}},jv,jv,Wv,Wv,{kernelName:ui,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tc(e,nc(rc(Yu(n,"float32")),2))}}},{kernelName:vi,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=pc(2);return{a:()=>nc(e,nc(s,Nc(n,r))),b:()=>nc(e,nc(s,Nc(r,n)))}}},{kernelName:xi,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nc(e,nc(Yu(n,"float32"),2))}}},{kernelName:zi,gradFunc:e=>({x:()=>ac(e)})},Vv,{kernelName:ci,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;Hn(a,r.shape).forEach((e=>{s[e]=1}));const i=Rh(e,s),o=nc(i,wf(r.shape,"float32"));return{x:()=>o}}},{kernelName:Ci,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>tc(e,sc(lp(n)))}}},{kernelName:Ei,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nc(Nc(pc(1),sc(n)),e)}}},{kernelName:$i,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let t=ac(r);if(1===r.rank)for(let n=0;n<s[0];++n)t=Zu(t,Lh(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)t=Zu(t,Lh(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)t=Zu(t,Lh(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)for(let o=0;o<s[3];++o)t=Zu(t,Lh(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},{kernelName:Ri,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=Op(s);return{x:()=>ld(e,a)}}},{kernelName:Di,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>$m(e,s)}}},{kernelName:Fi,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Oc(t,ac(t)),r=Gp(e,n);let s=qp(t,pc(0,"int32"));const a=r.rank-s.rank;for(let e=0;e<a;++e)s=Bp(s,e+1);s=uf(s,wf(r.shape,"bool"));const i=ac(r);return bp(s,r,i)}(e,n)}}},{kernelName:Li,gradFunc:e=>({x:()=>ac(e)})}];for(const e of Gv)Ji(e);Bo().prototype.abs=function(){return this.throwIfDisposed(),Cc(this)},Bo().prototype.acos=function(){return this.throwIfDisposed(),ah(this)},Bo().prototype.acosh=function(){return this.throwIfDisposed(),ih(this)},Bo().prototype.add=function(e){return this.throwIfDisposed(),Zu(this,e)},Bo().prototype.all=function(e,t){return this.throwIfDisposed(),lh(this,e,t)},Bo().prototype.any=function(e,t){return this.throwIfDisposed(),uh(this,e,t)},Bo().prototype.argMax=function(e){return this.throwIfDisposed(),ch(this,e)},Bo().prototype.argMin=function(e){return this.throwIfDisposed(),dh(this,e)},Bo().prototype.asScalar=function(){return this.throwIfDisposed(),Rn(1===this.size,(()=>"The array must have only 1 element.")),Rh(this,[])},Bo().prototype.asType=function(e){return this.throwIfDisposed(),Yu(this,e)},Bo().prototype.as1D=function(){return this.throwIfDisposed(),Rh(this,[this.size])},Bo().prototype.as2D=function(e,t){return this.throwIfDisposed(),Rh(this,[e,t])},Bo().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Rh(this,[e,t,n])},Bo().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Rh(this,[e,t,n,r])},Bo().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),Rh(this,[e,t,n,r,s])},Bo().prototype.asin=function(){return this.throwIfDisposed(),hh(this)},Bo().prototype.asinh=function(){return this.throwIfDisposed(),ph(this)},Bo().prototype.atan=function(){return this.throwIfDisposed(),fh(this)},Bo().prototype.atan2=function(e){return this.throwIfDisposed(),mh(this,e)},Bo().prototype.atanh=function(){return this.throwIfDisposed(),gh(this)},Bo().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Ah(this,e,t,n,r)},Bo().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Bh(this,e,t)},Bo().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),Uh(this,e,t,n,r,s)},Bo().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Kh(this,e)},Bo().prototype.cast=function(e){return this.throwIfDisposed(),Yu(this,e)},Bo().prototype.ceil=function(){return this.throwIfDisposed(),Xh(this)},Bo().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Yh(this,e,t)},Bo().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Po&&(e=[e]),Fh([this,...e],t)},Bo().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),np(this,e,t,n,r,s,a)},Bo().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),sp(this,e,t,n,r,s)},Bo().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),tp(this,e,t,n,r,s,a)},Bo().prototype.cos=function(){return this.throwIfDisposed(),lp(this)},Bo().prototype.cosh=function(){return this.throwIfDisposed(),up(this)},Bo().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),cp(this,e,t,n)},Bo().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),dp(this,e,t,n)},Bo().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),pp(this,e,t)},Bo().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),fp(this,e,t,n,r,s,a)},Bo().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),gp(this,e,t,n,r,s)},Bo().prototype.divNoNan=function(e){return this.throwIfDisposed(),vp(this,e)},Bo().prototype.div=function(e){return this.throwIfDisposed(),tc(this,e)},Bo().prototype.dot=function(e){return this.throwIfDisposed(),xp(this,e)},Bo().prototype.elu=function(){return this.throwIfDisposed(),kp(this)},Bo().prototype.equal=function(e){return this.throwIfDisposed(),yp(this,e)},Bo().prototype.erf=function(){return this.throwIfDisposed(),Ip(this)},Bo().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),zp(this,e,t)},Bo().prototype.exp=function(){return this.throwIfDisposed(),Pp(this)},Bo().prototype.expandDims=function(e){return this.throwIfDisposed(),Bp(this,e)},Bo().prototype.expm1=function(){return this.throwIfDisposed(),Up(this)},Bo().prototype.fft=function(){return this.throwIfDisposed(),km(this)},Bo().prototype.flatten=function(){return this.throwIfDisposed(),Rh(this,[this.size])},Bo().prototype.floor=function(){return this.throwIfDisposed(),Vp(this)},Bo().prototype.floorDiv=function(e){return this.throwIfDisposed(),ec(this,e)},Bo().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Gp(this,e,t,n)},Bo().prototype.greaterEqual=function(e){return this.throwIfDisposed(),qp(this,e)},Bo().prototype.greater=function(e){return this.throwIfDisposed(),Hp(this,e)},Bo().prototype.ifft=function(){return this.throwIfDisposed(),Sm(this)},Bo().prototype.irfft=function(){return this.throwIfDisposed(),Im(this)},Bo().prototype.isFinite=function(){return this.throwIfDisposed(),Kp(this)},Bo().prototype.isInf=function(){return this.throwIfDisposed(),Xp(this)},Bo().prototype.isNaN=function(){return this.throwIfDisposed(),Yp(this)},Bo().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Qp(this,e)},Bo().prototype.lessEqual=function(e){return this.throwIfDisposed(),Zp(this,e)},Bo().prototype.less=function(e){return this.throwIfDisposed(),Jp(this,e)},Bo().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),tf(this,e,t,n,r)},Bo().prototype.logSigmoid=function(){return this.throwIfDisposed(),af(this)},Bo().prototype.logSoftmax=function(e){return this.throwIfDisposed(),of(this,e)},Bo().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),lf(this,e,t)},Bo().prototype.log=function(){return this.throwIfDisposed(),nf(this)},Bo().prototype.log1p=function(){return this.throwIfDisposed(),rf(this)},Bo().prototype.logicalAnd=function(e){return this.throwIfDisposed(),uf(this,e)},Bo().prototype.logicalNot=function(){return this.throwIfDisposed(),cf(this)},Bo().prototype.logicalOr=function(e){return this.throwIfDisposed(),df(this,e)},Bo().prototype.logicalXor=function(e){return this.throwIfDisposed(),hf(this,e)},Bo().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),rd(this,e,t,n)},Bo().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),gf(this,e,t,n,r)},Bo().prototype.max=function(e,t){return this.throwIfDisposed(),Ap(this,e,t)},Bo().prototype.maximum=function(e){return this.throwIfDisposed(),Oc(this,e)},Bo().prototype.mean=function(e,t){return this.throwIfDisposed(),vf(this,e,t)},Bo().prototype.min=function(e,t){return this.throwIfDisposed(),Dp(this,e,t)},Bo().prototype.minimum=function(e){return this.throwIfDisposed(),Sf(this,e)},Bo().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),If(this,e,t)},Bo().prototype.mod=function(e){return this.throwIfDisposed(),Nf(this,e)},Bo().prototype.mul=function(e){return this.throwIfDisposed(),nc(this,e)},Bo().prototype.neg=function(){return this.throwIfDisposed(),id(this)},Bo().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Lp(this,e,t,n)},Bo().prototype.notEqual=function(e){return this.throwIfDisposed(),$f(this,e)},Bo().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),sd(this,e,t,n)},Bo().prototype.onesLike=function(){return this.throwIfDisposed(),_f(this)},Bo().prototype.pad=function(e,t){return this.throwIfDisposed(),Rf(this,e,t)},Bo().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),zf(this,e,t,n,r,s,a)},Bo().prototype.pow=function(e){return this.throwIfDisposed(),Ic(this,e)},Bo().prototype.prelu=function(e){return this.throwIfDisposed(),Pf(this,e)},Bo().prototype.prod=function(e,t){return this.throwIfDisposed(),Bf(this,e,t)},Bo().prototype.reciprocal=function(){return this.throwIfDisposed(),tm(this)},Bo().prototype.relu=function(){return this.throwIfDisposed(),nm(this)},Bo().prototype.relu6=function(){return this.throwIfDisposed(),rm(this)},Bo().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Rh(this,e.shape)},Bo().prototype.reshape=function(e){return this.throwIfDisposed(),Rh(this,e)},Bo().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),zg(this,e,t,n)},Bo().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Pg(this,e,t,n)},Bo().prototype.reverse=function(e){return this.throwIfDisposed(),sm(this,e)},Bo().prototype.rfft=function(){return this.throwIfDisposed(),Tm(this)},Bo().prototype.round=function(){return this.throwIfDisposed(),um(this)},Bo().prototype.rsqrt=function(){return this.throwIfDisposed(),cm(this)},Bo().prototype.selu=function(){return this.throwIfDisposed(),dm(this)},Bo().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),hm(this,e,t,n,r,s,a)},Bo().prototype.sigmoid=function(){return this.throwIfDisposed(),Mh(this)},Bo().prototype.sign=function(){return this.throwIfDisposed(),fm(this)},Bo().prototype.sin=function(){return this.throwIfDisposed(),mm(this)},Bo().prototype.sinh=function(){return this.throwIfDisposed(),gm(this)},Bo().prototype.slice=function(e,t){return this.throwIfDisposed(),Lh(this,e,t)},Bo().prototype.softmax=function(e){return this.throwIfDisposed(),wm(this,e)},Bo().prototype.softplus=function(){return this.throwIfDisposed(),sf(this)},Bo().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Lf(this,e,t)},Bo().prototype.split=function(e,t){return this.throwIfDisposed(),Nm(this,e,t)},Bo().prototype.sqrt=function(){return this.throwIfDisposed(),rc(this)},Bo().prototype.square=function(){return this.throwIfDisposed(),sc(this)},Bo().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Cm(this,e)},Bo().prototype.squeeze=function(e){return this.throwIfDisposed(),Em(this,e)},Bo().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Po?[this,e]:[this,...e];return $m(n,t)},Bo().prototype.step=function(e){return this.throwIfDisposed(),_m(this,e)},Bo().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),Om(this,e,t,n,r,s,a,i,o)},Bo().prototype.sub=function(e){return this.throwIfDisposed(),Nc(this,e)},Bo().prototype.sum=function(e,t){return this.throwIfDisposed(),Fp(this,e,t)},Bo().prototype.tan=function(){return this.throwIfDisposed(),Rm(this)},Bo().prototype.tanh=function(){return this.throwIfDisposed(),zh(this)},Bo().prototype.tile=function(e){return this.throwIfDisposed(),jp(this,e)},Bo().prototype.toBool=function(){return this.throwIfDisposed(),Yu(this,"bool")},Bo().prototype.toFloat=function(){return this.throwIfDisposed(),Yu(this,"float32")},Bo().prototype.toInt=function(){return this.throwIfDisposed(),Yu(this,"int32")},Bo().prototype.topk=function(e,t){return this.throwIfDisposed(),Pm(this,e,t)},Bo().prototype.transpose=function(e){return this.throwIfDisposed(),ld(this,e)},Bo().prototype.unique=function(e){return this.throwIfDisposed(),Um(this,e)},Bo().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),jm(this,e,t)},Bo().prototype.unstack=function(e){return this.throwIfDisposed(),Wm(this,e)},Bo().prototype.where=function(e,t){return this.throwIfDisposed(),bp(e,this,t)},Bo().prototype.zerosLike=function(){return this.throwIfDisposed(),ac(this)};class Hv extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Hv.prototype)}}class qv extends Error{constructor(e){super(e),Object.setPrototypeOf(this,qv.prototype)}}class Kv extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Kv.prototype)}}class Xv extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Xv.prototype)}}class Yv extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Yv.prototype)}}Error;class Qv{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function Jv(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function Zv(e,t){if(!e)throw new Yv(t)}function ex(e,t){let n=0;for(const r of e)r===t&&n++;return n}function tx(e){return 1===e.length?e[0]:e}function nx(e){return Array.isArray(e)?e:[e]}function rx(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function sx(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let ax={};function ix(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function ox(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>ox(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?ox(t):e[n]=t.value)}}}function lx(e,t={},n={},r="object",s=!1){if("string"==typeof e){const s=e;let a;if(s in n)a=n[s];else if(s in ax)a=ax[s];else if(a=t[s],null==a)throw new Kv(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a.className||null==a.config)throw new Kv(`${r}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a.className;let o,l;if(i in n?[o,l]=n[i]:i in ax?[o,l]=ax.className:i in t&&([o,l]=t[i]),null==o)throw new Kv(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const t of Object.keys(ax))e[t]=ax[t];for(const t of Object.keys(n))e[t]=n[t];a.config.customObjects=e;const t=Object.assign({},ax);for(const e of Object.keys(n))ax[e]=n[e];ox(a.config);const r=l(o,a.config,n,s);return ax=Object.assign({},t),r}{const e=Object.assign({},ax);for(const e of Object.keys(n))ax[e]=n[e];const t=new o(a.config);return ax=Object.assign({},e),t}}}function ux(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function cx(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function dx(e){if(null==e)throw new Kv(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function hx(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new Kv(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function px(e,t,n=0,r=1/0){return Zv(n>=0),Zv(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function fx(e,t){Array.isArray(e)?(Rn(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>fx(e,`element ${n+1} of ${t}`)))):Rn(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${mx(e)}.`))}function mx(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>mx(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function gx(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let yx=0;function bx(){return yx++}const vx={};function xx(e=""){return e in vx||(vx[e]=0),vx[e]+=1,e+vx[e].toString()}const wx=["channelsFirst","channelsLast"],kx=["nearest","bilinear"],Sx=["valid","same","causal"],Ix=["max","avg"],Nx=["sum","mul","concat","ave"],Tx=new Map;function Cx(e){hx(wx,"DataFormat",e)}function Ex(e){hx(Sx,"PaddingMode",e)}function $x(e){hx(Ix,"PoolMode",e)}const _x=[];function Ox(e,t){_x.push(e);try{const e=t();return _x.pop(),e}catch(e){throw _x.pop(),e}}function Rx(e){if(!Fx(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===_x.length?"":_x.join("/")+"/")+e}function Ax(e){if(!Fx(e))throw new Error("Not a valid tensor name: '"+e+"'");Tx.has(e)||Tx.set(e,0);const t=Tx.get(e);if(Tx.set(e,Tx.get(e)+1),t>0){const n=`${e}_${t}`;return Tx.set(n,1),n}return e}const Dx=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Fx(e){return!!e.match(Dx)}function Mx(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function Lx(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function zx(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function Px(e,t){if(t<e)throw new Kv(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let Bx;function Ux(){return null==Bx&&(Bx=Gl().epsilon()),Bx}function jx(e,t){return Yu(e,t)}function Wx(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Rh(e,n)}function Vx(e,t,n){return Dl((()=>{switch(e.rank){case 1:return ym(e,t,n);case 2:return bm(e,[t,0],[n,e.shape[1]]);case 3:return vm(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return xm(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Lh(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Lh(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new Kv(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Gx(e,t,n){return Dl((()=>{switch(e.rank){case 1:return ym(e,t,n);case 2:return bm(e,[0,t],[e.shape[0],n]);case 3:return vm(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return xm(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new Kv(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Hx(e,t,n,r){return Dl((()=>{switch(e.rank){case 1:return ym(e,t,n);case 2:switch(r){case 1:return Vx(e,t,n);case 2:return Gx(e,t,n);default:throw new Kv(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Vx(e,t,n);case 2:return vm(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Gx(e,t,n);default:throw new Kv(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Vx(e,t,n);case 2:return xm(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return xm(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Gx(e,t,n);default:throw new Kv(`The axis is not within the rank of the tensor ${r}`)}default:throw new Kv(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function qx(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),Fh(e,t)}function Kx(e,t){switch(e.rank){case 1:return Qh([e,t]);case 2:return Jh([e,t],0);case 3:return Zh([e,t],0);case 4:return ep([e,t],0);default:throw new Kv(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Xx(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new Kv(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return jp(e,t)}function Yx(e,t=0,n=1,r,s){return Yf(e,t,n,r,s)}function Qx(e,t,n,r){if(e.rank<2||t.rank<2)throw new Xv(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new Xv(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){return hg({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?ew(e.rank,r,"channelsLast"):null,activation:n})}{const s=e.shape.slice(),a=s.pop();e=Rh(e,[-1,a]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Rh(ld(t,c),[l,-1]);const d=[...s,...u];return Rh(hg({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?ew(e.rank,r,"channelsLast"):null,activation:n}),d)}}function Jx(e,t,n){return Dl((()=>(t=Array.isArray(t)?Am(t,"int32"):Yu(t,"int32"),Gp(e,t,n))))}function Zx(e){return nc(e,e)}function ew(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new Kv(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?Rh(t,[1,r[0],1,1,1]):Rh(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Rh(t,[1,1,1,1,r[0]]):Rh(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?Rh(t,[1,r[0],1,1]):Rh(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Rh(t,[1,1,1,r[0]]):Rh(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?Rh(t,[1,r[0],1]):Rh(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Rh(t,[1,1,r[0]]):Rh(t,[1].concat(r))}else if(e<3)return t;throw new Kv(`Unsupported input rank by biasAdd: ${t.rank}`)}function tw(e,t,n){return Dl((()=>(null==n&&(n="channelsLast"),Cx(n),Zu(e,ew(e.rank,t,n)))))}function nw(e,t,n,r){return Dl((()=>Zm(e,t,n,r)))}function rw(e,t,n=!1){return n?e():t()}const sw=["fanIn","fanOut","fanAvg"],aw=["normal","uniform","truncatedNormal"];class iw extends gc{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class ow extends iw{apply(e,t){return xf(e,t)}}ow.className="Zeros",bc(ow);class lw extends iw{apply(e,t){return wf(e,t)}}lw.className="Ones",bc(lw);class uw extends iw{constructor(e){if(super(),"object"!=typeof e)throw new Kv(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new Kv(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Dl((()=>nc(pc(this.value),wf(e,t))))}getConfig(){return{value:this.value}}}uw.className="Constant",bc(uw);class cw extends iw{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Jf(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}cw.className="RandomUniform",bc(cw);class dw extends iw{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Xv(`randomNormal does not support dType ${t}.`);return Yx(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}dw.className="RandomNormal",bc(dw);class hw extends iw{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Xv(`truncatedNormal does not support dType ${t}.`);return Bm(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}hw.className="TruncatedNormal",bc(hw);class pw extends iw{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Dl((()=>{if(2!==e.length||e[0]!==e[1])throw new Kv("Identity matrix initializer can only be used for 2D square matrices.");return nc(this.gain,Wp(e[0]))}))}getConfig(){return{gain:this.gain}}}pw.className="Identity",bc(pw);class fw extends iw{constructor(e){if(super(),e.scale<0)throw new Kv(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,hx(sw,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){hx(aw,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,r;if(Cx(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=Mx(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){const t=Mx(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{const t=Mx(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],s=n[1];let a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Xv(`${this.getClassName()} does not support dType ${t}.`);return Bm(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return Jf(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}fw.className="VarianceScaling",bc(fw);class mw extends fw{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return fw.className}}mw.className="GlorotUniform",bc(mw);class gw extends fw{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return fw.className}}gw.className="GlorotNormal",bc(gw);class yw extends fw{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return fw.className}}yw.className="HeNormal",bc(yw);class bw extends fw{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return fw.className}}bw.className="HeUniform",bc(bw);class vw extends fw{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return fw.className}}vw.className="LeCunNormal",bc(vw);class xw extends fw{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return fw.className}}xw.className="LeCunUniform",bc(xw);class ww extends iw{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Dl((()=>{if(e.length<2)throw new Xv("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=Fn(e.slice(0,-1)),r=e[e.length-1];this.ELEMENTS_WARN_SLOW;const s=Yx([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),a=py.qr(s,!1);let i=a[0];const o=a[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return i=nc(i,o.sign()),n<r&&(i=i.transpose()),nc(pc(this.gain),i.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}ww.className="Orthogonal",bc(ww);const kw={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Sw(e,t={}){return lx(e,yc.getMap().classNameMap,t,"initializer")}function Iw(e){return ix(e)}function Nw(e){if("string"==typeof e){const t=e in kw?kw[e]:e;if("GlorotNormal"===t)return new gw;if("GlorotUniform"===t)return new mw;if("HeNormal"===t)return new yw;if("HeUniform"===t)return new bw;if("LeCunNormal"===t)return new vw;if("LeCunUniform"===t)return new xw;{const e={};return e.className=t,e.config={},Sw(e)}}return e instanceof iw?e:Sw(e)}function Tw(e){return Array.isArray(e)&&Array.isArray(e[0])}function Cw(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function Ew(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new Kv(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function $w(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new Kv(`Expected exactly 1 Shape; got ${e.length}`)}return e}function _w(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const Ow="Variable";class Rw{constructor(e,t="float32",n=Ow,r=!0,s=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=bx(),n=null==n?Ow:n,this.originalName=Rx(n),this.name=Ax(this.originalName),this.trainable_=r,this.constraint=s,this.val=Gm(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Aw(e){return e.map((e=>e.read()))}function Dw(e){e.forEach((e=>{e[0].write(e[1])}))}class Fw{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Mw{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=bx(),null!=a&&(this.originalName=Rx(a),this.name=Ax(this.originalName)),this.rank=t.length}}let Lw=0;class zw{constructor(e,t){this.callArgs=t,this.id=Lw++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const t of e.inboundLayers)null!=t&&t.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Pw=0;class Bw extends gc{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Pw++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=rx(e)+"_"+xx(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new qv(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Kv(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return tx(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return tx(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Hv(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Hv(`Layer ${this.name} is not connected, no input to return.`);return tx(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Hv(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Hv(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return tx(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=nx(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=nx(this.inputSpec);if(t.length!==n.length)throw new Kv(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let e=0;e<t.length;e++){const r=t[e],s=n[e];if(null==s)continue;const a=r.rank;if(null!=s.ndim&&a!==s.ndim)throw new Kv(`Input ${e} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(null!=s.maxNDim&&a>s.maxNDim)throw new Kv(`Input ${e} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(null!=s.minNDim&&a<s.minNDim)throw new Kv(`Input ${e} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(null!=s.dtype&&r.dtype!==s.dtype)throw new Kv(`Input ${e} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){const t=r.shape;for(const n in s.axes){const r=Number(n),a=s.axes[n],i=r>=0?t[r]:t[t.length+r];if(null!=a&&-1===[a,null].indexOf(i))throw new Kv(`Input ${e} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${a} but got shape ${t}.`)}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const n=s.shape[t],a=r.shape[t];if(null!=n&&null!=a&&n!==a)throw new Kv(`Input ${e} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=nx(e),r=function(e){let t=!0;for(const n of nx(e))if(!(n instanceof Mw)){t=!1;break}return t}(e),s=function(e){let t=!0;for(const n of nx(e))if(n instanceof Mw){t=!1;break}return t}(e);if(r===s)throw new Kv("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ox(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of nx(e))t.push(n.shape);this.build(tx(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const s=nx(r),a=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(r=tx(a),null!=this.activityRegularizer)throw new Xv("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=nx(e);const t=[];for(const n of e)t.push(n.shape);return tx(t)}(e),r=this.computeOutputShape(n);let s;const a="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new Mw(a,n,this,nx(e),t,this.name,r))):new Mw(a,r,this,nx(e),t,this.name),this.addInboundNode(e,s,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new Xv("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)}))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Hv(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Hv(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new qv(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return _w(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Aw(e?this.trainableWeights:this.weights)}setWeights(e){Dl((()=>{const t=this.weights;if(t.length!==e.length)throw new Kv(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=Aw(t);for(let s=0;s<r.length;++s){const a=r[s],i=t[s],o=e[s];if(!zn(a.shape,o.shape))throw new Kv(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}Dw(n)}))}addWeight(e,t,n,r,s,a,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new Kv(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():Nw("zeros"));const l=r.apply(t,n),u=new Rw(l,n,e,a,i);return l.dispose(),null!=s&&this.addLoss((()=>s.apply(u.read()))),null==a&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=nx(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),s=nx(t),a=nx(r);if(s.length!==a.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let e=0;e<s.length;e++)s[e].kerasMask=a[e]}addInboundNode(e,t,n,r,s,a,i=null){const o=nx(e);t=nx(t),n=nx(n),r=nx(r),s=Cw(s),a=Cw(a);const l=[],u=[],c=[];for(const e of o)l.push(e.sourceLayer),u.push(e.nodeIndex),c.push(e.tensorIndex);new zw({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0==--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function Uw(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=Uw(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class jw extends Bw{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:xx("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new Kv("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new Kv("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new Kv("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new Mw(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new zw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Kv(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}jw.className="InputLayer",bc(jw);class Ww{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Ww)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new Kv(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Yu(t,e.dtype)}catch(n){throw new Kv(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Mw){if(null==this.id2Value[e.id])throw new Kv(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new Kv(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Mw){if(null==this.id2Value[e.id])throw new Kv(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new Kv(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&Fl(this.id2Mask)}}const Vw=new Qv,Gw=new Qv;function Hw(e,t,n,r){const s=null!=n&&n.training,a=Array.isArray(e),i=a?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(const e of o)-1!==u.indexOf(e)?l.push(t.getValue(e)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let d,h=Vw.get(c);if(null==h){const e=function(e,t){Rn(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const s=Kw(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:e,recipientMap:i}=Kw(a,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const e in i)null==r[e]&&(r[e]=new Set),i[e].forEach((t=>r[e].add(t)))}}return{sorted:n,recipientCounts:qw(r)}}(i,t);h=e.sorted,d=e.recipientCounts,Vw.put(c,h),Gw.put(c,d)}d={},s||Object.assign(d,Gw.get(c));const p=new Ww(t);for(let e=0;e<h.length;++e){if(null!=r){const e=Rl().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const a=h[e],i=a.sourceLayer;if(i instanceof jw)continue;const u=[],c=[],f=[];let m=!1;for(const e of a.inputs){const n=p.getValue(e),r=p.getMask(e);u.push(n),c.push(r),null!=r&&(m=!0),s||(d[e.name]--,0!==d[e.name]||t.hasKey(e)||-1!==o.indexOf(e.name)||n.isDisposed||!0===e.sourceLayer.stateful||f.push(n))}m&&((n=n||{}).mask=c[0]);const g=nx(i.apply(u,n));let y=null;i.supportsMasking&&(y=i.computeMask(u,c));const b=Xw(a),v=Array.isArray(b)?b:[b];for(let e=0;e<v.length;++e){p.hasKey(v[e])||p.add(v[e],g[e],Array.isArray(y)?y[0]:y);const t=o.indexOf(v[e].name);-1!==t&&(l[t]=g[e])}s||Fl(f)}return p.disposeMasks(),a?l:l[0]}function qw(e){const t={};for(const n in e)t[n]=e[n].size;return t}function Kw(e,t){const n=new Set,r=[],s={};for(const e of t.names())n.add(e);const a=[],i=[];for(a.push(e);a.length>0;){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=i[i.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(a.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:r,recipientMap:s}}function Xw(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function Yw(e,t){return Dl((()=>rc(Fp(nc(e,e),t,!0))))}wr().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=Vw&&Vw.setMaxEntries(e),null!=Gw&&Gw.setMaxEntries(e)}));class Qw extends gc{getConfig(){return{}}}class Jw extends Qw{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Dl((()=>{const t=Yw(e,this.axis),n=Yh(t,0,this.maxValue);return nc(e,tc(n,Zu(Ux(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Jw.className="MaxNorm",bc(Jw);class Zw extends Qw{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Dl((()=>tc(e,Zu(Ux(),Yw(e,this.axis)))))}getConfig(){return{axis:this.axis}}}Zw.className="UnitNorm",bc(Zw);class ek extends Qw{apply(e){return nm(e)}}ek.className="NonNeg",bc(ek);class tk extends Qw{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Dl((()=>{const t=Yw(e,this.axis),n=Zu(nc(this.rate,Yh(t,this.minValue,this.maxValue)),nc(1-this.rate,t));return nc(e,tc(n,Zu(Ux(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}tk.className="MinMaxNorm",bc(tk);const nk={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function rk(e){return ix(e)}function sk(e,t={}){return lx(e,yc.getMap().classNameMap,t,"constraint")}function ak(e){if(null==e)return null;if("string"==typeof e){return sk({className:e in nk?nk[e]:e,config:{}})}return e instanceof Qw?e:sk(e)}async function ik(e){if(null==e)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if("number"!=typeof a){const e=a;t.push(e.data()),n.push(s),r.push(e)}}if(t.length>0){const s=await Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];Fl(r)}}function ok(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}var lk;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(lk||(lk={}));class uk{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class ck{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class dk extends uk{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const e in t){const r=t[e];if("number"==typeof r)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+r*n;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;const s=Dl((()=>Zu(this.totals[e],nc(r,n))));this.totals[e]=s,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?t[e]=this.totals[e]/this.seen:Dl((()=>{const n=nc(tc(1,this.seen),this.totals[e]);t[e]=n,this.totals[e].dispose(),Ml(t[e])})))}}class hk extends uk{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const e in t)null==this.history[e]&&(this.history[e]=[]),this.history[e].push(t[e])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const s=this.history[r];for(let a=0;a<s.length;++a)if("number"!=typeof s[a]){const i=s[a];e.push(i.data()),t.push(r),n.push(a)}}const r=await Promise.all(e);for(let e=0;e<r.length;++e){this.history[t[e]][n[e]].dispose(),this.history[t[e]][n[e]]=r[e][0]}}}class pk extends uk{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||vy,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");rr(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,s=null!=n?n():wo();return(...a)=>{const i=null!=n?n():wo();return i-s<t||(s=i,r=e(...a)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await ik(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await ik(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await ik(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await ik(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await ik(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):rr(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await ik(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await ik(e),await this.trainEnd(e))}}function fk(e,t){if(null==e&&(e={}),e instanceof uk)return[e];if(Array.isArray(e)&&e[0]instanceof uk)return e;return nx(e).map((e=>new pk(e,t)))}class mk{constructor(){}static registerCallbackConstructor(e,t){Rn(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),mk.checkForDuplicate(t),null==mk.constructors[e]&&(mk.constructors[e]=[]),mk.constructors[e].push(t)}static checkForDuplicate(e){for(const t in mk.constructors){mk.constructors[+t].forEach((t=>{if(t===e)throw new Kv("Duplicate callback constructor.")}))}}static clear(){mk.constructors={}}static createCallbacks(e){const t=[];for(const n in mk.constructors){const r=+n;e>=r&&t.push(...mk.constructors[r])}return t.map((e=>new e))}}function gk(e,t,n,r,s,a,i,o,l){const u=new hk,c=[new dk,...mk.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const d=new ck(c);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function yk(e,t={},n=!1){return lx(e,yc.getMap().classNameMap,t,"layer",n)}function bk(e,t){return Dl((()=>{"float32"!==e.dtype&&(e=Yu(e,"float32"));const n=Fp(Zx(e),t,!0),r=kc(n.shape,Ux()),s=rc(Oc(n,r));return tc(e,s)}))}function vk(e,t){return Dl((()=>vf(Zx(Nc(t,e)),-1)))}function xk(e,t){return Dl((()=>vf(Cc(Nc(t,e)),-1)))}function wk(e,t){return Dl((()=>{const n=Nc(e,t),r=Yh(Cc(e),Ux(),Number.MAX_VALUE),s=Cc(tc(n,r));return nc(100,vf(s,-1))}))}function kk(e,t){return Dl((()=>{const n=Yh(t,Ux(),Number.MAX_VALUE),r=nf(Zu(1,n)),s=Yh(e,Ux(),Number.MAX_VALUE),a=nf(Zu(1,s));return vf(Zx(Nc(r,a)),-1)}))}function Sk(e,t,n=!1){return Dl((()=>{if(n)t=wm(t);else{const e=Fp(t,t.shape.length-1,!0);t=tc(t,e)}return t=Yh(t,Ux(),1-Ux()),id(Fp(nc(Yu(e,"float32"),nf(t)),t.shape.length-1))}))}function Ik(e,t,n=!1){return Dl((()=>{const r=Yu(Vp(function(e){const t=[Mx(e.shape)];return Rh(e,t)}(e)),"int32"),s=(t=Yh(t,Ux(),1-Ux())).shape;return Sk(Rh(sd(r,s[s.length-1]),s),t,n)}))}function Nk(e,t){return Dl((()=>{let n;return n=Yh(t,Ux(),1-Ux()),n=nf(tc(n,Nc(1,n))),vf(function(e,t){if(!zn(e.shape,t.shape))throw new Kv(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return Dl((()=>{const n=nm(t),r=id(Cc(t));return Zu(Nc(n,nc(t,e)),rf(Pp(r)))}))}(e,n),-1)}))}function Tk(e,t){return Dl((()=>{const n=Yh(e,Ux(),1),r=Yh(t,Ux(),1);return Fp(nc(e,nf(tc(n,r))),-1)}))}function Ck(e,t){return Dl((()=>{const n=bk(e,-1),r=bk(t,-1),s=nc(n,r);return id(Fp(s,-1))}))}mk.constructors={};const Ek={meanSquaredError:vk,meanAbsoluteError:xk,meanAbsolutePercentageError:wk,meanSquaredLogarithmicError:kk,squaredHinge:function(e,t){return Dl((()=>{const n=Oc(0,Nc(1,nc(e,t)));return vf(Zx(n),-1)}))},hinge:function(e,t){return Dl((()=>{const n=Oc(0,Nc(1,nc(e,t)));return vf(n,-1)}))},categoricalHinge:function(e,t){return Dl((()=>{const n=Fp(nc(e,t),-1),r=Ap(nc(Nc(1,e),t),-1);return Oc(0,Zu(1,Nc(r,n)))}))},logcosh:function(e,t){return Dl((()=>{const n=Math.log(2),r=Nc(t,e),s=Nc(Zu(r,sf(nc(-2,r))),n);return vf(s,-1)}))},categoricalCrossentropy:Sk,sparseCategoricalCrossentropy:Ik,binaryCrossentropy:Nk,kullbackLeiblerDivergence:Tk,poisson:function(e,t){return Dl((()=>{const n=nf(Zu(Ux(),t));return vf(Nc(t,nc(e,n)),-1)}))},cosineProximity:Ck};function $k(e){if("string"==typeof e){if(e in Ek)return Ek[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Kv(t)}return e}function _k(e,t){return Dl((()=>{const n=nc(.5,_f(t)),r=jx(Hp(t,n),e.dtype);return vf(yp(e,r),-1)}))}function Ok(e,t){return Dl((()=>jx(yp(ch(e,-1),ch(t,-1)),"float32")))}function Rk(e,t){return Dl((()=>Yu(Fp(uf(yp(e,1),yp(t,1))),"float32")))}function Ak(e,t){return Nk(e,t)}function Dk(e,t){return e.rank===t.rank&&(e=Em(e,[e.rank-1])),(t=ch(t,-1)).dtype!==e.dtype&&(t=Yu(t,e.dtype)),Yu(yp(e,t),"float32")}const Fk=Sk,Mk=Ik,Lk={binaryAccuracy:_k,categoricalAccuracy:Ok,precision:function(e,t){return Dl((()=>{const n=Rk(e,t),r=function(e,t){return Dl((()=>Yu(Fp(uf(yp(e,0),yp(t,1))),"float32")))}(e,t),s=Zu(n,r);return Yu(bp(Hp(s,0),tc(n,s),0),"float32")}))},categoricalCrossentropy:Fk,sparseCategoricalCrossentropy:Mk,mse:vk,MSE:vk,mae:xk,MAE:xk,mape:wk,MAPE:wk,cosine:Ck};function zk(e){if("string"==typeof e&&e in Lk)return Lk[e];if("string"!=typeof e&&null!=e)return e;throw new Kv(`Unknown metric ${e}`)}function Pk(e){if(Zv(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(Ek))if(Ek[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(Lk))if(Lk[n]===e){t=n;break}return void 0!==t?t:e.name}}function Bk(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!Uk(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){JSON.stringify(e).length}}function Uk(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!Uk(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!Uk(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function jk(e,t,n,r=console.log){const s=function(e){let t=!0;const n=[],r=[];for(const t in e.nodesByDepth)n.push(e.nodesByDepth[t]);for(const e of n){if(e.length>1||1===e.length&&e[0].inboundLayers.length>1){t=!1;break}r.push(...e)}if(t)for(const n of e.layers){let e=!1;for(const s of n.inboundNodes)if(-1!==r.indexOf(s)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),a=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){a.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),Wk(a,n,r),r("=".repeat(t));const o=e.layers;for(let e=0;e<o.length;++e)s?Vk(o[e],n,r):Gk(o[e],n,i,r),r((e===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;t=null!=e.collectedTrainableWeights?_w(e.collectedTrainableWeights):_w(e.trainableWeights);return t}(e),u=_w(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function Wk(e,t,n=console.log){let r="";for(let n=0;n<e.length;++n)n>0&&(r=r.slice(0,r.length-1)+" "),r+=e[n],r=r.slice(0,t[n]),r+=" ".repeat(t[n]-r.length);n(r)}function Vk(e,t,n){let r,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}Wk([`${e.name} (${e.getClassName()})`,s,r,e.countParams().toString()],t,n)}function Gk(e,t,n,r){let s,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(e){a="multiple"}try{s=JSON.stringify(e.outputShape)}catch(e){s="multiple"}const i=[];for(const t of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(t)))for(let e=0;e<t.inboundLayers.length;++e){const n=t.inboundLayers[e].name,r=t.nodeIndices[e],s=t.tensorIndices[e];i.push(`${n}[${r}][${s}]`)}const o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];Wk([`${o} (${l})`,a,s,e.countParams().toString(),u],t,r);for(let e=1;e<i.length;++e)Wk(["","","","",i[e]],t,r)}function Hk(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function qk(e,t){if(null===e)return null;if("string"==typeof e)return sx(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];Hk(t,s,r)?n.push(r):n.push(qk(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{const e=sx(n);t[e]=qk(r,e)}}return t}}function Kk(e,t){if(null==e)return null;if("string"==typeof e)return rx(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];Hk(t,s,r)?n.push(r):n.push(Kk(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],s=rx(n);t[s]="name"!==n&&"className"!==n||"string"!=typeof r?Kk(r,n):r}return t}}const Xk="4.22.0";class Yk extends Bw{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=xx(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],cx(this.inputs).length!==this.inputs.length)throw new Kv(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);cx(this.outputs).length,this.outputs.length,this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const e of this.outputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(const e of this.inputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;Zv(0===n,"input layer has >1 nodes"),Zv(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t];if(!(n instanceof jw))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${t} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},s={},a={},i=[],o=(e,t,n,r,s,l)=>{null!=r&&null!=s&&null!=l||(r=e.sourceLayer,s=e.nodeIndex,l=e.tensorIndex);const u=r.inboundNodes[s];if(-1!==n.indexOf(u))throw new qv(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(Yk.nodeKey(r,s)),r.id in a||(a[r.id]=Object.keys(a).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let e=0;e<c;e++){const r=u.inputTensors[e],s=u.inboundLayers[e],a=u.nodeIndices[e],i=u.tensorIndices[e];o(r,t,n,s,a,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(const e of this.outputs)o(e,l,u);const c=i.slice().reverse();for(const e of c){n[e.id]=e,e.id in t||(t[e.id]=0);let a=t[e.id];const i=null==r[e.outboundLayer.id]?0:r[e.outboundLayer.id];a=Math.max(a,i),r[e.outboundLayer.id]=a,s[e.outboundLayer.id]=e.outboundLayer,t[e.id]=a;for(let r=0;r<e.inboundLayers.length;r++){const s=e.inboundLayers[r],i=e.nodeIndices[r],o=s.inboundNodes[i],l=null==t[o.id]?0:t[o.id];t[o.id]=Math.max(a+1,l),n[o.id]=o}}const d={};for(const e in t){const r=t[e];r in d||(d[r]=[]),d[r].push(n[e])}const h={};for(const e in r){const t=r[e];t in h||(h[t]=[]),h[t].push(s[e])}let p=Object.keys(h).map((e=>parseInt(e,10))).sort(ux);this.layers=[];for(const e of p){const t=h[e];t.sort(((e,t)=>{const n=a[e.id],r=a[t.id];return n<r?-1:n>r?1:0}));for(const e of t)e instanceof Yk&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=h,p=Object.keys(d).map((e=>parseInt(e,10))).sort(ux);const f=this.inputs.slice(),m=[];for(const e of p)for(const t of d[e]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new qv(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${m}`);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=d;const g=this.layers.map((e=>e.name));for(const e of g){const t=g.filter((t=>t===e)).length;if(1!==t)throw new qv(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new zw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Kv("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let r=0;const s=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);s&&this.parseWeights(e);for(const e of this.layers)for(const[t,a]of e.weights.entries()){const e=s?`${a.name.split("/").slice(0,-1).join("/")+"/"}${t}`:a.originalName;if(null!=n[e])throw new Kv(`Duplicate weight name: ${e}`);n[e]=a,r++}const a=[];for(const r in e){let s=r;if(null==n[r]){const e=r.split("/");s=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[s])a.push([n[s],e[r]]);else if(t)throw new Kv(`Provided weight data has no target variable: ${r}`);delete n[s]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new Kv(`${e.length} of ${r} weights are not set: ${e}`)}Dw(a)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],s=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${Xk}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=Kk(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Dl((()=>{e=nx(e);const n=new Ww;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return Hw(this.outputs,n,t)}))}computeMask(e,t){return Dl((()=>{let n;return e=nx(e),n=null==t?Jv(null,e.length):nx(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=Cw(e);if(t.length!==this.inputLayers.length)throw new Kv(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let e=0;e<t.length;e++){const r=this.inputLayers[e],s=t[e];n[r.name+"_0_0"]=s}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(ux);if(r.length>1)for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(t.id))continue;const r=[];for(let t=0;t<e.inboundLayers.length;t++){const s=e.inboundLayers[t],a=e.nodeIndices[t],i=e.tensorIndices[t],o=n[`${s.name}_${a}_${i}`];r.push(o)}const s=Cw(t.computeOutputShape(tx(r))),a=t.inboundNodes.indexOf(e);for(let e=0;e<s.length;e++){n[`${t.name}_${a}_${e}`]=s[e]}}}const s=[],a=[];for(let e=0;e<this.outputLayers.length;e++){const t=this.outputLayers[e],n=this.outputLayersNodeIndices[e],r=this.outputLayersTensorIndices[e],s=`${t.name}_${n}_${r}`;a.push(s)}for(let e=0;e<a.length;e++){const t=a[e];Zv(t in n),s.push(n[t])}return tx(s)}runInternalGraph(e,t){null==t&&(t=Jv(null,e.length));const n={};for(let r=0;r<this.inputs.length;++r){const s=this.inputs[r],a=e[r],i=t[r];n[s.id]=[a,i]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(ux);for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,s=e.outputTensors,a=new Array;for(const e of r)e.id in n&&a.push(n[e.id]);if(a.length===r.length){let r,i,o,l,u={};if(null!=e.callArgs&&(u=e.callArgs),1===a.length){const[e,n]=a[0];null==u.mask&&(u.mask=n),o=nx(t.call(e,u)),l=nx(t.computeMask(e,n)),r=[e],i=[n]}else r=a.map((e=>e[0])),i=a.map((e=>e[1])),null==u.mask&&(u.mask=i),o=nx(t.call(r,u)),l=nx(t.computeMask(r,i));if(t.activityRegularizer)throw new Xv("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e){const t=s[e],r=o[e],a=l[e];n[t.id]=[r,a]}}}}const s=[],a=[],i=[];for(const e of this.outputs){Zv(e.id in n,`Could not compute output ${e.name} : ${e.id}`);const[t,r]=n[e.id];i.push(t.shape),s.push(t),a.push(r)}return[s,a,i]}buildNodeConversionMap(e){const t={};let n;for(const e of this.layers){n=e instanceof Yk?1:0;for(let r=0;r<e.inboundNodes.length;r++){const s=Yk.nodeKey(e,r);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new Kv("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(const t of this.layers)if(t.name===e)return t;throw new Kv(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new Kv(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return Dl((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=Yk.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const e of this.layers){const r=e.getClassName(),s=e.getConfig(),a=[];for(let n=0;n<e.inboundNodes.length;n++){const r=e.inboundNodes[n],s=Yk.nodeKey(e,n);let i={};if(this.containerNodes.has(s)){if(r.callArgs)try{JSON.stringify(r.callArgs),i=r.callArgs}catch(e){i={}}if(r.inboundLayers.length>0){const e=[];for(let n=0;n<r.inboundLayers.length;n++){const s=r.inboundLayers[n],a=r.nodeIndices[n],o=r.tensorIndices[n];let l=t[Yk.nodeKey(s,a)];null==l&&(l=0),e.push([s.name,l,o,i])}a.push(e)}}}const i={};i.name=e.name,i.className=r,i.config=s,i.inboundNodes=a,n.push(i)}e.layers=n;const r=[];for(let e=0;e<this.inputLayers.length;e++){const n=this.inputLayers[e],s=this.inputLayersNodeIndices[e],a=Yk.nodeKey(n,s);if(!this.containerNodes.has(a))continue;let i=t[a];null==i&&(i=0);const o=this.inputLayersTensorIndices[e];r.push([n.name,i,o])}e.inputLayers=r;const s=[];for(let e=0;e<this.outputLayers.length;e++){const n=this.outputLayers[e],r=this.outputLayersNodeIndices[e],a=Yk.nodeKey(n,r);if(!this.containerNodes.has(a))continue;let i=t[a];null==i&&(i=0);const o=this.outputLayersTensorIndices[e];s.push([n.name,i,o])}return e.outputLayers=s,e}static fromConfig(e,t,n={},r=!1){const s={},a={};function i(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function o(e,t){const n=[];let r;for(const a of t){const o=a[0],l=a[1],u=a[2];if(r=null==a[3]?{}:a[3],!(o in s))return void i(e,t);const c=s[o];if(c.inboundNodes.length<=l)return void i(e,t);const d=c.inboundNodes[l];n.push(d.outputTensors[u])}n.length>0&&e.apply(tx(n),r)}function l(e){const n=e.name,a=yk(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(r),s[n]=a;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new Kv(`Corrupted configuration, expected array for nodeData: ${e}`);i(a,e)}))}const u=t.name,c=t.layers;for(const e of c)l(e);for(;!dx(a);)for(const e of c){const t=s[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)o(t,n)}}const d=[],h=[],p=t.inputLayers;for(const e of p){const t=e[0],n=e[1],r=e[2];Zv(t in s);const a=s[t].inboundNodes[n].outputTensors;d.push(a[r])}const f=t.outputLayers;for(const e of f){const t=e[0],n=e[1],r=e[2];Zv(t in s);const a=s[t].inboundNodes[n].outputTensors;h.push(a[r])}return new e({inputs:d,outputs:h,name:u})}get stateful(){if(this._stateful)throw new Kv("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Dl((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function Qk(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function Jk(e,t){return Qk(e,t,"classWeight")}async function Zk(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Dl((()=>{if(1===e.shape.length)return Qu(e);if(2===e.shape.length){if(e.shape[1]>1){return ch(e,1)}if(1===e.shape[1])return Rh(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());Fl(t);const s=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);s.push(n[e])})),Am(s,"float32")}return null}function eS(e,t){return nc(e,t)}function tS(e,t){let n,r;const s=t;n=s.xs,r=s.ys,Rn(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const a=nS("input",e.inputNames,n),i=nS("output",e.outputNames,r),o=a[0].shape[0];Rn(a.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),Rn(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let t=0;t<a.length;t++)Rn(a[t].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[t]} has ${a[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let t=0;t<i.length;t++)Rn(i[t].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[t]} has ${i[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:a,ys:i}}function nS(e,t,n){if(n instanceof Po)return[n];if(Array.isArray(n))return Rn(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const s of t){if(null==n[s])throw new Kv(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}async function rS(e,t,n){const r=null!=n.batchesPerEpoch;if(Rn(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Rn(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Rn(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),Rn(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),Rn(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let a,i;if(s)if(sS(n.validationData))Rn(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new Xv("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,i=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const c=fk(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=gk(c,d,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,s,u);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const u={};await h.onEpochBegin(f);let c=0,d=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){const t=await m.next();if(r&&t.done)break;if(null!=t.value){const{xs:r,ys:s}=tS(e,t.value),a={};a.batch=d,a.size=r[0].shape[0],await h.onBatchBegin(d,a);const i=[];if(null!=n.classWeight){const t=Jk(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await Zk(s[e],null,t[e]))}const u=r.concat(s).concat(i),p=o(u);Fl(u);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];a[t]=n,Ml(n)}await h.onBatchEnd(d,a),ok(a),d++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(s){let t;t=sS(n.validationData)?nx(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):nx(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,u),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function sS(e){return"function"==typeof e.iterator}function aS(e){Rn(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function iS(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>Vx(e,t,n-t))):Vx(e,t,n-t)}function oS(e,t){return Dl((()=>null==e?null:Array.isArray(e)?e.map((e=>oS(e,t))):Jx(e,"int32"===t.dtype?t:Yu(t,"int32"))))}function lS(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function uS(e){const t=[];e instanceof Po&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(Wx(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function cS(e,t){if(null==e)return;const n=[];if(t instanceof Po)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const e in t){const r=t[e];n.push(r.id)}const r=[];if(e instanceof Po)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const t in e){const s=e[t];-1===n.indexOf(s.id)&&r.push(s)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function dS(e){return Array.isArray(e)}function hS(e){return!function(e){return e instanceof Po}(e)&&!dS(e)}function pS(e,t,n,r=!0,s=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(dS(e)&&e.length>0)t=!0;else if(hS(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new Kv(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let a;if(hS(e)){a=[];for(const n of t){if(null==e[n])throw new Kv(`No data provided for "${n}". Need data for each key in: ${t}`);a.push(e[n])}}else if(dS(e)){if(e.length!==t.length)throw new Kv(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(t.length>1)throw new Kv(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=uS(a),null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const i=a[e];if(i.shape.length!==n[e].length)throw new Kv(`Error when checking ${s}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${i.shape}`);for(let t=0;t<n[e].length;++t){if(0===t&&!r)continue;const a=i.shape[t],o=n[e][t];if(null!=o&&o>=0&&a!==o)throw new Kv(`${s} expected a batch of elements where each example has shape [${n[e].slice(1,n[e].length)}] (i.e.,tensor shape [*,${n[e].slice(1,n[e].length)}]) but the ${s} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return a}function fS(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new Kv(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new Kv(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const i=a[e];if(i.shape.length!==n[e].length)throw new Kv(`Error when checking ${s}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let a=0;a<n[e].length;++a){if(0===a&&!r)continue;const o=i.shape[a],l=n[e][a];if(null!=l&&l!==o)throw new Kv(`Error when checking ${s}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}class mS extends Yk{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new Kv("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");jk(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>yy.adagrad(.01),Adadelta:()=>yy.adadelta(1,.95,Ux()),Adam:()=>yy.adam(.001,.9,.999,Ux()),Adamax:()=>yy.adamax(.002,.9,.999,Ux(),0),RMSProp:()=>yy.rmsprop(.001,.9,0,Ux()),SGD:()=>yy.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new Kv(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof xc))throw new Kv("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Kv(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>$k(e)))}else{const n=$k(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new Kv(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)e.loss[n],t.push($k(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){const t=this.internalOutputShapes[e],n=this.outputNames[e];this.feedOutputNames.push(n),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ox("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};Ox("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,a;for(const i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===Nk?-1!==["accuracy","acc"].indexOf(i)?r=_k:-1!==["crossentropy","ce"].indexOf(i)&&(r=Ak):this.lossFunctions[e]===Ik?-1!==["accuracy","acc"].indexOf(i)?r=Dk:-1!==["crossentropy","ce"].indexOf(i)&&(r=Mk):-1!==["accuracy","acc"].indexOf(i)?r=Ok:-1!==["crossentropy","ce"].indexOf(i)&&(r=Fk),-1!==["accuracy","acc"].indexOf(i)?s="acc":-1!==["crossentropy","ce"].indexOf(i)&&(s="ce"),a=r,n=""+s}else{const e=zk(i);a=e,n=""+Pk(i)}let t;Ox(n,(()=>{t=a})),s(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&(this.trainableWeights.length,this.collectedTrainableWeights.length)}evaluate(e,t,n={}){const r=null==n.batchSize?32:n.batchSize;aS(r);const s=this.standardizeUserDataXY(e,t,!0,r);try{const e=s[0].concat(s[1]);this.makeTestFunction();const t=this.testFunction;return tx(this.testLoop(t,e,r,n.verbose,n.steps))}finally{cS(s[0],e),cS(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,s=e.testFunction;let a=[];if(n.verbose>0)throw new Xv("Verbose mode is not implemented yet.");Rn(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const i="function"==typeof t.next?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const t=await i.next();if(a=Dl((()=>{if(t.value){const{xs:n,ys:r}=tS(e,t.value),i=n.concat(r),u=Dl((()=>s(i)));if(Fl(i),0===l)for(let e=0;e<u.length;++e)a.push(pc(0));const c=i[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=a[e];a[e]=Dl((()=>Zu(a[e],nc(c,t)))),l>0&&Fl(n)}Fl(u),o+=c,++l}return a})),t.done)break}for(let e=0;e<a.length;++e){const t=a[e];a[e]=tc(a[e],o),Fl(t)}return tx(a)}(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(null!=n){if(s=null,null!=t)throw new Kv(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new Kv(`Either the input data should have a defined shape, or ${r} shoud be specified.`);s=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return s}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new Kv("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new Ww;if(e instanceof Po&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Kv(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)a.add(this.inputs[t],e[t])}else for(const t of this.inputs){const n=e[t.name];if(null==n)throw new Kv(`No value is provided for the model's input ${t.name}`);a.add(t,n)}const i=Hw(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){const t=Jv(null,e.length);let n=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],a=s.map((e=>e.name));for(let r=0;r<e.length;++r){const i=a.indexOf(e[r]);if(-1!==i&&(t[r]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new Kv(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return Dl((()=>{const r=this.checkNumSamples(e);if(n)throw new Xv("Verbose predictLoop() is not implemented yet.");const s=lS(r,t),a=this.outputs.map((e=>[]));for(let t=0;t<s.length;++t){Dl((()=>{const n=s[t][0],r=s[t][1],a=iS(e,n,r),i=[];if(Array.isArray(a))for(let e=0;e<a.length;++e)i.push({key:this.inputs[e],value:a[e]});else i.push({key:this.inputs[0],value:a});const o=new Ww(i);return Hw(this.outputs,o)})).forEach(((e,t)=>a[t].push(e)))}return tx(a.map((e=>Fh(e,0))))}))}predict(e,t={}){const n=uS(e);fS(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return aS(e),this.predictLoop(n,e)}finally{cS(n,e)}}predictOnBatch(e){fS(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new qv("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let e=0;e<this.feedOutputShapes.length;++e){const t=this.feedOutputShapes[e];this.feedLossFns[e]===Ik?s.push(t.slice(0,t.length-1).concat([1])):s.push(t)}if(function(e,t){const n=cx(e.map((e=>e.shape[0])));n.sort();const r=cx(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new Kv(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new Kv(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!zn(n,r))throw new Kv(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=pS(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=pS(t,this.feedOutputNames,s,!1,"target")),function(e,t,n){const r=[vk,Nk,Sk];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(null!=i){if(i===Sk&&1===a.shape[a.shape.length-1])throw new Kv(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=a.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],s=t[n];if(null!=s&&r!==s)throw new Kv(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!=0)throw new Kv(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){const[i,o]=this.standardizeUserDataXY(e,t,s,a);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=Jk(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await Zk(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n,r=0,s){return Dl((()=>{const a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new Xv("Verbose mode is not implemented yet.");if(null!=s)throw new Xv("steps mode in testLoop() is not implemented yet");{const r=lS(a,n),s=Am(Px(0,a));for(let n=0;n<r.length;++n){const a=r[n][0],o=r[n][1],l=Vx(s,a,o-a),u=oS(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(pc(0));for(let e=0;e<c.length;++e){const t=c[e];i[e]=Zu(i[e],nc(o-a,t))}}for(let e=0;e<i.length;++e)i[e]=tc(i[e],a)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let s=r;if(ex(e,r)>1){s+=`_${ex(e.slice(0,n),r)}`}t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new Ww(e),o=Hw(this.outputs,i,{training:!0});let l;for(let e=0;e<this.lossFunctions.length;++e){let n=(0,this.lossFunctions[e])(r[e],o[e]);null!=s[e]&&(n=eS(n,s[e]));const a=vf(n);t.push(a),l=0===e?n:Zu(l,n)}for(let e=0;e<this.metricsTensors.length;++e){let n;if(this.outputs.length>1&&e<this.outputs.length)n=t[e];else{const t=this.metricsTensors[e][0],s=this.metricsTensors[e][1];n=vf(t(r[s],o[s]))}Ml(n),a.push(n)}return l=vf(l),this.calculateLosses().forEach((e=>{l=Zu(l,e)})),l}),!0,i)].concat(a)}}makeTestFunction(){this.testFunction=e=>Dl((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:r[e]});const i=new Ww(a),o=Hw(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],a=vf(r(s[e],o[e]));n=0===e?a:Zu(n,a),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],a=vf(n(s[r],o[r]));t.push(a)}return t}))}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,s,a,i,o,l,u,c,d;this.isTraining=!0;try{const h=null==n.batchSize?32:n.batchSize;aS(h);const p=!1,f=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,p,h);r=f[0],s=f[1],d=f[2];let m,g=!1;if(null!=n.validationData&&n.validationData.length>0){if(g=!0,2!==n.validationData.length)throw 3===n.validationData.length?new Xv("validationData including sample weights is not supported yet."):new Kv(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);o=n.validationData[0],l=n.validationData[1];const e=!0,t=await this.standardizeUserData(o,l,null,null,e,h);u=t[0],c=t[1],m=u.concat(c)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){g=!0;const e=Math.floor(r[0].shape[0]*(1-n.validationSplit)),t=r[0].shape[0];u=iS(r,e,t),a=r,r=iS(r,0,e),c=iS(s,e,t),i=s,s=iS(s,0,e),m=u.concat(c)}else null!=n.validationSteps&&(g=!0);const y=r.concat(s).concat(d);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let x,w;g?(this.makeTestFunction(),x=this.testFunction,w=v.slice().concat(v.map((e=>"val_"+e)))):(x=null,m=[],w=v.slice());const k=fk(n.callbacks,n.yieldEvery);return await this.fitLoop(b,y,v,h,n.epochs,n.verbose,k,x,m,n.shuffle,w,n.initialEpoch,null,null)}finally{this.isTraining=!1,cS(r,e),cS(s,t),cS(a,e),cS(i,t),cS(u,o),cS(c,l),null!=d&&Fl(d)}}async fitLoop(e,t,n,r,s,a,i,o,l,u,c,d,h,p){null==r&&(r=32),null==s&&(s=1),null==u&&(u=!0),null==d&&(d=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==h))throw new Kv("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,r,h,"steps_per_epoch");let g;null!=m&&(g=Px(0,m)),null==a&&(a=1);const{callbackList:y,history:b}=gk(i,a,s,d,m,h,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let a=d;a<s;++a){await y.onEpochBegin(a);const s={};if(null!=h)throw new Xv("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new Xv("batch shuffling is not implemneted yet");u&&In(g);const a=Am(g),i=lS(m,r);for(let u=0;u<i.length;++u){const c={};if(await y.onBatchBegin(u,c),Dl((()=>{const d=i[u][0],h=i[u][1],p=Vx(a,d,h-d);c.batch=u,c.size=h-d;const m=oS(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],r=g[e];c[t]=r,Ml(r)}if(u===i.length-1&&f){const e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){const r=n[t],a=e[t];Ml(a),s["val_"+r]=a}}})),await y.onBatchEnd(u,c),ok(c),this.stopTraining_)break}a.dispose()}if(await y.onEpochEnd(a,s),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return rS(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(const e of a){const t=await e.data();i.push(t[0])}return Fl(a),cS(n[0],e),cS(n[1],t),tx(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let e=0;e<r.length;++e)n&&!r[e].trainable||t.push({name:r[e].originalName,tensor:s[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=Rl().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Rl().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=rx(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>rx(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=rx(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[rx(Pk(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>rx(Pk(e))));{const e={};for(const t in this.metrics)e[t]=rx(Pk(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=yk(qk(e.optimizer_config));let n,r;if("string"==typeof e.loss)n=sx(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>sx(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=sx(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>sx(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=sx(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"==typeof e){const t=fu(e);if(0===t.length)throw new Kv(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Kv(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Kv("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await Kl(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${Xk}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:s}=await Kl(await this.optimizer.getWeights(),e);n.specs.push(...s),n.data=su([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;Bk(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){Bk(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}mS.className="Model",bc(mS);class gS extends mS{}gS.className="Functional",bc(gS);class yS extends mS{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:xx("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new Kv(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof yS||e instanceof mS;let n;if(t){if(n=e,1!==n.outputs.length)throw new Kv("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new Kv("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new Kv("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new Kv("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new jw({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new Kv(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new Kv("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Uw(this.outputs[0])}this.inboundNodes=[],new zw({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Jv(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if($w(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new mS({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new qv("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new qv("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new qv("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new qv("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let s,a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new Kv("Legacy serialization format not supported yet.");s=t}else Rn(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),s=t.layers,delete t.layers,a=t;const i=new e(a);if(!(i instanceof yS))throw new Xv(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const e of s){const t=yk(e,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),i.add(t)}return i}set stopTraining(e){if(null==this.model)throw new Kv("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new Kv("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}yS.className="Sequential",bc(yS);class bS extends gc{getConfig(){return{}}}class vS extends bS{apply(e,t=1){return function(e,t=1){if(1!==t)throw new Xv(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return kp(e)}(e,t)}}vS.className="elu",bc(vS);class xS extends bS{apply(e){return dm(e)}}xS.className="selu",bc(xS);class wS extends bS{apply(e){return nm(e)}}wS.className="relu",bc(wS);class kS extends bS{apply(e){return Dl((()=>Sf(6,nm(e))))}}kS.className="relu6",bc(kS);class SS extends bS{apply(e){return e}}SS.className="linear",bc(SS);class IS extends bS{apply(e){return Mh(e)}}IS.className="sigmoid",bc(IS);class NS extends bS{apply(e){return function(e){return Dl((()=>{const t=Zu(.5,nc(.2,e));return Yh(t,0,1)}))}(e)}}NS.className="hardSigmoid",bc(NS);class TS extends bS{apply(e){return sf(e)}}TS.className="softplus",bc(TS);class CS extends bS{apply(e){return function(e){return Dl((()=>tc(e,Zu(Cc(e),1))))}(e)}}CS.className="softsign",bc(CS);class ES extends bS{apply(e){return zh(e)}}ES.className="tanh",bc(ES);class $S extends bS{apply(e,t=-1){return wm(e,t)}}$S.className="softmax",bc($S);class _S extends bS{apply(e,t=-1){return of(e,t)}}_S.className="logSoftmax",bc(_S);class OS extends bS{apply(e){return Dl((()=>Dl((()=>{const t=Math.sqrt(2),n=nc(.5,Zu(1,Ip(tc(e,t))));return nc(e,n)}))))}}OS.className="gelu",bc(OS);class RS extends bS{apply(e){return Dl((()=>nc(.5,nc(e,Zu(1,zh(nc(rc(tc(2,Math.PI)),Zu(e,nc(.044715,Ic(e,3))))))))))}}RS.className="gelu_new",bc(RS);class AS extends bS{apply(e){return Dl((()=>nc(e,zh(sf(e)))))}}AS.className="mish",bc(AS);class DS extends bS{apply(e,t=1){return Dl((()=>nc(Mh(nc(e,t)),e)))}}function FS(e){return e.getClassName()}function MS(e,t={}){return lx(e,yc.getMap().classNameMap,t,"activation")}function LS(e){if(null==e){const e={className:"linear",config:{}};return MS(e)}if("string"==typeof e){const t={};return t.className=e,t.config={},MS(t)}return e instanceof bS?e:MS(e)}function zS(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}DS.className="swish",bc(DS);class PS extends gc{}class BS extends PS{constructor(e){super(),zS(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Dl((()=>{let t=xf([1]);return this.hasL1&&(t=Zu(t,Fp(nc(this.l1,Cc(e))))),this.hasL2&&(t=Zu(t,Fp(nc(this.l2,Zx(e))))),Rh(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}BS.className="L1L2",bc(BS);const US={l1l2:"L1L2"};function jS(e){return ix(e)}function WS(e,t={}){return lx(e,yc.getMap().classNameMap,t,"regularizer")}function VS(e){if(null==e)return null;if("string"==typeof e){return WS({className:e in US?US[e]:e,config:{}})}return e instanceof PS?e:WS(e)}class GS extends Bw{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=Ew(e);let n=nm(e);return null!=this.maxValue&&(n=Yh(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}GS.className="ReLU",bc(GS);class HS extends Bw{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Ew(e);return Qp(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}HS.className="LeakyReLU",bc(HS);class qS extends Bw{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Nw(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=VS(e.alphaRegularizer),this.alphaConstraint=ak(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new Kv(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=$w(e)).slice(1);if(null!=this.sharedAxes)for(const e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let t=1;t<e.length;++t)n[t]=e[t];this.inputSpec=[new Fw({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Ew(e),Pf(e,this.alpha.read())}getConfig(){const e={alphaInitializer:Iw(this.alphaInitializer),alphaRegularizer:jS(this.alphaRegularizer),alphaConstraint:rk(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}qS.className="PReLU",bc(qS);class KS extends Bw{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Xv(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=Ew(e);return kp(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}KS.className="ELU",bc(KS);class XS extends Bw{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=Ew(e);return nc(n,Yu(Hp(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}XS.className="ThresholdedReLU",bc(XS);class YS extends Bw{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new $S).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return Dl((()=>{let n=Ew(e);const r=t.mask;if(null!=r){const e=nc(Nc(wf(n.shape),Yu(r,n.dtype)),pc(-1e9));n=Zu(n,e)}return this.axis instanceof Array?this.axis.length>1?Pp(Nc(n,lf(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function QS(e,t,n){if("number"==typeof e)return Jv(e,t);if(e.length!==t)throw new Kv(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let s=0;s<t;++s){const a=e[s];if((r=a)!==parseInt(r.toString(),10))throw new Kv(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e;var r}function JS(e,t,n,r,s=1){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*(s-1))+1,Math.floor((a+r-1)/r)}function ZS(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+zx([n-t,0]);else{if("same"!==r)throw new Kv(`Unsupport padding mode: ${r}.`);e*=t}return e}function eI(e,t){return Dl((()=>(Cx(t),"channelsFirst"===t?ld(e,[0,2,3,1]):e)))}function tI(e,t){return Dl((()=>(Cx(t),"channelsFirst"===t?ld(e,[0,2,3,4,1]):e)))}function nI(e,t,n,r=1,s="valid",a,i=1){return Dl((()=>{if(null==a&&(a="channelsLast"),Cx(a),3!==e.shape.length)throw new Kv(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new Kv(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new Kv(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===a&&(e=ld(e,[0,2,1])),"causal"===s)throw new Xv("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=np(e,t,r,"same"===s?"same":"valid","NWC",i);return null!=n&&(o=tw(o,n)),o}))}function rI(e,t,n,r=[1,1],s="valid",a,i,o=null){return Dl((()=>{if(null==a&&(a="channelsLast"),Cx(a),3!==e.rank&&4!==e.rank)throw new Kv(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new Kv(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=eI(e,a);if("causal"===s)throw new Xv("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=lg({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===a&&(l=ld(l,[0,3,1,2])),l}))}function sI(e,t,n,r=[1,1,1],s="valid",a,i){return Dl((()=>{if(null==a&&(a="channelsLast"),Cx(a),4!==e.rank&&5!==e.rank)throw new Kv(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new Kv(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=tI(e,a);if("causal"===s)throw new Xv("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=ap(o,t,r,"same"===s?"same":"valid","NDHWC",i),null!=n&&(o=tw(o,n)),"channelsFirst"===a&&(o=ld(o,[0,4,1,2,3])),o}))}YS.className="Softmax",bc(YS);class aI extends Bw{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",aI.verifyArgs(t),this.rank=e,fx(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Xv(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=QS(t.kernelSize,e,"kernelSize"),this.strides=QS(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,Ex(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Cx(this.dataFormat),this.activation=LS(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=Nw(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ak(t.biasConstraint),this.biasRegularizer=VS(t.biasRegularizer),this.activityRegularizer=VS(t.activityRegularizer),this.dilationRate=QS(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new Kv(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new Kv(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new Kv(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(Zv("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!px(e.kernelSize,"number",1,3))throw new Kv(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:FS(this.activation),useBias:this.useBias,biasInitializer:Iw(this.biasInitializer),biasRegularizer:jS(this.biasRegularizer),activityRegularizer:jS(this.activityRegularizer),biasConstraint:rk(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class iI extends aI{constructor(e,t){super(e,t),this.kernel=null,iI.verifyArgs(t),this.filters=t.filters,fx(this.filters,"filters"),this.kernelInitializer=Nw(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ak(t.kernelConstraint),this.kernelRegularizer=VS(t.kernelRegularizer)}build(e){e=$w(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Kv(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Dl((()=>{let t;e=Ew(e);const n=null==this.bias?null:this.bias.read(),r=gx(this.activation.getClassName());if(null!=r&&2===this.rank)t=rI(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=nI(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=rI(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Xv("convolutions greater than 3D are not implemented yet.");t=sI(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=$w(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<n.length;++e){const r=JS(n[e],this.kernelSize[e],this.padding,this.strides[e],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[e]);t.push(r)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:Iw(this.kernelInitializer),kernelRegularizer:jS(this.kernelRegularizer),kernelConstraint:rk(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new Kv(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class oI extends iI{constructor(e){super(2,e),oI.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!px(e.kernelSize,"number",1,2))throw new Kv(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}oI.className="Conv2D",bc(oI);class lI extends iI{constructor(e){super(3,e),lI.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new Kv(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}lI.className="Conv3D",bc(lI);class uI extends oI{constructor(e){if(super(e),this.inputSpec=[new Fw({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new Kv(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=$w(e)).length)throw new Kv("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Kv("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Fw({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Dl((()=>{let t=Ew(e);if(4!==t.shape.length)throw new Kv(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a;"channelsFirst"===this.dataFormat?(s=2,a=3):(s=1,a=2);const i=n[s],o=n[a],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1],h=[r,ZS(i,c,l,this.padding),ZS(o,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=ld(t,[0,2,3,1]));let p=sp(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=ld(p,[0,3,1,2])),null!=this.bias&&(p=tw(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=$w(e)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=ZS(t[r],o,a,this.padding),t[s]=ZS(t[s],l,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}uI.className="Conv2DTranspose",bc(uI);class cI extends lI{constructor(e){if(super(e),this.inputSpec=[new Fw({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new Kv(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=$w(e)).length)throw new Kv("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Kv("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Fw({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Dl((()=>{let t=Ew(e);if(5!==t.shape.length)throw new Kv(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a,i;"channelsFirst"===this.dataFormat?(i=2,s=3,a=4):(i=1,s=2,a=3);const o=n[i],l=n[s],u=n[a],c=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[r,ZS(o,p,c,this.padding),ZS(l,f,d,this.padding),ZS(u,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=ld(t,[0,2,3,4,1]));let y=op(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=ld(y,[0,4,1,2,3])),null!==this.bias&&(y=tw(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){const t=(e=$w(e)).slice();let n,r,s,a;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=ZS(t[r],u,i,this.padding),t[s]=ZS(t[s],c,o,this.padding),t[a]=ZS(t[a],d,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}cI.className="Conv3DTranspose",bc(cI);class dI extends iI{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new Kv("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new Kv("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new Kv(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=Nw(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=VS(t.depthwiseRegularizer),this.depthwiseConstraint=ak(t.depthwiseConstraint),this.pointwiseInitializer=Nw(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=VS(t.pointwiseRegularizer),this.pointwiseConstraint=ak(t.pointwiseConstraint)}build(e){if((e=$w(e)).length<this.rank+2)throw new Kv(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new Kv(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let e=0;e<this.rank;++e)s.push(1);s.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Fw({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Dl((()=>{let t;if(e=Ew(e),1===this.rank)throw new Xv("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=ld(e,[0,2,3,1])),t=hm(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=tw(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=ld(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Iw(this.depthwiseInitializer),e.pointwiseInitializer=Iw(this.pointwiseInitializer),e.depthwiseRegularizer=jS(this.depthwiseRegularizer),e.pointwiseRegularizer=jS(this.pointwiseRegularizer),e.depthwiseConstraint=rk(this.depthwiseConstraint),e.pointwiseConstraint=rk(this.pointwiseConstraint),e}}dI.className="SeparableConv";class hI extends dI{constructor(e){super(2,e)}}hI.className="SeparableConv2D",bc(hI);class pI extends iI{constructor(e){super(1,e),pI.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!px(e.kernelSize,"number",1,1))throw new Kv(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}pI.className="Conv1D",bc(pI);class fI extends Bw{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Dl((()=>{if(e=Ew(e),"channelsLast"===this.dataFormat){const t=Hx(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Hx(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=Hx(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Hx(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}fI.className="Cropping2D",bc(fI);class mI extends Bw{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Cx(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,hx(kx,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return Dl((()=>{let t=Ew(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=ld(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?hy.resizeNearestNeighbor(t,[e,r]):hy.resizeBilinear(t,[e,r]);return ld(s,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?hy.resizeNearestNeighbor(t,[e,r]):hy.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}mI.className="UpSampling2D",bc(mI);class gI extends aI{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=Nw(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ak(e.depthwiseConstraint),this.depthwiseRegularizer=VS(e.depthwiseRegularizer)}build(e){if((e=$w(e)).length<4)throw new Kv(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new Kv(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Dl((()=>{let t=function(e,t,n=[1,1],r="valid",s,a){return Dl((()=>{null==s&&(s="channelsLast"),Cx(s);let i=eI(e,s);if(4!==e.rank)throw new Kv(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new Kv(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=fp(i,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===s&&(i=ld(i,[0,3,1,2])),i}))}(e=Ew(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=tw(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=$w(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=JS(t,this.kernelSize[0],this.padding,this.strides[0]),a=JS(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Iw(this.depthwiseInitializer),e.depthwiseRegularizer=jS(this.depthwiseRegularizer),e.depthwiseConstraint=rk(this.depthwiseRegularizer),e}}function yI(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new Kv("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function bI(e,t,n,r=!1,s,a,i=!1,o=!1){return Dl((()=>{const i=t.shape.length;if(i<3)throw new Kv(`Input should be at least 3D, but is ${i}D.`);const l=[1,0].concat(Px(2,i));if(t=ld(t,l),null!=a)throw new Xv("The rnn() functoin of the deeplearn.js backend does not support constants yet.");null!=s&&((s=Yu(Yu(s,"bool"),"float32")).rank===i-1&&(s=Bp(s,-1)),s=ld(s,l)),r&&(t=sm(t,0),null!=s&&(s=sm(s,0)));const u=[];let c,d=n;const h=t.shape[0],p=Wm(t);let f,m;null!=s&&(f=Wm(s));for(let t=0;t<h;++t){const n=p[t],r=Dl((()=>e(n,d)));if(null==s)c=r[0],d=r[1];else{const e=Dl((()=>{const e=f[t],n=Nc(_f(e),e);return{output:Zu(nc(r[0],e),nc(d[0],n)),newStates:d.map(((t,s)=>Zu(nc(r[1][s],e),nc(t,n))))}}));c=e.output,d=e.newStates}o&&u.push(c)}if(o){m=$m(u,1)}return[c,m,d]}))}gI.className="DepthwiseConv2D",bc(gI);class vI extends Bw{constructor(e){let t;if(super(e),null==e.cell)throw new Kv("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new CI({cells:e.cell}):e.cell,null==t.stateSize)throw new Kv("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Fw({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return Px(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Tw(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return Dl((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Xv("Constants support is not implemented in RNN yet.");Tw(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new Fw({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!zn(this.stateSpec.map((e=>e.shape[e.shape.length-1])),s))throw new Kv(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map((e=>new Fw({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){Dl((()=>{if(!this.stateful)throw new Hv("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new Kv("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>xf([n,e]))):this.states_=[xf([n,this.cell.stateSize])];else if(null==e)Fl(this.states_),null!=this.keptStates&&(Fl(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>xf([n,e]))):this.states_[0]=xf([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Kv(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):Fl(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,s];if(!zn(r.shape,a))throw new Kv(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>Ml(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=yI(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],i=[];if(null!=n){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new Fw({shape:e.shape}));i=i.concat(this.stateSpec)}null!=r&&(t.constants=r,a=a.concat(r),this.numConstants=r.length);if(a[0]instanceof Mw){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Dl((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let s=null==t?null:t.initialState;e=Ew(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new Kv(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll;const i={training:r},o=bI(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d}))}getInitialState(e){return Dl((()=>{let t=xf(e.shape);return t=Fp(t,[1,2]),t=Wx(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?Xx(t,[1,e]):t)):this.cell.stateSize>1?[Xx(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===vI.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){const r=yk(t.cell,n);return new e(Object.assign(t,{cell:r}))}}vI.className="RNN",bc(vI);class xI extends Bw{}class wI extends xI{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,fx(this.units,"units"),this.activation=LS(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Nw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Nw(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Nw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=VS(e.kernelRegularizer),this.recurrentRegularizer=VS(e.recurrentRegularizer),this.biasRegularizer=VS(e.biasRegularizer),this.kernelConstraint=ak(e.kernelConstraint),this.recurrentConstraint=ak(e.recurrentConstraint),this.biasConstraint=ak(e.biasConstraint),this.dropout=Lx([1,zx([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Lx([1,zx([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=$w(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Dl((()=>{if(2!==e.length)throw new Kv(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=EI({ones:()=>_f(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=EI({ones:()=>_f(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;s=Qx(null!=a?nc(e,a):e,this.kernel.read()),null!=this.bias&&(s=tw(s,this.bias.read())),null!=i&&(n=nc(n,i));let o=Zu(s,Qx(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:FS(this.activation),useBias:this.useBias,kernelInitializer:Iw(this.kernelInitializer),recurrentInitializer:Iw(this.recurrentInitializer),biasInitializer:Iw(this.biasInitializer),kernelRegularizer:jS(this.kernelRegularizer),recurrentRegularizer:jS(this.recurrentRegularizer),biasRegularizer:jS(this.biasRegularizer),activityRegularizer:jS(this.activityRegularizer),kernelConstraint:rk(this.kernelConstraint),recurrentConstraint:rk(this.recurrentConstraint),biasConstraint:rk(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}wI.className="SimpleRNNCell",bc(wI);class kI extends vI{constructor(e){e.cell=new wI(e),super(e)}call(e,t){return Dl((()=>{null!=this.cell.dropoutMask&&(Fl(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Fl(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return new e(t)}}kI.className="SimpleRNN",bc(kI);class SI extends xI{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Kv("GRUCell does not support reset_after parameter set to true.");this.units=e.units,fx(this.units,"units"),this.activation=LS(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=LS(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Nw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Nw(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Nw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=VS(e.kernelRegularizer),this.recurrentRegularizer=VS(e.recurrentRegularizer),this.biasRegularizer=VS(e.biasRegularizer),this.kernelConstraint=ak(e.kernelConstraint),this.recurrentConstraint=ak(e.recurrentConstraint),this.biasConstraint=ak(e.biasConstraint),this.dropout=Lx([1,zx([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Lx([1,zx([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=$w(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Dl((()=>{if(2!==e.length)throw new Kv(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=EI({ones:()=>_f(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=EI({ones:()=>_f(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let i,o,l;0<this.dropout&&this.dropout<1&&(e=nc(e,s[0]));let u=Qx(e,this.kernel.read());this.useBias&&(u=tw(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=nc(r,a[0]));const c=this.recurrentKernel.read(),[d,h]=Nm(c,[2*this.units,this.units],c.rank-1),p=Qx(r,d),[f,m,g]=Nm(u,3,u.rank-1),[y,b]=Nm(p,2,p.rank-1);i=this.recurrentActivation.apply(Zu(f,y)),o=this.recurrentActivation.apply(Zu(m,b));const v=Qx(nc(o,r),h);l=this.activation.apply(Zu(g,v));const x=Zu(nc(i,r),nc(Zu(1,id(i)),l));return[x,x]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:FS(this.activation),recurrentActivation:FS(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Iw(this.kernelInitializer),recurrentInitializer:Iw(this.recurrentInitializer),biasInitializer:Iw(this.biasInitializer),kernelRegularizer:jS(this.kernelRegularizer),recurrentRegularizer:jS(this.recurrentRegularizer),biasRegularizer:jS(this.biasRegularizer),activityRegularizer:jS(this.activityRegularizer),kernelConstraint:rk(this.kernelConstraint),recurrentConstraint:rk(this.recurrentConstraint),biasConstraint:rk(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}SI.className="GRUCell",bc(SI);class II extends vI{constructor(e){e.implementation,e.cell=new SI(e),super(e)}call(e,t){return Dl((()=>{null!=this.cell.dropoutMask&&(Fl(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Fl(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}II.className="GRU",bc(II);class NI extends xI{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,fx(this.units,"units"),this.activation=LS(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=LS(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=Nw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Nw(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Nw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=VS(e.kernelRegularizer),this.recurrentRegularizer=VS(e.recurrentRegularizer),this.biasRegularizer=VS(e.biasRegularizer),this.kernelConstraint=ak(e.kernelConstraint),this.recurrentConstraint=ak(e.recurrentConstraint),this.biasConstraint=ak(e.biasConstraint),this.dropout=Lx([1,zx([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Lx([1,zx([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=$w(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends iw{apply(t,r){const s=e.apply([n]),a=(new lw).apply([n]),i=e.apply([2*n]);return Kx(Kx(s,a),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Dl((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new Kv(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=EI({ones:()=>_f(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=EI({ones:()=>_f(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u,c;0<this.dropout&&this.dropout<1&&(e=nc(e,a[0]));let d=Qx(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=nc(r,i[0])),d=Zu(d,Qx(r,this.recurrentKernel.read())),this.useBias&&(d=tw(d,this.bias.read()));const[h,p,f,m]=Nm(d,4,d.rank-1);o=this.recurrentActivation.apply(h),l=this.recurrentActivation.apply(p),u=Zu(nc(l,s),nc(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=nc(c,this.activation.apply(u));return[g,g,u]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:FS(this.activation),recurrentActivation:FS(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Iw(this.kernelInitializer),recurrentInitializer:Iw(this.recurrentInitializer),biasInitializer:Iw(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:jS(this.kernelRegularizer),recurrentRegularizer:jS(this.recurrentRegularizer),biasRegularizer:jS(this.biasRegularizer),activityRegularizer:jS(this.activityRegularizer),kernelConstraint:rk(this.kernelConstraint),recurrentConstraint:rk(this.recurrentConstraint),biasConstraint:rk(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}NI.className="LSTMCell",bc(NI);class TI extends vI{constructor(e){e.implementation,e.cell=new NI(e),super(e)}call(e,t){return Dl((()=>{null!=this.cell.dropoutMask&&(Fl(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Fl(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}TI.className="LSTM",bc(TI);class CI extends xI{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Dl((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let a;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;Tw(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{Ox(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t,n={}){const r=[];for(const e of t.cells)r.push(yk(e,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Aw(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,s=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}Dw(t)}}function EI(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>null!=a?a(t(),n):nw(t(),n),o=()=>rw(i,t,r);if(!s||s<=1)return Ml(o().clone());return Array(s).fill(void 0).map(o).map((e=>Ml(e.clone())))}CI.className="StackedRNNCells",bc(CI);var $I=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n};class _I extends vI{constructor(e){if(e.unroll)throw new Xv("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Xv("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Fw({ndim:5})]}call(e,t){return Dl((()=>{if(null!=this.cell.dropoutMask&&(Fl(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Fl(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Kv("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Dl((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=xf([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(s):[s]}))}resetStates(e,t=!1){Dl((()=>{if(!this.stateful)throw new Hv("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new Kv("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>xf(s))):this.states_=[xf(s)];else if(null==e)Fl(this.states_),null!=this.keptStates&&(Fl(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>xf(s))):this.states_[0]=xf(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Kv(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Fl(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=s;if(!zn(n.shape,r))throw new Kv(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>Ml(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=JS(l,r[0],s,a[0],i[0]),d=JS(u,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}}_I.className="ConvRNN2D";class OI extends NI{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,fx(this.filters,"filters"),this.kernelSize=QS(n,2,"kernelSize"),this.kernelSize.forEach((e=>fx(e,"kernelSize"))),this.strides=QS(r||1,2,"strides"),this.strides.forEach((e=>fx(e,"strides"))),this.padding=s||"valid",Ex(this.padding),this.dataFormat=a||"channelsLast",Cx(this.dataFormat),this.dilationRate=QS(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>fx(e,"dilationRate")))}build(e){var t;e=$w(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new Kv(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],s=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends iw{apply(e,t){return qx([n.apply([r]),wf([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Dl((()=>{if(3!==e.length)throw new Kv(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],s=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=EI({ones:()=>_f(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?nc(t[n],e):e;let l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),d=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=EI({ones:()=>_f(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const h=this.recurrentDropoutMask;let p=o(s,h,0),f=o(s,h,1),m=o(s,h,2),g=o(s,h,3);const[y,b,v,x]=Nm(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?Nm(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,k,this.padding),c=this.inputConv(c,v,S,this.padding),d=this.inputConv(d,x,I,this.padding);const[N,T,C,E]=Nm(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,N),f=this.recurrentConv(f,T),m=this.recurrentConv(m,C),g=this.recurrentConv(g,E);const $=this.recurrentActivation.apply(Zu(l,p)),_=this.recurrentActivation.apply(Zu(u,f)),O=Zu(nc(_,a),nc($,this.activation.apply(Zu(c,m)))),R=nc(this.recurrentActivation.apply(Zu(d,g)),this.activation.apply(O));return[R,R,O]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=$I(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const s=tp(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?tw(s,n,this.dataFormat):s}recurrentConv(e,t){return tp(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}OI.className="ConvLSTM2DCell",bc(OI);class RI extends _I{constructor(e){const t=new OI(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}RI.className="ConvLSTM2D",bc(RI);class AI extends Bw{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let e=0;e<this.noiseShape.length;++e)n.push(null==this.noiseShape[e]?t[e]:this.noiseShape[e]);return n}call(e,t){return Dl((()=>{this.invokeCallHook(e,t);const n=Ew(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return rw((()=>nw(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}AI.className="Dropout",bc(AI);class DI extends AI{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}DI.className="SpatialDropout1D",bc(DI);class FI extends Bw{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,fx(this.units,"units"),this.activation=LS(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=Nw(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Nw(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ak(e.kernelConstraint),this.biasConstraint=ak(e.biasConstraint),this.kernelRegularizer=VS(e.kernelRegularizer),this.biasRegularizer=VS(e.biasRegularizer),this.activityRegularizer=VS(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=$w(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=$w(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Dl((()=>{this.invokeCallHook(e,t);const n=Ew(e),r=gx(this.activation.getClassName());let s;return null!=r?s=Qx(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=Qx(n,this.kernel.read()),null!=this.bias&&(s=tw(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s}))}getConfig(){const e={units:this.units,activation:FS(this.activation),useBias:this.useBias,kernelInitializer:Iw(this.kernelInitializer),biasInitializer:Iw(this.biasInitializer),kernelRegularizer:jS(this.kernelRegularizer),biasRegularizer:jS(this.biasRegularizer),activityRegularizer:jS(this.activityRegularizer),kernelConstraint:rk(this.kernelConstraint),biasConstraint:rk(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}FI.className="Dense",bc(FI);class MI extends Bw{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=$w(e);for(const t of e.slice(1))if(null==t)throw new Kv(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Mx(e,1)]}call(e,t){return Dl((()=>{this.invokeCallHook(e,t);let n=Ew(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=ld(n,e)}return function(e){if(e.rank<=1)throw new Kv(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],Mx(e.shape,1)];return Rh(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}MI.className="Flatten",bc(MI);class LI extends Bw{constructor(e){super(e),this.supportsMasking=!0,this.activation=LS(e.activation)}call(e,t){return Dl((()=>{this.invokeCallHook(e,t);const n=Ew(e);return this.activation.apply(n)}))}getConfig(){const e={activation:FS(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}LI.className="Activation",bc(LI);class zI extends Bw{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Dl((()=>{return e=Ew(e),t=e,n=this.n,Dl((()=>{if(2!==t.shape.length)throw new Kv(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return Xx(Wx(t,1),[1,n,1])}));var t,n}))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}zI.className="RepeatVector",bc(zI);class PI extends Bw{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let s=1,a=null;for(let e=0;e<r.length;++e){const t=r[e];if(this.isUnknown(t)){if(null!==a)throw new Kv("Can only specifiy one unknown dimension.");a=e}else s*=t}const i=Mx(e);if(null!==a){if(0===s||i%s!=0)throw new Kv(n);r[a]=i/s}else if(i!==s)throw new Kv(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Dl((()=>{this.invokeCallHook(e,t);const n=Ew(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Rh(n,s)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}PI.className="Reshape",bc(PI);class BI extends Bw{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Px(1,e.dims.length+1);if(!zn(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Fw({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=$w(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return ld(Ew(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}BI.className="Permute",bc(BI);class UI extends Bw{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=Ew(e);return uh($f(n,this.maskValue),-1)}call(e,t){return Dl((()=>{this.invokeCallHook(e,t);const n=Ew(e),r=uh($f(n,this.maskValue),-1,!0);return nc(n,Yu(r,n.dtype))}))}}UI.className="Masking",bc(UI);class jI extends Bw{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(nx(e.inputLength))}this.inputDim=e.inputDim,fx(this.inputDim,"inputDim"),this.outputDim=e.outputDim,fx(this.outputDim,"outputDim"),this.embeddingsInitializer=Nw(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=VS(e.embeddingsRegularizer),this.activityRegularizer=VS(e.activityRegularizer),this.embeddingsConstraint=ak(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Dl((()=>this.maskZero?(e=Ew(e),$f(e,ac(e))):null))}computeOutputShape(e){if(e=$w(e),null==this.inputLength)return[...e,this.outputDim];const t=nx(this.inputLength);if(t.length!==e.length-1)throw new Kv(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const s=t[r],a=e[r+1];if(null!=s&&null!=a&&s!==a)throw new Kv(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Dl((()=>{this.invokeCallHook(e,t);let n=Ew(e);"int32"!==n.dtype&&(n=jx(n,"int32"));const r=Jx(this.embeddings.read(),Rh(n,[n.size]));return Rh(r,$w(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Iw(this.embeddingsInitializer),embeddingsRegularizer:jS(this.embeddingsRegularizer),activityRegularizer:jS(this.activityRegularizer),embeddingsConstraint:rk(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}jI.className="Embedding",bc(jI);class WI extends Bw{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Xv}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],a=t[r];if(null==s||null==a||s<0||a<0)n.push(null);else if(1===s)n.push(a);else if(1===a)n.push(s);else{if(s!==a)throw new Kv("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[$w(e)]),e.length<2)throw new Kv(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const n of e)null!=n&&null!==n[0]&&t.push(n[0]);if(t=cx(t),t.length>1)throw new Kv(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){const r=null==e[t]?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,r)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===cx(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Dl((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=zx(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=Wx(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const r of e){const e=r.rank;if(null==e){const e=r.shape,s=e[0],a=e.slice(1).concat([s]);let i=Rh(r,[s].concat(Mx(e.slice(1))));i=ld(i,[1,0]),i=Rh(i,a),t.push(i),n=!0}else if(e>1){const s=Px(1,e).concat([0]);t.push(ld(r,s)),n=!0}else t.push(r)}let r=this.mergeFunction(t);const s=r.rank;if(n)if(null==s){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=Rh(ld(Rh(r,[-1,t]),[1,0]),n)}else if(s>1){const e=[s-1].concat(Px(0,s-1));r=ld(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){const r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(const t of e)null!=t&&null!==t[0]&&n.push(t[0]);return n=cx(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Dl((()=>{if(null==t)return null;if(!Array.isArray(t))throw new Kv("`mask` should be an Array");if(!Array.isArray(e))throw new Kv("`inputs` should be an Array");if(t.length!==e.length)throw new Kv(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:Bp(e,0))))[0];for(let e=1;e<t.length-1;++e)n=uf(n,t[e]);return n}))}}class VI extends WI{constructor(e){super(e)}mergeFunction(e){return Dl((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Zu(t,e[n]);return t}))}}VI.className="Add",bc(VI);class GI extends WI{constructor(e){super(e)}mergeFunction(e){return Dl((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=nc(t,e[n]);return t}))}}GI.className="Multiply",bc(GI);class HI extends WI{constructor(e){super(e)}mergeFunction(e){return Dl((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Zu(t,e[n]);return nc(1/e.length,t)}))}}HI.className="Average",bc(HI);class qI extends WI{constructor(e){super(e)}mergeFunction(e){return Dl((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Oc(t,e[n]);return t}))}}qI.className="Maximum",bc(qI);class KI extends WI{constructor(e){super(e)}mergeFunction(e){return Dl((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Sf(t,e[n]);return t}))}}KI.className="Minimum",bc(KI);class XI extends WI{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new Kv("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const n of e)if(null!=n){t=!1;break}if(t)return;const n=[];for(let t=0;t<e.length;++t){const r=e[t].slice();r.splice(this.axis,1);let s=!1;for(const e of n)if(zn(e,r)){s=!0;break}s||n.push(r)}if(n.length>1)throw new Kv("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Dl((()=>qx(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Kv("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const e of t.slice(1)){if(null==n[r]||null==e[r]){n[r]=null;break}n[r]+=e[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new Kv("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Kv("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Kv(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Dl((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let n=0;n<e.length;++n)null==t[n]?r.push(Yu(_f(e[n]),"bool")):t[n].rank<e[n].rank?r.push(Bp(t[n],-1)):r.push(t[n]);const s=Fh(r,this.axis);return lh(s,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function YI(e,t){for(;e<0;)e+=t;return e}XI.className="Concatenate",bc(XI);class QI extends WI{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Rn(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Xv("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new Kv(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new Kv(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>YI(t,e[n].shape.length))):[YI(this.axes,n.shape.length),YI(this.axes,r.shape.length)],this.normalize&&(n=bk(n,t[0]),r=bk(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Xv("batchDot is not implemented for tensors of 4D or higher rank yet");if(Rn(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),Rn(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new Xv("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;null==n&&(n=[r-1,s-2]);const a=n;return Dl((()=>{let n,i;if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=Rh(t,t.shape.concat(e))}else if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=Rh(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=a[0]===a[1]?Fp(nc(e,t),a[0]):Fp(nc(ld(e,[1,0]),t),a[1]);else{const n=a[0]!==e.shape.length-1,r=a[1]===t.shape.length-1;i=rd(e,t,n,r)}if(n>0){let e;e=r>s?r+s-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=Em(i,t)}return 1===i.shape.length&&(i=Bp(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[YI(this.axes,e.length),YI(this.axes,t.length)],n}computeOutputShape(e){Rn(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Xv("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}QI.className="Dot",bc(QI);class JI extends Bw{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Dl((()=>{this.invokeCallHook(e,t);const n=Ew(e);return rw((()=>Zu(Yx(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}JI.className="GaussianNoise",bc(JI);class ZI extends Bw{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Dl((()=>{this.invokeCallHook(e,t);const n=Ew(e);if(this.rate>0&&this.rate<1){return rw((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return nc(n,Yx(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}ZI.className="GaussianDropout",bc(ZI);class eN extends Bw{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ew(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Dl((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=Ew(e),r=-1.7580993408473766;let s=qp(Jf(n),this.rate);s=jx(s,"float32");const a=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-a*r*this.rate,o=Zu(nc(t,s),nc(Zu(s,-1),r));return Zu(nc(o,a),i)};return rw(r,(()=>Ew(e)),t.training||!1)}return e}))}}function tN(e,t,n,r,s,a=.001){let i;if(2===e.rank)i=jh(e,t,n,r,s,a);else if(3===e.rank)i=Wh(e,t,n,r,s,a);else{if(4!==e.rank)throw new Xv(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=Vh(e,t,n,r,s,a)}return i}function nN(e,t,n,r,s=.001){return zn(r.slice().sort(),Px(0,e.rank-1))?function(e,t,n,r,s=.001){return Dl((()=>{const a=Tf(e,r),i=a.mean,o=a.variance;return[tN(e,i,o,n,t,s),i,o]}))}(e,t,n,r,s):function(e,t,n,r,s=.001){return Dl((()=>{const a=Tf(e,r),i=a.mean,o=a.variance,l=[];for(const t of Px(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=Rh(i,l),c=Rh(o,l),d=null==t?null:Rh(t,l),h=null==n?null:Rh(n,l);return[tN(e,u,c,h,d,s),i,o]}))}(e,t,n,r,s)}eN.className="AlphaDropout",bc(eN);class rN extends Bw{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Nw(e.betaInitializer||"zeros"),this.gammaInitializer=Nw(e.gammaInitializer||"ones"),this.movingMeanInitializer=Nw(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Nw(e.movingVarianceInitializer||"ones"),this.betaConstraint=ak(e.betaConstraint),this.gammaConstraint=ak(e.gammaConstraint),this.betaRegularizer=VS(e.betaRegularizer),this.gammaRegularizer=VS(e.gammaRegularizer)}build(e){e=$w(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new Kv(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Fw({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Dl((()=>{const n=null!=t.training&&t.training,r=Ew(e),s=r.shape,a=s.length,i=Px(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);const l=Jv(1,a);l[o]=s[o];const u=i.slice();u.sort();const c=!zn(u,Px(0,a).slice(0,a-1));if(!n)return(()=>{if(c){const e=Rh(this.movingMean.read(),l),t=Rh(this.movingVariance.read(),l),n=this.center?Rh(this.beta.read(),l):null,s=this.scale?Rh(this.gamma.read(),l):null;return tN(r,e,t,n,s,this.epsilon)}return tN(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,h,p]=nN(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{Dl((()=>{const r=1-n,s=e.read(),a=nc(Nc(s,t),r);e.write(Nc(s,a))}))};return(()=>{f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum)})(),d}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Iw(this.betaInitializer),gammaInitializer:Iw(this.gammaInitializer),movingMeanInitializer:Iw(this.movingMeanInitializer),movingVarianceInitializer:Iw(this.movingVarianceInitializer),betaRegularizer:jS(this.betaRegularizer),gammaRegularizer:jS(this.gammaRegularizer),betaConstraint:rk(this.betaConstraint),gammaConstraint:rk(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}rN.className="BatchNormalization",bc(rN);class sN extends Bw{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=Nw(e.betaInitializer||"zeros"),this.gammaInitializer=Nw(e.gammaInitializer||"ones"),this.betaRegularizer=VS(e.betaRegularizer),this.gammaRegularizer=VS(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=$w(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(const e of this.axis)if(e<0||e>=t)throw new Error(`Invalid axis: ${e}`);if(this.axis.length!==cx(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=Ew(e),r=n.shape,s=r.length;return Dl((()=>{let{mean:e,variance:t}=Tf(n,this.axis,!0);const a=Jv(1,s);for(const e of this.axis)a[e]=r[e];const i=e=>null!=e&&e.shape.length!==s?Rh(e,a):e;let o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null;const u=[],c=[];for(let e=0;e<s;++e)-1!==this.axis.indexOf(e)?(u.push(r[e]),c.push(1)):(u.push(1),c.push(r[e]));return e=jp(e,u),t=jp(t,u),null!=o&&(o=jp(o,c)),null!=l&&(l=jp(l,c)),tN(n,e,t,l,o,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Iw(this.betaInitializer),gammaInitializer:Iw(this.gammaInitializer),betaRegularizer:jS(this.betaRegularizer),gammaRegularizer:jS(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}sN.className="LayerNormalization",bc(sN);class aN extends Bw{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new Kv(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new Kv(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new Kv(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Fw({ndim:4})]}computeOutputShape(e){let t,n;return e=$w(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Dl((()=>{return t=Ew(e),n=this.padding,r=this.dataFormat,Dl((()=>{if(4!==t.rank)throw new Kv(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new Kv("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new Kv(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Rf(t,e)}));var t,n,r}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function iN(e,t,n,r,s,a){return Dl((()=>{let i;Cx(s),$x(a),Ex(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=eI(e,s);const o="same"===r?"same":"valid";return i="max"===a?gf(e,t,n,o):Ah(e,t,n,o),"channelsFirst"===s&&(i=ld(i,[0,3,1,2])),i}))}function oN(e,t,n,r,s,a){return Dl((()=>{let i;Cx(s),$x(a),Ex(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=tI(e,s);const o="same"===r?"same":"valid";return i="max"===a?yf(e,t,n,o):Dh(e,t,n,o),"channelsFirst"===s&&(i=ld(i,[0,4,1,2,3])),i}))}aN.className="ZeroPadding2D",bc(aN);class lN extends Bw{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new Kv(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(fx(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new Kv(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}fx(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,Ex(this.padding),this.inputSpec=[new Fw({ndim:3})]}computeOutputShape(e){const t=JS((e=$w(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Dl((()=>{this.invokeCallHook(e,t),e=Wx(Ew(e),2);const n=this.poolingFunction(Ew(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Em(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class uN extends lN{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Cx(s),Ex(r),iN(e,t,n,r,s,"max")}}uN.className="MaxPooling1D",bc(uN);class cN extends lN{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Cx(s),Ex(r),iN(e,t,n,r,s,"avg")}}cN.className="AveragePooling1D",bc(cN);class dN extends Bw{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new Kv(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];fx(this.poolSize,"poolSize"),fx(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Cx(this.dataFormat),Ex(this.padding),this.inputSpec=[new Fw({ndim:4})]}computeOutputShape(e){e=$w(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=JS(t,this.poolSize[0],this.padding,this.strides[0]),n=JS(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Dl((()=>(this.invokeCallHook(e,t),this.poolingFunction(Ew(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class hN extends dN{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Cx(s),Ex(r),iN(e,t,n,r,s,"max")}}hN.className="MaxPooling2D",bc(hN);class pN extends dN{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Cx(s),Ex(r),iN(e,t,n,r,s,"avg")}}pN.className="AveragePooling2D",bc(pN);class fN extends Bw{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new Kv(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];fx(this.poolSize,"poolSize"),fx(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Cx(this.dataFormat),Ex(this.padding),this.inputSpec=[new Fw({ndim:5})]}computeOutputShape(e){e=$w(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=JS(t,this.poolSize[0],this.padding,this.strides[0]),n=JS(n,this.poolSize[1],this.padding,this.strides[1]),r=JS(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return Dl((()=>(this.invokeCallHook(e,t),this.poolingFunction(Ew(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class mN extends fN{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Cx(s),Ex(r),oN(e,t,n,r,s,"max")}}mN.className="MaxPooling3D",bc(mN);class gN extends fN{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return Cx(s),Ex(r),oN(e,t,n,r,s,"avg")}}gN.className="AveragePooling3D",bc(gN);class yN extends Bw{constructor(e){super(e),this.inputSpec=[new Fw({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Xv}}class bN extends yN{constructor(e){super(e||{})}call(e,t){return Dl((()=>{const t=Ew(e);return vf(t,1)}))}}bN.className="GlobalAveragePooling1D",bc(bN);class vN extends yN{constructor(e){super(e||{})}call(e,t){return Dl((()=>{const t=Ew(e);return Ap(t,1)}))}}vN.className="GlobalMaxPooling1D",bc(vN);class xN extends Bw{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Cx(this.dataFormat),this.inputSpec=[new Fw({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Xv}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class wN extends xN{call(e,t){return Dl((()=>{const t=Ew(e);return"channelsLast"===this.dataFormat?vf(t,[1,2]):vf(t,[2,3])}))}}wN.className="GlobalAveragePooling2D",bc(wN);class kN extends xN{call(e,t){return Dl((()=>{const t=Ew(e);return"channelsLast"===this.dataFormat?Ap(t,[1,2]):Ap(t,[2,3])}))}}kN.className="GlobalMaxPooling2D",bc(kN);class SN extends Bw{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const r=yk(t.layer,n);delete t.layer;const s={layer:r};return Object.assign(s,t),new e(s)}}class IN extends SN{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=$w(e)).length<3)throw new Kv(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=$w(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return Dl((()=>bI(((e,n)=>[Ew(this.layer.call(e,t)),[]]),e=Ew(e),[],!1,null,null,!1,!0)[1]))}}IN.className="TimeDistributed",bc(IN);class NN extends SN{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=yk(n),t.goBackwards=!0!==t.goBackwards;const r={};var s;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=yk(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,s=this.mergeMode,hx(Nx,"BidirectionalMergeMode",s),e.weights)throw new Xv("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(r=s.slice(1),t=s[0]):t=s[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):tx(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=yI(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const a=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new Kv("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const r=n.map((e=>new Fw({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new Xv("Support for constants in Bidirectional layers is not implemented yet.");const o=a[0]instanceof Mw;for(const e of a)if(e instanceof Mw!==o)throw new Kv("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Dl((()=>{const n=t.initialState;let r,s,a,i;if(null==n)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=sm(s,1)),"concat"===this.mergeMode?i=qx([r,s]):"sum"===this.mergeMode?i=Zu(r,s):"ave"===this.mergeMode?i=nc(.5,Zu(r,s)):"mul"===this.mergeMode?i=nc(r,s):null==this.mergeMode&&(i=[r,s]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Ox(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),Ox(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=yk(t.layer);if(delete t.layer,null!=t.numConstants)throw new Xv("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}NN.className="Bidirectional",bc(NN);class TN extends Bw{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Dl((()=>("float32"!==(e=Ew(e)).dtype&&(e=jx(e,"float32")),Zu(nc(e,this.scale),this.offset))))}}TN.className="Rescaling",bc(TN);const{resizeBilinear:CN,cropAndResize:EN}=hy;class $N extends Bw{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,i,o){return Dl((()=>{let l,u=!1;const c=[t/a,n/i,(r+t)/a,(s+n)/i],d=[];3===e.rank?(u=!0,l=$m([e])):l=e;for(let e=0;e<l.shape[0];e++)d.push(c);const h=Sl(d,[d.length,4]),p=em(0,d.length,1,"int32"),f=EN(l,h,p,[r,s],"nearest");return jx(u?Ew(Wm(f)):f,o)}))}upsize(e,t,n,r){return Dl((()=>jx(CN(e,[t,n]),r)))}call(e,t){return Dl((()=>{const t=Ew(e),n=t.dtype,r=t.shape,s=r[r.length-3],a=r[r.length-2];let i=0;s!==this.height&&(i=Math.floor((s-this.height)/2));let o=0;return a!==this.width&&(o=Math.floor((a-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,s,a,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=$w(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}$N.className="CenterCrop",bc($N);class _N extends Bw{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=$w(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Dl((()=>{let n;if("int32"!==(e=Ew(e)).dtype&&(e=jx(e,"int32")),void 0!==t.countWeights){if("count"!==this.outputMode)throw new Kv(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=Ew(t.countWeights)}const r=Ap(e),s=Dp(e),a=Hp(this.numTokens,r).bufferSync().get(0),i=qp(s,0).bufferSync().get(0);if(!a||!i)throw new Kv(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let s=Ew(e);if("int32"!==s.dtype&&(s=jx(s,"int32")),"int"===t)return s;const a=s.shape;if(0===s.rank&&(s=Bp(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=Bp(s,-1)),s.rank>2)throw new Kv(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t),o=s;let l;if(l=hp(o,void 0!==r&&"count"===t?r:[],n,i),"tfIdf"!==t)return l;if(r)return nc(l,r);throw new Kv("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}_N.className="CategoryEncoding",bc(_N);const ON=new Set(["bilinear","nearest"]);class RN extends Bw{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!ON.has(e.interpolation))throw new Kv(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=$w(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Dl((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return hy.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return hy.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...ON]} are supported`)}))}}RN.className="Resizing",bc(RN);class AN{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}AN.className="RandomSeed";class DN extends Bw{constructor(e){super(e),this.randomGenerator=new AN(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}DN.className="BaseRandomLayer";const FN=new Set(["bilinear","nearest"]);class MN extends DN{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new Kv(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new Kv(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new Kv(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!FN.has(n))throw new Kv(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=$w(e))[2];return[this.imgHeight,-1,t]}call(e,t){return Dl((()=>{const t=Ew(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=Jf([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return hy.resizeBilinear(e,s);case"nearest":return hy.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...FN]} are supported`)}}))}}MN.className="RandomWidth",bc(MN);var LN,zN;wr().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(LN||(LN={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(zN||(zN={}));const PN={};function BN(e){return PN[e]}function UN(e,t,n,r,s){const a=t.inputParams[e];if(a&&void 0!==a.inputIndexStart){const e=a.inputIndexStart,i=0===a.inputIndexEnd?void 0:void 0===a.inputIndexEnd?e+1:a.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===a.type)return jN(t.inputNames[o],n,r,s);if("tensors"===a.type){const a=t.inputs.slice(e,i),o=t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=a[t])||void 0===n?void 0:n.op)}));return o.map((e=>jN(e,n,r,s)))}const l=jN(t.inputNames[o],n,r,s),u=l.dataSync();return"number"===a.type?u[0]:ur(l.shape,u)}const i=t.attrParams[e];return i&&i.value}function jN(e,t,n,r){const[s,a]=HN(e,n);if(null!=r){const e=r.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find((e=>!!t[GN(s,e)]));return void 0!==i?t[GN(s,i)][a]:void 0}function WN(e,t,n){return t[GN(e,n.currentContextId)]}function VN(e,t){const[n,r,s]=HN(e,t);return[GN(n,t&&t.currentContextId),r,s]}function GN(e,t){return t?`${e}-${t}`:e}function HN(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const r=e.split(":");let s;if(1===r.length)s=[e,0,void 0];else{const e=r[0],t=3===r.length?r[1]:void 0;s=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,s),s}function qN(e,t,n){let r=UN("pad",e,t,n);if("explicit"===r){r=UN("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function KN(e){return e.kept?e:Qu(e)}const XN=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],YN=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],QN=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],JN=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],ZN=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],eT=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],tT=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],nT=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],rT=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],sT=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],aT=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],iT=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],oT=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],lT=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],uT=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],cT=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],dT=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],hT=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],pT=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class fT{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[v,x,w,k,S,I,N,T,C,E,$,_,O,R,A,D,F,M,L].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){const n=e.node,r=[],s=[],a=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||a.push(e[t.name]),e)),{});let o=[];const l=[];let u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const d=Object.keys(i);d.forEach((e=>{const t=i[e];t.inputNames.forEach(((e,n)=>{const[r,,s]=VN(e),a=i[r];if(null!=a.outputs){const e=a.outputs.indexOf(s);if(-1!==e){const s=`${r}:${e}`;t.inputNames[n]=s}}t.inputs.push(a),a.children.push(t)}))})),0===Object.keys(c).length?d.forEach((e=>{const t=i[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{const[t]=VN(e),n=i[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{const[t]=VN(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:i,inputs:o,outputs:l,weights:s,placeholders:r,signature:t,functions:h};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=BN(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let s;switch(n.type){case"string":s=gT(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=gT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=TT(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=TT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=bT(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=bT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=NT(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=NT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=yT(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=yT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=ET(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=ET(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=IT(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=IT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=CT(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=CT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=wT(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=wT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=kT(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=kT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=xT(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=xT(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:s,type:r},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const s=[],a=[];e.signature.inputArg.forEach((e=>{const[t]=VN(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:vT(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),r[t]=n}));Object.keys(r).forEach((e=>{const t=r[e];t.inputNames.forEach(((e,n)=>{const[s,,a]=VN(e),i=r[s];if(null!=i.outputs){const e=i.outputs.indexOf(a);if(-1!==e){const r=`${s}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)}))}));const i=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=VN(i[e.name]),s=r[t];null!=s&&(s.defaultOutput=n,a.push(s))}));const o=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:a,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function mT(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=wr().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function gT(e,t,n,r=!1){const s=e[t];return null!=s?mT(s.s,r):n}function yT(e,t,n){const r=e[t];return r?r.b:n}function bT(e,t,n){const r=e[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof s?s:parseInt(s,10)}function vT(e){switch("string"==typeof e&&(e=LN[e]),e){case LN.DT_FLOAT:case LN.DT_HALF:return"float32";case LN.DT_INT32:case LN.DT_INT64:case LN.DT_INT8:case LN.DT_UINT8:return"int32";case LN.DT_BOOL:return"bool";case LN.DT_DOUBLE:return"float32";case LN.DT_STRING:return"string";case LN.DT_COMPLEX64:case LN.DT_COMPLEX128:return"complex64";default:return null}}function xT(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function wT(e,t,n){const r=e[t];return r&&r.type?vT(r.type):n}function kT(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>vT(e))):n}function ST(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function IT(e,t,n){const r=e[t];return r&&r.shape?ST(r.shape):n}function NT(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function TT(e,t,n,r=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map((e=>mT(e,r))):n}function CT(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>ST(e))):n}function ET(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class $T{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return jN(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return jN(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return bT(this.node.rawAttrs,e,t);if(null!=n.s)return gT(this.node.rawAttrs,e,t);if(null!=n.b)return yT(this.node.rawAttrs,e,t);if(null!=n.shape)return IT(this.node.rawAttrs,e,t);if(null!=n.type)return wT(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return NT(this.node.rawAttrs,e,t);if(null!=n.list.s)return TT(this.node.rawAttrs,e,t);if(null!=n.list.shape)return CT(this.node.rawAttrs,e,t);if(null!=n.list.b)return ET(this.node.rawAttrs,e,t);if(null!=n.list.type)return kT(this.node.rawAttrs,e,t)}return t}}function _T(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){Rn(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){const s=e[r],a=t[r];Rn(s<0||a<0||s===a,(()=>n+` Shapes ${e} and ${t} must match`))}}}function OT(e){return"number"!=typeof e&&!e.some((e=>e<0))}function RT(e,t,n){let r=AT(e,n);const s=!OT(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach((e=>{r=AT(e.shape,r)})),!OT(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function AT(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}class DT{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=pc(0),Ml(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),_T(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Ml(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Sl([],[0].concat(this.elementShape));const n=this.readMany(e);return _T(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),$m(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return Sl([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const n=this.readMany(t);return _T(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Fh(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Wm(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:t.size/n,a=[];Dl((()=>{t=Rh(t,[1,n,s]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:r[n-1],0],o=[1,e[n],s];a[n]=Rh(Lh(t,i,o),this.elementShape)}return a}));const i=[];for(let t=0;t<e.length;t++)i[t]=t;this.writeMany(i,a)}}class FT{get id(){return this.idTensor.id}constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);_T(t,e.shape,"TensorList shape mismatch: "),Ml(e)})),this.idTensor=pc(0),this.maxNumElements=r,Ml(this.idTensor)}copy(){return new FT([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);_T(e,this.elementShape,"TensorList shape mismatch: ");const r=RT(this.elementShape,this.tensors,e);return Dl((()=>{const e=this.tensors.map((e=>Rh(e,r)));return $m(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=RT(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,_T(r.shape,e,"TensorList shape mismatch: "),Rh(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(_T(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ml(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new FT([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);_T(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=RT(this.elementShape,this.tensors,t);return Rh(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);_T(this.elementShape,t.shape,"TensorList shape mismatch: "),Ml(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);_T(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=RT(this.elementShape,this.tensors,n);return 0===e.length?Sl([],[0].concat(r)):Dl((()=>{const t=e.map((e=>Rh(this.tensors[e],r)));return $m(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);_T(this.elementShape,t,"TensorList shape mismatch: ");const n=RT(this.elementShape,this.tensors,t);return 0===this.size()?Sl([],[0].concat(n)):Dl((()=>{const e=this.tensors.map((e=>Rh(e,n)));return Fh(e,0)}))}}const MT=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=UN("thenBranch",e,t,n),s=UN("elseBranch",e,t,n),a=UN("cond",e,t,n),i=UN("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=UN("body",e,t,n),s=UN("cond",e,t,n),a=UN("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map((e=>e.id));let l=await i[0].data();i.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()}));let u=a;for(;l[0];){const e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map((e=>e.id));e.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const a=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await a[0].data(),a.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return u}case"LoopCond":return[KN(UN("pred",e,t,n))];case"Switch":{const r=UN("pred",e,t,n);let s=UN("data",e,t,n);return s.kept||(s=KN(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==jN(e,t,n)));if(r){return[KN(jN(r,t,n))]}return}case"Enter":{const r=UN("frameName",e,t,n),s=UN("tensor",e,t,n);return n.enterFrame(r),[KN(s)]}case"Exit":{const r=UN("tensor",e,t,n);return n.exitFrame(),[KN(r)]}case"NextIteration":{const r=UN("tensor",e,t,n);return n.nextIteration(),[KN(r)]}case"TensorArrayV3":{const r=UN("size",e,t,n),s=UN("dtype",e,t,n),a=UN("elementShape",e,t,n),i=UN("dynamicSize",e,t,n),o=UN("clearAfterRead",e,t,n),l=UN("identicalElementShapes",e,t,n),u=UN("name",e,t,n),c=new DT(u,s,r,a,l,i,o);return n.addTensorArray(c),[c.idTensor,pc(1)]}case"TensorArrayWriteV3":{const r=UN("tensorArrayId",e,t,n),s=UN("index",e,t,n),a=UN("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{const r=UN("tensorArrayId",e,t,n),s=UN("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=UN("tensorArrayId",e,t,n),s=UN("indices",e,t,n),a=UN("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=UN("tensorArrayId",e,t,n),s=UN("indices",e,t,n),a=UN("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{const r=UN("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=UN("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=UN("tensorArrayId",e,t,n),s=UN("tensor",e,t,n),a=UN("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{const r=UN("tensorArrayId",e,t,n);return[pc(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=UN("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=UN("tensorListId",e,t,n),s=UN("index",e,t,n),a=UN("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{const r=UN("tensorListId",e,t,n),s=UN("index",e,t,n),a=UN("elementShape",e,t,n),i=UN("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=UN("indices",e,t,n),s=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new FT([],n,e.dtype,r),i=Wm(e,0);return t.forEach(((e,t)=>{a.setItem(e,i[t])})),a}(UN("tensor",e,t,n),r,UN("elementShape",e,t,n),UN("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=UN("elementShape",e,t,n),s=UN("elementDType",e,t,n);let a;a="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=UN(a,e,t,n),o=function(e,t,n,r){return new FT([],e,t,r)}(r,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const r=UN("tensorListId",e,t,n),s=UN("indices",e,t,n),a=UN("elementShape",e,t,n),i=UN("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{const r=UN("tensorListId",e,t,n),s=UN("elementShape",e,t,n),a=UN("elementDType",e,t,n),i=UN("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);_T(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=Wm(e);return new FT(s,t,r)}(UN("tensor",e,t,n),UN("elementShape",e,t,n),UN("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=UN("tensorListId",e,t,n),s=n.getTensorList(r.id),a=UN("dtype",e,t,n),i=UN("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{const r=UN("tensorListId",e,t,n),s=UN("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=UN("tensorListId",e,t,n),s=UN("elementShape",e,t,n),a=UN("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=UN("tensor",e,t,n),s=UN("elementShape",e,t,n),a=function(e,t,n){let r=0;const s=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const a=AT(e.shape.slice(1),n),i=0===r?0:e.size/r,o=Dl((()=>{const n=[];e=Rh(e,[1,r,i]);for(let r=0;r<t.length;++r){const o=[0,0===r?0:s[r-1],0],l=[1,t[r],i];n[r]=Rh(Lh(e,o,l),a)}return e.dispose(),n})),l=new FT([],n,e.dtype,t.length);for(let e=0;e<o.length;e++)l.setItem(e,o[e]);return l}(r,UN("lengths",e,t,n),s);return n.addTensorList(a),[a.idTensor]}case"TensorListLength":{const r=UN("tensorListId",e,t,n);return[pc(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{const r=UN("tensorListId",e,t,n),s=UN("size",e,t,n),a=n.getTensorList(r.id).resize(s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function LT(e,t,n){const[r,s]=UN("fusedOps",e,t,n),a="biasadd"===r,i=!a,o="prelu"===s,l="fusedbatchnorm"===r,u=UN("numArgs",e,t,n);if(a){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=UN("strides",e,t,n),d=qN(e,t,n),h=UN("dataFormat",e,t,n).toUpperCase(),p=UN("dilations",e,t,n);let[f,m]=UN("args",e,t,n);i&&(m=f,f=void 0);return{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:UN("leakyreluAlpha",e,t,n)}}function zT(e,t,n){return{boxes:UN("boxes",e,t,n),scores:UN("scores",e,t,n),maxOutputSize:UN("maxOutputSize",e,t,n),iouThreshold:UN("iouThreshold",e,t,n),scoreThreshold:UN("scoreThreshold",e,t,n),softNmsSigma:UN("softNmsSigma",e,t,n)}}class PT{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=pc(0),this.tensorMap=new Map,Ml(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return pc(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),Dl((()=>{const e=Wm(t),r=n.length,s=e.length;Rn(r===s,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`));for(let t=0;t<r;t++){const r=n[t],s=e[t];Ml(s),this.tensorMap.set(r,s)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return Dl((()=>{const e=[];for(let r=0;r<n.length;r++){const s=n[r],a=this.findWithDefault(s,t);e.push(a)}return $m(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function BT(e,t,n,r,s=Dl){const a=((e,t,n)=>{switch(e.category){case"arithmetic":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(UN("a",e,t,n),UN("b",e,t,n))];case"AddN":return[r.addN(UN("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(UN("a",e,t,n),UN("b",e,t,n))];case"Mul":return[r.mul(UN("a",e,t,n),UN("b",e,t,n))];case"RealDiv":case"Div":return[r.div(UN("a",e,t,n),UN("b",e,t,n))];case"DivNoNan":return[r.divNoNan(UN("a",e,t,n),UN("b",e,t,n))];case"FloorDiv":return[r.floorDiv(UN("a",e,t,n),UN("b",e,t,n))];case"Sub":return[r.sub(UN("a",e,t,n),UN("b",e,t,n))];case"Minimum":return[r.minimum(UN("a",e,t,n),UN("b",e,t,n))];case"Maximum":return[r.maximum(UN("a",e,t,n),UN("b",e,t,n))];case"Pow":return[r.pow(UN("a",e,t,n),UN("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(UN("a",e,t,n),UN("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"basic_math":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(UN("x",e,t,n))];case"Acos":return[r.acos(UN("x",e,t,n))];case"Acosh":return[r.acosh(UN("x",e,t,n))];case"Asin":return[r.asin(UN("x",e,t,n))];case"Asinh":return[r.asinh(UN("x",e,t,n))];case"Atan":return[r.atan(UN("x",e,t,n))];case"Atan2":return[r.atan2(UN("x",e,t,n),UN("y",e,t,n))];case"Atanh":return[r.atanh(UN("x",e,t,n))];case"Ceil":return[r.ceil(UN("x",e,t,n))];case"Complex":return[r.complex(UN("real",e,t,n),UN("imag",e,t,n))];case"Cos":return[r.cos(UN("x",e,t,n))];case"Cosh":return[r.cosh(UN("x",e,t,n))];case"Elu":return[r.elu(UN("x",e,t,n))];case"Erf":return[r.erf(UN("x",e,t,n))];case"Exp":return[r.exp(UN("x",e,t,n))];case"Expm1":return[r.expm1(UN("x",e,t,n))];case"Floor":return[r.floor(UN("x",e,t,n))];case"Log":return[r.log(UN("x",e,t,n))];case"Log1p":return[r.log1p(UN("x",e,t,n))];case"Imag":return[r.imag(UN("x",e,t,n))];case"Neg":return[r.neg(UN("x",e,t,n))];case"Reciprocal":return[r.reciprocal(UN("x",e,t,n))];case"Real":return[r.real(UN("x",e,t,n))];case"Relu":return[r.relu(UN("x",e,t,n))];case"Round":return[r.round(UN("x",e,t,n))];case"Selu":return[r.selu(UN("x",e,t,n))];case"Sigmoid":return[r.sigmoid(UN("x",e,t,n))];case"Sin":return[r.sin(UN("x",e,t,n))];case"Sign":return[r.sign(UN("x",e,t,n))];case"Sinh":return[r.sinh(UN("x",e,t,n))];case"Softplus":return[r.softplus(UN("x",e,t,n))];case"Sqrt":return[r.sqrt(UN("x",e,t,n))];case"Square":return[r.square(UN("x",e,t,n))];case"Tanh":return[r.tanh(UN("x",e,t,n))];case"Tan":return[r.tan(UN("x",e,t,n))];case"ClipByValue":return[r.clipByValue(UN("x",e,t,n),UN("clipValueMin",e,t,n),UN("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(UN("x",e,t,n))];case"Rsqrt":return[r.rsqrt(jN(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(UN("x",e,t,n),UN("alpha",e,t,n))];case"Prelu":return[r.prelu(UN("x",e,t,n),UN("alpha",e,t,n))];case"IsNan":return[r.isNaN(jN(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(jN(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(jN(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"control":return MT(e,t,n);case"convolution":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"Conv1D":{const s=UN("stride",e,t,n),a=UN("pad",e,t,n),i=UN("dataFormat",e,t,n).toUpperCase(),o=UN("dilation",e,t,n);return[r.conv1d(UN("x",e,t,n),UN("filter",e,t,n),s,a,i,o)]}case"Conv2D":{const s=UN("strides",e,t,n),a=qN(e,t,n),i=UN("dataFormat",e,t,n).toUpperCase(),o=UN("dilations",e,t,n);return[r.conv2d(UN("x",e,t,n),UN("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=LT(e,t,n);return[r.fused.conv2d({x:UN("x",e,t,n),filter:UN("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=LT(e,t,n);return[r.fused.depthwiseConv2d({x:UN("x",e,t,n),filter:UN("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=UN("outputShape",e,t,n),a=UN("strides",e,t,n),i=qN(e,t,n);return[r.conv2dTranspose(UN("x",e,t,n),UN("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=UN("strides",e,t,n),a=qN(e,t,n),i=UN("dilations",e,t,n),o=UN("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(UN("input",e,t,n),UN("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const s=UN("strides",e,t,n),a=UN("pad",e,t,n),i=UN("dataFormat",e,t,n).toUpperCase(),o=UN("dilations",e,t,n);return[r.conv3d(UN("x",e,t,n),UN("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=UN("strides",e,t,n),a=UN("pad",e,t,n),i=UN("kernelSize",e,t,n);return[r.avgPool(UN("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=UN("strides",e,t,n),a=UN("pad",e,t,n),i=UN("kernelSize",e,t,n);return[r.maxPool(UN("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=UN("strides",e,t,n),a=UN("pad",e,t,n),i=UN("kernelSize",e,t,n),o=UN("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(UN("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[l,u]}case"AvgPool3D":{const s=UN("strides",e,t,n),a=UN("pad",e,t,n),i=UN("kernelSize",e,t,n);return[r.avgPool3d(UN("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=UN("strides",e,t,n),a=UN("pad",e,t,n),i=UN("kernelSize",e,t,n);return[r.maxPool3d(UN("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=UN("strides",e,t,n),a=UN("pad",e,t,n),i=UN("dilations",e,t,n),o=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(UN("x",e,t,n),UN("filter",e,t,n),[o,l],a,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"creation":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"Fill":{const s=UN("shape",e,t,n),a=UN("dtype",e,t,n),i=UN("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{const s=UN("start",e,t,n),a=UN("stop",e,t,n),i=UN("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{const s=UN("logits",e,t,n),a=UN("numSamples",e,t,n),i=UN("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{const s=UN("indices",e,t,n),a=UN("depth",e,t,n),i=UN("onValue",e,t,n),o=UN("offValue",e,t,n),l=UN("dtype",e,t,n);return[r.oneHot(s,a,i,o,l)]}case"Ones":return[r.ones(UN("shape",e,t,n),UN("dtype",e,t,n))];case"OnesLike":return[r.onesLike(UN("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(UN("shape",e,t,n),UN("dtype",e,t,n),UN("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(UN("shape",e,t,n),UN("minval",e,t,n),UN("maxval",e,t,n),UN("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(UN("shape",e,t,n),UN("minval",e,t,n),UN("maxval",e,t,n),UN("seed",e,t,n))];case"Range":{const s=UN("start",e,t,n),a=UN("stop",e,t,n),i=UN("step",e,t,n);return[r.range(s,a,i,UN("dtype",e,t,n))]}case"TruncatedNormal":{const s=UN("shape",e,t,n),a=UN("mean",e,t,n),i=UN("stdDev",e,t,n),o=UN("seed",e,t,n);return[r.truncatedNormal(s,a,i,UN("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(UN("shape",e,t,n),UN("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(UN("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"dynamic":return(async(e,t,n,r,s=z)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=zT(e,t,n),c=await s.image.nonMaxSuppressionWithScoreAsync(r,a,i,o,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=zT(e,t,n),u=UN("padToMaxOutputSize",e,t,n),c=await s.image.nonMaxSuppressionPaddedAsync(r,a,i,o,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=zT(e,t,n);return[await s.image.nonMaxSuppressionAsync(r,a,i,o,l)]}case"Where":{const r=s.cast(UN("condition",e,t,n),"bool"),a=[await s.whereAsync(r)];return r.dispose(),a}case"ListDiff":return s.setdiff1dAsync(UN("x",e,t,n),UN("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"evaluation":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"LowerBound":{const s=UN("sortedSequence",e,t,n),a=UN("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=UN("x",e,t,n),a=UN("k",e,t,n),i=UN("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{const s=UN("sortedSequence",e,t,n),a=UN("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{const s=UN("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=UN("x",e,t,n),a=UN("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"image":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"ResizeBilinear":{const s=UN("images",e,t,n),a=UN("size",e,t,n),i=UN("alignCorners",e,t,n),o=UN("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const s=UN("images",e,t,n),a=UN("size",e,t,n),i=UN("alignCorners",e,t,n),o=UN("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{const s=UN("image",e,t,n),a=UN("boxes",e,t,n),i=UN("boxInd",e,t,n),o=UN("cropSize",e,t,n),l=UN("method",e,t,n),u=UN("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,l,u)]}case"ImageProjectiveTransformV3":{const s=UN("images",e,t,n),a=UN("transforms",e,t,n),i=UN("outputShape",e,t,n),o=UN("fillValue",e,t,n),l=UN("interpolation",e,t,n),u=UN("fillMode",e,t,n);return[r.image.transform(s,a,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"graph":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const s=UN("default",e,t,n);return[jN(e.name,t,n)||s];case"Placeholder":return[jN(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[KN(UN("x",e,t,n))];case"IdentityN":return UN("x",e,t,n).map((e=>KN(e)));case"Shape":return[r.tensor1d(UN("x",e,t,n).shape,"int32")];case"ShapeN":return UN("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(UN("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(UN("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const a=UN("x",e,t,n),i=UN("data",e,t,n);UN("message",e,t,n),UN("summarize",e,t,n);for(let e=0;e<i.length;e++);return[a];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"logical":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"Equal":return[r.equal(UN("a",e,t,n),UN("b",e,t,n))];case"NotEqual":return[r.notEqual(UN("a",e,t,n),UN("b",e,t,n))];case"Greater":return[r.greater(UN("a",e,t,n),UN("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(UN("a",e,t,n),UN("b",e,t,n))];case"Less":return[r.less(UN("a",e,t,n),UN("b",e,t,n))];case"LessEqual":return[r.lessEqual(UN("a",e,t,n),UN("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(UN("a",e,t,n),UN("b",e,t,n))];case"LogicalNot":return[r.logicalNot(UN("a",e,t,n))];case"LogicalOr":return[r.logicalOr(UN("a",e,t,n),UN("b",e,t,n))];case"Select":case"SelectV2":return[r.where(UN("condition",e,t,n),UN("a",e,t,n),UN("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(UN("a",e,t,n),UN("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"matrices":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(UN("a",e,t,n),UN("b",e,t,n),UN("transposeA",e,t,n),UN("transposeB",e,t,n))];case"Einsum":return[r.einsum(UN("equation",e,t,n),...UN("tensors",e,t,n))];case"Transpose":return[r.transpose(UN("x",e,t,n),UN("perm",e,t,n))];case"_FusedMatMul":const[s,a]=UN("fusedOps",e,t,n),i="biasadd"===s,o="prelu"===a,l=UN("numArgs",e,t,n),u=UN("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=UN("args",e,t,n);return[r.fused.matMul({a:UN("a",e,t,n),b:UN("b",e,t,n),transposeA:UN("transposeA",e,t,n),transposeB:UN("transposeB",e,t,n),bias:c,activation:a,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(UN("a",e,t,n),UN("numLower",e,t,n),UN("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"normalization":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(UN("x",e,t,n),UN("axis",e,t,n),UN("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(UN("x",e,t,n),UN("mean",e,t,n),UN("variance",e,t,n),UN("offset",e,t,n),UN("scale",e,t,n),UN("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(UN("x",e,t,n),UN("radius",e,t,n),UN("bias",e,t,n),UN("alpha",e,t,n),UN("beta",e,t,n))];case"Softmax":return[r.softmax(UN("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(UN("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"ragged":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(UN("paramsNestedSplits",e,t,n),UN("paramsDenseValues",e,t,n),UN("indices",e,t,n),UN("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(UN("starts",e,t,n),UN("limits",e,t,n),UN("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(UN("shape",e,t,n),UN("values",e,t,n),UN("defaultValue",e,t,n),UN("rowPartitionTensors",e,t,n),UN("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"reduction":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"Max":{const s=UN("axis",e,t,n),a=UN("keepDims",e,t,n);return[r.max(UN("x",e,t,n),s,a)]}case"Mean":{const s=UN("axis",e,t,n),a=UN("keepDims",e,t,n);return[r.mean(UN("x",e,t,n),s,a)]}case"Min":{const s=UN("axis",e,t,n),a=UN("keepDims",e,t,n);return[r.min(UN("x",e,t,n),s,a)]}case"Sum":{const s=UN("axis",e,t,n),a=UN("keepDims",e,t,n);return[r.sum(UN("x",e,t,n),s,a)]}case"All":{const s=UN("axis",e,t,n),a=UN("keepDims",e,t,n);return[r.all(UN("x",e,t,n),s,a)]}case"Any":{const s=UN("axis",e,t,n),a=UN("keepDims",e,t,n);return[r.any(UN("x",e,t,n),s,a)]}case"ArgMax":{const s=UN("axis",e,t,n);return[r.argMax(UN("x",e,t,n),s)]}case"ArgMin":{const s=UN("axis",e,t,n);return[r.argMin(UN("x",e,t,n),s)]}case"Prod":{const s=UN("axis",e,t,n),a=UN("keepDims",e,t,n);return[r.prod(UN("x",e,t,n),s,a)]}case"Cumprod":{const s=UN("axis",e,t,n),a=UN("exclusive",e,t,n),i=UN("reverse",e,t,n);return[r.cumprod(UN("x",e,t,n),s,a,i)]}case"Cumsum":{const s=UN("axis",e,t,n),a=UN("exclusive",e,t,n),i=UN("reverse",e,t,n);return[r.cumsum(UN("x",e,t,n),s,a,i)]}case"Bincount":const s=UN("x",e,t,n),a=UN("weights",e,t,n),i=UN("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{const s=UN("x",e,t,n),a=UN("weights",e,t,n),i=UN("size",e,t,n),o=UN("binaryOutput",e,t,n);return[r.denseBincount(s,a,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"slice_join":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"ConcatV2":case"Concat":{const s=UN("n",e,t,n),a=UN("axis",e,t,n);let i=UN("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{const s=UN("x",e,t,n),a=UN("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=UN("axis",e,t,n),a=UN("batchDims",e,t,n),i=UN("x",e,t,n),o=UN("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{const s=UN("dims",e,t,n),a=[];for(let e=0;e<s.length;e++)s[e]&&a.push(e);const i=UN("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{const s=UN("axis",e,t,n),a=UN("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{const s=UN("begin",e,t,n),a=UN("size",e,t,n);return[r.slice(UN("x",e,t,n),s,a)]}case"StridedSlice":{const s=UN("begin",e,t,n),a=UN("end",e,t,n),i=UN("strides",e,t,n),o=UN("beginMask",e,t,n),l=UN("endMask",e,t,n),u=UN("ellipsisMask",e,t,n),c=UN("newAxisMask",e,t,n),d=UN("shrinkAxisMask",e,t,n),h=UN("x",e,t,n);return[r.stridedSlice(h,s,a,i,o,l,u,c,d)]}case"Pack":return Dl((()=>{const s=UN("axis",e,t,n),a=UN("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,l=a.map((e=>{const t=zn(e.shape,i);if(!t&&!zn(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(l,s)]}));case"Unpack":{const s=UN("axis",e,t,n),a=UN("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{const s=UN("reps",e,t,n);return[r.tile(UN("x",e,t,n),s)]}case"Split":case"SplitV":{const s=UN("axis",e,t,n),a=UN("numOrSizeSplits",e,t,n),i=UN("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{const s=UN("indices",e,t,n),a=UN("values",e,t,n),i=UN("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{const s=UN("x",e,t,n),a=UN("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=UN("sparseIndices",e,t,n),a=UN("outputShape",e,t,n),i=UN("sparseValues",e,t,n),o=UN("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const s=UN("indices",e,t,n),a=UN("values",e,t,n),i=UN("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"sparse":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(UN("indices",e,t,n),UN("values",e,t,n),UN("denseShape",e,t,n),UN("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(UN("inputIndices",e,t,n),UN("inputShape",e,t,n),UN("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(UN("data",e,t,n),UN("indices",e,t,n),UN("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(UN("data",e,t,n),UN("indices",e,t,n),UN("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"spectral":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"FFT":return[r.fft(UN("x",e,t,n))];case"IFFT":return[r.ifft(UN("x",e,t,n))];case"RFFT":return[r.rfft(UN("x",e,t,n))];case"IRFFT":return[r.irfft(UN("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"string":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(UN("input",e,t,n),UN("pattern",e,t,n),UN("rewrite",e,t,n),UN("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(UN("data",e,t,n),UN("dataSplits",e,t,n),UN("separator",e,t,n),UN("nGramWidths",e,t,n),UN("leftPad",e,t,n),UN("rightPad",e,t,n),UN("padWidth",e,t,n),UN("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:i}=r.string.stringSplit(UN("input",e,t,n),UN("delimiter",e,t,n),UN("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(UN("input",e,t,n),UN("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"transformation":return s((()=>((e,t,n,r=z)=>{switch(e.op){case"Cast":return[r.cast(UN("x",e,t,n),UN("dtype",e,t,n))];case"ExpandDims":{const s=UN("axis",e,t,n);return[r.expandDims(UN("x",e,t,n),s)]}case"Squeeze":{const s=UN("axis",e,t,n);return[r.squeeze(UN("x",e,t,n),s)]}case"Reshape":return[r.reshape(UN("x",e,t,n),UN("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(UN("x",e,t,n),UN("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(UN("x",e,t,n),UN("padding",e,t,n),UN("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(UN("x",e,t,n),UN("padding",e,t,n),UN("constantValue",e,t,n))];case"SpaceToBatchND":{const s=UN("blockShape",e,t,n),a=UN("paddings",e,t,n);return[r.spaceToBatchND(UN("x",e,t,n),s,a)]}case"BatchToSpaceND":{const s=UN("blockShape",e,t,n),a=UN("crops",e,t,n);return[r.batchToSpaceND(UN("x",e,t,n),s,a)]}case"DepthToSpace":{const s=UN("blockSize",e,t,n),a=UN("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(UN("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(UN("x",e,t,n),UN("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(UN("s0",e,t,n),UN("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(e.name);if(null!=s)return[s];{const s=UN("keyDType",e,t,n),a=UN("valueDType",e,t,n),i=new PT(s,a);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=UN("tableHandle",e,t,n,r),a=UN("keys",e,t,n),i=UN("values",e,t,n),o=r.getHashTableById(s.id);return[await o.import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=UN("tableHandle",e,t,n,r),a=UN("keys",e,t,n),i=UN("defaultValue",e,t,n),o=r.getHashTableById(s.id);return[await o.find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=UN("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":const a=BN(e.op);if(a&&a.customExecutor)return a.customExecutor(new $T(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return yr(a)?a.then((e=>[].concat(e))):[].concat(a)}class UT{constructor(e={},t={},n={},r={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function jT(e,t,n,r){const s=new Set,a=[];let i=null,o=null;const l=new Set,u=new Set(Object.keys(e).map((e=>HN(e)[0])));r=r||[];const c=new Set(r.map((e=>HN(e.name)[0]))),d=[...t];for(;d.length>0;){const e=d.pop();(KT(e)||XT(e)||YT(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>s.has(e)))),s.add(e.name),null==n[e.name]&&(u.has(e.name)||c.has(e.name)||(0!==e.inputs.length?e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),d.push(e))})):a.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}function WT(e,t){const{usedNodes:n,inputs:r}=t,s=Object.keys(r).map((e=>HN(e)[0])).map((t=>e.nodes[t])),a=e.initNodes||[],i=e=>n.has("string"==typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}const l=o([...s,...e.weights,...a]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map((e=>[e.name,e]))),d={};for(const e of u){d[e.name]=d[e.name]||0;for(const t of e.children)i(t)||(d[t.name]=Number.POSITIVE_INFINITY),d[t.name]=(d[t.name]||0)+1}const h=Object.entries(d).filter((([,e])=>0===e)).map((([e])=>e)),p=[...h];for(;h.length>0;){const e=h.pop(),t=c.get(e);for(const e of t.children.filter(i))0==--d[e.name]&&(p.push(e.name),h.push(e.name))}const f=function(e,t){const n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),s=new Set(r);for(;r.length>0;){const e=r.pop(),t=n.get(e);for(const e of t.children)n.has(e.name)&&!s.has(e.name)&&(s.add(e.name),r.push(e.name))}const a=e.filter((e=>s.has(e.name)));return a}(p.map((e=>c.get(e))),l);return function(e,t){const n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),s=e=>r.has("string"==typeof e?e:e.name),a=new Set(e.map((e=>e.name))),i=e=>a.has("string"==typeof e?e:e.name);for(const t of e){for(const e of t.children.filter(i)){if(!n.has(e.name))throw new VT(`Child ${e.name} of node ${t.name} is unreachable.`);if(n.get(t.name)>n.get(e.name))throw new VT(`Node ${t.name} is scheduled to run after its child ${e.name}.`)}if(!s(t))for(const e of t.inputs){if(!n.has(e.name))throw new VT(`Input ${e.name} of node ${t.name} is unreachable.`);if(n.get(e.name)>n.get(t.name))throw new VT(`Node ${t.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}class VT extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}const GT=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),HT=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),qT=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function KT(e){return GT.has(e.op)}function XT(e){return HT.has(e.op)}function YT(e){return qT.has(e.op)}class QT{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new QT(e.functions[t],this)}))}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const n=jT(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const n=t.map((e=>e.name)),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}const i=WT(this.graph,n),o=function(e){const t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>KT(e)?n:t)),s=e=>{const n=r[t.get(e.name)];return null==n?-1:n},a=e.map(((e,t)=>e.children.map(s).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let t=0;t<e.length;++t){const r=a[t];if(r===n)continue;const s=e[t],o=e[r];i.has(o.name)||i.set(o.name,[]),i.get(o.name).push(s)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return Ml(t),t}cloneTensorList(e){if(!e)return null;const t=e.map((e=>this.cloneAndKeepTensor(e)));return t}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((([e,t])=>[e,this.cloneTensorList(t)])))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[HN(e)[0]])),s=t.map((e=>HN(e)[0])),a=new Set(s);let i=s.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const o=this.getCompilationKey(r,i);let l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=wr().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1}const u={},c={};return Dl((()=>{const n=new UT(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{const[s,a]=HN(t,n),i=[];i[a]=e[t],r[s]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[s]=this.cloneTensorList(i))}));const s=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(const e of i){if(r[e.name])continue;const t=BT(e,r,n,this._resourceManager);if(yr(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,s,a,o.get(e.name))}return null==this.parent&&n.dispose(s),t.map((e=>jN(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,i){if(!KT(t)&&!a.has(e)){for(const r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(const e of t.inputs){if(KT(e))continue;const t=WN(e.name,n,r);if(null!=t)for(const e of t){if(!e||e.kept||s.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,s,a){function i(e){return KT(e)||s.has(e.name)}if(!KT(e)&&null!=a)for(const e of a){if(i(e))continue;const s=WN(e.name,t,n);for(const e of s)!e||e.kept||r.has(e.id)||e.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,r={},s={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=wr().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1}const a=new UT(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,a,t,n),o=t.map((e=>jN(e,i,a))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),c=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{!e||e.isDisposed||c.has(e.id)||e.dispose()}))})),null==this.parent&&a.dispose(c),o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const s=Object.keys(e),a=s.map((e=>this.graph.nodes[HN(e)[0]])),i=n.map((e=>HN(e)[0])),o=new Set(i);let l=i.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:d,syncInputs:h}=jT(e,l,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=HN(t),s=[];s[r]=e[t],f[n]=s}));const m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=this.processStack(a,p,t,f,y,g,o,m,u);await Promise.all(e)}const b=l.filter((e=>!KT(e)&&!jN(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=d&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,s,a,i,o,l){const u=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&UN("isConstant",e.node,r,n)&&([c]=VN(e.node.name,n)),null==r[e.node.name]){const d=BT(e.node,r,n,this._resourceManager);c||([c]=VN(e.node.name,n));const h=n.currentContext;yr(d)?u.push(d.then((u=>(r[c]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(u)),n.currentContext=h,this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l),u)))):(r[c]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(d)),this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l))}else this.processChildNodes(e.node,t,n,r,s,l)}return u}processChildNodes(e,t,n,r,s,a){e.children.forEach((e=>{const[i]=VN(e.name,n);!s[i]&&a.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!jN(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!jN(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[r]=HN(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value;Rn(e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t)),(()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}s.attrParams.dtype&&s.attrParams.dtype.value&&Rn(n.dtype===s.attrParams.dtype.value,(()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;const r={};for(const s in e){const a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[s];null!=a?r[a.name]=e[s]:r[s]=e[s]}return r}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=HN(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=HN(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class JT{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const ZT="?tfjs-format=file",eC="model.json";class tC{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=o){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new JT}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return yr(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await eu(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new QT(fT.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=fT.Instance.transformGraph(e.modelInitializer);this.initializer=new QT(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t={};return(e instanceof Po?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Po||Array.isArray(e))){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var s,a,i;const o=null===(i=null===(a=null===(s=this.signature)||void 0===s?void 0:s.inputs)||void 0===a?void 0:a[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){const s=t[n[r]];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Fl(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function nC(e,t={},n=o){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=function(e){e.endsWith("/")||(e+="/");return`${e}${eC}${ZT}`}(e));const r=new tC(e,t,n);return await r.load(),r}function rC(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(oC(e)){const s=Array.isArray(e)?[]:{};r.add(e);for(const a in e){const i=rC(e[a],t,n,r);s[a]=i}return r.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,s.value),s.value}function sC(e,t=iC){return aC(e,t)}function aC(e,t,n=new Set){const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(oC(r)){const s=Array.isArray(r)?[]:{};n.add(r);for(const a in r){const r=aC(e.map((e=>e[a])),t,n);s[a]=r}return n.delete(r),s}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return s.value}function iC(e){return null===e?null:oC(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function oC(e){let t=!1;if(wr().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:r}=n(932);t=e instanceof r}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof Po)&&!(e instanceof Promise)&&!t)}function lC(e){return function(e,t){return rC(e,t)}(e,uC)}function uC(e){return e instanceof Po?{value:e.clone(),recurse:!1}:oC(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class cC{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class dC extends cC{constructor(){super(dC.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let e=0;e<n;e++)t[e]=this.get(this.wrap(this.begin+e));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function hC(e){return new gC(e)}function pC(e,t){return new CC(e,t)}dC.INITIAL_CAPACITY=32;class fC{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new SC(this,e)}filter(e){return new wC(this,e)}map(e){return new kC(this,e)}mapAsync(e){return new IC(this,e)}serialMapAsync(e){return new IC(this,e).serial()}flatmap(e){return new TC(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e,t=!0){return new xC(this,e,t)}columnMajorBatch(e,t=!0,n=iC){return this.rowMajorBatch(e,t).map((e=>sC(e,n)))}concatenate(e,t){return new CC(new mC([this,e]),t)}take(e){return e<0||null==e?this:new vC(this,e)}skip(e){return e<0||null==e?this:new bC(this,e)}prefetch(e){return new $C(this,e)}shuffle(e,t){return new _C(this,e,t)}serial(){return new yC(this)}}class mC extends fC{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:lC(e),done:!1}}}class gC extends fC{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class yC extends fC{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class bC extends fC{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Fl(e.value)}return this.upstream.next()}}class vC extends fC{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class xC extends fC{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class wC extends fC{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Fl(e.value)}}}class kC extends fC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=tl(e.value),n=this.transform(e.value),r=tl(n);for(const e of t)el(e,r)||e.dispose();return{value:n,done:!1}}}class SC extends fC{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class IC extends fC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=tl(e.value),n=await this.transform(e.value),r=tl(n);for(const e of t)el(e,r)||e.dispose();return{value:n,done:!1}}}class NC extends fC{constructor(){super(),this.outputQueue=new dC,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class TC extends NC{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=tl(e.value),n=this.transform(e.value),r=tl(n);this.outputQueue.pushAll(n);for(const e of t)el(e,r)||e.dispose();return!0}}class CC extends fC{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var EC;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(EC||(EC={}));class $C extends fC{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new cC(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class _C extends $C{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Gf.alea(n||wo().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class OC{constructor(){this.size=null}batch(e,t=!0){const n=this;let r;return Rn(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),RC((async()=>(await n.iterator()).columnMajorBatch(e,t,AC)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,RC((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,RC((async()=>(await t.iterator()).filter((t=>Dl((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return RC((async()=>(await t.iterator()).map((t=>Dl((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return RC((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return RC((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,RC((async()=>pC(hC((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,RC((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,s=Gf.alea(t||wo().toString());return RC((async()=>{let t=s.int32();return n&&(t+=s.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,RC((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function RC(e,t=null){return new class extends OC{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function AC(e){if(null===e)return null;const t=e[0];if(null==(n=t)||null===(r=n)||"object"!=typeof r&&"function"!=typeof r||Array.isArray(n)||"object"==typeof n&&n instanceof Po||No(n)){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Po?$m(e):Sl(e)}(e),recurse:!1}}var n,r;return{value:null,recurse:!0}}OC.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function DC(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Rn("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}const FC=Hm;class MC extends kn{nextDataId(){return MC.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new wn(this,Ol())}write(e,t,n){this.firstUse&&(this.firstUse=!1,wr().get("IS_NODE")&&Vi());const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&tr(n[0])){const s=n.map((e=>So(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return Wy(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return cr(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Io(e)));return Xu(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return Xu(e.shape,e.dtype,t)}makeOutput(e,t,n){return Ol().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=wo();e();return{kernelMs:wo()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){DC([e],"where");const t=this.readSync(e.dataId);return FC(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}MC.nextDataId=0;function LC(e){return(t,n,r)=>{const s=Xn(n,t.length);for(let n=0;n<t.length;++n)s[n]=e(t[n],r);return s}}function zC(e,t,n){return PC(e,LC(t),n)}function PC(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;DC(i,e);const o=a,l=o.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=Sb(l)}else u=l;const c=n||i.dtype,d=t(u,c,s);return o.makeTensorInfo(i.shape,c,d)}}Vl("cpu",(()=>new MC),1);const BC=zC(Ns,(e=>e>=0?e:Math.exp(e)-1)),UC={kernelName:Ns,backendName:"cpu",kernelFunc:BC};function jC(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const WC={kernelName:js,backendName:"cpu",kernelFunc:jC};function VC(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;DC([s],"leakyRelu");const i=Fn(s.shape),o=n.data.get(s.dataId).values,l=Kn("float32",i);for(let e=0;e<o.length;e++)l[e]=o[e]<0?a*o[e]:o[e];return n.makeTensorInfo(s.shape,"float32",l)}const GC={kernelName:Ks,backendName:"cpu",kernelFunc:VC};function HC(e){return(t,n,r,s,a)=>{const i=_c(t,n),o=i.length,l=or(i),u=Kn(a,Fn(i)),c=t.length,d=n.length,h=or(t),p=or(n),f=Ec(t,i),m=Ec(n,i);if(f.length+m.length===0)for(let t=0;t<u.length;++t)u[t]=e(r[t%r.length],s[t%s.length]);else for(let t=0;t<u.length;++t){const n=gr(t,o,l),a=n.slice(-c);f.forEach((e=>a[e]=0));const i=mr(a,c,h),g=n.slice(-d);m.forEach((e=>g[e]=0));const y=mr(g,d,p);u[t]=e(r[i],s[y])}return[u,i]}}const qC=HC(((e,t)=>e<0?t*e:e));function KC(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;DC([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=qC(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}const XC={kernelName:Da,backendName:"cpu",kernelFunc:KC},YC=zC(ja,(e=>Math.max(0,e))),QC={kernelName:ja,backendName:"cpu",kernelFunc:YC},JC=zC(Ka,(e=>Math.min(Math.max(0,e),6))),ZC={kernelName:Ka,backendName:"cpu",kernelFunc:JC},eE=LC((e=>1/(1+Math.exp(-e)))),tE=zC(oi,(e=>1/(1+Math.exp(-e)))),nE={kernelName:oi,backendName:"cpu",kernelFunc:tE};function rE(e,t,n,r,s){if("linear"===n)return jC({inputs:{x:t},backend:e});if("relu"===n)return YC({inputs:{x:t},backend:e});if("elu"===n)return BC({inputs:{x:t},backend:e});if("relu6"===n)return JC({inputs:{x:t},backend:e});if("prelu"===n)return KC({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return VC({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return tE({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function sE(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const aE={kernelName:Zr,backendName:"cpu",kernelFunc:sE};function iE(e,t,n="float32"){if("complex64"===n){return sE({inputs:{real:iE(e,t,"float32"),imag:iE(e,t,"float32")},backend:e})}const r=hr(Fn(t),n);return e.makeTensorInfo(t,n,r)}function oE(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const lE={kernelName:Ba,backendName:"cpu",kernelFunc:oE};function uE(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){const r=xo([0],n),[s,a]=HC(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function cE(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return jC({inputs:{x:s},backend:n});const e=iE(n,s.shape,s.dtype),t=cE({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=sE({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=oE({inputs:{input:s},backend:n}),t=cE({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!Jn(s.dtype,a)){const e=jC({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,l,u]=uE(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}const dE={kernelName:Yr,backendName:"cpu",kernelFunc:cE};function hE(e,t,n,r){return null==n?({inputs:n,backend:s})=>{const{a,b:i}=n,o=s;DC([a,i],e);const l=o.data.get(a.dataId).values,u=o.data.get(i.dataId).values,c="string"===a.dtype?Sb(l):l,d="string"===a.dtype?Sb(u):u,h=r||a.dtype,[p,f]=t(a.shape,i.shape,c,d,h);return o.makeTensorInfo(f,h,p)}:({inputs:e,backend:s})=>{const{a,b:i}=e,o=s;if("complex64"===a.dtype||"complex64"===i.dtype){const e=cE({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,l=o.data.get(r.dataId).values,u=o.data.get(s.dataId).values,c=cE({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),d=o.data.get(c.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=o.data.get(h.dataId).values,m=o.data.get(p.dataId).values,[g,y,b]=n(a.shape,i.shape,l,u,f,m),v=o.makeTensorInfo(b,"float32",g),x=o.makeTensorInfo(b,"float32",y),w=sE({inputs:{real:v,imag:x},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(v),o.disposeIntermediateTensorInfo(x),w}{const e=o.data.get(a.dataId).values,n=o.data.get(i.dataId).values,s=r||a.dtype,[l,u]=t(a.shape,i.shape,e,n,s);return o.makeTensorInfo(u,s,l)}}}function pE(e){return(t,n,r,s,a,i)=>{const o=_c(t,n),l=Fn(o),u=o.length,c=or(o),d=Kn("float32",l),h=Kn("float32",l),p=Ec(t,o),f=Ec(n,o),m=Wy(r,s),g=Wy(a,i),y=t.length,b=or(t),v=n.length,x=or(n);if(p.length+f.length===0)for(let t=0;t<d.length;t++){const n=t%m.length,r=t%g.length,s=e(m[2*n],m[2*n+1],g[2*r],g[2*r+1]);d[t]=s.real,h[t]=s.imag}else for(let t=0;t<d.length;t++){const n=gr(t,u,c),r=n.slice(-y);p.forEach((e=>r[e]=0));const s=mr(r,y,b),a=n.slice(-v);f.forEach((e=>a[e]=0));const i=mr(a,v,x),o=e(m[2*s],m[2*s+1],g[2*i],g[2*i+1]);d[t]=o.real,h[t]=o.imag}return[d,h,o]}}const fE=HC(((e,t)=>e+t)),mE=pE(((e,t,n,r)=>({real:e+n,imag:t+r}))),gE=hE($r,fE,mE),yE={kernelName:$r,backendName:"cpu",kernelFunc:gE};function bE(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=Fn(s.shape),o=Gn(a,i),l=Fn(o);Rn(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const vE={kernelName:Wa,backendName:"cpu",kernelFunc:bE};function xE(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;DC([s,a],"matMul");const l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=o?a.shape[u-1]:a.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=Fn(f),y=Fn(m),b=_c(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);Rn(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`));const v=o?[y,p,d]:[y,d,p],x=bE({inputs:{x:s},backend:n,attrs:{shape:i?[g,c,h]:[g,h,c]}}),w=bE({inputs:{x:a},backend:n,attrs:{shape:v}}),k=i?x.shape[1]:x.shape[2],S=i?x.shape[2]:x.shape[1],I=o?w.shape[1]:w.shape[2],N=Math.max(g,y),T=n.data.get(x.dataId).values,C=n.data.get(w.dataId).values,E=or(x.shape),$=or(w.shape),[_,O,R]=i?[E[0],1,E[1]]:[E[0],E[1],1],[A,D,F]=o?[1,$[1],$[0]]:[$[1],1,$[0]],M=S*I,L=Xu([N,S,I],x.dtype),z=L.values,P=n.blockSize;for(let e=0;e<N;e++){const t=e%g,n=e%y;for(let r=0;r<S;r+=P){const s=Math.min(r+P,S);for(let a=0;a<I;a+=P){const i=Math.min(a+P,I);for(let o=0;o<k;o+=P){const l=Math.min(o+P,k);for(let u=r;u<s;u++)for(let r=a;r<i;r++){let s=0;for(let e=o;e<l;e++){s+=T[t*_+u*O+e*R]*C[e*A+r*D+n*F]}z[e*M+(u*I+r)]+=s}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,L.dtype,L.values)}const wE={kernelName:Vr,backendName:"cpu",kernelFunc:xE};const kE={kernelName:Ui,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const m=[];h=xE({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=gE({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),c&&(f=rE(n,h,c,o,d),m.push(h),h=f);for(const e of m)n.disposeIntermediateTensorInfo(e);return h}};function SE(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const IE={kernelName:Tr,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;DC(t,"abs");let r=new Float32Array(Fn(t.shape));return r=SE(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}},NE=zC(Cr,(e=>Math.acos(e))),TE={kernelName:Cr,backendName:"cpu",kernelFunc:NE},CE=zC(Er,(e=>Math.acosh(e))),EE={kernelName:Er,backendName:"cpu",kernelFunc:CE};const $E={kernelName:_r,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;DC(t,"addN");const s=r.map((e=>n.data.get(e.dataId).values)),a=Xu(r[0].shape,r[0].dtype),i=a.values;for(let e=0;e<r.length;e++){const t=s[e];for(let e=0;e<i.length;e++)i[e]+=t[e]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}};function _E(e,t,n,r,s){const a=t.length,i=Fn(t),o=or(t),l=or(s),u=Kn(n,Fn(s));for(let t=0;t<i;++t){const n=gr(t,a,o),s=new Array(n.length);for(let e=0;e<s.length;e++)s[e]=n[r[e]];u[mr(s,a,l)]=e[t]}return u}function OE(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;DC(s,"transpose");const i=s.shape.length,o=new Array(i);for(let e=0;e<o.length;e++)o[e]=s.shape[a[e]];const l=_E(r.data.get(s.dataId).values,s.shape,s.dtype,a,o);return{dataId:r.write(l,o,s.dtype),shape:o,dtype:s.dtype}}const RE={kernelName:Ri,backendName:"cpu",kernelFunc:OE};const AE={kernelName:Or,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;DC(s,"all");const o=Hn(a,s.shape);let l=o;const u=_p(l,s.shape.length);let c=s;null!=u&&(c=OE({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Rp(l.length,s.shape.length)),$p("all",l,c.shape.length);const[d,h]=Cp(c.shape,l),p=Fn(h),f=hr(Fn(d),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];n=n&&r}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=bE({inputs:{x:g},backend:n,attrs:{shape:Ep(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const DE={kernelName:Rr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;DC(s,"any");const o=Hn(a,s.shape);let l=o;const u=_p(l,s.shape.length);let c=s;null!=u&&(c=OE({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Rp(l.length,s.shape.length)),$p("any",l,c.shape.length);const[d,h]=Cp(c.shape,l),p=Fn(h),f=hr(Fn(d),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];n=n||r}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=bE({inputs:{x:g},backend:n,attrs:{shape:Ep(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const FE={kernelName:Ar,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;DC(s,"argMax");let i=Hn(a,s.shape);const o=_p(i,s.shape.length);let l=s;const u=[];null!=o&&(l=OE({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Rp(i.length,l.shape.length)),i=[i[0]],$p("argMax",i,l.shape.length);const[c,d]=Cp(l.shape,i),h=hr(Fn(c),"int32"),p=Fn(d),f=n.data.get(l.dataId).values;for(let e=0;e<h.length;++e){const t=e*p;let n=f[t],r=0;for(let e=0;e<p;++e){const s=f[t+e];s>n&&(n=s,r=e)}h[e]=r}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}};const ME={kernelName:Dr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;DC(s,"argMin");let i=Hn(a,s.shape);const o=_p(i,s.shape.length);let l=s;const u=[];null!=o&&(l=OE({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Rp(i.length,l.shape.length)),i=[i[0]],$p("argMin",i,l.shape.length);const[c,d]=Cp(l.shape,i),h=hr(Fn(c),"int32"),p=Fn(d),f=n.data.get(l.dataId).values;for(let e=0;e<h.length;++e){const t=e*p;let n=f[t],r=0;for(let e=0;e<p;++e){const s=f[t+e];s<n&&(n=s,r=e)}h[e]=r}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}},LE=zC(Fr,(e=>Math.asin(e))),zE={kernelName:Fr,backendName:"cpu",kernelFunc:LE},PE=zC(Mr,(e=>Math.asinh(e))),BE={kernelName:Mr,backendName:"cpu",kernelFunc:PE},UE=zC(Lr,(e=>Math.atan(e))),jE={kernelName:Lr,backendName:"cpu",kernelFunc:UE},WE=HC(((e,t)=>Math.atan2(e,t))),VE=hE(Pr,WE),GE={kernelName:Pr,backendName:"cpu",kernelFunc:VE},HE=zC(zr,(e=>Math.atanh(e))),qE={kernelName:zr,backendName:"cpu",kernelFunc:HE};function KE(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,p=s.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Xu(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],v=s.outShape[3];for(let t=0;t<s.batchSize;++t){const n=t*y,m=t*r[0];for(let t=0;t<s.inChannels;++t)for(let y=0;y<s.outHeight;++y){const x=y*i-h,w=Math.max(0,x),k=Math.min(s.inHeight,c+x),S=n+y*b;for(let n=0;n<s.outWidth;++n){const i=n*o-p,c=Math.max(0,i),h=Math.min(s.inWidth,d+i);let y=f,b=0,x=0;for(let n=w;n<k;n+=l){const s=m+n*r[1];for(let n=c;n<h;n+=u){const i=e[s+n*r[2]+t];"max"===a&&i>y?y=i:"avg"===a&&(b+=i,x++)}if(isNaN(y))break}g[S+n*v+t]="avg"===a?b/x:y}}}return m}function XE(e,t,n,r,s=!1,a=!1){const i=Xu(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Xu(t,n,e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let n=0;n<r.outHeight;++n){const g=n*o-p;let y=g;for(;y<0;)y+=u;const b=Math.min(r.inHeight,d+g);for(let o=0;o<r.outWidth;++o){const d=o*l-f;let p=d;for(;p<0;)p+=c;const v=Math.min(r.inWidth,h+d);let x=Number.NEGATIVE_INFINITY,w=-1;for(let n=y;n<b;n+=u){const i=n-g;for(let o=p;o<v;o+=c){const l=o-d,u=m.get(e,n,o,t);u>x&&(x=u,w=s?a?((e*r.inHeight+n)*r.inWidth+o)*r.inChannels+t:(n*r.inWidth+o)*r.inChannels+t:i*h+l)}}i.set(w,e,n,o,t)}}return i}function YE(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Xu(s.outShape,n),x=v.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],S=s.outShape[3]*s.outShape[4],I=s.outShape[4];for(let t=0;t<s.batchSize;++t){const n=t*w,v=t*r[0];for(let t=0;t<s.inChannels;++t)for(let w=0;w<s.outDepth;++w){const N=w*i-m;let T=N;for(;T<0;)T+=u;const C=Math.min(s.inDepth,h+N),E=n+w*k;for(let n=0;n<s.outHeight;++n){const i=n*o-g;let h=i;for(;h<0;)h+=c;const m=Math.min(s.inHeight,p+i),w=E+n*S;for(let n=0;n<s.outWidth;++n){const i=n*l-y;let o=i;for(;o<0;)o+=d;const p=Math.min(s.inWidth,f+i),g=w+n*I;let k=b,S=0,N=0;for(let n=T;n<C;n+=u){const s=v+n*r[1];for(let n=h;n<m;n+=c){const i=s+n*r[2];for(let n=o;n<p;n+=d){const s=e[i+n*r[3]+t];if("max"===a&&s>k?k=s:"avg"===a&&(S+=s,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+t]="avg"===a?S/Math.max(N,1):k}}}}return v}const QE={kernelName:Br,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;DC(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Rn(Eh(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=bh(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&zn(u.inShape,u.outShape))c=jC({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=or(s.shape),r=KE(e,s.shape,s.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}};const JE={kernelName:jr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;DC(s,"avgPool3d");const c=vh(s.shape,a,i,1,o,l,u),d=YE(n.data.get(s.dataId).values,s.shape,s.dtype,or(s.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};const ZE={kernelName:Wr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;DC([s,a],"avgPool3DGrad");const c=vh(a.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=x-1-c.padInfo.front,I=k-1-c.padInfo.left,N=w-1-c.padInfo.top,T=Xu(a.shape,"float32"),C=1/(f*m*g),E=n.bufferSync(s);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let s=0;s<c.inWidth;++s){const a=n-S,i=r-N,o=s-I;let l=0;for(let n=0;n<x;n+=y){const r=(a+n)/d;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let n=0;n<w;n+=b){const s=(i+n)/h;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let n=0;n<k;n+=v){const a=(o+n)/p;if(a<0||a>=c.outWidth||Math.floor(a)!==a)continue;l+=E.get(e,r,s,a,t)}}}T.set(l*C,e,n,r,s,t)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}};const e$={kernelName:Ur,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;DC([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=bh(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,x=y-1-c.padInfo.top,w=Xu(i.shape,"float32"),k=1/(p*f),S=n.data.get(s.dataId).values,I=Xu(s.shape,"float32",S);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=n-x,a=r-v;let i=0;for(let n=0;n<y;n+=m){const r=(s+n)/d;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let n=0;n<b;n+=g){const s=(a+n)/h;if(s<0||s>=c.outWidth||Math.floor(s)!==s)continue;i+=I.get(e,r,s,t)}}w.set(i*k,e,n,r,t)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const t$={kernelName:Ls,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:l}=t;Rn(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Rn(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Rn(null==a||o.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),DC([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,v=d.length;let x=0,w=0,k=0,S=0;for(let e=0;e<c.length;++e)m[e]=f[x++]+(c[e]-d[w++])*p[k++]/Math.sqrt(h[S++]+u),x>=g&&(x=0),w>=v&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(s.shape,s.dtype,m)}};function n$(e,t,n,r,s){const a=zd(r,t,n),i=Fn(n),o=or(r);if(a){const n=Pd(t,o);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const l=Xu(r,s,"string"===s?Sb(e):e),u=Xu(n,s);for(let e=0;e<u.size;++e){const n=u.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));u.set(l.get(...r),...n)}return"string"===s?Ib(u.values):u.values}function r$(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;DC(s,"slice");const[o,l]=Bd(s,a,i);Td(s,o,l);const u=n$(n.data.get(s.dataId).values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,u)}const s$={kernelName:ri,backendName:"cpu",kernelFunc:r$};const a$={kernelName:Gr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;DC([s],"batchToSpaceND");const o=a.reduce(((e,t)=>e*t)),l=_y(s.shape,a,o),u=Oy(l.length,a.length),c=Ry(s.shape,a,o),d=Ay(i,a.length),h=Dy(c,i,a.length),p=bE({inputs:{x:s},backend:n,attrs:{shape:l}}),f=OE({inputs:{x:p},backend:n,attrs:{perm:u}}),m=bE({inputs:{x:f},backend:n,attrs:{shape:c}}),g=r$({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function i$(e,t,n,r,s){const a=Fn(r),i=hr(s,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=s||(i[r]+=a>0?t[n]:1)}return i}function o$(e,t,n,r=!1){const s=e.shape[0],a=e.shape[1],i=Xu([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<a;s++){const a=e.get(o,s);if(a<0)throw new Error("Input x must be non-negative!");a>=n||(r?i.set(1,o,a):t.size>0?i.set(i.get(o,a)+t.get(o,s),o,a):i.set(i.get(o,a)+1,o,a))}return i}const l$={kernelName:Hr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=i$(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,o)}},u$=HC(((e,t)=>e&t)),c$=hE(qr,u$),d$={kernelName:qr,backendName:"cpu",kernelFunc:c$};const h$={kernelName:Xr,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=_c(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},p$=LC((e=>Math.ceil(e))),f$=PC(Qr,p$),m$={kernelName:Qr,backendName:"cpu",kernelFunc:f$},g$=zC(Jr,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),y$={kernelName:Jr,backendName:"cpu",kernelFunc:g$},b$={kernelName:es,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Fn(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let e=0;e<o.length;e++){const t=o[e],n=l[e];r[e]=Math.hypot(t,n)}return n.makeOutput(r,t.shape,"float32")}};function v$(e,t,n,r){const s=Xn(n,Fn(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=Fn(e.shape);s.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const a="string"===n?Sb(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[o+t]=a[i++]}r+=e.shape[1]}))}return s}function x$(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const w$={kernelName:Vs,backendName:"cpu",kernelFunc:x$};function k$(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Hn(s,t[0].shape)[0];xy(t.map((e=>e.shape)),a);let i=wy(t.map((e=>e.shape)),a);if(0===Fn(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Fn(e.shape)>0));if(1===o.length)return jC({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const e=o.map((e=>oE({inputs:{input:e},backend:n}))),t=o.map((e=>x$({inputs:{input:e},backend:n}))),r=k$({inputs:e,backend:n,attrs:{axis:a}}),s=k$({inputs:t,backend:n,attrs:{axis:a}}),i=sE({inputs:{real:r,imag:s},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}const l=o.map((e=>{const t=Fn(e.shape.slice(a));return bE({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=wy(l.map((e=>e.shape)),1);const c=1===l[0].shape[0],d=v$(u,i,t[0].dtype,c),h=wy(o.map((e=>e.shape)),a),p=n.makeTensorInfo(h,t[0].dtype,d);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const S$={kernelName:ts,backendName:"cpu",kernelFunc:k$};function I$(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;DC([s,a],"conv2d");const d=_h(l),h=xh(s.shape,a.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,v="channelsLast"===h.dataFormat,x=new Fo(h.outShape,s.dtype),w=or(s.shape),k=or(a.shape),S=w[0],I=v?w[1]:w[2],N=v?w[2]:1,T=v?1:w[1],C=x.strides[0],E=v?x.strides[1]:x.strides[2],$=v?x.strides[2]:1,_=v?1:x.strides[1],O=n.data.get(s.dataId).values,R=n.data.get(a.dataId).values,A=x.values;for(let e=0;e<h.batchSize;++e){const t=e*S,n=e*C;for(let e=0;e<h.outHeight;++e){const r=n+e*E,s=e*h.strideHeight-b;for(let e=0;e<p;++e){const n=s+e*m;if(n<0||n>=h.inHeight)continue;const a=e*k[0],i=t+n*I;for(let e=0;e<h.outWidth;++e){const t=r+e*$,n=e*h.strideWidth-y;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=h.inWidth)continue;const s=i+r*N;let o=a+e*k[1];for(let e=0;e<h.inChannels;++e){const n=O[s+e*T];for(let e=0;e<h.outChannels;++e)A[t+e*_]+=n*R[o+e];o+=h.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,A)}const N$={kernelName:ns,backendName:"cpu",kernelFunc:I$};const T$={kernelName:rs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;DC([s,a],"conv2dBackpropFilter");const d=_h(l),h=xh(s.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new Fo(h.filterShape,"float32"),v=h.padInfo.left,x=h.padInfo.top,w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=new Fo(s.shape,s.dtype,w),I=new Fo(a.shape,a.dtype,k);for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((x-e)/p)),n=Math.min(h.outHeight,(h.inHeight+x-e)/p);for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((v-r)/f)),a=Math.min(h.outWidth,(h.inWidth+v-r)/f);for(let i=0;i<h.inChannels;++i)for(let o=0;o<h.outChannels;++o){let l=0;for(let u=0;u<h.batchSize;++u)for(let c=t;c<n;++c){const t=e+c*p-x;for(let e=s;e<a;++e){const n=r+e*f-v;l+=y?S.get(u,t,n,i)*I.get(u,c,e,o):S.get(u,i,t,n)*I.get(u,o,c,e)}}b.set(l,e,r,i,o)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const C$={kernelName:ss,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;DC([s,a],"conv2dBackpropInput");const d=or(a.shape),h=or(s.shape);let p=_h(u);const f=xh(i,a.shape,o,1,l,c,!1,p),m=new Fo(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[v,x,w]=d,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:N,inHeight:T,inWidth:C,outChannels:E,outHeight:$,outWidth:_,strideHeight:O,strideWidth:R}=f;p=f.dataFormat;const A=S-1-f.padInfo.top,D=I-1-f.padInfo.left,F="channelsLast"===p,M=m.strides[0],L=F?m.strides[1]:m.strides[2],z=F?m.strides[2]:1,P=F?1:m.strides[1],B=h[0],U=F?h[1]:h[2],j=F?h[2]:1,W=F?1:h[1];for(let e=0;e<k;++e)for(let t=0;t<N;++t)for(let n=0;n<T;++n){const r=n-A,s=Math.max(0,Math.ceil(r/O)),a=Math.min($,(S+r)/O);for(let i=0;i<C;++i){const o=i-D,l=Math.max(0,Math.ceil(o/R)),u=Math.min(_,(I+o)/R);let c=0;for(let n=s;n<a;++n){const s=n*O-r;for(let r=l;r<u;++r){const a=B*e+U*n+j*r,i=v*(S-1-s)+x*(I-1-(r*R-o))+w*t;for(let e=0;e<E;++e){c+=y[a+W*e]*b[i+e]}}}g[M*e+L*n+z*i+P*t]=c}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const E$={kernelName:as,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;DC([s,a],"conv3d");const u=wh(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,x=new Fo(u.outShape,s.dtype),w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=x.values,I=or(s.shape),N=or(a.shape);for(let e=0;e<u.batchSize;++e){const t=e*I[0],n=e*x.strides[0];for(let e=0;e<u.outDepth;++e){const r=n+e*x.strides[1],s=e*u.strideDepth-y;for(let e=0;e<c;++e){const n=s+e*p;if(n<0||n>=u.inDepth)continue;const a=e*N[0],i=t+n*I[1];for(let e=0;e<u.outHeight;++e){const t=r+e*x.strides[2],n=e*u.strideHeight-v;for(let e=0;e<d;++e){const r=n+e*f;if(r<0||r>=u.inHeight)continue;const s=a+e*N[1],o=i+r*I[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<h;++e){const t=r+e*m;if(t<0||t>=u.inWidth)continue;const a=s+e*N[2],i=o+t*u.inChannels;let l=a;for(let e=0;e<u.inChannels;++e){const t=w[i+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const $$={kernelName:is,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;DC([s,a],"conv3dBackpropFilterV2");const u=or(s.shape),c=or(a.shape),d=wh(s.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new Fo(d.filterShape,"float32"),v=b.values,[x,w,k,S]=b.strides,I=n.data.get(a.dataId).values,[N,T,C,E]=c,$=n.data.get(s.dataId).values,[_,O,R,A]=u,D=d.padInfo.front,F=d.padInfo.left,M=d.padInfo.top;for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((D-e)/h)),n=Math.min(d.outDepth,(d.inDepth+D-e)/h),r=e*x;for(let s=0;s<g;++s){const a=Math.max(0,Math.ceil((M-s)/p)),i=Math.min(d.outHeight,(d.inHeight+M-s)/p),o=s*w+r;for(let r=0;r<y;++r){const l=Math.max(0,Math.ceil((F-r)/f)),u=Math.min(d.outWidth,(d.inWidth+F-r)/f),c=r*k+o;for(let o=0;o<d.inChannels;++o){const m=o*S+c;for(let c=0;c<d.outChannels;++c){let g=0;for(let m=0;m<d.batchSize;++m){const d=m*_,y=m*N;for(let m=t;m<n;++m){const t=(e+m*h-D)*O+d,n=m*T+y;for(let e=a;e<i;++e){const a=(s+e*p-M)*R+t,i=e*C+n;for(let e=l;e<u;++e){const t=e*E+i;g+=$[(r+e*f-F)*A+a+o]*I[t+c]}}}}v[m+c]=g}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const _$={kernelName:os,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;DC([s],"conv3dBackpropInputV2");const u=or(s.shape),c=or(a.shape),d=wh(l,a.shape,o,1,i),h=new Fo(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(s.dataId).values,[v,x,w,k]=u,S=n.data.get(a.dataId).values,[I,N,T,C]=c,{batchSize:E,filterDepth:$,filterHeight:_,filterWidth:O,inChannels:R,inDepth:A,inHeight:D,inWidth:F,outChannels:M,outDepth:L,outHeight:z,outWidth:P,strideDepth:B,strideHeight:U,strideWidth:j}=d,W=$-1-d.padInfo.front,V=_-1-d.padInfo.top,G=O-1-d.padInfo.left;for(let e=0;e<E;++e)for(let t=0;t<R;++t)for(let n=0;n<A;++n){const r=n-W,s=Math.max(0,Math.ceil(r/B)),a=Math.min(L,($+r)/B);for(let i=0;i<D;++i){const o=i-V,l=Math.max(0,Math.ceil(o/U)),u=Math.min(z,(_+o)/U);for(let c=0;c<F;++c){const d=c-G,h=Math.max(0,Math.ceil(d/j)),E=Math.min(P,(O+d)/j);let R=0;for(let n=s;n<a;++n){const s=n*B-r;for(let r=l;r<u;++r){const a=r*U-o;for(let i=h;i<E;++i){const o=v*e+x*n+w*r+k*i,l=I*($-1-s)+N*(_-1-a)+T*(O-1-(i*j-d))+C*t;for(let e=0;e<M;++e){R+=b[o+e]*S[l+e]}}}}p[f*e+m*n+g*i+y*c+t]=R}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},O$=zC(ls,(e=>Math.cos(e))),R$={kernelName:ls,backendName:"cpu",kernelFunc:O$},A$=zC(us,(e=>Math.cosh(e))),D$={kernelName:us,backendName:"cpu",kernelFunc:A$};const F$={kernelName:hs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=s.shape,f=a.shape[0],[m,g]=o,y=Xu([f,m,g,p],"float32"),b=n.data.get(a.dataId).values,v=n.data.get(i.dataId).values,x=n.data.get(s.dataId).values,w=or(s.shape),k=or(y.shape);for(let e=0;e<f;e++){const t=4*e,n=b[t],r=b[t+1],s=b[t+2],a=b[t+3],i=v[e];if(i>=c)continue;const o=m>1?(s-n)*(d-1)/(m-1):0,f=g>1?(a-r)*(h-1)/(g-1):0;for(let t=0;t<m;t++){const c=m>1?n*(d-1)+t*o:.5*(n+s)*(d-1);if(c<0||c>d-1)for(let n=0;n<g;n++)for(let r=0;r<p;r++){const s=r+n*k[2]+t*k[1]+e*k[0];y.values[s]=u}else if("bilinear"===l){const n=Math.floor(c),s=Math.ceil(c),o=c-n;for(let l=0;l<g;l++){const c=g>1?r*(h-1)+l*f:.5*(r+a)*(h-1);if(c<0||c>h-1){for(let n=0;n<p;n++){const r=n+l*k[2]+t*k[1]+e*k[0];y.values[r]=u}continue}const d=Math.floor(c),m=Math.ceil(c),b=c-d;for(let r=0;r<p;r++){let a=r+d*w[2]+n*w[1]+i*w[0];const u=x[a];a=r+m*w[2]+n*w[1]+i*w[0];const c=x[a];a=r+d*w[2]+s*w[1]+i*w[0];const h=x[a];a=r+m*w[2]+s*w[1]+i*w[0];const p=u+(c-u)*b,f=h+(x[a]-h)*b;a=r+l*k[2]+t*k[1]+e*k[0],y.values[a]=p+(f-p)*o}}}else for(let n=0;n<g;++n){const s=g>1?r*(h-1)+n*f:.5*(r+a)*(h-1);if(s<0||s>h-1){for(let r=0;r<p;r++){const s=r+n*k[2]+t*k[1]+e*k[0];y.values[s]=u}continue}const o=Math.round(s),l=Math.round(c);for(let r=0;r<p;r++){const s=r+o*w[2]+l*w[1]+i*w[0],a=r+n*k[2]+t*k[1]+e*k[0];y.values[a]=x[s]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const M$={kernelName:cs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;DC(s,"cumprod");const l=_p([a],s.shape.length);let u=s;null!=l&&(u=OE({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=Rp(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Ko(u.dtype,"int32"),h=dr(Fn(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<p.length;e+=f)for(let t=0;t<f;t++){const n=m(e,t);if(0===t)h[n]=i?1:p[n];else{const r=m(e,t-1);h[n]=i?p[r]*h[r]:p[n]*h[r]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=OE({inputs:{x:g},backend:n,attrs:{perm:Op(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const L$={kernelName:ds,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;DC(s,"cumsum");const l=_p([a],s.shape.length);let u=s;null!=l&&(u=OE({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=Rp(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Ko(u.dtype,"int32"),h=hr(Fn(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<p.length;e+=f)for(let t=0;t<f;t++){const n=m(e,t);if(0===t)h[n]=i?0:p[n];else{const r=m(e,t-1);h[n]=i?p[r]+h[r]:p[n]+h[r]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=OE({inputs:{x:g},backend:n,attrs:{perm:Op(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const z$={kernelName:ps,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=i$(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,e)}if(2===s.shape.length){const e=o$(n.bufferSync(s),n.bufferSync(a),i,o);return n.makeTensorInfo(e.shape,a.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};const P$={kernelName:fs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;Rn("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));const o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*a,h=u*a,p=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*d*h*p);let g=0;for(let e=0;e<o;++e)for(let t=0;t<d;++t){const n=Math.floor(t/a),r=t%a;for(let t=0;t<h;++t){const s=Math.floor(t/a),i=(r*a+t%a)*p;for(let t=0;t<p;++t){const r=t+i+c*(s+u*(n+l*e));m[g++]=f[r]}}}return n.makeTensorInfo([o,d,h,p],s.dtype,m)}};function B$(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;DC([s,a],"depthwiseConv2DNative");const c=or(s.shape),d=or(a.shape);let h=l;null==h&&(h=[1,1]),Rn(Eh(i,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`));const p=xh(s.shape,a.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,w=p.outChannels/p.inChannels,k=new Fo(p.outShape,s.dtype),S=n.data.get(s.dataId).values,I=n.data.get(a.dataId).values,N=k.values;for(let e=0;e<p.batchSize;++e){const t=e*c[0],n=e*k.strides[0];for(let e=0;e<p.outHeight;++e){const r=n+e*k.strides[1],s=e*p.strideHeight-x;for(let e=0;e<f;++e){const n=s+e*g;if(n<0||n>=p.inHeight)continue;const a=e*d[0],i=t+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){const r=n+e*y;if(r<0||r>=p.inWidth)continue;const s=a+e*d[1],o=i+r*p.inChannels;let l=t,u=s;for(let e=0;e<p.inChannels;++e){const t=S[o+e];for(let e=0;e<w;++e)N[l+e]+=t*I[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const U$={kernelName:ms,backendName:"cpu",kernelFunc:B$};const j$={kernelName:gs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;DC([s,a],"depthwiseConv2dNativeBackpropFilter");const d=xh(s.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new Fo(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,v=d.outChannels/d.inChannels,x=n.data.get(s.dataId).values,w=new Fo(s.shape,s.dtype,x),k=n.data.get(a.dataId).values,S=new Fo(a.shape,a.dtype,k);for(let e=0;e<f;++e){const t=Math.max(0,Math.ceil((b-e)/h)),n=Math.min(d.outHeight,(d.inHeight+b-e)/h);for(let r=0;r<m;++r){const s=Math.max(0,Math.ceil((y-r)/p)),a=Math.min(d.outWidth,(d.inWidth+y-r)/p);for(let i=0;i<d.outChannels;++i){const o=Math.trunc(i/v),l=i%v;let u=0;for(let l=0;l<d.batchSize;++l)for(let c=t;c<n;++c){const t=e+c*h-b;for(let e=s;e<a;++e){const n=r+e*p-y;u+=w.get(l,t,n,o)*S.get(l,c,e,i)}}g.set(u,e,r,o,l)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const W$={kernelName:ys,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;DC([s,a],"depthwiseConv2DNativeBackpropInput");const d=or(s.shape),h=or(a.shape),p=xh(c,a.shape,i,o,l,u,!0),f=new Fo(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(s.dataId).values,[x,w,k]=d,S=n.data.get(a.dataId).values,[I,N,T]=h,{batchSize:C,filterHeight:E,filterWidth:$,inChannels:_,inHeight:O,inWidth:R,outChannels:A,outHeight:D,outWidth:F,strideHeight:M,strideWidth:L}=p,z=E-1-p.padInfo.top,P=$-1-p.padInfo.left,B=A/_;for(let e=0;e<C;++e)for(let t=0;t<_;++t)for(let n=0;n<O;++n){const r=n-z,s=Math.max(0,Math.ceil(r/M)),a=Math.min(D,(E+r)/M);for(let i=0;i<R;++i){const o=i-P,l=Math.max(0,Math.ceil(o/L)),u=Math.min(F,($+o)/L);let c=0;for(let n=s;n<a;++n){const s=n*M-r;for(let r=l;r<u;++r){const a=x*e+w*n+k*r,i=I*(E-1-s)+N*($-1-(r*L-o))+T*t;for(let e=0;e<B;++e){c+=v[a+(t*B+e)]*S[i+e]}}}m[g*e+y*n+b*i+t]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const V$={kernelName:bs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=Fn(r.shape),a=n.data.get(r.dataId).values,i=Xu([s,s],r.dtype),o=i.values;for(let e=0;e<a.length;e++)o[e*s+e]=a[e];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},G$={kernelName:vs,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:T}=yh(r.shape,s.shape,a,i,"NHWC",o),C=Fn(T),E=T.length,$=Xn(r.dtype,C);for(let e=0;e<p;++e)for(let t=0;t<y;++t){const n=t*x-v.top;for(let a=0;a<b;++a){const i=a*w-v.left;for(let o=0;o<g;++o){let l=Number.MIN_SAFE_INTEGER;for(let t=0;t<k;++t){const a=n+t*I;if(a>=0&&a<f)for(let n=0;n<S;++n){const p=i+n*N;if(p>=0&&p<m){const i=mr([e,a,p,o],c,or(r.shape)),f=mr([t,n,o],h,or(s.shape)),m=u[i]+d[f];m>l&&(l=m)}}}$[mr([e,t,a,o],E,or(T))]=l}}}return{dataId:l.write(xo($,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},H$={kernelName:ws,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=ur(r.shape,u.data.get(r.dataId).values),d=ur(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:k,dilationHeight:S,dilationWidth:I,outShape:N}=yh(r.shape,s.shape,i,o,"NHWC",l);Rn(a.rank===N.length,(()=>`Error in ${ws}, dy must have the same rank as output ${N.length}, but got ${a.rank}`));const T=ur(N,u.data.get(a.dataId).values),C=pr(s.shape,s.dtype);for(let e=0;e<h;++e)for(let t=0;t<g;++t){const n=t*v-b.top;for(let r=0;r<y;++r){const s=r*x-b.left;for(let a=0;a<m;++a){let i=Number.MIN_SAFE_INTEGER,o=0,l=0;for(let t=0;t<w;++t){const r=n+t*S;if(r>=0&&r<p)for(let n=0;n<k;++n){const u=s+n*I;if(u>=0&&u<f){const s=c[e][r][u][a]+d[t][n][a];s>i&&(i=s,o=t,l=n)}}}C[o][l][a]+=T[e][t][r][a]}}}return{dataId:u.write(xo(C,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},q$={kernelName:xs,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=ur(r.shape,u.data.get(r.dataId).values),d=ur(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:v,strideWidth:x,filterHeight:w,filterWidth:k,dilationHeight:S,dilationWidth:I,outShape:N}=yh(r.shape,s.shape,i,o,"NHWC",l);Rn(a.rank===N.length,(()=>`Error in ${xs}, dy must have the same rank as output ${N.length}, but got ${a.rank}`));const T=ur(N,u.data.get(a.dataId).values),C=pr(r.shape,r.dtype);for(let e=0;e<h;++e)for(let t=0;t<g;++t){const n=t*v-b.top;for(let r=0;r<y;++r){const s=r*x-b.left;for(let a=0;a<m;++a){let i=Number.MIN_SAFE_INTEGER,o=n<0?0:n,l=s<0?0:s;for(let t=0;t<w;++t){const r=n+t*S;if(r>=0&&r<p)for(let n=0;n<k;++n){const u=s+n*I;if(u>=0&&u<f){const s=c[e][r][u][a]+d[t][n][a];s>i&&(i=s,o=r,l=u)}}}C[e][o][l][a]+=T[e][t][r][a]}}}return{dataId:u.write(xo(C,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const K$={kernelName:ks,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null==l?void 0:l.alpha)||1,c=(null==o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const d=a.getContext(c,(null==o?void 0:o.contextAttributes)||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);const[h,p]=s.shape.slice(0,2),f=2===s.shape.length?1:s.shape[2],m=n.data.get(s.dataId).values,g="float32"===s.dtype?255:1,y=new Uint8ClampedArray(p*h*4);for(let e=0;e<h*p;++e){const t=[0,0,0,255*u];for(let n=0;n<f;n++){const r=m[e*f+n];if("float32"===s.dtype){if(r<0||r>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${r}.`)}else if("int32"===s.dtype&&(r<0||r>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${r}.`);1===f?(t[0]=r*g,t[1]=r*g,t[2]=r*g):t[n]=r*g}const n=4*e;y[n+0]=Math.round(t[0]),y[n+1]=Math.round(t[1]),y[n+2]=Math.round(t[2]),y[n+3]=Math.round(t[3])}a.width=p,a.height=h;const b=new ImageData(y,p,h);return d.putImageData(b,0,0),s}},X$=HC(((e,t)=>e*t)),Y$=pE(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),Q$=hE(ka,X$,Y$),J$={kernelName:ka,backendName:"cpu",kernelFunc:Q$};function Z$(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;let o;DC(s,"sum"),o="bool"===s.dtype?cE({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):jC({inputs:{x:s},backend:n});const l=o.shape.length,u=Hn(a,o.shape),c=_p(u,l);let d=u,h=o;null!=c&&(h=OE({inputs:{x:o},backend:n,attrs:{perm:c}}),d=Rp(d.length,l)),$p("sum",d,h.shape.length);const[p,f]=Cp(h.shape,d);let m=iE(n,p,Ko(h.dtype,"int32"));const g=Fn(f),y=n.data.get(m.dataId).values,b=n.data.get(h.dataId).values;for(let e=0;e<y.length;++e){const t=e*g;let n=0;for(let e=0;e<g;++e)n+=b[t+e];y[e]=n}if(i){const e=m;m=bE({inputs:{x:m},backend:n,attrs:{shape:Ep(m.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(h),m}const e_={kernelName:ci,backendName:"cpu",kernelFunc:Z$};const t_={kernelName:Is,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=tb(s,a.length);rb(i.length,l,a);const{path:u,steps:c}=sb(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let e=0;e<d;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:r}=nb(p,l[t]);let s;ab(e)?s=a[t]:(s=OE({inputs:{x:a[t]},backend:n,attrs:{perm:e}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);zn(s.shape,i)||(s=bE({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===h?h=s:(h=Q$({inputs:{a:s,b:h},backend:n}),f.push(h))}e<d-1&&(u[e]>=0&&(h=Z$({inputs:{x:h},backend:n,attrs:{axis:u[e]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const e of f)e!==h&&n.disposeIntermediateTensorInfo(e);return h}};const n_={kernelName:Ts,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;DC([r,s],"eluGrad");const a=new Float32Array(Fn(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let e=0;e<i.length;++e){const t=i[e];a[e]=t>=0?o[e]:o[e]*(t+1)}return n.makeTensorInfo(s.shape,"float32",a)}},r_=HC(((e,t)=>e===t?1:0)),s_=hE(Es,r_,null,"bool"),a_={kernelName:Es,backendName:"cpu",kernelFunc:s_},i_=Ly,o_=zy,l_=Py,u_=By,c_=Uy,d_=jy,h_=zC(Cs,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+i_*n);return t*(1-((((d_*r+c_)*r+u_)*r+l_)*r+o_)*r*Math.exp(-n*n))})),p_={kernelName:Cs,backendName:"cpu",kernelFunc:h_},f_=LC((e=>Math.exp(e))),m_=PC($s,f_,"float32"),g_={kernelName:$s,backendName:"cpu",kernelFunc:m_};function y_(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(Rn(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),bE({inputs:{x:s},backend:n,attrs:{shape:o}})}const b_={kernelName:_s,backendName:"cpu",kernelFunc:y_},v_=LC((e=>Math.expm1(e))),x_=PC(Os,v_),w_={kernelName:Os,backendName:"cpu",kernelFunc:x_},k_=HC(((e,t)=>e/t)),S_=hE(Ss,k_),I_={kernelName:Ss,backendName:"cpu",kernelFunc:S_},N_=HC(((e,t)=>e-t)),T_=pE(((e,t,n,r)=>({real:e-n,imag:t-r}))),C_=hE(Ti,N_,T_),E_={kernelName:Ti,backendName:"cpu",kernelFunc:C_};function $_(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=Fn(u),d=Kn("float32",c),h=Kn("float32",c);for(let e=0;e<s;e++){const r=r$({inputs:{x:o},backend:n,attrs:{begin:[e,0],size:[1,a]}}),s=r$({inputs:{x:l},backend:n,attrs:{begin:[e,0],size:[1,a]}}),i=sE({inputs:{real:r,imag:s},backend:n}),{real:u,imag:c}=__(i,t,n),p=Wy(u,c);for(let t=0;t<a;t++){const n=qy(p,t);d[e*a+t]=n.real,h[e*a+t]=n.imag}n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i)}const p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=sE({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function __(e,t,n){const r=Fn(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if((o=r)&o-1){const e=function(e,t,n){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let a=0,i=0;for(let r=0;r<t;r++){const o=Yy(s*r,t,n),l=qy(e,r);a+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(a/=t,i/=t),Ky(r,a,i,s)}return r}(Wy(a,i),r,t);return Vy(e)}{const s=O_(a,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",s.real),t=n.makeTensorInfo(o,"float32",s.imag),a=n.makeTensorInfo([],"float32",vo(r,"float32")),i=jC({inputs:{x:a},backend:n}),l=I_.kernelFunc({inputs:{a:e,b:a},backend:n}),u=I_.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:d}}return s}var o}function O_(e,t,n,r,s){if(1===n)return{real:e,imag:t};const a=Wy(e,t),i=n/2,o=Gy(a),l=o.real,u=o.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),p=sE({inputs:{real:d,imag:h},backend:s}),f=Hy(a),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),v=s.makeTensorInfo(y,"float32",g),x=sE({inputs:{real:b,imag:v},backend:s}),w=O_(l,u,i,r,s),k=w.real,S=w.imag,I=[k.length],N=s.makeTensorInfo(I,"float32",k),T=s.makeTensorInfo(I,"float32",S),C=sE({inputs:{real:N,imag:T},backend:s}),E=O_(m,g,i,r,s),$=E.real,_=E.imag,O=[$.length],R=s.makeTensorInfo(O,"float32",$),A=s.makeTensorInfo(O,"float32",_),D=sE({inputs:{real:R,imag:A},backend:s}),F=Xy(n,r),M=[F.real.length],L=s.makeTensorInfo(M,"float32",F.real),z=s.makeTensorInfo(M,"float32",F.imag),P=sE({inputs:{real:L,imag:z},backend:s}),B=Q$({inputs:{a:P,b:D},backend:s}),U=gE({inputs:{a:C,b:B},backend:s}),j=C_({inputs:{a:C,b:B},backend:s}),W=oE({inputs:{input:U},backend:s}),V=oE({inputs:{input:j},backend:s}),G=x$({inputs:{input:U},backend:s}),H=x$({inputs:{input:j},backend:s}),q=k$({inputs:[W,V],backend:s,attrs:{axis:0}}),K=k$({inputs:[G,H],backend:s,attrs:{axis:0}}),X=s.data.get(q.dataId).values,Y=s.data.get(K.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(N),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(A),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}const R_={kernelName:Rs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Fn(r.shape),a=r.shape[r.shape.length-1],i=bE({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=$_(i,!1,n),l=bE({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function A_(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||sr(s),o=Xn(i,Fn(r));return function(e,t){e.fill(t)}(o,s),t.makeTensorInfo(r,i,o)}const D_={kernelName:As,backendName:"cpu",kernelFunc:A_};const F_={kernelName:Ds,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,s=n,a=Kn(r.dtype,Fn(r.shape)),[i,o,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let e=0;e<i;e++){const t=e*l*o*u;for(let e=0;e<o;e++){const n=e*(l*u);for(let e=0;e<l;e++){const r=e*u;for(let s=0;s<u;s++){const i=Math.round(l-e-1),o=t+n+r+s;let d=c[o];if(i>=0&&i<l){d=c[t+n+i*u+s]}a[o]=d}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},M_=LC((e=>Math.floor(e))),L_=PC(Fs,M_),z_={kernelName:Fs,backendName:"cpu",kernelFunc:L_},P_=HC(((e,t)=>Math.floor(e/t))),B_=hE(Ms,P_,null,"int32"),U_={kernelName:Ms,backendName:"cpu",kernelFunc:B_};const j_={kernelName:ji,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=I$({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const e=bE({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=gE({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=gE({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=bE({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=rE(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=rE(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};const W_={kernelName:Wi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=B$({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;m=gE({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=rE(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function V_(e,t,n,r,s,a,i,o,l){const u=Xu([r,a],n);for(let n=0;n<r;n++){const r=[];let c=0;for(let t=0;t<s;t++){const a=e[n*s+t];c+=a*i[t],r.push(a)}if(c<0||c>=l/a)throw new Error(`Invalid indices: ${r} does not index into ${o}`);for(let e=0;e<a;e++)u.values[n*a+e]=t.get(...t.indexToLoc(c*a+e))}return u}const G_={kernelName:Ps,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=Fn(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,d]=xd(r,s);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const h=V_(n.data.get(s.dataId).values,n.bufferSync(r),r.dtype,u,o,c,d,r.shape,a);return n.makeTensorInfo(l,r.dtype,h.values)}};function H_(e,t,n){const r=Xu(n,e.dtype);for(let n=0;n<r.size;++n){const s=r.indexToLoc(n).slice(),a=s[0],i=s[2],o=t.locToIndex([a,i]);s[2]=t.values[o];const l=e.locToIndex(s);0<=l&&l<e.values.length&&(r.values[n]=e.values[l])}return r}const q_={kernelName:zs,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;DC([s,a],"gatherV2");const l=Hn(i,s.shape)[0],u=n.data.get(a.dataId).values,c=s.shape[l];for(let e=0;e<u.length;++e){const t=u[e];Rn(t<=c-1&&t>=0,(()=>`GatherV2: the index value ${t} is not in [0, ${c-1}]`))}let d=o;null==o&&(d=0);const h=Fn(a.shape),p=kb(s,a,l,d),f=bE({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=bE({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=H_(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},K_=HC(((e,t)=>e>t?1:0)),X_=hE(Bs,K_,null,"bool"),Y_={kernelName:Bs,backendName:"cpu",kernelFunc:X_},Q_=HC(((e,t)=>e>=t?1:0)),J_=hE(Us,Q_,null,"bool"),Z_={kernelName:Us,backendName:"cpu",kernelFunc:J_};const eO={kernelName:Ws,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Fn(r.shape),a=r.shape[r.shape.length-1],i=bE({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=$_(i,!0,n),l=bE({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},tO=zC(Gs,(e=>Number.isFinite(e)?1:0),"bool"),nO={kernelName:Gs,backendName:"cpu",kernelFunc:tO},rO=zC(Hs,(e=>Math.abs(e)===1/0?1:0),"bool"),sO={kernelName:Hs,backendName:"cpu",kernelFunc:rO},aO=zC(qs,(e=>Number.isNaN(e)?1:0),"bool"),iO={kernelName:qs,backendName:"cpu",kernelFunc:aO},oO=HC(((e,t)=>e<t?1:0)),lO=hE(Xs,oO,null,"bool"),uO={kernelName:Xs,backendName:"cpu",kernelFunc:lO},cO=HC(((e,t)=>e<=t?1:0)),dO=hE(Ys,cO,null,"bool"),hO={kernelName:Ys,backendName:"cpu",kernelFunc:dO};function pO(e,t,n){const r=(t-e)/(n-1),s=hr(n,"float32");s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+r;return s}const fO={kernelName:Qs,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=pO(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},mO=LC((e=>Math.log(e))),gO=PC(Js,mO),yO={kernelName:Js,backendName:"cpu",kernelFunc:gO},bO=zC(Zs,(e=>Math.log1p(e))),vO={kernelName:Zs,backendName:"cpu",kernelFunc:bO},xO=HC(((e,t)=>e&&t)),wO=hE(ea,xO,null,"bool"),kO={kernelName:ea,backendName:"cpu",kernelFunc:wO},SO=zC(ta,(e=>e?0:1),"bool"),IO={kernelName:ta,backendName:"cpu",kernelFunc:SO},NO=HC(((e,t)=>e||t)),TO=hE(na,NO,null,"bool"),CO={kernelName:na,backendName:"cpu",kernelFunc:TO};const EO={kernelName:ia,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;DC(s,"LRN");const u=s.shape[3],c=u-1,d=n.data.get(s.dataId).values,h=Fn(s.shape),p=new Float32Array(h);function f(e){const t=e%u;let n=e-t+Math.max(0,t-a);const r=e-t+Math.min(t+a,c);let s=0;for(;n<=r;n++){const e=d[n];s+=e*e}return s}for(let e=0;e<h;e++){const t=f(e),n=d[e]*Math.pow(i+o*t,-l);p[e]=n}return n.makeTensorInfo(s.shape,s.dtype,p)}};const $O={kernelName:oa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;DC(i,"LRNGrad");const d=Fn(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(d),y=d;for(let e=0;e<y;e++){const t=e%h,n=e-t+Math.max(0,t-o),r=e-t+Math.min(h,t+o+1);let s=0;for(let e=n;e<r;e++)s+=Math.pow(f[e],2);s=u*s+l;for(let t=n;t<r;t++){let n=-2*u*c*f[t]*m[e]/s;e===t&&(n+=Math.pow(s,-c)),n*=p[e],g[t]+=n}}return n.makeTensorInfo(i.shape,s.dtype,g)}};function _O(e,t,n,r){const s=Kn(r,Fn(n));for(let n=0;n<s.length;++n){const r=n*t;let a=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>a)&&(a=t)}s[n]=a}return s}function OO(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let l=s.shape;const u=l.length,c=Hn(a,l);let d=c;const h=_p(d,u);let p=o.data.get(s.dataId).values;if(null!=h){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[h[t]];p=_E(p,l,s.dtype,h,e),d=Rp(d.length,u),l=e}DC(s,"max"),$p("max",d,u);const[f,m]=Cp(l,d),g=_O(p,Fn(m),f,s.dtype),y=o.write(g,f,s.dtype);let b=f;if(i){b=Ep(f,c)}return{dataId:y,shape:b,dtype:s.dtype}}const RO={kernelName:ua,backendName:"cpu",kernelFunc:OO},AO=HC(((e,t)=>Math.max(e,t))),DO=hE(ca,AO),FO={kernelName:ca,backendName:"cpu",kernelFunc:DO};const MO={kernelName:da,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;DC(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Rn(Eh(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=bh(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&zn(u.inShape,u.outShape))c=jC({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=or(s.shape),r=KE(e,s.shape,s.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}};const LO={kernelName:pa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;DC(s,"maxPool3d");const c=vh(s.shape,a,i,1,o,l,u),d=YE(n.data.get(s.dataId).values,s.shape,s.dtype,or(s.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};const zO={kernelName:fa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;DC([s,a],"maxPool3DGrad");const c=vh(a.shape,i,o,1,l,u),d=function(e,t){const n=Xu(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-h;let v=b;for(;v<0;)v+=i;const x=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){const u=r*s-p;let h=u;for(;h<0;)h+=o;const w=Math.min(t.inHeight,c+u);for(let s=0;s<t.outWidth;++s){const p=s*a-f;let k=p;for(;k<0;)k+=l;const S=Math.min(t.inWidth,d+p);let I=Number.NEGATIVE_INFINITY,N=-1;for(let t=v;t<x;t+=i){const n=t-b;for(let r=h;r<w;r+=o){const s=r-u;for(let a=k;a<S;a+=l){const i=a-p,o=e.get(m,t,r,a,g);o>=I&&(I=o,N=n*c*d+s*c+i)}}}n.set(N,m,y,r,s,g)}}}return n}(n.bufferSync(a),c),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,x=c.effectiveFilterWidth,w=b-1-c.padInfo.front,k=x-1-c.padInfo.left,S=v-1-c.padInfo.top,I=Xu(a.shape,"float32"),N=n.bufferSync(s);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let s=0;s<c.inWidth;++s){const a=n-w,i=r-S,o=s-k;let l=0;for(let n=0;n<b;n+=m){const r=(a+n)/h;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let s=0;s<v;s+=g){const a=(i+s)/p;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let i=0;i<x;i+=y){const u=(o+i)/f;if(u<0||u>=c.outWidth||Math.floor(u)!==u)continue;const h=b*v*x-1-d.get(e,r,a,u,t)===n*v*x+s*x+i?1:0;if(0===h)continue;l+=N.get(e,r,a,u,t)*h}}}I.set(l,e,n,r,s,t)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const PO={kernelName:ha,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;DC([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=bh(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=Xu(h.outShape,o.dtype,XE(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,v=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,k=v-1-h.padInfo.top,S=Xu(o.shape,"float32"),I=n.data.get(s.dataId).values,N=Xu(s.shape,"float32",I);for(let e=0;e<h.batchSize;++e)for(let t=0;t<h.inChannels;++t)for(let n=0;n<h.inHeight;++n)for(let r=0;r<h.inWidth;++r){const s=n-k,a=r-w;let i=0;for(let n=0;n<v;n+=y){const r=(s+n)/m;if(!(r<0||r>=h.outHeight||Math.floor(r)!==r))for(let s=0;s<x;s+=b){const o=(a+s)/g;if(o<0||o>=h.outWidth||Math.floor(o)!==o)continue;const l=v*x-1-f.get(e,r,o,t)===n*x+s?1:0;if(0===l)continue;i+=N.get(e,r,o,t)*l}}S.set(i,e,n,r,t)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const BO={kernelName:ma,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;DC(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=bh(r.shape,s,a,[1,1],i),[d,h]=function(e,t,n,r,s){const a=KE(e,0,n,or(t),s,"max"),i=XE(e,t,n,s,!0,r);return[a.values,i.values]}(u,r.shape,r.dtype,o,c),p=l.write(d,c.outShape,r.dtype),f=l.write(h,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};const UO={kernelName:ga,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=Hn(a,s.shape),l=Fn(Cp(s.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const d=cE({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});u.push(d);const h=S_({inputs:{a:d,b:c},backend:n});u.push(h);const p=Z$({inputs:{x:h},backend:n,attrs:{axis:a,keepDims:i}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const jO={kernelName:ya,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;DC(s,"min");const o=Hn(a,s.shape);let l=o;const u=_p(l,s.shape.length);let c=s;null!=u&&(c=OE({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Rp(l.length,s.shape.length)),$p("min",l,c.shape.length);const[d,h]=Cp(c.shape,l),p=Fn(h),f=hr(Fn(d),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];(Number.isNaN(r)||r<n)&&(n=r)}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=bE({inputs:{x:g},backend:n,attrs:{shape:Ep(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},WO=HC(((e,t)=>Math.min(e,t))),VO=hE(ba,WO),GO={kernelName:ba,backendName:"cpu",kernelFunc:VO};const HO={kernelName:va,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;DC(s,"mirrorPad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),l=a.map((e=>e[0])),u=a.map(((e,t)=>e[0]+s.shape[t])),c="reflect"===i?0:1,d=n.data.get(s.dataId).values,h=s.shape.length,p=or(s.shape),f=Fn(o),m=o.length,g=or(o),y=Kn(s.dtype,f);for(let e=0;e<f;e++){let t=gr(e,m,g);for(let e=0;e<m;e++)t[e]<l[e]?t[e]=2*l[e]-t[e]-c:t[e]>=u[e]&&(t[e]=2*(u[e]-1)-t[e]+c);t=t.map(((e,t)=>e-l[t]));const n=mr(t,h,p);y[e]=d[n]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}},qO=HC(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),KO=hE(xa,qO),XO={kernelName:xa,backendName:"cpu",kernelFunc:KO};function YO(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=Hn([o],s.shape),u=OO({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=Ep(u.shape,l),d=bE({inputs:{x:u},backend:n,attrs:{shape:c}}),h=C_({inputs:{a:s,b:d},backend:n}),p=m_({inputs:{x:h},backend:n}),f=Z$({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=bE({inputs:{x:f},backend:n,attrs:{shape:c}}),g=S_({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const QO={kernelName:pi,backendName:"cpu",kernelFunc:YO};const JO={kernelName:wa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;DC(s,"multinomial");const l=o?s:YO({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,a],p=hr(Fn(h),"int32");for(let e=0;e<u;++e){const t=e*c,n=new Float32Array(c-1);n[0]=d[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+d[t+e];const r=Gf.alea(i.toString()),s=e*a;for(let e=0;e<a;++e){const t=r();p[s+e]=n.length;for(let r=0;r<n.length;r++)if(t<n[r]){p[s+e]=r;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}};function ZO(e,t,n){const r=vo(-1,n);return X$([],t,r,e,n)}const eR={kernelName:Sa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;DC(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=ZO(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}},tR=Tg;const nR={kernelName:Na,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;DC(s,"NonMaxSuppression");const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:d}=tR(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},rR=Cg;const sR={kernelName:Ta,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;DC(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:h,validOutputs:p}=rR(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},aR=Eg;const iR={kernelName:Ca,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;DC(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=aR(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},oR=HC(((e,t)=>e!==t?1:0)),lR=hE(Ia,oR,null,"bool"),uR={kernelName:Ia,backendName:"cpu",kernelFunc:lR};const cR={kernelName:$a,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r;DC(s,"oneHot");const u=Fn(s.shape),c=new Float32Array(u*i);c.fill(l);const d=n.data.get(s.dataId).values;for(let e=0;e<u;++e)d[e]>=0&&d[e]<i&&(c[e*i+d[e]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}};function dR(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=oE({inputs:{input:r},backend:n}),t=dR({inputs:{x:e},backend:n}),s=x$({inputs:{input:r},backend:n}),a=dR({inputs:{x:s},backend:n}),i=sE({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return A_({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const hR={kernelName:Li,backendName:"cpu",kernelFunc:dR};const pR={kernelName:Ea,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=oE({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=x$({inputs:{input:s},backend:r}),i=dR({inputs:{x:a},backend:r}),o=sE({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return A_({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function fR(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return y_({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{An(a,e.shape,"All tensors passed to stack must have matching shapes"),Rn(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=k$({inputs:t.map((e=>{const t=y_({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const mR={kernelName:_a,backendName:"cpu",kernelFunc:fR};const gR={kernelName:Oa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;DC(s,"pad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),l=a.map((e=>e[0])),u=n.data.get(s.dataId).values,c=Fn(s.shape),d=s.shape.length,h=or(s.shape),p=Fn(o),f=o.length,m=or(o),g=Kn(s.dtype,p);0!==i&&g.fill(i);for(let e=0;e<c;e++){g[mr(gr(e,d,h).map(((e,t)=>e+l[t])),f,m)]=u[e]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}},yR=HC(((e,t)=>Math.pow(e,t))),bR=hE(Aa,yR),vR={kernelName:Aa,backendName:"cpu",kernelFunc:bR};function xR(e,t,n,r){const[s,a]=Cp(e,r),i=Ko(t,"int32"),o=hr(Fn(s),i),l=Fn(a);for(let e=0;e<o.length;++e){const t=e*l;let r=1;for(let e=0;e<l;++e)r*=n[t+e];o[e]=r}return{outVals:o,outShape:s,outDtype:i}}const wR={kernelName:Fa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;DC(s,"prod");const o=s.shape.length,l=Hn(a,s.shape),u=_p(l,o);let c=l,d=s;const h=[];null!=u&&(d=OE({inputs:{x:s},backend:n,attrs:{perm:u}}),h.push(d),c=Rp(c.length,o));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=xR(d.shape,d.dtype,p,c);let y=m;return i&&(y=Ep(m,l)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function kR(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let e=0;e<t.length-1;++e){l*=t[e];const n=t[e+1];for(let t=1;t<l+1;++t)o[e].push(t*n)}for(let r=0;r<e.length;++r){let i=e[r],l=e[r]+1;for(let e=0;e<n.length;++e){const r=n[e],s=e+t.length-1;if(s>=0){const e=o[s],t=e[e.length-1]-r[i];for(let e=i;e<l;++e)o[s].push(r[e+1]+t)}i=r[i],l=r[l]}l!==i&&(s.push([i,l]),a+=l-i)}return{outSplits:o,valueSlices:s,numValues:a}}function SR(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function IR(e,t,n,r,s){const a=t.slice();a[0]=s;const i=Xn(n,Fn(a)),o=e.length;return function(e,t,n,r,s,a){const i=SR(t,2)[1],o=SR(a,2)[1];let l=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)s[l*o+t]=e[n*i+t];++l}}(e,t,r,0===o?0:o/t[0],i,a),[i,a]}function NR(e,t,n,r,s,a,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const s=gr(r,t.length,or(t)).join(",");throw new Error(`indices[${s}] = ${e} is not in [0, ${n})`)}}))}(a,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:u,valueSlices:c,numValues:d}=kR(a,i,e,l),h=function(e){const t=[];for(let n=0;n<e.length;++n){const r=Xn("int32",e[n].length);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(u),p=IR(n,r,s,c,d);return[h,p[0],p[1]]}const TR={kernelName:Ma,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map((e=>n.data.get(e.dataId).values)),u=s.map((e=>e.shape)),c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=NR(l,u,c,a.shape,a.dtype,d,i.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}},CR=2147483647;function ER(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,l=0===s.length,u=0===i.length,c=[];o||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let e=1;e<c.length;++e)if(c[e]!==c[e-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=Xn("int32",d+1);h[0]=0;for(let t=0;t<d;++t){const n=o?e[0]:e[t],s=l?r[0]:r[t],i=u?a[0]:a[t];if(0===i)throw new Error("Requires delta != 0");let c;if(i>0&&s<n||i<0&&s>n)c=0;else if(c=Math.ceil(Math.abs((s-n)/i)),c>CR)throw new Error(`Requires ((limit - start) / delta) <= ${CR}`);h[t+1]=h[t]+c}const p=Xn(n,h[d]);let f=0;for(let t=0;t<d;++t){const n=h[t+1]-h[t];let r=o?e[0]:e[t];const s=u?a[0]:a[t];for(let e=0;e<n;++e)p[f++]=r,r+=s}return[h,p]}const $R={kernelName:La,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=ER(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var _R=ky;class OR{constructor(e,t,n,r,s,a,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=Iy(u),this.raggedRank=Ny(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===_R.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===_R.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case _R.VALUE_ROWIDS:return OR.getMaxWidthValueRowID(t);case _R.ROW_SPLITS:return OR.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${_R[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],s=0;for(let a=1;a<t;++a){const t=e[a];t!==r&&(r=t,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return AR(e,n)}calculateOutputSize(e){const t=this.valuesShape;Ty(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=Sy(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let e=1;e<=this.raggedRank;++e)r[e]<0&&(r[e]=this.getMaxWidth(e));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),s=[];let a=0;for(let e=0;e<r;++e,a+=t)s.push(a);for(let t=r;t<e;++t)s.push(-1);return Rn(s.length===e,(()=>"Final length of result must be equal to firstDimension.")),s}calculateOutputIndexRowSplit(e,t,n,r){const s=e.length,a=[];for(let i=0;i<s-1;++i){const s=e[i+1]-e[i];let o=Math.min(r,s),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)a.push(l),l+=n;for(let e=0;e<s-o;++e)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){const s=e.length,a=[];if(0===s)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];a.push(l);for(let u=1;u<s;++u){const s=e[u];if(s===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);l=t[s]}a.push(l)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){const s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case _R.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,r);case _R.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,r);default:throw new Error(`Unsupported partition type: ${_R[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case _R.FIRST_DIM_SIZE:return e[0];case _R.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case _R.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${_R[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const r=AR(t,!1),s=Xn(this.valuesDType,Fn(r));if(n[0]*t[0]>0){let a=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){a=this.calculateOutputIndex(e-1,a,n[e],t[e])}this.setOutput(this.raggedRank,a,s,r)}return[r,s]}setOutput(e,t,n,r){if(0===n.length)return;const s=this.values,a=n;let i=r.slice();i=i.slice(e+1);const o=Fn(i),l=t.length;let u=this.defaultValue;if(u.length!==o&&1!==u.length){const e=this.defaultValueShape;Dl((()=>{const t=Rh(u,e),n=Kh(t,i);u=n.dataSync()}))}let c=0,d=0,h=0;for(let e=0;e<=l;++e){let r=e<l?t[e]:-1;if(r!==h){if(d<h){const e=s.subarray(c*o);RR(a.subarray(d*o),e,(h-d)*o)}if(e>=l){const e=n.length;r=Math.floor(e/o)}if(r>h)if(1===this.defaultValue.length)a.subarray(h*o,r*o).fill(this.defaultValue[0]),h=r;else for(;r>h;){RR(a.slice(h*o),u,o),++h}r<0?(c=e+1,d=h):(c=e,d=h,h=d+1)}else++h}}}function RR(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function AR(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function DR(e,t,n,r,s,a,i,o,l,u){return new OR(e,t,n,r,s,a,i,o,l,u).compute()}const FR={kernelName:za,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,m]=DR(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}};function MR(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return hr(0,r);const s=hr(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return s}const LR={kernelName:Pa,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=MR(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}},zR=zC(Ua,(e=>1/e)),PR={kernelName:Ua,backendName:"cpu",kernelFunc:zR};const BR={kernelName:Ha,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;DC(s,"resizeBilinear");const l=or(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(Fn([d,u,c,f])),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c];let v=0;const x=y[0]/b[0],w=y[1]/b[1];for(let e=0;e<d;e++)for(let t=0;t<u;t++){let n;n=i?x*(t+.5)-.5:x*t;const r=Math.max(0,Math.floor(n)),s=n-r,a=Math.min(h-1,Math.ceil(n)),o=e*l[0]+r*l[1],u=e*l[0]+a*l[1];for(let e=0;e<c;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(p-1,Math.ceil(t)),c=o+n*l[2],d=u+n*l[2],h=o+a*l[2],y=u+a*l[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[d+e],a=t+(m[h+e]-t)*r,i=a+(n+(m[y+e]-n)*r-a)*s;g[v++]=i}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}};const UR={kernelName:qa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;DC([a,s],"resizeBilinearGrad");const o=or(s.shape),[l,u,c,d]=s.shape,[,h,p]=a.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(a.dataId).values;let x=0;for(let e=0;e<l;e++){const t=e*o[0];for(let e=0;e<h;e++){const n=e*y,r=Math.floor(n),s=Math.min(Math.ceil(n),u-1),a=t+r*o[1],i=t+s*o[1],l=n-r,h=1-l;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),s=t-n,u=1-s,p=a+n*o[2],m=a+r*o[2],g=i+n*o[2],y=i+r*o[2],w=h*u,k=h*s,S=l*u,I=l*s;for(let e=0;e<d;e++){const t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*I}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}};const jR={kernelName:Va,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;DC(s,"resizeNearestNeighbor");const l=or(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(d*u*c*f),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c],v=y[0]/b[0],x=y[1]/b[1];let w=0;for(let e=0;e<d;e++){const t=e*l[0];for(let e=0;e<u;e++){const n=i?v*(e+.5):v*e;let r=Math.min(h-1,a?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const s=t+r*l[1];for(let e=0;e<c;e++){const t=i?x*(e+.5):x*e;let n=Math.min(p-1,a?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=s+n*l[2];for(let e=0;e<f;e++){const t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([d,u,c,f],s.dtype,g)}};const WR={kernelName:Ga,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;DC([a,s],"resizeNearestNeighborGrad");const o=or(s.shape),l=or(a.shape),[u,c,d,h]=s.shape,[,p,f]=a.shape,m=new Float32Array(u*c*d*h),g=n.data.get(a.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let e=0;e<u;e++){const t=e*o[0];for(let e=0;e<c;e++){const n=t+e*o[1],r=Math.floor(e*w),s=Math.floor(r-S/2);for(let r=0;r<d;r++){const a=n+r*o[2],u=Math.floor(r*k),y=Math.floor(u-I/2);for(let n=0;n<h;n++){let o=0;for(let a=0;a<S;a++){const u=a+s;if(u<0||u>=p)continue;const h=t+u*l[1],m=u*v;if(e===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){const t=e+y;if(t<0||t>=f)continue;const s=h+t*l[2],a=t*x;r===Math.min(d-1,i?Math.round(a):Math.floor(a))&&(o+=g[s+n])}}m[a+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}};const VR={kernelName:Xa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;DC(s,"reverse");const i=s.shape.length,o=Hn(a,s.shape);if(0===i)return jC({inputs:{x:s},backend:n});const l=new Fo(s.shape,s.dtype),u=n.bufferSync(s);for(let e=0;e<l.size;e++){const t=l.indexToLoc(e),n=t.slice();o.forEach((e=>n[e]=s.shape[e]-1-n[e])),l.set(u.get(...n),...t)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},GR={kernelName:Bi,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=Kn(r.dtype,Fn(r.shape)),[u,c,d,h]=r.shape,[p,f]=$y(i,c,d),m=Math.sin(s),g=Math.cos(s),y=o.data.get(r.dataId).values;for(let e=0;e<u;e++){const t=e*d*c*h;for(let e=0;e<c;e++){const n=e*(d*h);for(let r=0;r<d;r++){const s=r*h;for(let i=0;i<h;i++){const o=[u,e,r,i],b=o[2],v=o[1];let x=(b-p)*g-(v-f)*m,w=(b-p)*m+(v-f)*g;x=Math.round(x+p),w=Math.round(w+f);let k=a;if("number"!=typeof a&&(k=3===i?255:a[i]),x>=0&&x<d&&w>=0&&w<c){k=y[t+w*(d*h)+x*h+i]}l[t+n+s+i]=k}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},HR=zC(Ya,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1})),qR={kernelName:Ya,backendName:"cpu",kernelFunc:HR},KR=LC((e=>1/Math.sqrt(e))),XR=PC(Qa,KR),YR={kernelName:Qa,backendName:"cpu",kernelFunc:XR};function QR(e,t,n,r,s,a,i,o,l,u){const c=[r/s,s],d=e.values,h=t.values;if(0===r)return Xu(n,t.dtype);const p=l instanceof Fo?l:Xu(c,t.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let e=0;e<a;e++){const a=[];let l=0;for(let t=0;t<i;t++){const n=d[e*i+t];a.push(n),l+=n*o[t]}if(l<0||l>=r/s)throw new Error(`Invalid indices: ${a} does not index into ${n}`);for(let n=0;n<s;n++)u?p.values[l*s+n]+=h[e*s+n]:p.values[l*s+n]=0===t.rank?h[0]:h[e*s+n]}return p}const JR={kernelName:Ja,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Sd(0,s,i),h=QR(n.bufferSync(s),n.bufferSync(a),i,d,u,l,o,c,0,!0);return n.makeTensorInfo(i,h.dtype,h.values)}};function ZR(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function eA(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}const tA={kernelName:ei,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=function(e,t,n,r,s,a){const i=Xn("int32",n*s);for(let o=0;o<n;++o){const n=e.slice(o*r,(o+1)*r),l=o*s;for(let e=0;e<s;++e)i[l+e]="left"===a?ZR(n,t[e+l]):eA(n,t[e+l])}return i}(n.data.get(s.dataId).values,n.data.get(a.dataId).values,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",o)}};const nA={kernelName:ti,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;DC([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=Ko(s.dtype,a.dtype),d=hr(Fn(s.shape),c);let h=0;const p=0===i||i>1||1===s.shape.length?1:Fn(s.shape.slice(1));for(let e=0;e<o.length;e++)for(let t=0;t<p;t++)1===o[e]?d[h++]=l[e]:d[h++]=u[e];return n.makeTensorInfo(s.shape,c,d)}},rA=Fy,sA=My,aA=zC(ni,(e=>e>=0?sA*e:rA*(Math.exp(e)-1))),iA={kernelName:ni,backendName:"cpu",kernelFunc:aA},oA=zC(ii,(e=>e<0?-1:e>0?1:0)),lA={kernelName:ii,backendName:"cpu",kernelFunc:oA},uA=zC(si,(e=>Math.sin(e))),cA={kernelName:si,backendName:"cpu",kernelFunc:uA},dA=zC(ai,(e=>Math.sinh(e))),hA={kernelName:ai,backendName:"cpu",kernelFunc:dA},pA=Math.log(1.1920928955078125e-7)+2,fA=zC(li,(e=>{const t=e>-pA,n=e<pA,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s})),mA={kernelName:li,backendName:"cpu",kernelFunc:fA};const gA={kernelName:di,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;DC([s],"spaceToBatchND");const o=Fn(a),l=[[0,0]];l.push(...i);for(let e=1+a.length;e<s.shape.length;++e)l.push([0,0]);const u=gR.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=_y(u.shape,a,o,!1),d=Oy(c.length,a.length,!1),h=Ry(u.shape,a,o,!1),p=bE({inputs:{x:u},backend:n,attrs:{shape:c}}),f=OE({inputs:{x:p},backend:n,attrs:{perm:d}}),m=bE({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function yA(e,t,n,r,s,a,i){const o=t[0],l=a[0],u=new Array(l),c=new Array(o),d=t[1];if(0===l){if(0!==o)throw new Error(lb(o));return[Xn(n,0),[0,d],Xn(s,0),u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let t=0;t<o;++t){const n=e[t*d];if(n<0)throw new Error(ub(t,n));if(n>=l)throw new Error(cb(t,n,l));++f[n],h=h&&n>=p,p=n}let m=!0;for(let e=0;e<l;++e){const t=0===f[e];u[e]=t,m=m&&!t,f[e]=Math.max(f[e],1),e>0&&(f[e]+=f[e-1])}if(m&&h){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,d],n,u,c]}{const t=f[l-1],a=Xn(n,t*d),h=Xn(s,t),p=new Array(l).fill(0);for(let t=0;t<o;++t){const n=e[t*d],s=p[n],i=(0===n?0:f[n-1])+s;p[n]++;for(let n=0;n<d;++n)a[i*d+n]=e[t*d+n];h[i]=r[t],c[t]=i}for(let e=0;e<l;++e){if(0===p[e]){const t=0===e?0:f[e-1];a[t*d+0]=e;for(let e=1;e<d;++e)a[t*d+e]=0;h[t]=i}}return[a,[t,d],h,u,c]}}const bA={kernelName:fi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=yA(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function vA(e,t,n,r,s){const a=Fn(r),i=t[0],o=s.length,l=[];let u=1,c=-1;for(let e=0;e<o;++e){const t=s[e];if(-1===t){if(-1!==c)throw new Error(db(c,e));c=e,l.push(1)}else{if(t<0)throw new Error(hb(e,t));u*=t,l.push(t)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(a/u);if(u*e!==a)throw new Error(fb(r,l));l[c]=e}if(Fn(l)!==a)throw new Error(mb(r,l));const d=r.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=Xn(n,i*o);for(let t=0;t<i;++t){let n=0;for(let r=0;r<d;++r)n+=e[t*d+r]*h[r];for(let e=0;e<o;++e)f[t*o+e]=Math.trunc(n/p[e]),n%=p[e]}return[f,[i,o],l]}const xA={kernelName:mi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,d]=vA(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}};function wA(e,t,n,r,s,a=!1,i=0){const o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?s[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const d=t.slice();d[0]=c;const h=Xn(n,d.reduce(((e,t)=>e*t),1));if(0===o)return c>0&&h.fill(i),[h,d];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=s[p];for(;;){let t=0;if(f<o){if(t=s[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(bb(g,c));g>m&&h.fill(i,m*u,g*u);for(let t=p;t<f;++t){const n=r[t];if(n<0||n>=l[0])throw new Error(vb(t,r[t],l[0]));for(let t=0;t<u;t++)h[g*u+t]+=e[n*u+t]}if(a)for(let e=0;e<u;e++)h[g*u+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>o)break}return m<c&&h.fill(i,m*u,c*u),[h,d]}const kA={kernelName:gi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=wA(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const SA={kernelName:yi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=wA(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const IA={kernelName:bi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Sd(0,s,o),p=!1,f=n.bufferSync(s);let m;switch(a.dtype){case"bool":m=QR(f,n.bufferSync(a),o,h,c,u,l,d,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":m=QR(f,n.bufferSync(a),o,h,c,u,l,d,n.data.get(i.dataId).values[0],p);break;case"int32":m=QR(f,n.bufferSync(a),o,h,c,u,l,d,n.data.get(i.dataId).values[0],p);break;case"string":m=QR(f,n.bufferSync(a),o,h,c,u,l,d,Io(n.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}};const NA={kernelName:hi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Hn(i,s.shape)[0],l=ob(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map((e=>{const t=[...c];t[o]=e;const r=r$({inputs:{x:s},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},TA=LC((e=>Math.sqrt(e))),CA=zC(ui,(e=>Math.sqrt(e))),EA={kernelName:ui,backendName:"cpu",kernelFunc:CA},$A={kernelName:xi,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;DC(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let e=0;e<s.length;++e){const t=s[e];a[e]=t*t}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},_A=HC(((e,t)=>{const n=e-t;return n*n})),OA=hE(vi,_A),RA={kernelName:vi,backendName:"cpu",kernelFunc:OA},AA=LC(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)})),DA=PC(wi,AA),FA={kernelName:wi,backendName:"cpu",kernelFunc:DA},MA=zC(zi,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),LA={kernelName:zi,backendName:"cpu",kernelFunc:MA};function zA(e,t,n,r){const s=Xu(e,t.dtype);for(let e=0;e<s.size;e++){const a=s.indexToLoc(e),i=new Array(a.length);for(let e=0;e<i.length;e++)i[e]=a[e]*n[e]+r[e];s.set(t.get(...i),...a)}return s}const PA={kernelName:ki,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;DC(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=Ud(s.shape,a,i,o,l,u,c,d,h);let w;if(m)w=bE({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){Rn(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=Ed(b,v,x),t=r$({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=bE({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=zA(p,n.bufferSync(s),x,b);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class BA{constructor(e,t,n,r,s,a){this.separator=So(e),this.nGramWidths=t,this.leftPad=So(n),this.rightPad=So(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){const o=this.getPadWidth(a),l=Math.max(0,o-i),u=Math.max(0,o-(s-(i+1))),c=a-(l+u),d=t+(l>0?0:i-o);let h=0;h+=l*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=u*this.rightPad.length;h+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(h);const p=n[r+i];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let s=1;s<r;++s){let r=t[s]>=e;if(r=r&&t[s]<=n,!r)throw new Error(`Invalid split value ${t[s]}, must be in [${e}, ${n}]`);e=t[s]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=r-1,a=Xn("int32",r);if(0===n||0===r){const e=new Array(n);for(let e=0;e<=s;++e)a[e]=0;return[e,a]}a[0]=0;for(let e=1;e<=s;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach((e=>{r+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===r&&(r=1),a[e]=a[e-1]+r}const i=new Array(a[s]);for(let n=0;n<s;++n){const r=t[n];let s=a[n];if(this.nGramWidths.forEach((a=>{const o=t[n+1]-t[n],l=this.getNumNGrams(o,a);this.createNGrams(e,r,i,s,l,a),s+=l})),this.preserveShort&&s===a[n]){const a=t[n+1]-t[n];if(0===a)continue;const o=a+2*this.padWidth,l=1;this.createNGrams(e,r,i,s,l,o)}}return[i,a]}}function UA(e,t,n,r,s,a,i,o){return new BA(n,r,s,a,i,o).compute(e,t)}const jA={kernelName:Si,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=UA(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};function WA(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let a=e.indexOf(s);for(;-1!==a;){const t=e.subarray(0,a);n&&0===t.length||r.push(t),a=(e=e.subarray(a+1)).indexOf(s)}return void(n&&0===e.length||r.push(e))}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(s,a);n&&0===t.length||r.push(t),s=a+1}}function VA(e,t,n){const r=e.length,s=[];let a=0,i=0;const o=new Array(r);for(let l=0;l<r;++l){const r=s.length;WA(e[l],t,n,s);const u=s.length-r;o[l]=u,a+=u,i=Math.max(i,u)}const l=Xn("int32",2*a),u=new Array(a),c=[r,i];let d=0;for(let e=0;e<r;++e)for(let t=0;t<o[e];++t)l[2*d]=e,l[2*d+1]=t,u[d]=s[d],++d;return[l,u,c]}const GA={kernelName:Ii,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=VA(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};function HA(e,t){const n=Xn("int32",e.length);for(let r=0;r<e.length;++r)n[r]=bo(e[r]).modulo(t).getLowBitsUnsigned();return n}const qA={kernelName:Ni,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=HA(n.data.get(a.dataId).values,s);return n.makeTensorInfo(a.shape,"int32",i)}},KA=zC(Ci,(e=>Math.tan(e))),XA={kernelName:Ci,backendName:"cpu",kernelFunc:KA},YA=zC(Ei,(e=>Math.tanh(e)));const QA={kernelName:Za,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=Sd(0,s,r.shape),d=n.bufferSync(s),h=n.bufferSync(a),p=n.bufferSync(r),f=QR(d,h,r.shape,c,l,o,i,u,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function JA(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=Xu(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),s=new Array(e.rank);for(let t=0;t<s.length;t++)s[t]=n[t]%e.shape[t];const a=e.locToIndex(s);r.values[t]=e.values[a]}return r}const ZA={kernelName:$i,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;DC(s,"tile");const i=JA(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},eD=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function tD(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const s=r-n+1,a=t-n+1,i=Math.log(s),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(s-o)/s)*Math.sign(a-s/2);tD(e,t,Math.max(n,Math.floor(t-a*o/s+l)),Math.min(r,Math.floor(t+(s-a)*o/s+l)))}const s=e[t];let a=n,i=r;for(En(e,n,t),eD(e[r],s)>0&&En(e,n,r);a<i;){for(En(e,a,i),a++,i--;eD(e[a],s)<0;)a+=1;for(;eD(e[i],s)>0;)i-=1}0===eD(e[n],s)?En(e,n,i):(i+=1,En(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function nD(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],l=Kn(n,i*r),u=Kn("int32",i*r);for(let t=0;t<i;t++){const n=t*o,a=e.subarray(n,n+o);let i=new Array(a.length);a.forEach(((e,t)=>i[t]={value:e,index:t})),r<i.length&&(tD(i,r),i=i.slice(0,r)),s&&i.sort(eD);const c=t*r,d=l.subarray(c,c+r),h=u.subarray(c,c+r);for(let e=0;e<r;e++)d[e]=i[e].value,h[e]=i[e].index}const c=t.slice();return c[c.length-1]=r,[Xu(c,n,l),Xu(c,"int32",u)]}const rD={kernelName:_i,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;DC(s,"topk");const o=n.data.get(s.dataId).values,[l,u]=nD(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};const sD={kernelName:Oi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=s.shape,[f,m]=null!=u?u:[d,h],g=[c,f,m,p],y=or(s.shape),b=y[0],v=y[1],x=y[2],w=or(g),k=w[0],S=w[1],I=w[2],N=Kn(s.dtype,Fn(g));N.fill(l);const T=r.data.get(s.dataId).values,C=r.data.get(a.dataId).values;for(let e=0;e<c;++e){const t=1===a.shape[0]?C:C.subarray(8*e,8*e+8);for(let n=0;n<f;++n)for(let r=0;r<m;++r)for(let s=0;s<p;++s){let a;const u=t[6]*r+t[7]*n+1;if(0===u)continue;const c=(t[0]*r+t[1]*n+t[2])/u,p=(t[3]*r+t[4]*n+t[5])/u,f=aD(c,h,o),m=aD(p,d,o);switch(i){case"nearest":a=oD(T,d,h,b,v,x,e,m,f,s,l);break;case"bilinear":a=lD(T,d,h,b,v,x,e,m,f,s,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}N[e*k+n*S+r*I+s]=a}return r.makeTensorInfo(g,s.dtype,N)}return{dataId:r.write(N,g,s.dtype),shape:s.shape,dtype:s.dtype}}};function aD(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Tn(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return Tn(0,n,t-1)}(e,t);case"nearest":return function(e,t){return Tn(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function iD(e,t,n,r,s,a,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*s+l*a+u]:c}function oD(e,t,n,r,s,a,i,o,l,u,c){return iD(e,t,n,r,s,a,i,Math.round(o),Math.round(l),u,c)}function lD(e,t,n,r,s,a,i,o,l,u,c){const d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1;return(p-o)*((f-l)*iD(e,t,n,r,s,a,i,d,h,u,c)+(l-h)*iD(e,t,n,r,s,a,i,d,f,u,c))+(o-d)*((f-l)*iD(e,t,n,r,s,a,i,p,h,u,c)+(l-h)*iD(e,t,n,r,s,a,i,p,f,u,c))}function uD(e,t,n,r){const s=Hn(t,n)[0],a=[1,n[0],1];for(let e=0;e<s;e++)a[0]*=n[e];a[1]=n[s];for(let e=s+1;e<n.length;e++)a[2]*=n[e];const i=new Map,o=new Int32Array(n[s]),l=new Fo(a,r,e),u=[],c=1===a[0]&&1===a[2];for(let t=0;t<n[s];t++){let n;if(c)n=e[t].toString();else{const e=[];for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)e.push(l.get(n,t,r));n=e.join(",")}const r=i.get(n);if(null!=r)o[t]=r;else{const e=i.size;i.set(n,e),o[t]=e,u.push(t)}}const d=a.slice();d[1]=i.size;const h=new Fo(d,r);u.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)h.set(l.get(n,e,r),n,t,r)}));const p=n.slice();return p[s]=d[1],{outputValues:h.values,outputShape:p,indices:o}}const cD={kernelName:Ai,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;DC(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=uD(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const dD={kernelName:Di,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],l=new Array(i-1);let u=0;for(let e=0;e<i;e++)e!==a&&(l[u++]=s.shape[e]);const c=new Array(i).fill(0),d=s.shape.slice();d[a]=1;const h=new Array(o);for(let e=0;e<h.length;e++){c[a]=e;const t=r$({inputs:{x:s},backend:n,attrs:{begin:c,size:d}});h[e]=bE({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return h}};const hD={kernelName:Fi,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;DC(s,"unsortedSegmentSum");const o=[],l=[],u=s.shape.length-a.shape.length;let c=a;for(let e=0;e<u;++e){const t=y_({inputs:{input:c},backend:n,attrs:{dim:e+1}});c=t,l.push(t)}for(let e=0;e<i;++e){const t=vo(e,"int32"),r=n.makeTensorInfo([],"int32",t),a=s_({inputs:{a:r,b:c},backend:n}),i=cE({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),u=Q$({inputs:{a:i,b:s},backend:n}),d=Z$({inputs:{x:u},backend:n,attrs:{axis:0,keepDims:!1}});o.push(d),l.push(r),l.push(a),l.push(i),l.push(u),l.push(d)}const d=fR({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},pD=[kE,IE,TE,EE,yE,$E,AE,DE,FE,ME,zE,BE,jE,GE,qE,QE,JE,ZE,e$,wE,t$,a$,l$,d$,h$,dE,m$,y$,aE,b$,S$,N$,T$,C$,E$,$$,_$,R$,D$,F$,M$,L$,z$,P$,U$,j$,W$,V$,G$,H$,q$,K$,t_,UC,n_,a_,p_,g_,b_,w_,R_,D_,F_,z_,U_,j_,W_,G_,q_,Y_,Z_,WC,eO,w$,nO,sO,iO,GC,uO,hO,fO,yO,vO,kO,IO,CO,EO,$O,RO,FO,MO,LO,zO,PO,BO,UO,jO,GO,HO,XO,JO,J$,eR,nR,sR,iR,uR,cR,pR,mR,gR,vR,XC,wR,TR,$R,FR,LR,lE,I_,PR,QC,ZC,vE,BR,UR,jR,WR,VR,GR,qR,YR,JR,tA,nA,iA,nE,lA,cA,hA,s$,QO,mA,gA,bA,xA,kA,SA,IA,NA,EA,$A,RA,FA,LA,PA,jA,GA,qA,E_,e_,XA,{kernelName:Ei,backendName:"cpu",kernelFunc:YA},QA,ZA,rD,sD,RE,cD,dD,hD,hR];for(const e of pD)Qi(e);const fD={},mD={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function gD(e,t){if(!(e in fD)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(wr().getBool("IS_SAFARI")||"undefined"==typeof OffscreenCanvas||2!==e){if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete fD[e]}),!1),wr().getBool("SOFTWARE_WEBGL_ENABLED")&&(mD.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",mD)||n.getContext("experimental-webgl",mD);return n.getContext("webgl2",mD)}(e,t);if(null===n)return null;fD[e]=n}const n=fD[e];return null==n||n.isContextLost()?(delete fD[e],gD(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),fD[e])}var yD,bD,vD;function xD(e,t){return[t,e]}function wD(e){const t=Fn(e);return Un(Math.ceil(t/4))}function kD(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function SD(e,t){const n=e;let r,s,a,i,o,l,u,c,d,h;return 2===wr().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function ID(e,t){const n=t();return wr().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(yD||(yD={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(bD||(bD={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(vD||(vD={}));function ND(e){return!!(wr().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function TD(e,t){return FD(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const CD=/ERROR: [0-9]+:([0-9]+):/g;function ED(e,t){const n=CD.exec(t);if(null==n)return;const r=+n[1],s=e.split("\n"),a=s.length.toString().length+2,i=s.map(((e,t)=>Wn((t+1).toString(),a)+e));let o=0;for(let e=0;e<i.length;e++)o=Math.max(i[e].length,o);i.slice(0,r-1),i.slice(r-1,r),i.slice(r)}function $D(e,t){if(ID(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw new Error("Shader program validation failed.")}function _D(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return-1!==o&&(ID(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),ID(e,(()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i))),ID(e,(()=>e.enableVertexAttribArray(o))),!0)}function OD(e,t,n,r){ID(e,(()=>function(e,t,n){MD(e,n),ID(e,(()=>e.activeTexture(e.TEXTURE0+n))),ID(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),ID(e,(()=>e.uniform1i(n,r)))}function RD(e,t,n){ID(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),ID(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function AD(e,t){ID(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),ID(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function DD(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function FD(e,t,n){const r=ID(e,(()=>t()));if(null==r)throw new Error(n);return r}function MD(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function LD(e,t=2){return Fn(e.slice(0,e.length-t))}function zD(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function PD(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[LD(e),...zD(e)]),t}function BD(e){return e%2==0}function UD(e,t){if(zn(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(BD(n)&&BD(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&BD(e[0])&&BD(t[0])}let jD,WD;function VD(e,t){return null!=e.getExtension(t)}function GD(e){try{if(null!=gD(e))return!0}catch(e){return!1}return!1}function HD(e){if(0===e)return!1;const t=gD(e);if(1!==e){if(VD(t,"EXT_color_buffer_float"))return qD(t);const e="EXT_color_buffer_half_float";if(VD(t,e)){const n=t.getExtension(e);return function(e,t){const n=SD(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const s=1,a=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,a,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}(t,n)}return!1}if(!VD(t,"OES_texture_float"))return!1;if(!VD(t,"WEBGL_color_buffer_float"))return!1;return qD(t)}function qD(e){const t=SD(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function KD(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Rn("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const XD=wr();function YD(){let e,t,n,r,s,a,i,o,l,u;return 2===wr().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=wr().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function QD(e,t,n="index"){const r=or(t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / ${t}`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`)).join("")}function JD(e,t,n="index"){const r=or(t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / outShapeStrides[${s}]`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`};`)).join("")}function ZD(e,t,n="index"){const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),s=new Array(n-1);s[n-2]=r[n-1];for(let e=n-3;e>=0;--e)s[e]=`(${s[e+1]} * ${r[e+1]})`;return s}(e.map(((e,t)=>t)),t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / ${r[s]}`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r[s]}`:`index -= ${e[s]} * ${r[s]}`};`)).join("")}function eF(e){const t=or(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}XD.registerFlag("HAS_WEBGL",(()=>XD.getNumber("WEBGL_VERSION")>0)),XD.registerFlag("WEBGL_VERSION",(()=>GD(2)?2:GD(1)?1:0)),XD.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),XD.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===XD.get("WEBGL_VERSION"))),XD.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),XD.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),XD.registerFlag("WEBGL_PACK",(()=>XD.getBool("HAS_WEBGL"))),XD.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>XD.getBool("WEBGL_PACK"))),XD.registerFlag("WEBGL_PACK_CLIP",(()=>XD.getBool("WEBGL_PACK"))),XD.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>XD.getBool("WEBGL_PACK"))),XD.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>XD.getBool("WEBGL_PACK"))),XD.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>XD.getBool("WEBGL_PACK"))),XD.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>XD.getBool("WEBGL_PACK"))),XD.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>XD.getBool("WEBGL_PACK"))),XD.registerFlag("WEBGL_PACK_REDUCE",(()=>XD.getBool("WEBGL_PACK"))),XD.registerFlag("WEBGL_LAZILY_UNPACK",(()=>XD.getBool("WEBGL_PACK"))),XD.registerFlag("WEBGL_CONV_IM2COL",(()=>XD.getBool("WEBGL_PACK"))),XD.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>XD.getBool("WEBGL_PACK"))),XD.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==jD){const t=gD(e);jD=t.getParameter(t.MAX_TEXTURE_SIZE)}return jD}(XD.getNumber("WEBGL_VERSION")))),XD.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==WD){const t=gD(e);WD=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,WD)}(XD.getNumber("WEBGL_VERSION")))),XD.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=XD.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=gD(e);return t=VD(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:VD(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),XD.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>XD.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!dl())),XD.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=gD(e);if(1===e){if(!VD(t,"OES_texture_float"))return!1}else if(!VD(t,"EXT_color_buffer_float"))return!1;return qD(t)}(XD.getNumber("WEBGL_VERSION")))),XD.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!XD.getBool("WEBGL_FORCE_F16_TEXTURES")&&XD.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),XD.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>HD(XD.getNumber("WEBGL_VERSION")))),XD.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=XD.getNumber("WEBGL_VERSION"))&&null!=gD(e).fenceSync;var e})),XD.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>XD.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),XD.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),XD.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>dl()?1:-1),(e=>{if("number"!=typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),XD.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),XD.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),XD.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),XD.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),XD.registerFlag("WEBGL_EXP_CONV",(()=>!1)),XD.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>XD.getBool("IS_TEST"))),XD.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),XD.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),XD.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),XD.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const tF="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:nF}=g;function rF(e,t,n){const r=[];if(e.forEach((e=>{const t=Fn(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=fF(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const s=r.join("\n"),a=e.map((e=>function(e,t,n=!1,r){let s="";s+=n?aF(e,r):sF(e,r);const a=e.shapeInfo.logicalShape,i=t.logicalShape;a.length<=i.length&&(s+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=nF(e.shapeInfo.logicalShape,t.logicalShape),l=pF(i),u=i-a;let c;const d=["x","y","z","w","u","v"];c=0===a?"":i<2&&o.length>=1?"coords = 0;":o.map((e=>`coords.${d[e+u]} = 0;`)).join("\n");let h="";h=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+u]}`)).join(", ");let p="return outputValue;";const f=1===Fn(e.shapeInfo.logicalShape),m=Fn(t.logicalShape),g=1===m;if(1!==a||f||g){if(f&&!g)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=a-2,t=a-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&zn(i,a))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=pF(l),c=nF(e.shapeInfo.logicalShape,t.logicalShape),d=l-o;let h;const p=["x","y","z","w","u","v"];h=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${p[e+d]} = 0;`)).join("\n");let f="";f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+d]}`)).join(", ");return`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${f});\n    }\n  `}(e,t));return s}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),i=t.texShape,o=YD(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let u,c,d=function(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${iF}\n    ${oF}\n    ${lF}\n  `;return t}(o);t.isPacked?(u=function(e,t,n){switch(e.length){case 0:return cF();case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(zn(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,o="",l="b, r, c";for(let t=2;t<e.length-1;t++)i*=e[e.length-t-1],o=`\n      int b${t} = index / ${i};\n      index -= b${t} * ${i};\n    `+o,l=`b${t}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(u=function(e,t,n){switch(e.length){case 0:return cF();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){if(zn(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${JD(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=QD(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${JD(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=QD(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=QD(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=QD(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(d+=uF);return[d,l,c,s,u,a,n.userCode].join("\n")}function sF(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(1===s&&1===a)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=dF(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${hF(e)}\n      }\n    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(1===i&&1===a)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=dF(n);if(1===i)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===a)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(null!=a&&zn(n,a)){if(t)return`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=a[0];return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${a[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:o}=qn(n),l=i;if(l.length<n.length){const n=["row","col"];return`\n      ${sF(mF(e,l),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${gF(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${hF(e)}\n      }\n    `;const u=a[0],c=a[1],d=dF(r);if(1===c)return t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===u)return t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(t)return`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=qn(n),u=o;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${sF(mF(e,u),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${gF(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${i}, 1)));\n        ${hF(e)}\n      }\n    `;const c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===a&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=dF(r);if(t)return`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:u}=qn(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${sF(mF(e,l),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${gF(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${a}, 1)));\n        ${hF(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===a&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=dF(r);if(t)return`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:u}=qn(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${sF(mF(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${gF(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${a}, ${s})) +\n          depth3;\n        ${hF(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=dF(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=qn(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${sF(mF(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${gF(t,a)});\n      }\n    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${hF(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=dF(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function aF(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=YD();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=YD();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],l=YD();if(null!=a&&zn(n,a))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===n[0]){const r=[1,2],a=["b","row","col"];return`\n        ${aF(mF(e,n.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${gF(a,r)});\n        }\n      `}const o=YD();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=YD();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(a[i-1]/2);let h=d*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<i-1;e++)p=`int b${e}, `+p,h*=a[i-e-1],f=`b${e} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const iF="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",oF="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",lF="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",uF="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function cF(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function dF(e){return`offset${e}`}function hF(e){const t=e.name,n=Fn(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function pF(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function fF(e,t,n){const{newShape:r,keptDims:s}=qn(t),a=t.length,i=e&&3===a&&1===t[0],o=i?t.slice(1):r,l=!e&&a>1&&!zn(t,n)&&r.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:s}}function mF(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function gF(e,t){return t.map((t=>e[t])).join(", ")}function yF(e,t,n,r){const s=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),a=s.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=rF(s,i,t),l=function(e,t){const n=FD(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(ID(e,(()=>e.shaderSource(n,t))),ID(e,(()=>e.compileShader(n))),wr().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw ED(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),u=e.createProgram(l);return wr().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i},bF(e,t,u)))}function bF(e,t,n){const r=[],s=[];let a,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===wr().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const s of t.variableNames){const a={name:s,uniform:e.getUniformLocation(n,s,c),offset:e.getUniformLocation(n,`offset${s}`,c)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,`${s}Shape`,c),a.texShape=e.getUniformLocation(n,`${s}TexShape`,c)),r.push(a)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const r of t.customUniforms)s.push(e.getUniformLocation(n,r.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function vF(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,s=t[n],a=s.shape;if(!zn(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,o=s.isUniform?null:s.texData.texShape;if(!zn(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function xF(e){return wr().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class wF{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=yD.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=YD();this.outputShape=e,this.enableShapeUniforms=xF(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?JD(["r","c","d"],e):QD(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class kF{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=yD.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=YD();this.outputShape=e,this.enableShapeUniforms=xF(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?JD(["r","c","d"],e):QD(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class SF{constructor(e){this.variableNames=["A"],this.outTexUsage=bD.DOWNLOAD;const t=YD();this.outputShape=e,this.userCode=`\n      ${tF}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class IF{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=bD.DOWNLOAD;const t=YD();this.outputShape=e,this.userCode=`\n      ${tF}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const NF={R:0,G:1,B:2,A:3};class TF{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=YD();this.outputShape=e,this.enableShapeUniforms=xF(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let e=0;e<n.length;e++){const t=n[e];a+=`\n          if(offset == ${e}) {\n            result = values[${NF[t]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":eF(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${a}\n        }\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class CF{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=YD();this.outputShape=e,this.enableShapeUniforms=xF(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let s=0;s<=1;s++){const a=2*t+s;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${s} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${s};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":eF(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${s};\n        }\n    `}}function EF(e){const t=YD();return function(e,t){const n=FD(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(ID(e,(()=>e.shaderSource(n,t))),ID(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function $F(e){return function(e,t){const n=FD(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return ID(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),ID(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function _F(e){return function(e,t){const n=FD(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return ID(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),ID(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function OF(e,t,n,r,s,a){!function(e,t){const n=wr().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return FD(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return ID(e,(()=>e.bindTexture(o,i))),ID(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),ID(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),ID(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),ID(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===wr().getNumber("WEBGL_VERSION")?ID(e,(()=>e.texImage2D(o,0,r,t,n,0,s,a,null))):ID(e,(()=>e.texStorage2D(o,1,r,t,n))),ID(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function RF(e){return e.internalFormatFloat}function AF(e){return e.internalFormatHalfFloat}function DF(e){return e.downloadTextureFormat}function FF(e){return e.internalFormatPackedFloat}function MF(e){return e.internalFormatPackedHalfFloat}function LF(e,t,n,r,s,a,i,o){const l=e,u=new Float32Array(function(e,t){const[n,r]=kD(e,t);return n*r*4}(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}class zF{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=wr().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){fD[e]=t}(t,e)):this.gl=gD(t),e=this.gl,2===wr().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>ID(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>ID(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>ID(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>ID(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ID(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>ID(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>ID(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>ID(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===wr().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=TD(this.gl,e),VD(this.gl,t))this.textureHalfFloatExtension=TD(this.gl,t);else if(wr().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),VD(this.gl,r))this.colorBufferHalfFloatExtension=TD(this.gl,r);else if(wr().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",VD(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!VD(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=$F(this.gl),this.indexBuffer=_F(this.gl),this.framebuffer=function(e){return FD(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=SD(this.gl,this.textureHalfFloatExtension)}get debug(){return wr().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program,this.outputTexture;const e=this.gl;ID(e,(()=>e.finish())),ID(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),ID(e,(()=>e.deleteFramebuffer(this.framebuffer))),ID(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),ID(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),ID(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=xD(t,n);return OF(e,s,a,RF(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=xD(t,n);return OF(e,s,a,AF(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=xD(t,n);return OF(e,s,a,DF(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){ID(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===wr().getNumber("WEBGL_VERSION")?ID(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):ID(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===wr().getNumber("WEBGL_VERSION")?ID(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):ID(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),ID(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,s,a){let i,o,l;ID(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=a.internalFormatPackedFloat),i.set(s),2===wr().getNumber("WEBGL_VERSION")?ID(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):ID(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),ID(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=kD(t,n);return OF(e,s,a,MF(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=kD(t,n);return OF(e,s,a,FF(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(AD(this.gl,this.framebuffer),this.outputTexture=null),ID(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[s,a]=xD(t,n),i=new Uint8Array(t*n*4);return ID(e,(()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return LF(this.gl,e,0,0,0,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n){const r=e.createBuffer();ID(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const s=16*t*n;return ID(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),ID(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),ID(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(wr().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else wr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,wr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return ID(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=EF(t));const n=function(e){return FD(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);ID(t,(()=>t.attachShader(n,this.vertexShader))),ID(t,(()=>t.attachShader(n,e))),function(e,t){if(ID(e,(()=>e.linkProgram(t))),!wr().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&$D(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;ID(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){ID(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),_D(e,t,"clipSpacePos",n,3,20,0)&&_D(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(ID(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&$D(this.gl,this.program),ID(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return FD(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),ID(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),OD(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=kD(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&$D(this.gl,this.program),DD(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){this.getVertexArray();this.debugValidate()}ID(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ID(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=TD(this.gl,2===wr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===wr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===wr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Vn((()=>this.disposed||this.isQueryAvailable(e,wr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,wr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in wr().platform&&(n=wr().platform.setTimeoutCustom.bind(wr().platform)),Vn((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),RD(this.gl,e,this.framebuffer),this.debug&&DD(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(RD(this.gl,this.outputTexture,this.framebuffer),this.debug&&DD(this.gl)):AD(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;RD(r,e,this.framebuffer),this.debug&&DD(r),this.outputTexture=e,ID(r,(()=>r.viewport(0,0,t,n))),ID(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),ID(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:PF,XI:BF,Nk:UF,f6:jF,ct:WF,YG:VF,hH:GF,z3:HF,sG:qF,uM:KF,vS:XF,qB:YF,GG:QF,rq:JF,lg:ZF,WR:eM,cu:tM,GE:nM,px:rM,jC:sM,He:aM,hE:iM,BF:oM,Dk:lM,cl:uM,_B:cM,ub:dM,_f:hM,Ku:pM,qy:fM,Zy:mM,bu:gM,zv:yM,dH:bM,HS:vM,yH:xM,l3:wM,z9:kM,x6:SM,_m:IM,eW:NM,GK:TM,SP:CM,yr:EM,dl:$M,Dw:_M,xT:OM,_X:RM,wz:AM}=P;function DM(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function FM(e,t){return 1===t?[e]:DM(e,t)}class MM{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=xF(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=FM("rc",this.rank),t=pF(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),s=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)s=`${e[e.length-1-t]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class LM{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=xF(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r,s;this.userCode=`\n      ${r=t,s=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${s?ZD(["r","c","d"],"inputShape"):QD(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":eF(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class zM{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=BM(t,n),s=UM(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=PM(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}let i;return r===vD.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===vD.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===vD.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===vD.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===vD.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=BM(n,r),a=UM(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=PM(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=wr().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[a],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;this.numFreeTextures,this.numUsedTextures,this._numBytesFree,this._numBytesAllocated}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function PM(e,t,n,r,s){const a=function(e,t){switch(e){case vD.PACKED_2X2_FLOAT32:return FF(t);case vD.PACKED_2X2_FLOAT16:return MF(t);case vD.UNPACKED_FLOAT32:return RF(t);case vD.UNPACKED_FLOAT16:return AF(t);case vD.PACKED_4X1_UNSIGNED_BYTE:return DF(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(s){const[t,n]=kD(e[0],e[1]);i=t*n}else{const[t,n]=xD(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,a);return i*o}function BM(e,t){if(e===bD.UPLOAD)return vD.PACKED_2X2_FLOAT32;if(e===bD.RENDER||null==e)return function(e){return wr().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?vD.PACKED_2X2_FLOAT32:vD.UNPACKED_FLOAT32:e?vD.PACKED_2X2_FLOAT16:vD.UNPACKED_FLOAT16}(t);if(e===bD.DOWNLOAD||e===bD.PIXELS)return vD.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function UM(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class jM{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=xF(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const WM="if (isnan(x)) return x;",VM="return abs(x);";const GM=WM+"\n  return (x < 0.0) ? 0.0 : x;\n",HM=WM+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",qM="return x;";class KM{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=xF(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class XM{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=xF(this.outputShape.length);const t=e.length,n=FM("rc",t),r=pF(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const YM=Hm,QM={};const JM=wr().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class ZM extends kn{nextDataId(){return ZM.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!wr().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof zF)t=e;else{const n=gD(wr().getNumber("WEBGL_VERSION"),e);t=new zF(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=gD(wr().getNumber("WEBGL_VERSION"));t=new zF(e),this.binaryCache=((n=wr().getNumber("WEBGL_VERSION"))in QM||(QM[n]={}),QM[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new zM(this.gpgpu),this.numMBBeforeWarning=null==wr().global.screen?1024:wr().global.screen.height*wr().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new wn(this,Ol())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,s,a){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,s]},o.texShape=[r,s];const l=PD(t),u=new TF(l,!1,a),c=this.runWebGLProgram(u,[i],n,[[r,s]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((wr().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||wr().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:bD.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,s){if(wr().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:bD.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:i,isPacked:o}=t;if(null!=a){let t;t=o?new KM(i,qM):new jM(i,qM);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;if(l&&(u=wo()),"complex64"===r){c=Wy(this.readSync(s.real.dataId),this.readSync(s.imag.dataId))}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=wo()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:i,isPacked:o}=t;if(null!=s){let t;t=o?new KM(r,qM):new jM(r,qM);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if(wr().getBool("DEBUG")&&!wr().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===wr().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==a&&wr().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...wD(r))}if(this.pendingRead.set(e,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);u=Wy(e[0],e[1])}else if(null==c)u=this.getValuesFromTexture(e);else{const e=Fn(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const e=this.gpgpu.gl;ID(e,(()=>e.deleteBuffer(c)))}const d=this.convertAndCacheOnCPU(e,u),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ol().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:s,slice:a,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let n;n=o?new KM(s,qM):new jM(s,qM);const r=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),a=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),a}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),c=Ol().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Io(e)));return Xu(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return Xu(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!ND(n)){if(wr().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=Fn(t);if(wr().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...wD(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),a}const a=wr().getBool("WEBGL_PACK")&&!0===r,i=a?PD(t):t,o=a?new IF(i):new SF(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return wr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=To(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=To(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(wr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);i.kernelMs=$n(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return wr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:wo(),endMs:null}}endTimer(e){return wr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=wo(),e)}async getQueryTime(e){if(wr().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=JM){return wr().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Fn(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){Vi();const t=e.dataSync();return YM(e.shape,t)}packedUnaryOp(e,t,n){const r=new KM(e.shape,t),s=this.compileAndRun(r,[e],n);return Ol().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=bM(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(wr().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,VM,e.dtype);const t=new jM(e.shape,VM),n=this.compileAndRun(t,[e]);return Ol().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&tr(n[0])){const s=n.map((e=>So(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return Ol().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new XM(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new MM(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[LD(e.shape),...zD(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[LD(t),...zD(t)],a=new LM(s,n),i=[n],o=this.runWebGLProgram(a,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:s,dtype:a}=n;if(null!=t){Rn(Fn(s)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const i=PD(s);let o;o=r?new kF(i):new wF(i);const l=[null!=t?t:wD(i)];return{dtype:a,shape:s,dataId:this.runWebGLProgram(o,[{shape:i,dtype:a,dataId:e}],a,l,!0,t).dataId}}runWebGLProgram(e,t,n,r,s=!1,a){const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===yD.DENSE){const t=null!=a?a:wD(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===Fn(i.shape))return o.values=Kn(i.dtype,0),i;const l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Fn(t.shape)<=wr().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!UD(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const c={shape:i.shape,texData:o,isUniform:!1},d=function(e,t,n){let r="";t.concat(n).forEach((t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const a=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=fF(e.packedInputs,t.shape,a);let u="",c="",d="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=or(o);d=`${e[0]===a[1]}_${e[e.length-1]===a[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const h=t.shape.length,p=2===o.length&&zn(t.shape,a),f=1===Fn(t.shape),m=Ec(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&zn(a,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${a[0]>1}_${a[1]>1}`;r+=`${h}_${g}_${i?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${d}_${y}_${s}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${s}`}}));const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s+`${wr().getNumber("WEBGL_VERSION")}`,a}(e,u,c),h=this.getAndSaveBinary(d,(()=>yF(this.gpgpu,e,u,c))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),wr().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,s){t.program.enableShapeUniforms||(vF(t.inShapeInfos,n),vF([t.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===wr().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let r=0;r<n.length;++r){const s=n[r],{uniform:a,offset:i,shape:o,texShape:l}=t.variablesLocations[r];if(o){const{uniformShape:n}=fF(t.program.packedInputs,s.shape,s.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(o,new Int32Array(n));break;case 2:e.gl.uniform2iv(o,new Int32Array(n));break;case 3:e.gl.uniform3iv(o,new Int32Array(n));break;case 4:e.gl.uniform4iv(o,new Int32Array(n))}}if(l&&e.gl.uniform2i(l,s.texData.texShape[0],s.texData.texShape[1]),null!=a)if(s.isUniform)if(Fn(s.shape)<2)e.gl.uniform1f(a,s.uniformValues[0]);else{let t=s.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=s.texData.slice&&null!=i&&e.gl.uniform1i(i,s.texData.slice.flatOffset),e.setInputMatrixTexture(s.texData.texture.texture,a,r)}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=or(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let n=0;n<t.program.customUniforms.length;++n){const r=t.program.customUniforms[n],a=t.customUniformLocations[n],i=s[n];if("float"===r.type)e.gl.uniform1fv(a,i);else if("vec2"===r.type)e.gl.uniform2fv(a,i);else if("vec3"===r.type)e.gl.uniform3fv(a,i);else if("vec4"===r.type)e.gl.uniform4fv(a,i);else if("int"===r.type)e.gl.uniform1iv(a,i);else if("ivec2"===r.type)e.gl.uniform2iv(a,i);else if("ivec3"===r.type)e.gl.uniform3iv(a,i);else{if("ivec4"!==r.type)throw Error(`uniform type ${r.type} is not supported yet.`);e.gl.uniform4iv(a,i)}}e.executeProgram()}(this.gpgpu,h,u,c,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=wr().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=wo();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!wr().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===s){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r,s=!1){n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!wr().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Dl((()=>{if(!wr().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=wr().getBool("DEBUG");wr().set("DEBUG",!1);const t=this.abs(pc(1e-8)).dataSync()[0];if(wr().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:o}=t;if(null!=a)return;const l=null!=this.activeTimers;let u;l&&(u=wo());let c=t.texShape;if(null==c&&(c=function(e,t=!1){let n=wr().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=wr().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&wr().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?Cn(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=qn(e);e=t.newShape}let s=Fn(e),a=null;e.length<=1&&s<=n?a=[1,s]:2===e.length&&e[0]<=n&&e[1]<=n?a=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);const i=null!=a&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(null==a||i)if(t){const t=LD(e);let n=2,r=2;e.length&&([n,r]=zD(e)),s=t*(n/2)*(r/2),a=Un(s).map((e=>2*e))}else a=Un(s);return a}(n,o),t.texShape=c),null!=s){const e=PD(n);let a,i=c[1],d=c[0];const h=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!o&&h||([i,d]=kD(c[0],c[1])),a=o?new CF(e,h):new TF(e,h);const p=h?[d,i]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=h?bD.PIXELS:bD.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,s);const g=[[d,i]],y=!0,b=this.runWebGLProgram(a,[f],r,g,y),v=this.texData.get(b.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,wr().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=wo()-u)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Zn(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await vy(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw ED(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:o}=bF(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:s,width:a,channels:i}=e,o=Ol().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=o.writeTexture(r,t,n,s,a,i);return Ol().makeTensorFromDataId(l,t,n,o)}}ZM.nextDataId=0;hl()&&Vl("webgl",(()=>new ZM),2);const eL="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class tL{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=_c(t,n),this.enableShapeUniforms=xF(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const nL="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class rL{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=_c(t,n);const s=this.outputShape.length;this.enableShapeUniforms=xF(s);let a="";if(r)if(0===s||1===Fn(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(a=`\n          ${pF(s)} coords = getOutputCoords();\n        `,1===s)this.enableShapeUniforms?a+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=FM("coords",s);this.enableShapeUniforms?a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function sL(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const aL={kernelName:js,backendName:"webgl",kernelFunc:sL};function iL(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=sL({inputs:{x:r},backend:n}),l=sL({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const oL={kernelName:Zr,backendName:"webgl",kernelFunc:iL},lL="return (a < 0.) ? b * a : a;",uL="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const cL={kernelName:Ks,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",vo(a,"float32")),o=wr().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rL(uL,s.shape,i.shape):new tL(lL,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},dL="return (a < 0.) ? b * a : a;",hL="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const pL={kernelName:Da,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=wr().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rL(hL,r.shape,s.shape):new tL(dL,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}},fL="if (isnan(x)) return x;";function mL({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{const{x:i}=s,o=a,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){const e=o.texData.get(i.dataId),t=n(e.values,l);return o.makeTensorInfo(i.shape,l,t)}let u;return u=wr().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new KM(i.shape,t):new jM(i.shape,e),o.runWebGLProgram(u,[i],l)}}function gL({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{const{a:l,b:u}=i,c=o;if(r&&"complex64"===l.dtype){const t=c.texData.get(l.dataId),n=c.texData.get(u.dataId),[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:l.shape},a={dataId:r.dataId,dtype:r.dtype,shape:u.shape},i=new tL(e,l.shape,u.shape);return c.runWebGLProgram(i,[s,a],Ko(n.dtype,r.dtype))})),a=iL({inputs:{real:r,imag:s},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(s),a}const d=a||Ko(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=s){const e=c.texData.get(l.dataId).values,t=c.texData.get(u.dataId).values,n="string"===l.dtype?Sb(e):e,r="string"===l.dtype?Sb(t):t,[a,i]=s(l.shape,u.shape,n,r,d),o=c.makeTensorInfo(i,d);return c.texData.get(o.dataId).values=a,o}let h;return h=wr().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new rL(t,l.shape,u.shape,n):new tL(e,l.shape,u.shape),c.runWebGLProgram(h,[l,u],d)}}function yL(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":GM;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":HM;if("prelu"===e)return t?hL:dL;if("leakyrelu"===e)return t?uL:lL;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class bL{constructor(e,t,n,r=!1,s=!1,a=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=xF(this.outputShape.length);const u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");const y=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${v};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const vL="return areal * breal - aimag * bimag;",xL="return areal * bimag + aimag * breal;";class wL{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=_c(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const kL="return a * b;";function SL(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=Ko(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),a=new wL(vL,r.shape,s.shape),i=new wL(xL,r.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=n.runWebGLProgram(a,o,"float32"),u=n.runWebGLProgram(i,o,"float32"),c=iL({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[i,o]=oM(r.shape,s.shape,e.values,t.values,a),l=n.makeTensorInfo(o,a);return n.texData.get(l.dataId).values=i,l}let i;return i=wr().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rL(kL,r.shape,s.shape):new tL(kL,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const IL={kernelName:ka,backendName:"webgl",kernelFunc:SL};function NL(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=Fn(s.shape),l=Gn(a,o),u=Fn(l);Rn(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=i.texData.get(s.dataId);return!c.isPacked||UD(s.shape,l)||null!==c.texture&&UD(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function(e,t,n){const r=[LD(e.shape),...zD(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[LD(t),...zD(t)],i=new LM(a,r),o=[r],l=n.runWebGLProgram(i,[s],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(s,l,i)}const TL={kernelName:Wa,backendName:"webgl",kernelFunc:NL};class CL{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];const i=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${Pn(e)?e.toPrecision(2):e}, ones);`}let u="";s%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class EL{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}}function $L(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=Ey(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:l,outSize:u}=s[i];let c,d;c="mean"===n?0===i?new CL({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new CL({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new EL({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=a,a=r.runWebGLProgram(c,[a],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return a}class _L{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=pF(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class OL{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=pF(this.rank),s=DM("rc",this.rank),a=new Array(this.rank);for(let e=0;e<t.length;e++)a[t[e]]=s[e];const i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function RL(e,t,n){const r=wr().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new OL(e.shape,t):new _L(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function AL(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return function(e,t,n,r){const s=t,a=e.shape.length,i=Hn(s,e.shape);let o=i;const l=_p(o,a),u=null!=l;let c=e;u&&(c=RL(e,l,r),o=Rp(o.length,a)),$p("sum",o,a);const[d,h]=Cp(c.shape,o);let p=d;n&&(p=Ep(d,i));const f=Fn(h),m=NL({inputs:{x:c},attrs:{shape:[Fn(e.shape)/f,f]},backend:r}),g=$L(m,Xo(e.dtype),"sum",r),y=NL({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),y}(s,a,i,n)}const DL={kernelName:ci,backendName:"webgl",kernelFunc:AL};function FL(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let e=0;e<l.length;e++)l[e]=s.shape[a[e]];let u;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId).values,t=RM(e,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype);i.texData.get(u.dataId).values=t}else u=RL(s,a,i);return u}const ML={kernelName:Ri,backendName:"webgl",kernelFunc:FL};function LL({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const u=e.shape.length,c=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],h=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=Fn(m),b=Fn(g),v=_c(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);Rn(d===h,(()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));const x=n?[y,d,p]:[y,p,d],w=r?[b,f,h]:[b,h,f],k=NL({inputs:{x:e},backend:s,attrs:{shape:x}}),S=NL({inputs:{x:t},backend:s,attrs:{shape:w}}),I=[k,S],N=Math.max(y,b),T=n?k.shape[1]:k.shape[2],C=null!=a,E=null!=i,$="leakyrelu"===l,_=null!=l?yL(l,!0):null;let O;if((1===p||1===f)&&T>1e3&&!1===(C||E||$||null!=_)){let e=k,t=S;n&&(e=FL({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),I.push(e)),r&&(t=FL({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),I.push(t));const a=1===f;let i=e;1!==f&&(i=NL({inputs:{x:e},backend:s,attrs:{shape:[N,T,1]}}),I.push(i));const o=1===f?2:1;let l=t;a&&(l=NL({inputs:{x:t},backend:s,attrs:{shape:[N,1,T]}}),I.push(l));const u=SL({inputs:{a:i,b:l},backend:s});O=AL({inputs:{x:u},backend:s,attrs:{axis:o,keepDims:!0}}),I.push(u)}else{const l=Ko(e.dtype,t.dtype),u=new bL(x,w,[N,p,f],n,r,C,_,E,$),c=[k,S];if(null!=a&&c.push(a),E&&c.push(i),$){const e=s.makeTensorInfo([],"float32",vo(o,"float32"));c.push(e),I.push(e)}O=s.runWebGLProgram(u,c,l)}const R=NL({inputs:{x:O},backend:s,attrs:{shape:v}});I.push(O);for(const e of I)s.disposeIntermediateTensorInfo(e);return R}const zL={kernelName:Ui,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return LL({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}},PL="return abs(x);";const BL={kernelName:Tr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=bM(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=wr().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new KM(r.shape,PL):new jM(r.shape,PL),n.runWebGLProgram(s,[r],r.dtype)}},UL=mL({opSnippet:WM+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),jL={kernelName:Cr,backendName:"webgl",kernelFunc:UL},WL=mL({opSnippet:WM+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),VL={kernelName:Er,backendName:"webgl",kernelFunc:WL},GL="return a + b;",HL=gL({opSnippet:GL,packedOpSnippet:GL,supportsComplex:!0,cpuKernelImpl:PF}),qL={kernelName:$r,backendName:"webgl",kernelFunc:HL};class KL{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class XL{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const YL={kernelName:_r,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return sL({inputs:{x:s[0]},backend:r});if(s.length>wr().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),a=e({inputs:s.slice(t),backend:r});return e({inputs:[n,a],backend:r})}const a=s.map((e=>e.dtype)).reduce(((e,t)=>Ko(e,t))),i=s.map((e=>e.shape)),o=wr().getBool("WEBGL_PACK")?new XL(s[0].shape,i):new KL(s[0].shape,i);return r.runWebGLProgram(o,s,a)}};const QL={kernelName:Or,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Hn(a,s.shape);let u=l;const c=_p(u,o);let d=s;null!=c&&(d=FL({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Rp(u.length,o)),$p("all",u,o);const[h,p]=Cp(d.shape,u),f=NL({inputs:{x:d},backend:n,attrs:{shape:[-1,Fn(p)]}}),m=$L(f,f.dtype,"all",n);let g;if(i){g=NL({inputs:{x:m},backend:n,attrs:{shape:Ep(h,l)}})}else g=NL({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};const JL={kernelName:Rr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Hn(a,s.shape);let u=l;const c=_p(u,o);let d=s;null!=c&&(d=FL({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Rp(u.length,o)),$p("any",u,o);const[h,p]=Cp(d.shape,u),f=NL({inputs:{x:d},backend:n,attrs:{shape:[-1,Fn(p)]}}),m=$L(f,f.dtype,"any",n);let g;if(i){g=NL({inputs:{x:m},backend:n,attrs:{shape:Ep(h,l)}})}else g=NL({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};class ZL{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class ez{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Rn(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,l=pF(o),u=FM("coords",o);let c,d;if(1===a){d=o+1;const e=pF(d);c=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[o-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[o-2]};`}else d=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map((e=>"int "+e)),m=FM("sourceLocR",d-1).concat("inIdx.r"),g=FM("sourceLocG",d-1).concat("inIdx.g"),y=FM("sourceLocB",d-1).concat("inIdx.b"),b=FM("sourceLocA",d-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function tz(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];null!=r&&(s=r.shape[0],a=r.shape[1]);const i=Ey(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new ZL(o,n,null==r),u=[t];null!=r&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=tz(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function nz(e,t,n,r=null){const s=null!=r?r.shape:t.shape,a=Ey(s[s.length-1]),i=new ez(s,a,n,null==r),o=null==r?[t]:[t,r],l=e.runWebGLProgram(i,o,"int32");if(l.shape.length===t.shape.length){const r=nz(e,t,n,l);return e.disposeIntermediateTensorInfo(l),r}return l}function rz(e,t,n,r){const s=[n];if($p("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!wr().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],a=e.texData.get(t.dataId);let i=t;null!==a&&a.isPacked&&(i=e.unpackTensor(t),n.push(i));const[o,l]=Cp(i.shape,s),u=Fn(l),c=NL({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(c);const d=tz(e,c,r);n.push(d);const h=NL({inputs:{x:d},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return nz(e,t,r)}const sz={kernelName:Ar,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Hn(a,s.shape);const o=_p(i,s.shape.length);let l=s;const u=[];null!=o&&(l=FL({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Rp(i.length,l.shape.length)),$p("argMax",[i[0]],l.shape.length);const c=rz(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};const az={kernelName:Dr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Hn(a,s.shape);const o=_p(i,s.shape.length);let l=s;const u=[];null!=o&&(l=FL({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Rp(i.length,l.shape.length)),$p("argMin",[i[0]],l.shape.length);const c=rz(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},iz=mL({opSnippet:WM+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),oz={kernelName:Fr,backendName:"webgl",kernelFunc:iz},lz=mL({opSnippet:WM+"return log(x + sqrt(x * x + 1.0));"}),uz={kernelName:Mr,backendName:"webgl",kernelFunc:lz},cz=mL({opSnippet:WM+"\n  return atan(x);\n"}),dz={kernelName:Lr,backendName:"webgl",kernelFunc:cz},hz=gL({opSnippet:eL+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nL+"\n  return result;\n"}),pz={kernelName:Pr,backendName:"webgl",kernelFunc:hz},fz=mL({opSnippet:WM+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),mz={kernelName:zr,backendName:"webgl",kernelFunc:fz};class gz{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");const v=4*Math.floor(a/4),x=a%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class yz{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let v="0.0";if(b||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(a/4),k=a%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${x});\n      }\n    `}}const bz={kernelName:Br,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;KD(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Rn(Eh(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=bh(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&zn(u.inShape,u.outShape))return sL({inputs:{x:s},backend:n});const c=new gz(u,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}};const vz={kernelName:jr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=vh(s.shape,a,i,[1,1,1],o,l,u),d=new yz(c,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}};class xz{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class wz{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const kz={kernelName:Wr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=vh(i.shape,o,l,[1,1,1],u,c),h=new wz(d);return n.runWebGLProgram(h,[s],i.dtype)}};const Sz={kernelName:Ur,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;KD([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=bh(i.shape,o,l,1,u),d=new xz(c);return n.runWebGLProgram(d,[s],i.dtype)}};const Iz={kernelName:Vr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return LL({a:s,b:a,transposeA:i,transposeB:o,backend:n})}};class Nz{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],_c(e,t),_c(e,n);let i="0.0";null!=r&&(_c(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=s&&(_c(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class Tz{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],_c(e,t),_c(e,n);let i="vec4(0.0)";null!=r&&(_c(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(_c(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const Cz={kernelName:Ls,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:o}=e;Rn(s.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Rn(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Rn(null==o||s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);const u=[r,s,a];let c=null;null!=i&&(c=i.shape,u.push(i));let d=null;null!=o&&(d=o.shape,u.push(o));const h=wr().getBool("WEBGL_PACK_NORMALIZATION")?new Tz(r.shape,s.shape,a.shape,c,d,l):new Nz(r.shape,s.shape,a.shape,c,d,l);return t.runWebGLProgram(h,u,u[0].dtype)}};class Ez{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=pF(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return $z.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${$z[t]} = start[${t}] + coords.${$z[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const $z=["x","y","z","w","u","v"];class _z{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=pF(this.rank),n=FM("coords",this.rank),r=FM("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}}function Oz(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,l]=Bd(s,a,i);if(Td(s,o,l),0===Fn(l))return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=vM(e.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,t)}const{isPacked:u}=n.texData.get(s.dataId),c=zd(s.shape,o,l);if(u||!c){const e=wr().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _z(l):new Ez(l),t=[o];return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Pd(t,or(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}(s,o,l,n)}const Rz={kernelName:ri,backendName:"webgl",kernelFunc:Oz},Az={kernelName:Gr,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;Rn(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),l=_y(s.shape,a,o),u=Oy(l.length,a.length),c=Ry(s.shape,a,o),d=Ay(i,a.length),h=Dy(c,i,a.length),p=[],f=NL({inputs:{x:s},backend:n,attrs:{shape:l}}),m=FL({inputs:{x:f},backend:n,attrs:{perm:u}}),g=NL({inputs:{x:m},backend:n,attrs:{shape:c}}),y=Oz({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};const Dz={kernelName:Hr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=BF(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}};const Fz={kernelName:qr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=wr().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=wr().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(s.dataId).values,[a,i]=jF(r.shape,s.shape,e,t,r.dtype),o=n.makeTensorInfo(i,r.dtype);return n.texData.get(o.dataId).values=a,o}let o;return o=a?new rL("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,s.shape,!1):new tL("\n  return float(int(a.r) & int(b.r));\n",r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}};const Mz={kernelName:Xr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=_c(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},Lz=gL({opSnippet:"return float(a != b);",cpuKernelImpl:uM,dtype:"bool"}),zz={kernelName:Ia,backendName:"webgl",kernelFunc:Lz};function Pz(e){const{inputs:t,backend:n}=e,{input:r}=t;return sL({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const Bz={kernelName:Ba,backendName:"webgl",kernelFunc:Pz};const Uz={kernelName:Yr,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:a}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===a.dtype)return sL({inputs:{x:a},backend:r});const t=xf(a.shape),n=e({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=iL({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===a.dtype){const t=Pz({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!Jn(a.dtype,i)){const e=sL({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([a])){const e=r.texData.get(a.dataId).values,[t,n,s]=WF(e,a.shape,a.dtype,i);return r.makeTensorInfo(t,n,s)}if("int32"===i)return function(e,t){const n=new jM(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",Kn("bool",1)),t=Lz({inputs:{a,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},jz="return ceil(x);",Wz=mL({opSnippet:jz,packedOpSnippet:jz,cpuKernelImpl:VF}),Vz={kernelName:Qr,backendName:"webgl",kernelFunc:Wz};class Gz{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class Hz{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const qz={kernelName:Jr,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;o=wr().getBool("WEBGL_PACK_CLIP")?new Hz(s.shape):new Gz(s.shape);const l=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,l)}};class Kz{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Xz(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const Yz={kernelName:es,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new Kz(r.shape),i=[Xz(r,s.complexTensorInfos.real),Xz(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}};class Qz{constructor(e){this.outputShape=[],this.outputShape=wy(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class Jz{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=wy(e,t);const n=this.outputShape,r=n.length,s=pF(r),a=FM("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const o=new Array(e.length-1);o[0]=e[0][t];for(let n=1;n<o.length;n++)o[n]=o[n-1]+e[n][t];const l=i[t],u=i.slice(-2),c=i.join();let d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let e=1;e<o.length;e++){const t=o[e-1];d+=`\n        if (${l} < ${o[e]}  && ${l} >= ${o[e-1]}) {\n          return getChannel(\n            getT${e}(${Zz(i,l,t)}),\n            vec2(${Zz(u,l,t)}));\n        }`}const h=o.length,p=o[o.length-1];d+=`\n        return getChannel(\n          getT${h}(${Zz(i,l,p)}),\n          vec2(${Zz(u,l,p)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function Zz(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function eP(e){const{inputs:t,backend:n}=e,{input:r}=t;return sL({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const tP={kernelName:Vs,backendName:"webgl",kernelFunc:eP};function nP(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>Pz({inputs:{input:e},backend:n}))),s=e.map((e=>eP({inputs:{input:e},backend:n}))),a=nP(r,t,n),i=nP(s,t,n),o=iL({inputs:{real:a,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),s.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map((e=>{const r=Fn(e.shape.slice(t));return NL({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),a=s.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=wy(s.map((e=>e.shape)),1),o=1===s[0].shape[0],l=GF(a,i,r,o),u=wy(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const a=e.filter((e=>Fn(e.shape)>0)),i=wr().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(1===a.length){const t=i?new jM(e[0].shape,qM):new KM(e[0].shape,qM);return n.runWebGLProgram(t,e,r)}const o=wr().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const e=[];for(let r=0;r<a.length;r+=o){const s=a.slice(r,r+o);e.push(nP(s,t,n))}const r=nP(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new Jz(a.map((e=>e.shape)),t);return n.runWebGLProgram(e,a,r)}const{tensors2D:l,outShape:u}=function(e,t,n){const r=wy(e.map((e=>e.shape)),t),s=e.map((e=>NL({inputs:{x:e},attrs:{shape:[-1,Fn(e.shape.slice(t))]},backend:n})));return{tensors2D:s,outShape:r}}(a,t,n),c=new Qz(l.map((e=>e.shape))),d=n.runWebGLProgram(c,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));const h=NL({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function rP(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Hn(s,t[0].shape)[0];xy(t.map((e=>e.shape)),a);const i=wy(t.map((e=>e.shape)),a);if(0===Fn(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Fn(e.shape)>0));return 1===o.length?sL({inputs:{x:o[0]},backend:n}):nP(o,a,n)}const sP={kernelName:ts,backendName:"webgl",kernelFunc:rP};class aP{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let v="",x="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}}class iP{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class oP{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=xF(this.outputShape.length);const a=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u;let d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<u;e++)d+=`\n           vec4 xTexelC${2*e};\n           int xTexelC${2*e}Ready;\n           vec4 xTexelC${2*e+1};\n           int xTexelC${2*e+1}Ready;\n           vec4 xC${e};`;d+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let e=0;e<u;e++)d+=`\n           xTexelC${2*e} = vec4(0.0);\n           xTexelC${2*e}Ready = 0;\n           xTexelC${2*e+1} = vec4(0.0);\n           xTexelC${2*e+1}Ready = 0;\n           xC${e} = vec4(0.0);`;d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let t=0;t<(c+1)/2;t++){const n=2*t;if(d+=`\n           xC = xCCorner + ${n*o};\n           `,1===i){if(n<u&&(a%2==1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n               `,d+=1===o&&n>0?`\n                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                   } else {\n                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xC${n} = xTexelC${n};\n                 `,n+1<u)){const e=a%2==0?Cn(o):o;o%2==0&&a%2==1||o%2!=0&&a%2!=1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${n+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${n+1}Ready = 1;\n                   }\n                   `,d+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                     } else {\n                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                     }\n                     `:`\n                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                     `):d+=1===e?`\n                     xC${n+1} = xTexelC${n};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${n+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${n+1}Ready = 1;\n                     }\n\n                     xC${n+1} = xTexelC${n+1};\n                     `}}else n<u&&(a%2==1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n               `,n+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(\n                   xTexelC${n}.xy, xTexelC${n+1}.xy);\n               `,n+1<u&&(d+=`\n                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                 `)));n<u&&(d+=`\n             wTexel = getW(r, ${n}, d1, d2);\n             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,n+1<u&&(d+=`\n               wTexel = getW(r, ${n+1}, d1, d2);\n               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${h}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}}class lP{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=xF(this.outputShape.length);const{dataFormat:n}=t,r=YD(),s="channelsLast"===n,a=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)l+=`\n          blockIndex = rc.z + ${t};\n          pos = rc.y + ${e};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function uP(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function cP({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const l=e.shape,u=r.texData.get(e.dataId),c=n.inChannels,d=l[0]*l[1]*l[2],h=n.outChannels,p="channelsLast"===n.dataFormat,f=!1;let m;const g=[];if(null!=a){const e=uP(a.shape,p);null!=e&&(a=NL({inputs:{x:a},backend:r,attrs:{shape:e}}),g.push(a))}if(null!=s){const e=uP(s.shape,p);null!=e&&(s=NL({inputs:{x:s},backend:r,attrs:{shape:e}}),g.push(s))}if(!((1===d||1===h)&&c>1e3)&&u.isPacked&&p&&null!=u.texture&&l[2]%2!=0&&zn(u.shape.slice(-3),l.slice(-3))){const c=l[0]*l[1]*(l[2]+1),d={dataId:e.dataId,shape:[1,c,n.inChannels],dtype:e.dtype},h=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Rn(UD(u.shape,d.shape),(()=>`packed reshape ${u.shape} to ${d.shape} isn't free`));const p=NL({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});g.push(p);const y=LL({a:d,b:p,backend:r,transposeA:false,transposeB:f,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),b=r.texData.get(y.dataId);Rn(b.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=h,b.shape=n.outShape,m=sL({inputs:{x:y},backend:r}),m.shape=n.outShape,g.push(y)}else{const l=n.outHeight*n.outWidth,u=NL({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,l,n.inChannels]:[n.batchSize,n.inChannels,l]}}),c=NL({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=LL({a:p?u:c,b:p?c:u,transposeA:!p,transposeB:f,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});m=NL({inputs:{x:d},backend:r,attrs:{shape:n.outShape}}),g.push(u),g.push(c),g.push(d)}for(const e of g)r.disposeIntermediateTensorInfo(e);return m}function dP({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=n,f="channelsLast"===p,m=l*u*c,g=h*d,y=[n.batchSize,m,g],b=[];if(null!=a){const e=uP(a.shape,f);null!=e&&(a=NL({inputs:{x:a},backend:r,attrs:{shape:e}}),b.push(a))}if(null!=s){const e=uP(s.shape,f);null!=e&&(s=NL({inputs:{x:s},backend:r,attrs:{shape:e}}),b.push(s))}const v=NL({inputs:{x:t},backend:r,attrs:{shape:[1,m,Fn(t.shape)/m]}});b.push(v);const x=new lP(y,n),w=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],k=r.runWebGLProgram(x,[e],"float32",w),S=NL({inputs:{x:k},backend:r,attrs:{shape:y}});b.push(k),b.push(S);const I=null!=s,N=null!=a,T="leakyrelu"===o,C=o?yL(o,!0):null,E=new bL(f?S.shape:v.shape,f?v.shape:S.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],!0,!1,I,C,N,T),$=f?[S,v]:[v,S];if(s&&$.push(s),N&&$.push(a),T){const e=r.makeTensorInfo([],"float32",vo(i,"float32"));$.push(e),b.push(e)}const _=r.runWebGLProgram(E,$,"float32"),O=NL({inputs:{x:_},backend:r,attrs:{shape:n.outShape}});b.push(_);for(const e of b)r.disposeIntermediateTensorInfo(e);return O}const hP={kernelName:ns,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=_h(l),h=xh(s.shape,a.shape,i,u,o,c,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&wr().getBool("WEBGL_EXP_CONV")){const e=new oP(h),t=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(e,[s,a],"float32",t)}else if(wr().getBool("WEBGL_CONV_IM2COL"))p=dP({x:s,filter:a,convInfo:h,backend:n});else{const e=new aP(h);p=n.runWebGLProgram(e,[s,a],"float32")}else p=cP({x:s,filter:a,convInfo:h,backend:n});const f=NL({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class pP{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${a?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class fP{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=a?1:2,u=a?2:3,c=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class mP{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${s};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class gP{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const yP={kernelName:rs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=_h(l),h=xh(s.shape,c,i,1,o,u,!1,d),p=new pP(h);return n.runWebGLProgram(p,[s,a],"float32")}};class bP{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=xF(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const vP={kernelName:ss,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=_h(u),h=xh(i,a.shape,o,1,l,c,!1,d);if(wr().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const e=[[h.strideHeight,h.strideWidth]],t=new bP(h);return n.runWebGLProgram(t,[s,a],"float32",e)}{const e=new fP(h);return n.runWebGLProgram(e,[s,a],"float32")}}};const xP={kernelName:as,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=wh(s.shape,a.shape,i,l,o),c=new iP(u);return n.runWebGLProgram(c,[s,a],"float32")}};const wP={kernelName:is,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r,u=wh(s.shape,l,i,1,o),c=new mP(u);return n.runWebGLProgram(c,[s,a],"float32")}};const kP={kernelName:os,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r,u=wh(l,a.shape,o,1,i),c=new gP(u);return n.runWebGLProgram(c,[s,a],"float32")}},SP=mL({opSnippet:fL+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${nL}\n  return result;\n`}),IP={kernelName:ls,backendName:"webgl",kernelFunc:SP},NP=mL({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),TP={kernelName:us,backendName:"webgl",kernelFunc:NP};class CP{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];const h="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,x]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const EP={kernelName:hs,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new CP(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")}};var $P;!function(e){e.Prod="*",e.Sum="+"}($P||($P={}));class _P{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=this.op===$P.Prod?"1.0":"0.0",i=n?a:`getX(${OP(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${pF(s)} coords = getOutputCoords();\n        int end = ${RP(s,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${RP(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${OP(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function OP(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function RP(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function AP(e,t,n,r,s,a){const i=t.shape.length,o=_p([r],i);let l=t;null!=o&&(l=FL({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=Rp(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=sL({inputs:{x:l},backend:n});for(let t=0;t<=Math.ceil(Math.log2(c))-1;t++){const r=new _P(e,l.shape,!1,a),s=[[t]],i=d;d=n.runWebGLProgram(r,[d],d.dtype,s),n.disposeIntermediateTensorInfo(i)}if(s){const t=new _P(e,l.shape,s,a),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const e=FL({inputs:{x:d},backend:n,attrs:{perm:Op(o)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),e}return d}const DP={kernelName:cs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return AP($P.Prod,s,n,a,i,o)}};const FP={kernelName:ds,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return AP($P.Sum,s,n,a,i,o)}};const MP={kernelName:ps,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(a.dataId),r=BF(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=UF(e,t,i,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class LP{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const zP={kernelName:fs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=("NHWC"===i?s.shape[1]:s.shape[2])*a,u=("NHWC"===i?s.shape[2]:s.shape[3])*a,c=("NHWC"===i?s.shape[3]:s.shape[1])/(a*a),d=new LP("NHWC"===i?[o,l,u,c]:[o,c,l,u],a,i);return n.runWebGLProgram(d,[s],s.dtype)}};class PP{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=xF(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class BP{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=xF(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<c;e++)h+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;h+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let e=0;e<c;e++)h+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(d+1)/2;e++){const t=2*e;if(h+=`\n          xC = xCCorner + ${t*l};\n          `,1===o){if(t<c&&(i%2==1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,h+=1===l&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<c)){const e=i%2==0?Cn(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,h+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                    } else {\n                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                    }\n                    `:`\n                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                    `):h+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<c&&(i%2==1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<c&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<c&&(h+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<c&&(h+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<c&&(h+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}const UP={kernelName:ms,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),Rn(Eh(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const d=xh(s.shape,a.shape,i,c,o,u,!0);let h;h=wr().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new BP(d):new PP(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[s,a],"float32",p)}};class jP{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class WP{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const VP={kernelName:gs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=xh(s.shape,c,i,o,l,u,!0),h=new jP(d);return n.runWebGLProgram(h,[s,a],"float32")}};const GP={kernelName:ys,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=xh(c,a.shape,i,o,l,u,!0),h=new WP(d);return n.runWebGLProgram(h,[s,a],"float32")}};class HP{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const qP={kernelName:bs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=Fn(r.shape),i=NL({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new HP(a),l=n.runWebGLProgram(o,[i],i.dtype),u=NL({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}};class KP{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const XP={kernelName:vs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=yh(s.shape,a.shape,i,o,"NHWC",l);let c;const d=new KP(u);c=n.runWebGLProgram(d,[s,a],"float32");const h=NL({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),h}};const YP={kernelName:Is,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=tb(s,a.length);rb(i.length,l,a);const{path:u,steps:c}=sb(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let e=0;e<d;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:r}=nb(p,l[t]);let s;ab(e)?s=a[t]:(s=FL({inputs:{x:a[t]},backend:n,attrs:{perm:e}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);zn(s.shape,i)||(s=NL({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===h?h=s:(h=SL({inputs:{a:s,b:h},backend:n}),f.push(h))}e<d-1&&(u[e]>=0&&(h=AL({inputs:{x:h},backend:n,attrs:{axis:u[e]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const e of f)e!==h&&n.disposeIntermediateTensorInfo(e);return h}},QP=mL({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),JP={kernelName:Ns,backendName:"webgl",kernelFunc:QP},ZP={kernelName:Ts,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=wr().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new rL("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new tL("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)}},eB=gL({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:HF}),tB={kernelName:Es,backendName:"webgl",kernelFunc:eB},nB=mL({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Ly};\n  float a1 = ${zy};\n  float a2 = ${Py};\n  float a3 = ${By};\n  float a4 = ${Uy};\n  float a5 = ${jy};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),rB={kernelName:Cs,backendName:"webgl",kernelFunc:nB},sB=mL({opSnippet:fL+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:qF,dtype:"float32"}),aB={kernelName:$s,backendName:"webgl",kernelFunc:sB};function iB(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(Rn(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),NL({inputs:{x:a},backend:r,attrs:{shape:o}})}const oB={kernelName:_s,backendName:"webgl",kernelFunc:iB},lB="return exp(x) - 1.0;",uB=mL({opSnippet:lB,packedOpSnippet:lB,cpuKernelImpl:KF}),cB={kernelName:Os,backendName:"webgl",kernelFunc:uB};class dB{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function hB(e,t,n){const r=n.texData.get(e.dataId),s=Fn(e.shape),a=e.shape[e.shape.length-1],i=NL({inputs:{x:e},backend:n,attrs:{shape:[s/a,a]}}),o=i.shape,l=new dB("real",o,t),u=new dB("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],d=n.runWebGLProgram(l,c,"float32"),h=n.runWebGLProgram(u,c,"float32"),p=iL({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);const f=NL({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const pB={kernelName:Rs,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return hB(r,!1,n)}};class fB{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function mB(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||sr(s),"string"===a){const e=Xn(a,Fn(r));return e.fill(s),t.makeTensorInfo(r,a,e)}{const e=new fB(r,s),n=[[s]];return t.runWebGLProgram(e,[],a,n)}}const gB={kernelName:As,backendName:"webgl",kernelFunc:mB};class yB{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const bB={kernelName:Ds,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new yB(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},vB="return floor(x);",xB=mL({opSnippet:vB,packedOpSnippet:vB,cpuKernelImpl:XF}),wB={kernelName:Fs,backendName:"webgl",kernelFunc:xB},kB=gL({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),SB={kernelName:Ms,backendName:"webgl",kernelFunc:kB};class IB{constructor(e){this.variableNames=["A"];const t=YD(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class NB{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=YD(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const TB={kernelName:Pi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,a];if(o||i){const e=wr().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=CB&&e===EB||(EB=e,CB=document.createElement("canvas").getContext("2d",{willReadFrequently:EB})),CB.canvas.width=l,CB.canvas.height=u,CB.drawImage(s,0,0,l,u),s=CB.canvas}const h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=bD.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),s);const p=wr().getBool("WEBGL_PACK")?new NB(d):new IB(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}};let CB,EB=wr().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const $B={kernelName:ji,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=_h(c),g=xh(s.shape,a.shape,l,d,u,h,!1,m);let y;const b=[],v=null!=i,x=null!=o,w="leakyrelu"===p,k=()=>{const e=[s,a],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=NL({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(i,c)),x&&e.push(t(o,c)),w){const t=n.makeTensorInfo([],"float32",vo(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&wr().getBool("WEBGL_EXP_CONV")){const e=p?yL(p,!0):null,t=new oP(g,v,e,x,w),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],s=k();y=n.runWebGLProgram(t,s,"float32",r)}else if(wr().getBool("WEBGL_CONV_IM2COL"))y=dP({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?yL(p,!1):null,t=new aP(g,v,e,x,w),r=k();y=n.runWebGLProgram(t,r,"float32")}else y=cP({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const S=NL({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const _B={kernelName:Wi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),Rn(Eh(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=xh(s.shape,a.shape,l,m,u,d,!0),y=wr().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=h?yL(h,y):null,v=[s,a],x=null!=i,w=null!=o,k="leakyrelu"===h;if(x&&v.push(i),w&&v.push(o),k){const e=n.makeTensorInfo([],"float32",vo(p,"float32"));v.push(e),f.push(e)}let S;S=y?new BP(g,x,b,w,k):new PP(g,x,b,w,k);const I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=n.runWebGLProgram(S,v,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}};class OB{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const s=pF(n.length);let a="\n    int index;";for(let e=0;e<this.sliceDim;e++)a+=`\n          index = round(getIndices(coords[0], ${e}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};\n          flattenIndex += index * ${this.strides[e]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${a}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const RB={kernelName:Ps,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=Fn(r.shape),[l,u,c,d]=xd(r,s),h=NL({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=NL({inputs:{x:r},backend:n,attrs:{shape:[Fn(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),a=YF(e,t,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,a.values)}const f=new OB(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=NL({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class AB{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=pF(this.rank),r=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function DB(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,l=Hn(i,s.shape)[0];if(wr().get("DEBUG")){const e=n.readSync(a.dataId),t=s.shape[l];for(let n=0;n<e.length;++n){const r=e[n];Rn(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const u=kb(s,a,l,o),c=Fn(a.shape),d=[],h=NL({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=NL({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||"string"===s.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),r=QF(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const m=new AB(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const y=NL({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const FB={kernelName:zs,backendName:"webgl",kernelFunc:DB},MB=gL({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:JF,dtype:"bool"}),LB={kernelName:Bs,backendName:"webgl",kernelFunc:MB},zB=gL({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:ZF}),PB={kernelName:Us,backendName:"webgl",kernelFunc:zB};const BB={kernelName:Ws,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return hB(r,!0,n)}},UB=mL({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),jB={kernelName:Gs,backendName:"webgl",kernelFunc:UB},WB=mL({opSnippet:"return float(isinf(x));",dtype:"bool"}),VB={kernelName:Hs,backendName:"webgl",kernelFunc:WB},GB=mL({opSnippet:"return float(isnan(x));",dtype:"bool"}),HB={kernelName:qs,backendName:"webgl",kernelFunc:GB},qB=gL({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:eM,dtype:"bool"}),KB={kernelName:Xs,backendName:"webgl",kernelFunc:qB},XB=gL({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:tM,dtype:"bool"}),YB={kernelName:Ys,backendName:"webgl",kernelFunc:XB};const QB={kernelName:Qs,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=nM(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},JB=mL({opSnippet:fL+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:rM}),ZB={kernelName:Js,backendName:"webgl",kernelFunc:JB},eU=mL({opSnippet:fL+"\n  return log(1.0 + x);\n"}),tU={kernelName:Zs,backendName:"webgl",kernelFunc:eU},nU=gL({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),rU={kernelName:ea,backendName:"webgl",kernelFunc:nU},sU=mL({opSnippet:"return float(!(x >= 1.0));"}),aU={kernelName:ta,backendName:"webgl",kernelFunc:sU},iU=gL({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),oU={kernelName:na,backendName:"webgl",kernelFunc:iU};class lU{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class uU{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const cU={kernelName:ia,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=wr().getBool("WEBGL_PACK_NORMALIZATION")?new uU(s.shape,a,i,o,l):new lU(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)}};class dU{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const hU={kernelName:oa,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new dU(s.shape,o,l,u,c);return n.runWebGLProgram(d,[s,a,i],s.dtype)}};function pU(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=Hn(a,s.shape);let u=l;const c=_p(u,o),d=null!=c,h=n.shouldExecuteOnCPU([s]);let p=s;if(d){if(h){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let e=0;e<t.length;e++)t[e]=s.shape[c[e]];const r=RM(e,s.shape,s.dtype,c,t);p=n.makeTensorInfo(t,s.dtype);n.texData.get(p.dataId).values=r}else p=RL(s,c,n);u=Rp(u.length,o)}$p("max",u,o);const[f,m]=Cp(p.shape,u);let g,y=f;if(i&&(y=Ep(f,l)),h){const e=n.texData.get(p.dataId).values,t=sM(e,Fn(m),y,s.dtype);g=n.makeTensorInfo(y,s.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const s=Fn(t),a=NL({inputs:{x:e},attrs:{shape:[Fn(e.shape)/s,s]},backend:r}),i=$L(a,e.dtype,"max",r),o=NL({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(p,m,y,n);return d&&n.disposeIntermediateTensorInfo(p),g}const fU={kernelName:ua,backendName:"webgl",kernelFunc:pU},mU=gL({opSnippet:eL+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nL+"\n  return result;\n",cpuKernelImpl:aM}),gU={kernelName:ca,backendName:"webgl",kernelFunc:mU};const yU={kernelName:da,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;KD(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Rn(Eh(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=bh(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&zn(u.inShape,u.outShape))return sL({inputs:{x:s},backend:n});const c=new gz(u,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}};const bU={kernelName:pa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=vh(s.shape,a,i,[1,1,1],o,u,l),d=new yz(c,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}};class vU{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,l=s*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class xU{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const wU={kernelName:fa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=vh(i.shape,o,l,[1,1,1],u,c),h=new yz(d,"max",!0),p=n.runWebGLProgram(h,[i],i.dtype),f=new xU(d),m=n.runWebGLProgram(f,[s,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};const kU={kernelName:ha,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;KD([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=bh(o.shape,l,u,1,c,d),p=new gz(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new vU(h),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};const SU={kernelName:ma,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;Rn(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const u=[1,1];Rn(Eh(a,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`));const c=bh(r.shape,s,a,u,i),[d,h]=function(e,t,n,r){let s=new gz(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");return s=new gz(n,"max",!0,!0,t),[a,r.runWebGLProgram(s,[e],"float32")]}(r,o,c,l);return[d,h]}};const IU={kernelName:ga,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,l=Hn(a,r.shape);let u=l;const c=_p(u,o),d=null!=c,h=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(d){if(h){const e=i.texData.get(f.dataId).values,t=new Array(o);for(let e=0;e<t.length;e++)t[e]=r.shape[c[e]];const n=RM(e,r.shape,r.dtype,c,t);f=i.makeTensorInfo(t,r.dtype);i.texData.get(f.dataId).values=n}else f=RL(r,c,i);p.push(f),u=Rp(u.length,o)}$p("sum",u,o);const[m,g]=Cp(f.shape,u);let y=m;s&&(y=Ep(m,l));const b=function(e,t,n,r){const s=Fn(t),a=NL({inputs:{x:e},attrs:{shape:[Fn(e.shape)/s,s]},backend:r}),i=$L(a,"float32","mean",r),o=NL({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(f,g,y,i);for(const e of p)i.disposeIntermediateTensorInfo(e);return b}};const NU={kernelName:ya,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Hn(a,s.shape);let u=l;const c=_p(u,o);let d=s;null!=c&&(d=FL({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Rp(u.length,s.shape.length)),$p("min",u,o);const[h,p]=Cp(d.shape,u),f=NL({inputs:{x:d},backend:n,attrs:{shape:[-1,Fn(p)]}}),m=$L(f,f.dtype,"min",n);let g;if(i){g=NL({inputs:{x:m},backend:n,attrs:{shape:Ep(h,l)}})}else g=NL({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}},TU=gL({opSnippet:eL+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+nL+"\n  return result;\n",cpuKernelImpl:iM}),CU={kernelName:ba,backendName:"webgl",kernelFunc:TU};class EU{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=pF(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class $U{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=pF(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=FM("rc",r),l=FM("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1;let h="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const _U={kernelName:va,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:a}=n,i=wr().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $U(r.shape,s,a):new EU(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)}},OU=gL({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+nL+"\n  return result;\n"}),RU={kernelName:xa,backendName:"webgl",kernelFunc:OU};class AU{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const DU=gL({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),FU={kernelName:Ss,backendName:"webgl",kernelFunc:DU},MU="return a - b;",LU=gL({opSnippet:MU,packedOpSnippet:MU,supportsComplex:!0,cpuKernelImpl:$M}),zU={kernelName:Ti,backendName:"webgl",kernelFunc:LU};function PU(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=Hn([a],s.shape),o=pU({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=Ep(o.shape,i),u=NL({inputs:{x:o},backend:n,attrs:{shape:l}}),c=LU({inputs:{a:s,b:u},backend:n}),d=sB({inputs:{x:c},backend:n}),h=AL({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=NL({inputs:{x:h},backend:n,attrs:{shape:l}}),f=DU({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const BU={kernelName:pi,backendName:"webgl",kernelFunc:PU};const UU={kernelName:wa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:PU({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new AU(u,c,a),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}},jU=WM+"\n  return -x;\n";const WU={kernelName:Sa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=lM(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=wr().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new KM(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new jM(r.shape,jU),n.runWebGLProgram(s,[r],r.dtype)}},VU=Tg;const GU={kernelName:Na,backendName:"webgl",kernelFunc:function(e){Vi();const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:d}=VU(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},HU=Cg;const qU={kernelName:Ta,backendName:"webgl",kernelFunc:function(e){Vi();const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),{selectedIndices:h,validOutputs:p}=HU(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},KU=Eg;const XU={kernelName:Ca,backendName:"webgl",kernelFunc:function(e){Vi();const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=KU(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class YU{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const QU={kernelName:$a,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=Fn(s.shape),c=new YU(u,i,o,l),d=NL({inputs:{x:s},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],a);n.disposeIntermediateTensorInfo(d);const p=NL({inputs:{x:h},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeIntermediateTensorInfo(h),p}};function JU(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=Pz({inputs:{input:r},backend:n}),t=JU({inputs:{x:e},backend:n}),s=eP({inputs:{input:r},backend:n}),a=JU({inputs:{x:s},backend:n}),i=iL({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return mB({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const ZU={kernelName:Li,backendName:"webgl",kernelFunc:JU};const ej={kernelName:Ea,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=Pz({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=eP({inputs:{input:s},backend:r}),i=JU({inputs:{x:a},backend:r}),o=iL({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return mB({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}};const tj={kernelName:_a,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return iB({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{An(a,e.shape,"All tensors passed to stack must have matching shapes"),Rn(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=rP({inputs:t.map((e=>{const t=iB({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class nj{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=pF(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class rj{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=pF(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=FM("rc",r),l=FM("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let e=0,t=1===r?2:4;e<t;e++)p+=`\n        ${d[e]}\n        if (${h}) {\n          result[${e}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${e}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const sj=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(0===Fn(s.shape)){const e=a.map(((e,t)=>e[0]+s.shape[t]+e[1]));return mB({backend:n,attrs:{shape:e,value:i,dtype:s.dtype}})}const o=wr().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rj(s.shape,a,i):new nj(s.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[s],s.dtype,l)},aj={kernelName:Oa,backendName:"webgl",kernelFunc:sj},ij=gL({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+nL+"\n  return result;\n"}),oj={kernelName:Aa,backendName:"webgl",kernelFunc:ij};const lj={kernelName:Fa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=Hn(a,s.shape);let c=u;const d=_p(c,o);let h,p=s;if(null!=d&&(p=FL({inputs:{x:s},backend:n,attrs:{perm:d}}),c=Rp(c.length,o),l.push(p)),$p("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:s}=cM(p.shape,p.dtype,e,c);h=n.makeTensorInfo(r,s,t)}else{const[e,t]=Cp(p.shape,c),r=Fn(t),a=NL({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=$L(a,Xo(s.dtype),"prod",n);h=NL({inputs:{x:i},backend:n,attrs:{shape:e}}),l.push(a),l.push(i)}if(i){l.push(h);const e=Ep(h.shape,u);h=NL({inputs:{x:h},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}};const uj={kernelName:Ma,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map((e=>n.readSync(e.dataId))),u=s.map((e=>e.shape)),c=n.readSync(a.dataId),d=n.readSync(i.dataId),[h,p,f]=dM(l,u,c,a.shape,a.dtype,d,i.shape,o),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}};const cj={kernelName:La,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=hM(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};const dj={kernelName:za,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),d=n.readSync(i.dataId),h=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,m]=pM(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}},hj=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=fM(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},pj={kernelName:Pa,backendName:"webgl",kernelFunc:hj},fj=mL({opSnippet:"return 1.0 / x;"}),mj={kernelName:Ua,backendName:"webgl",kernelFunc:fj},gj=mL({opSnippet:WM+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),yj={kernelName:ja,backendName:"webgl",kernelFunc:gj},bj=mL({opSnippet:WM+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),vj={kernelName:Ka,backendName:"webgl",kernelFunc:bj};class xj{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class wj{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const kj={kernelName:Ha,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=wr().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new wj(s.shape,l,u,a,i):new xj(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}};class Sj{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Ij={kernelName:qa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new Sj(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class Nj{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class Tj{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const Cj={kernelName:Va,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=wr().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Tj(s.shape,l,u,a,i):new Nj(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}};class Ej{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const $j={kernelName:Ga,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new Ej(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class _j{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),s=pF(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class Oj{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=FM("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=pF(n);function o(n){const r=e.map(((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const Rj={kernelName:Xa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=Hn(a,s.shape);if(0===i)return sL({inputs:{x:s},backend:n});const l=wr().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Oj(s.shape,o):new _j(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}};class Aj{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const Dj={kernelName:Bi,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=new Aj(r.shape,a),[u,c]=$y(i,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(l,[r],r.dtype,d)}},Fj=mL({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),Mj={kernelName:Ya,backendName:"webgl",kernelFunc:Fj},Lj=mL({opSnippet:"return inversesqrt(x);",cpuKernelImpl:mM}),zj={kernelName:Qa,backendName:"webgl",kernelFunc:Lj};class Pj{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const l=pF(s.length),u=pF(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const d=`getIndices(${c})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const p=`getUpdates(${h})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`\n        ${l} strides = ${l}(${s});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${d});\n              flattenedIndex += index * ${g};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(${m}, sum, float(found)));\n        }\n      `}}class Bj{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const l=pF(s.length),u=pF(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const d=`getIndices(${c})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const p=`getUpdates(${h})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",y=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${l} strides = ${l}(${s});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${d});\n              flattenedIndex += index.xz * ${g};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${y};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${p};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${m}, sum, found));\n        }\n      `}}const Uj={kernelName:Ja,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Sd(0,s,i),h=[d/u,u];if(0===d)return n.makeTensorInfo(i,s.dtype);const p=NL({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=NL({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=wr().getBool("WEBGL_PACK")?new Bj(l,o,p.shape.length,f.shape.length,c,h):new Pj(l,o,p.shape.length,f.shape.length,c,h);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=NL({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class jj{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=2===wr().getNumber("WEBGL_VERSION")?"while (left < right) {":s,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const Wj={kernelName:ei,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new jj(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}};class Vj{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),s=i.join()}const a=pF(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const Gj={kernelName:ti,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new Vj(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],Ko(s.dtype,a.dtype))}},Hj=mL({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Fy};\n  float scale = ${My};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),qj={kernelName:ni,backendName:"webgl",kernelFunc:Hj},Kj=mL({opSnippet:fL+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:yM}),Xj={kernelName:oi,backendName:"webgl",kernelFunc:Kj},Yj=mL({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Qj={kernelName:ii,backendName:"webgl",kernelFunc:Yj},Jj=mL({opSnippet:fL+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${nL}\n  return result;\n`}),Zj={kernelName:si,backendName:"webgl",kernelFunc:Jj},eW=mL({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),tW={kernelName:ai,backendName:"webgl",kernelFunc:eW},nW=mL({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),rW={kernelName:li,backendName:"webgl",kernelFunc:nW},sW={kernelName:di,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;Rn(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let e=1+a.length;e<s.shape.length;++e)l.push([0,0]);const u=[],c=sj({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),d=_y(c.shape,a,o,!1),h=Oy(d.length,a.length,!1),p=Ry(c.shape,a,o,!1),f=NL({inputs:{x:c},backend:n,attrs:{shape:d}}),m=FL({inputs:{x:f},backend:n,attrs:{perm:h}}),g=NL({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const aW={kernelName:fi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=xM(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};const iW={kernelName:mi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,d]=wM(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}};const oW={kernelName:gi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=kM(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const lW={kernelName:yi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=kM(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const uW={kernelName:bi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Sd(0,s,o),p=!1;if("string"===a.dtype){const e=n.bufferSync(s),t=n.bufferSync(a),r=Io(n.readSync(i.dataId)[0]),f=gM(e,t,o,h,c,u,l,d,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new Pj(u,l,s.shape.length,a.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[a,s,i],a.dtype),g=NL({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};const cW={kernelName:hi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Hn(i,s.shape)[0],l=ob(s,a,o),u=s.shape.length,c=new Array(u).fill(0),d=s.shape.slice();return l.map((e=>{const t=[...d];t[o]=e;const r=Oz({inputs:{x:s},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},dW="return sqrt(x);",hW=mL({opSnippet:dW,packedOpSnippet:dW,cpuKernelImpl:SM}),pW={kernelName:ui,backendName:"webgl",kernelFunc:hW},fW=mL({opSnippet:"return x * x;"}),mW={kernelName:xi,backendName:"webgl",kernelFunc:fW},gW="return (a - b) * (a - b);",yW=gL({opSnippet:gW,packedOpSnippet:gW}),bW={kernelName:vi,backendName:"webgl",kernelFunc:yW};const vW={kernelName:wi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const a=Sb(n.readSync(s.dataId)),i=IM(a,"string",r);return n.makeTensorInfo(s.shape,"string",i)}};const xW={kernelName:zi,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=WM+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,a=new jM(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}};class wW{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=pF(n.length),a=pF(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const kW={kernelName:ki,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=Ud(s.shape,a,i,o,l,u,c,d,h);let w;if(m)w=NL({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){Rn(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=Ed(b,v,x),t=Oz({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=NL({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=Xu(s.shape,s.dtype,e),r=NM(p,t,x,b);w=n.makeTensorInfo(f,s.dtype,r.values)}else{const e=new wW(b,x,p);w=n.runWebGLProgram(e,[s],s.dtype)}}const k=NL({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const SW={kernelName:Si,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=TM(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};const IW={kernelName:Ii,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=CM(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};const NW={kernelName:Ni,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=EM(i,s);return n.makeTensorInfo(a.shape,"int32",o)}},TW=mL({opSnippet:"return tan(x);"}),CW={kernelName:Ci,backendName:"webgl",kernelFunc:TW},EW=mL({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),$W={kernelName:Ei,backendName:"webgl",kernelFunc:EW};const _W={kernelName:Za,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Sd(0,a,s.shape),h=[d/u,u];if(0===d)return n.makeTensorInfo(s.shape,a.dtype);const p=NL({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=NL({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=NL({inputs:{x:s},backend:n,attrs:{shape:h}}),g=new Pj(l,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=NL({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}};class OW{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=pF(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function RW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map((e=>Io(e))):e,r=Xu(s.shape,s.dtype,t),i=_M(r,a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new OW(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const AW={kernelName:$i,backendName:"webgl",kernelFunc:RW};class DW{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class FW{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function MW(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function LW(e){let t=1;for(;t<e;)t*=2;return t}const zW={kernelName:_i,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=wr().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=wr().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>l){const e=n.readSync(s.dataId),[t,r]=OM(e,u,s.dtype,a,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===a)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[s,mB({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(s.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(s):s,f=Fn(u)/c,m=NL({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&MW(n,p);const g=LW(a),y=LW(c);let b=null;const v=()=>null===b?[m,m]:[m,b],x=(e,t,r)=>{const s=v(),a=new DW(r),i=[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(a,s,"int32",i),MW(n,o)};for(let e=1;e<g;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)x(t,n,[f,y])}for(let e=y;e>g;e/=2){const t=v(),r=new FW([f,e/2]),s=[[c],[null===b?1:0],[g]],a=b;b=n.runWebGLProgram(r,t,"int32",s),MW(n,a);const i=g/2,o=2*i;for(let e=i;e>=1;e/=2)x(o,e,b.shape)}let w=b;b=Oz({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,a]}}),MW(n,w);let k=DB({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});MW(n,m);const S=u.slice(0,-1);S.push(a),w=b,b=NL({inputs:{x:b},attrs:{shape:S},backend:n}),MW(n,w);const I=k;return k=NL({inputs:{x:k},attrs:{shape:S},backend:n}),MW(n,I),[k,b]}};class PW{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const BW={kernelName:Oi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=s.shape,[f,m]=null!=u?u:[d,h],g=new PW(d,h,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[s,a],"float32")}};const UW={kernelName:Ai,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;KD(a,"unique");const i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=AM(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const jW={kernelName:Di,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1);let c=0;for(let e=0;e<o;e++)e!==a&&(u[c++]=i.shape[e]);const d=[],h=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(l);for(let e=0;e<f.length;e++){h[a]=e;const t=Oz({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),r=NL({inputs:{x:t},backend:n,attrs:{shape:u}});f[e]=r,d.push(t)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class WW{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let d="";s%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const VW={kernelName:Fi,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,l=[];let u=0;const c=_p([u],o);let d=s;null!=c&&(d=FL({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(d),u=Rp(1,o)[0]);const h=wb(d.shape,u,i),p=Fn([d.shape[u]]),f=NL({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=Xo(s.dtype),g=(e,t,r,s,a)=>{const i=e.shape[0],o=e.shape[1],u=xb(o,a),c=new WW({windowSize:u,inSize:o,batchSize:i,numSegments:a},t),d=n.compileAndRun(c,[e,r],s);if(l.push(d),d.shape[1]===a)return d;const h=hj({backend:n,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),p=RW({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});l.push(h),l.push(p);return g(d,t,p,s,a)},y=NL({inputs:{x:g(f,"unsortedSegmentSum",a,m,i)},backend:n,attrs:{shape:h}});let b=y;if(null!=c){l.push(y);const e=Op(c);b=FL({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},GW=[zL,BL,jL,VL,qL,YL,QL,JL,sz,az,oz,uz,dz,pz,mz,bz,vz,kz,Sz,Iz,Cz,Az,Dz,Fz,Mz,Uz,Vz,qz,oL,Yz,sP,hP,yP,vP,xP,wP,kP,IP,TP,EP,DP,FP,MP,zP,UP,VP,GP,qP,XP,YP,JP,ZP,tB,rB,aB,oB,cB,pB,gB,bB,wB,SB,TB,$B,_B,RB,FB,LB,PB,aL,BB,tP,jB,VB,HB,cL,KB,YB,QB,ZB,tU,rU,aU,oU,cU,hU,fU,gU,yU,bU,wU,kU,SU,IU,NU,CU,_U,RU,UU,IL,WU,GU,qU,XU,zz,QU,ej,tj,aj,oj,pL,lj,uj,cj,dj,pj,Bz,FU,mj,yj,vj,TL,kj,Ij,Cj,$j,Rj,Dj,Mj,zj,Uj,Wj,Gj,qj,Xj,Qj,Zj,tW,Rz,BU,rW,sW,aW,iW,oW,lW,uW,cW,pW,mW,bW,vW,xW,kW,SW,IW,NW,zU,DL,CW,$W,_W,AW,zW,BW,ML,UW,jW,VW,ZU];for(const e of GW)Qi(e);var HW=function(e,t){return HW=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])},HW(e,t)};function qW(e,t){function n(){this.constructor=e}HW(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var KW=function(){return KW=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},KW.apply(this,arguments)};function XW(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))}function YW(e,t){var n,r,s,a,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return a={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function o(a){return function(o){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(s=2&a[0]?r.return:a[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,a[1])).done)return s;switch(r=0,s&&(a=[2&a[0],s.value]),a[0]){case 0:case 1:s=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,r=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!(s=i.trys,(s=s.length>0&&s[s.length-1])||6!==a[0]&&2!==a[0])){i=0;continue}if(3===a[0]&&(!s||a[1]>s[0]&&a[1]<s[3])){i.label=a[1];break}if(6===a[0]&&i.label<s[1]){i.label=s[1],s=a;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(a);break}s[2]&&i.ops.pop(),i.trys.pop();continue}a=t.call(e,i)}catch(e){a=[6,e],r=0}finally{n=s=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,o])}}}function QW(e){var t=e.shape[2],n=ch(e,2),r=Rh(n,[-1]);return sd(r,t)}function JW(e,t){return Dl((function(){return Yu(Hp(e,pc(t)),"int32")}))}function ZW(e,t){var n=t.shape,r=n[0],s=n[1],a=n[2];return Dl((function(){var n=QW(t),i=Bp(em(0,a,1,"int32"),1),o=Yu(rd(n,i),"int32"),l=Rh(o,[r,s]),u=Zu(l,pc(1,"int32"));return Nc(nc(u,e),pc(1,"int32"))}))}var eV=function(){function e(e,t){this.model=e,this.outputStride=t;var n=this.model.inputs[0].shape;Rn(-1===n[1]&&-1===n[2],(function(){return"Input shape [".concat(n[1],", ").concat(n[2],"] ")+"must both be equal to or -1"}))}return e.prototype.predict=function(e){var t=this;return Dl((function(){var n=t.preprocessInput(Yu(e,"float32")),r=Bp(n,0),s=t.model.predict(r).map((function(e){return Em(e,[0])})),a=t.nameOutputResults(s);return{heatmapScores:Mh(a.heatmap),offsets:a.offsets,displacementFwd:a.displacementFwd,displacementBwd:a.displacementBwd,segmentation:a.segmentation,partHeatmaps:a.partHeatmaps,longOffsets:a.longOffsets,partOffsets:a.partOffsets}}))},e.prototype.dispose=function(){this.model.dispose()},e}(),tV=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return qW(t,e),t.prototype.preprocessInput=function(e){return Dl((function(){return Nc(tc(e,127.5),1)}))},t.prototype.nameOutputResults=function(e){return{offsets:e[0],segmentation:e[1],partHeatmaps:e[2],longOffsets:e[3],heatmap:e[4],displacementFwd:e[5],displacementBwd:e[6],partOffsets:e[7]}},t}(eV),nV=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],rV=nV.length,sV=nV.reduce((function(e,t,n){return e[t]=n,e}),{});function aV(e,t,n){var r=e[0],s=e[1],a=t[0],i=t[1],o=n.top,l=n.bottom;return[i/(n.left+n.right+s),a/(o+l+r)]}function iV(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+rV)}}function oV(e,t,n){var r=iV(e.heatmapY,e.heatmapX,e.id,n),s=r.y,a=r.x;return{x:e.heatmapX*t+a,y:e.heatmapY*t+s}}function lV(e,t,n){return e<t?t:e>n?n:e}function uV(e,t){return{x:e.x+t.x,y:e.y+t.y}}function cV(e,t,n){void 0===n&&(n=.3);for(var r=0,s=0,a=0;a<e.length;a++)t.keypoints[a].score>n&&(s+=1,r+=Math.pow(e[a].x-t.keypoints[a].position.x,2)+Math.pow(e[a].y-t.keypoints[a].position.y,2));return 0===s?r=1/0:r/=s,r}function dV(e,t,n,r,s,a,i){for(var o=i[0],l=i[1],u=n(e),c=u.y*r+u.x,d=s[rV*(2*c)+t],h=s[rV*(2*c+1)+t],p=e.y+d,f=e.x+h,m=0;m<a;m++){p=Math.min(p,o-1);var g=n({x:f=Math.min(f,l-1),y:p}),y=g.y*r+g.x;p+=d=s[rV*(2*y)+t],f+=h=s[rV*(2*y+1)+t]}return{x:f,y:p}}function hV(e,t,n,r,s,a,i,o,l,u){for(var c=s[0],d=s[1],h=a[0],p=a[1],f=o[0],m=o[1],g=[],y=function(e){return function(e,t,n,r){var s=t[0],a=t[1],i=n[0],o=n[1],l=Math.round(((s+e.y+1)*o-1)/r);return{x:Math.round(((a+e.x+1)*i-1)/r),y:l}}(e,[c,d],[h,p],l)},b=0;b<r;b++){var v=dV(e,b,y,i,t,u,[f,m]);g.push(v)}for(var x=-1,w=1/0,k=0;k<n.length;k++){var S=cV(g,n[k]);S<w&&(x=k,w=S)}return x}function pV(e,t){var n=e[0],r=e[1];return[Math.round((r-1)/t+1),Math.round((n-1)/t+1)]}function fV(e,t,n,r,s,a,i,o,l,u,c){for(var d=i[0],h=i[1],p=e.shape,f=p[0],m=p[1],g=t.shape.slice(0,2),y=g[0],b=g[1],v=Rh(t,[y,b,2,rV]),x=new Float32Array(c*rV*3).fill(0),w=0;w<n.length;w++)for(var k=w*rV*3,S=n[w],I=0;I<rV;I++){var N=S.keypoints[I],T=k+3*I;x[T]=N.score,x[T+1]=N.position.y,x[T+2]=N.position.x}var C=aV([r,s],[d,h],o),E=C[0],$=C[1],_=Sl(x,[c,rV,3]),O=o.top,R=o.left,A={variableNames:["segmentation","longOffsets","poses"],outputShape:[f,m],userCode:"\n    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {\n      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));\n    }\n\n    float convertToPositionInOutputFloat(\n        int pos, int pad, float scale, int stride) {\n      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);\n    }\n\n    float dist(float x1, float y1, float x2, float y2) {\n      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);\n    }\n\n    float sampleLongOffsets(float h, float w, int d, int k) {\n      float fh = fract(h);\n      float fw = fract(w);\n      int clH = int(ceil(h));\n      int clW = int(ceil(w));\n      int flH = int(floor(h));\n      int flW = int(floor(w));\n      float o11 = getLongOffsets(flH, flW, d, k);\n      float o12 = getLongOffsets(flH, clW, d, k);\n      float o21 = getLongOffsets(clH, flW, d, k);\n      float o22 = getLongOffsets(clH, clW, d, k);\n      float o1 = mix(o11, o12, fw);\n      float o2 = mix(o21, o22, fw);\n      return mix(o1, o2, fh);\n    }\n\n    int findNearestPose(int h, int w) {\n      float prob = getSegmentation(h, w);\n      if (prob < 1.0) {\n        return -1;\n      }\n\n      // Done(Tyler): convert from output space h/w to strided space.\n      float stridedH = convertToPositionInOutputFloat(\n        h, ".concat(O,", ").concat($,", ").concat(a,");\n      float stridedW = convertToPositionInOutputFloat(\n        w, ").concat(R,", ").concat(E,", ").concat(a,");\n\n      float minDist = 1000000.0;\n      int iMin = -1;\n      for (int i = 0; i < ").concat(c,"; i++) {\n        float curDistSum = 0.0;\n        int numKpt = 0;\n        for (int k = 0; k < ").concat(rV,"; k++) {\n          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);\n          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);\n\n          float y = float(h) + dy;\n          float x = float(w) + dx;\n\n          for (int s = 0; s < ").concat(l,"; s++) {\n            int yRounded = round(min(y, float(").concat(r-1,")));\n            int xRounded = round(min(x, float(").concat(s-1,")));\n\n            float yStrided = convertToPositionInOutputFloat(\n              yRounded, ").concat(O,", ").concat($,", ").concat(a,");\n            float xStrided = convertToPositionInOutputFloat(\n              xRounded, ").concat(R,", ").concat(E,", ").concat(a,");\n\n            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);\n            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);\n\n            y = y + dy;\n            x = x + dx;\n          }\n\n          float poseScore = getPoses(i, k, 0);\n          float poseY = getPoses(i, k, 1);\n          float poseX = getPoses(i, k, 2);\n          if (poseScore > ").concat(u,") {\n            numKpt = numKpt + 1;\n            curDistSum = curDistSum + dist(x, y, poseX, poseY);\n          }\n        }\n        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {\n          minDist = curDistSum / float(numKpt);\n          iMin = i;\n        }\n      }\n      return iMin;\n    }\n\n    void main() {\n        ivec2 coords = getOutputCoords();\n        int nearestPose = findNearestPose(coords[0], coords[1]);\n        setOutput(float(nearestPose));\n      }\n  ")};return Gl().compileAndRun(A,[e,v,_])}function mV(){return"webgl"===Bl()}function gV(e,t,n,r,s,a,i,o,l,u,c,d){var h=i[0],p=i[1];return void 0===l&&(l=.2),void 0===u&&(u=8),void 0===c&&(c=.3),void 0===d&&(d=10),XW(this,void 0,void 0,(function(){var i,f,m,g,y;return YW(this,(function(b){switch(b.label){case 0:return i=n.filter((function(e){return e.score>=l})),mV()?(m=Dl((function(){var n=fV(e,t,i,r,s,a,[h,p],o,u,c,d),l=Ol().makeTensorFromDataId(n.dataId,n.shape,n.dtype);return i.map((function(e,t){return function(e,t){return Dl((function(){return Yu(yp(e,pc(t)),"int32")}))}(l,t)}))})),[4,Promise.all(m.map((function(e){return e.data()})))]):[3,2];case 1:return f=b.sent(),m.forEach((function(e){return e.dispose()})),[3,5];case 2:return[4,e.data()];case 3:return g=b.sent(),[4,t.data()];case 4:y=b.sent(),f=function(e,t,n,r,s,a,i,o,l,u){var c=i[0],d=i[1];void 0===u&&(u=5);for(var h=n.map((function(e){return new Uint8Array(r*s).fill(0)})),p=o.top,f=o.left,m=aV([r,s],[c,d],o),g=m[0],y=m[1],b=pV([c,d],a)[0],v=0;v<r;v+=1)for(var x=0;x<s;x+=1){var w=v*s+x;if(1===e[w]){var k=hV({x,y:v},t,n,u,[p,f],[g,y],b,[r,s],a,l);k>=0&&(h[k][w]=1)}}return h}(g,y,i,r,s,a,[h,p],o,u),b.label=5;case 5:return[2,f.map((function(e,t){return{data:e,pose:i[t],width:s,height:r}}))]}}))}))}function yV(e,t,n,r,s,a,i,o,l,u,c,d,h){var p=o[0],f=o[1];return void 0===u&&(u=.2),void 0===c&&(c=8),void 0===d&&(d=.3),void 0===h&&(h=10),XW(this,void 0,void 0,(function(){var o,m,g,y,b,v;return YW(this,(function(x){switch(x.label){case 0:return o=r.filter((function(e){return e.score>=u})),mV()?(g=Dl((function(){var r=fV(e,t,o,s,a,i,[p,f],l,c,d,h),u=Ol().makeTensorFromDataId(r.dataId,r.shape,r.dtype);return o.map((function(e,t){return function(e,t,n){return Dl((function(){return Nc(nc(Yu(yp(e,pc(n)),"int32"),Zu(t,1)),1)}))}(u,n,t)}))})),[4,Promise.all(g.map((function(e){return e.data()})))]):[3,2];case 1:return m=x.sent(),g.forEach((function(e){return e.dispose()})),[3,6];case 2:return[4,e.data()];case 3:return y=x.sent(),[4,t.data()];case 4:return b=x.sent(),[4,n.data()];case 5:v=x.sent(),m=function(e,t,n,r,s,a,i,o,l,u,c){var d=o[0],h=o[1];void 0===c&&(c=5);for(var p=r.map((function(e){return new Int32Array(s*a).fill(-1)})),f=l.top,m=l.left,g=aV([s,a],[d,h],l),y=g[0],b=g[1],v=pV([d,h],i)[0],x=0;x<s;x+=1)for(var w=0;w<a;w+=1){var k=x*a+w;if(1===e[k]){var S=hV({x:w,y:x},t,r,c,[f,m],[y,b],v,[s,a],i,u);S>=0&&(p[S][k]=n[k])}}return p}(y,b,v,o,s,a,i,[p,f],l,c),x.label=6;case 6:return[2,m.map((function(e,t){return{pose:o[t],data:e,height:s,width:a}}))]}}))}))}function bV(e){return Math.floor(e/2)}[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]].map((function(e){var t=e[0],n=e[1];return[sV[t],sV[n]]}));var vV=function(){function e(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return e.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},e.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},e.prototype.empty=function(){return-1===this.numberOfElements},e.prototype.size=function(){return this.numberOfElements+1},e.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},e.prototype.max=function(){return this.priorityQueue[0]},e.prototype.swim=function(e){for(;e>0&&this.less(bV(e),e);)this.exchange(e,bV(e)),e=bV(e)},e.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},e.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},e.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},e.prototype.exchange=function(e,t){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n},e}();function xV(e,t,n,r,s,a){for(var i=a.shape,o=i[0],l=i[1],u=!0,c=Math.max(n-s,0),d=Math.min(n+s+1,o),h=c;h<d;++h){for(var p=Math.max(r-s,0),f=Math.min(r+s+1,l),m=p;m<f;++m)if(a.get(h,m,e)>t){u=!1;break}if(!u)break}return u}var wV=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]].map((function(e){var t=e[0],n=e[1];return[sV[t],sV[n]]})),kV=wV.map((function(e){return e[1]})),SV=wV.map((function(e){return e[0]}));function IV(e,t,n,r){return{y:lV(Math.round(e.y/t),0,n-1),x:lV(Math.round(e.x/t),0,r-1)}}function NV(e,t,n,r,s,a,i,o){void 0===o&&(o=2);for(var l=r.shape,u=l[0],c=l[1],d=function(e,t,n){var r=n.shape[2]/2;return{y:n.get(t.y,t.x,e),x:n.get(t.y,t.x,r+e)}}(e,IV(t.position,a,u,c),i),h=uV(t.position,d),p=0;p<o;p++){var f=IV(h,a,u,c),m=iV(f.y,f.x,n,s);h=uV({x:f.x*a,y:f.y*a},{x:m.x,y:m.y})}var g=IV(h,a,u,c),y=r.get(g.y,g.x,n);return{position:h,part:nV[n],score:y}}function TV(e,t,n,r,s,a){var i=t.shape[2],o=kV.length,l=new Array(i),u=e.part,c=e.score,d=oV(u,r,n);l[u.id]={score:c,part:nV[u.id],position:d};for(var h=o-1;h>=0;--h){var p=kV[h],f=SV[h];l[p]&&!l[f]&&(l[f]=NV(h,l[p],f,t,n,r,a))}for(h=0;h<o;++h){p=SV[h],f=kV[h];l[p]&&!l[f]&&(l[f]=NV(h,l[p],f,t,n,r,s))}return l}function CV(e,t,n,r){var s=n.x,a=n.y;return e.some((function(e){var n,i,o,l,u,c,d=e.keypoints[r].position;return n=a,i=s,o=d.y,l=d.x,(u=o-n)*u+(c=l-i)*c<=t}))}function EV(e,t,n){var r=n.reduce((function(n,r,s){var a=r.position,i=r.score;return CV(e,t,a,s)||(n+=i),n}),0);return r/n.length}function $V(e,t,n,r,s,a,i,o){void 0===i&&(i=.5),void 0===o&&(o=20);for(var l=[],u=function(e,t,n){for(var r=n.shape,s=r[0],a=r[1],i=r[2],o=new vV(s*a*i,(function(e){return e.score})),l=0;l<s;++l)for(var u=0;u<a;++u)for(var c=0;c<i;++c){var d=n.get(l,u,c);d<e||xV(c,d,l,u,t,n)&&o.enqueue({score:d,part:{heatmapY:l,heatmapX:u,id:c}})}return o}(i,1,e),c=o*o;l.length<a&&!u.empty();){var d=u.dequeue();if(!CV(l,c,oV(d.part,s,t),d.part.id)){var h=TV(d,e,t,s,n,r),p=EV(l,c,h);l.push({keypoints:h,score:p})}}return l}var _V,OV=[-123.15,-115.9,-103.06],RV=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return qW(t,e),t.prototype.preprocessInput=function(e){return Zu(e,OV)},t.prototype.nameOutputResults=function(e){var t=e[0],n=e[1],r=e[2],s=e[3],a=e[4],i=e[5];return{offsets:a,segmentation:e[6],partHeatmaps:i,longOffsets:s,heatmap:r,displacementFwd:n,displacementBwd:t,partOffsets:e[7]}},t}(eV),AV="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/",DV="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/";function FV(e){if("undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas||"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)return function(e){if("offsetHeight"in e&&0!==e.offsetHeight&&"offsetWidth"in e&&0!==e.offsetWidth)return[e.offsetHeight,e.offsetWidth];if(null!=e.height&&null!=e.width)return[e.height,e.width];throw new Error("HTMLImageElement must have height and width attributes set.")}(e);if("undefined"!=typeof ImageData&&e instanceof ImageData)return[e.height,e.width];if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)return function(e){return e.hasAttribute("height")&&e.hasAttribute("width")?[e.height,e.width]:[e.videoHeight,e.videoWidth]}(e);if(e instanceof Po)return[e.shape[0],e.shape[1]];throw new Error("error: Unknown input type: ".concat(e,"."))}function MV(e,t){return function(e,t){return(e-1)%t==0}(e,t)?e:Math.floor(e/t)*t+1}var LV={low:"low",medium:"medium",high:"high",full:"full"},zV=((_V={})[LV.low]=.25,_V[LV.medium]=.5,_V[LV.high]=.75,_V[LV.full]=1,_V);function PV(e,t,n){var r=n[0],s=n[1],a=function(e){if("string"==typeof e){var t=zV[e];return Rn("number"==typeof t,(function(){return"string value of inputResolution must be one of ".concat(Object.values(LV).join(",")," but was ").concat(e,".")})),t}return Rn("number"==typeof e&&e<=2&&e>=.1,(function(){return"inputResolution must be a string or number between ".concat(.1," and ").concat(2,", but ")+"was ".concat(e)})),e}(e);return[MV(r*a,t),MV(s*a,t)]}function BV(e,t,n,r,s){var a=t[0],i=t[1],o=n[0],l=n[1],u=r[0],c=u[0],d=u[1],h=r[1],p=h[0],f=h[1];return void 0===s&&(s=!1),Dl((function(){var t=hy.resizeBilinear(e,[o,l],!0);return s&&(t=Mh(t)),function(e,t,n){var r=t[0],s=t[1],a=n[0],i=a[0],o=a[1],l=n[1],u=l[0],c=l[1];return Dl((function(){var t=Bp(e);return Em(hy.cropAndResize(t,[[i/(r+i+o-1),u/(s+u+c-1),(i+r-1)/(r+i+o-1),(u+s-1)/(s+u+c-1)]],[0],[r,s]),[0])}))}(t,[a,i],[[c,d],[p,f]])}))}function UV(e,t){var n=t[0],r=t[1],s=FV(e),a=s[0],i=s[1],o=r/n,l=[0,0,0,0],u=l[0],c=l[1],d=l[2],h=l[3];i/a<o?(u=0,c=0,d=Math.round(.5*(o*a-i)),h=Math.round(.5*(o*a-i))):(u=Math.round(.5*(1/o*i-a)),c=Math.round(.5*(1/o*i-a)),d=0,h=0);var p=Dl((function(){var t=function(e){return e instanceof Po?e:vd(e)}(e);return t=Ff(t,[[u,c],[d,h],[0,0]]),hy.resizeBilinear(t,[n,r])}));return{resized:p,padding:{top:u,left:d,right:h,bottom:c}}}function jV(e){return XW(this,void 0,void 0,(function(){return YW(this,(function(t){return[2,Promise.all(e.map((function(e){return e.buffer()})))]}))}))}function WV(e,t,n,r,s){var a=t[0],i=t[1],o=n[0],l=n[1],u=function(e,t,n,r,s){return void 0===r&&(r=0),void 0===s&&(s=0),1===n&&1===t&&0===r&&0===s?e:e.map((function(e){return function(e,t,n,r,s){return void 0===r&&(r=0),void 0===s&&(s=0),{score:e.score,keypoints:e.keypoints.map((function(e){var a=e.score,i=e.part,o=e.position;return{score:a,part:i,position:{x:o.x*n+s,y:o.y*t+r}}}))}}(e,t,n,r,s)}))}(e,(a+r.top+r.bottom)/o,(i+r.left+r.right)/l,-r.top,-r.left);return s?function(e,t){return t<=0?e:e.map((function(e){return function(e,t){return{score:e.score,keypoints:e.keypoints.map((function(e){var n=e.score,r=e.part,s=e.position;return{score:n,part:r,position:{x:t-1-s.x,y:s.y}}}))}}(e,t)}))}(u,i):u}var VV=!0,GV=!1,HV={architecture:"MobileNetV1",outputStride:16,quantBytes:4,multiplier:.75},qV=["MobileNetV1","ResNet50"],KV={MobileNetV1:[8,16,32],ResNet50:[32,16]},XV={MobileNetV1:[.5,.75,1],ResNet50:[1]},YV=[1,2,4];var QV={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20},JV={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20,minKeypointScore:.3,refineSteps:10};function ZV(e){var t=e.segmentationThreshold,n=e.maxDetections,r=e.scoreThreshold,s=e.nmsRadius;if(t<0||t>1)throw new Error("segmentationThreshold ".concat(t,". ")+"Should be in range [0.0, 1.0]");if(n<=0)throw new Error("Invalid maxDetections ".concat(n,". ")+"Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold ".concat(r,". ")+"Should be in range [0.0, 1.0]");if(s<=0)throw new Error("Invalid nmsRadius ".concat(s,"."))}function eG(e){var t=e.segmentationThreshold,n=e.maxDetections,r=e.scoreThreshold,s=e.nmsRadius,a=e.minKeypointScore,i=e.refineSteps;if(t<0||t>1)throw new Error("segmentationThreshold ".concat(t,". ")+"Should be in range [0.0, 1.0]");if(n<=0)throw new Error("Invalid maxDetections ".concat(n,". ")+"Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold ".concat(r,". ")+"Should be in range [0.0, 1.0]");if(s<=0)throw new Error("Invalid nmsRadius ".concat(s,"."));if(a<0||a>1)throw new Error("Invalid minKeypointScore ".concat(a,".")+"Should be in range [0.0, 1.0]");if(i<=0||i>20)throw new Error("Invalid refineSteps ".concat(i,".")+"Should be in range [1, 20]")}var tG=function(){function e(e){this.baseModel=e}return e.prototype.predictForPersonSegmentation=function(e){var t=this.baseModel.predict(e);return{segmentLogits:t.segmentation,heatmapScores:t.heatmapScores,offsets:t.offsets,displacementFwd:t.displacementFwd,displacementBwd:t.displacementBwd}},e.prototype.predictForPersonSegmentationAndPart=function(e){var t=this.baseModel.predict(e);return{segmentLogits:t.segmentation,partHeatmapLogits:t.partHeatmaps,heatmapScores:t.heatmapScores,offsets:t.offsets,displacementFwd:t.displacementFwd,displacementBwd:t.displacementBwd}},e.prototype.predictForMultiPersonInstanceSegmentationAndPart=function(e){var t=this.baseModel.predict(e);return{segmentLogits:t.segmentation,longOffsets:t.longOffsets,heatmapScores:t.heatmapScores,offsets:t.offsets,displacementFwd:t.displacementFwd,displacementBwd:t.displacementBwd,partHeatmaps:t.partHeatmaps}},e.prototype.segmentPersonActivation=function(e,t,n){var r=this;void 0===n&&(n=.5);var s=FV(e),a=s[0],i=s[1],o=PV(t,this.baseModel.outputStride,[a,i]),l=UV(e,o),u=l.resized,c=l.padding,d=Dl((function(){var e=r.predictForPersonSegmentation(u),t=e.segmentLogits,s=e.heatmapScores,o=e.offsets,l=e.displacementFwd,d=e.displacementBwd,h=u.shape,p=h[0],f=h[1],m=BV(t,[a,i],[p,f],[[c.top,c.bottom],[c.left,c.right]],VV);return{segmentation:JW(Em(m),n),heatmapScores:s,offsets:o,displacementFwd:l,displacementBwd:d}})),h=d.segmentation,p=d.heatmapScores,f=d.offsets,m=d.displacementFwd,g=d.displacementBwd;return u.dispose(),{segmentation:h,heatmapScores:p,offsets:f,displacementFwd:m,displacementBwd:g,padding:c,internalResolutionHeightAndWidth:o}},e.prototype.segmentPerson=function(e,t){return void 0===t&&(t=QV),XW(this,void 0,void 0,(function(){var n,r,s,a,i,o,l,u,c,d,h,p,f,m,g,y,b,v;return YW(this,(function(x){switch(x.label){case 0:return ZV(t=KW(KW({},QV),t)),n=this.segmentPersonActivation(e,t.internalResolution,t.segmentationThreshold),r=n.segmentation,s=n.heatmapScores,a=n.offsets,i=n.displacementFwd,o=n.displacementBwd,l=n.padding,u=n.internalResolutionHeightAndWidth,c=r.shape,d=c[0],h=c[1],[4,r.data()];case 1:return p=x.sent(),r.dispose(),[4,jV([s,a,i,o])];case 2:return f=x.sent(),m=f[0],g=f[1],y=f[2],b=f[3],v=WV(v=$V(m,g,y,b,this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[d,h],u,l,GV),s.dispose(),a.dispose(),i.dispose(),o.dispose(),[2,{height:d,width:h,data:p,allPoses:v}]}}))}))},e.prototype.segmentMultiPerson=function(e,t){return void 0===t&&(t=JV),XW(this,void 0,void 0,(function(){var n,r,s,a,i,o,l,u,c,d,h,p,f,m,g,y,b,v,x,w,k,S=this;return YW(this,(function(I){switch(I.label){case 0:return eG(t=KW(KW({},JV),t)),n=FV(e),r=n[0],s=n[1],a=PV(t.internalResolution,this.baseModel.outputStride,[r,s]),i=UV(e,a),o=i.resized,l=i.padding,u=Dl((function(){var e,n=S.predictForMultiPersonInstanceSegmentationAndPart(o),i=n.segmentLogits,u=n.longOffsets,c=n.heatmapScores,d=n.offsets,h=n.displacementFwd,p=n.displacementBwd,f=BV(i,[r,s],a,[[l.top,l.bottom],[l.left,l.right]],VV);return e=u,{segmentation:JW(Em(f),t.segmentationThreshold),longOffsets:e,heatmapScoresRaw:c,offsetsRaw:d,displacementFwdRaw:h,displacementBwdRaw:p}})),c=u.segmentation,d=u.longOffsets,h=u.heatmapScoresRaw,p=u.offsetsRaw,f=u.displacementFwdRaw,m=u.displacementBwdRaw,[4,jV([h,p,f,m])];case 1:return g=I.sent(),y=g[0],b=g[1],v=g[2],x=g[3],w=WV(w=$V(y,b,v,x,this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[r,s],a,l,GV),[4,gV(c,d,w,r,s,this.baseModel.outputStride,a,l,t.scoreThreshold,t.refineSteps,t.minKeypointScore,t.maxDetections)];case 2:return k=I.sent(),o.dispose(),c.dispose(),d.dispose(),h.dispose(),p.dispose(),f.dispose(),m.dispose(),[2,k]}}))}))},e.prototype.segmentPersonPartsActivation=function(e,t,n){var r=this;void 0===n&&(n=.5);var s=FV(e),a=s[0],i=s[1],o=PV(t,this.baseModel.outputStride,[a,i]),l=UV(e,o),u=l.resized,c=l.padding,d=Dl((function(){var e=r.predictForPersonSegmentationAndPart(u),t=e.segmentLogits,s=e.partHeatmapLogits,o=e.heatmapScores,l=e.offsets,d=e.displacementFwd,h=e.displacementBwd,p=u.shape,f=p[0],m=p[1],g=BV(t,[a,i],[f,m],[[c.top,c.bottom],[c.left,c.right]],VV),y=BV(s,[a,i],[f,m],[[c.top,c.bottom],[c.left,c.right]],VV);return{partSegmentation:ZW(JW(Em(g),n),y),heatmapScores:o,offsets:l,displacementFwd:d,displacementBwd:h}})),h=d.partSegmentation,p=d.heatmapScores,f=d.offsets,m=d.displacementFwd,g=d.displacementBwd;return u.dispose(),{partSegmentation:h,heatmapScores:p,offsets:f,displacementFwd:m,displacementBwd:g,padding:c,internalResolutionHeightAndWidth:o}},e.prototype.segmentPersonParts=function(e,t){return void 0===t&&(t=QV),XW(this,void 0,void 0,(function(){var n,r,s,a,i,o,l,u,c,d,h,p,f,m,g,y,b,v;return YW(this,(function(x){switch(x.label){case 0:return ZV(t=KW(KW({},QV),t)),n=this.segmentPersonPartsActivation(e,t.internalResolution,t.segmentationThreshold),r=n.partSegmentation,s=n.heatmapScores,a=n.offsets,i=n.displacementFwd,o=n.displacementBwd,l=n.padding,u=n.internalResolutionHeightAndWidth,c=r.shape,d=c[0],h=c[1],[4,r.data()];case 1:return p=x.sent(),r.dispose(),[4,jV([s,a,i,o])];case 2:return f=x.sent(),m=f[0],g=f[1],y=f[2],b=f[3],v=WV(v=$V(m,g,y,b,this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[d,h],u,l,GV),s.dispose(),a.dispose(),i.dispose(),o.dispose(),[2,{height:d,width:h,data:p,allPoses:v}]}}))}))},e.prototype.segmentMultiPersonParts=function(e,t){return void 0===t&&(t=JV),XW(this,void 0,void 0,(function(){var n,r,s,a,i,o,l,u,c,d,h,p,f,m,g,y,b,v,x,w,k,S,I=this;return YW(this,(function(N){switch(N.label){case 0:return eG(t=KW(KW({},JV),t)),n=FV(e),r=n[0],s=n[1],a=PV(t.internalResolution,this.baseModel.outputStride,[r,s]),i=UV(e,a),o=i.resized,l=i.padding,u=Dl((function(){var e=I.predictForMultiPersonInstanceSegmentationAndPart(o),n=e.segmentLogits,i=e.longOffsets,u=e.heatmapScores,c=e.offsets,d=e.displacementFwd,h=e.displacementBwd,p=e.partHeatmaps,f=BV(n,[r,s],a,[[l.top,l.bottom],[l.left,l.right]],VV),m=BV(p,[r,s],a,[[l.top,l.bottom],[l.left,l.right]],VV),g=i,y=JW(Em(f),t.segmentationThreshold),b=function(e){var t=e.shape,n=t[0],r=t[1],s=t[2];return Dl((function(){var t=QW(e),a=Bp(em(0,s,1,"int32"),1),i=Yu(rd(t,a),"int32");return Rh(i,[n,r])}))}(m);return{segmentation:y,longOffsets:g,heatmapScoresRaw:u,offsetsRaw:c,displacementFwdRaw:d,displacementBwdRaw:h,partSegmentation:b}})),c=u.segmentation,d=u.longOffsets,h=u.heatmapScoresRaw,p=u.offsetsRaw,f=u.displacementFwdRaw,m=u.displacementBwdRaw,g=u.partSegmentation,[4,jV([h,p,f,m])];case 1:return y=N.sent(),b=y[0],v=y[1],x=y[2],w=y[3],k=WV(k=$V(b,v,x,w,this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[r,s],a,l,GV),[4,yV(c,d,g,k,r,s,this.baseModel.outputStride,a,l,t.scoreThreshold,t.refineSteps,t.minKeypointScore,t.maxDetections)];case 2:return S=N.sent(),o.dispose(),c.dispose(),d.dispose(),h.dispose(),p.dispose(),f.dispose(),m.dispose(),g.dispose(),[2,S]}}))}))},e.prototype.dispose=function(){this.baseModel.dispose()},e}();function nG(e){return XW(this,void 0,void 0,(function(){var t,n,r,s,a,i;return YW(this,(function(o){switch(o.label){case 0:if(t=e.outputStride,n=e.quantBytes,r=e.multiplier,null==b)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");return s=function(e,t,n){var r={1:"100",.75:"075",.5:"050"},s="model-stride".concat(e,".json");return 4===n?DV+"float/".concat(r[t],"/")+s:DV+"quant".concat(n,"/").concat(r[t],"/")+s}(t,r,n),[4,nC(e.modelUrl||s)];case 1:return a=o.sent(),i=new tV(a,t),[2,new tG(i)]}}))}))}function rG(e){return XW(this,void 0,void 0,(function(){var t,n,r,s,a;return YW(this,(function(i){switch(i.label){case 0:if(t=e.outputStride,n=e.quantBytes,null==b)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");return r=function(e,t){var n="model-stride".concat(e,".json");return 4===t?AV+"float/"+n:AV+"quant".concat(t,"/")+n}(t,n),[4,nC(e.modelUrl||r)];case 1:return s=i.sent(),a=new RV(s,t),[2,new tG(a)]}}))}))}function sG(e){return void 0===e&&(e=HV),XW(this,void 0,void 0,(function(){return YW(this,(function(t){return"ResNet50"===(e=function(e){if(null==(e=e||HV).architecture&&(e.architecture="MobileNetV1"),qV.indexOf(e.architecture)<0)throw new Error("Invalid architecture ".concat(e.architecture,". ")+"Should be one of ".concat(qV));if(null==e.outputStride&&(e.outputStride=16),KV[e.architecture].indexOf(e.outputStride)<0)throw new Error("Invalid outputStride ".concat(e.outputStride,". ")+"Should be one of ".concat(KV[e.architecture]," ")+"for architecture ".concat(e.architecture,"."));if(null==e.multiplier&&(e.multiplier=1),XV[e.architecture].indexOf(e.multiplier)<0)throw new Error("Invalid multiplier ".concat(e.multiplier,". ")+"Should be one of ".concat(XV[e.architecture]," ")+"for architecture ".concat(e.architecture,"."));if(null==e.quantBytes&&(e.quantBytes=4),YV.indexOf(e.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(e.quantBytes,". ")+"Should be one of ".concat(YV," ")+"for architecture ".concat(e.architecture,"."));return e}(e)).architecture?[2,rG(e)]:"MobileNetV1"===e.architecture?[2,nG(e)]:[2,null]}))}))}function aG(e,t,n,r,s){if(void 0===t&&(t={r:0,g:0,b:0,a:0}),void 0===n&&(n={r:0,g:0,b:0,a:255}),void 0===r&&(r=!1),void 0===s&&(s=[1]),Array.isArray(e)&&0===e.length)return null;var a,i=(a=Array.isArray(e)?e:[e])[0],o=i.width,l=i.height,u=new Uint8ClampedArray(o*l*4);function c(e,t,n,r,s,a){void 0===a&&(a={r:0,g:255,b:255,a:255});for(var i=-s;i<=s;i++)for(var o=-s;o<=s;o++)if(0!==i&&0!==o){var l=(t+i)*r+(n+o);e[4*l+0]=a.r,e[4*l+1]=a.g,e[4*l+2]=a.b,e[4*l+3]=a.a}}function d(e,t,n,r,s,a){void 0===s&&(s=[1]),void 0===a&&(a=1);for(var i=0,o=-a;o<=a;o++)for(var l=function(a){if(0!==o&&0!==a){var l=(t+o)*r+(n+a);s.some((function(t){return t===e[l]}))||(i+=1)}},u=-a;u<=a;u++)l(u);return i>0}for(var h=0;h<l;h+=1)for(var p=function(e){var i=h*o+e;u[4*i+0]=n.r,u[4*i+1]=n.g,u[4*i+2]=n.b,u[4*i+3]=n.a;for(var p=function(n){if(s.some((function(e){return e===a[n].data[i]}))){u[4*i]=t.r,u[4*i+1]=t.g,u[4*i+2]=t.b,u[4*i+3]=t.a;var p=d(a[n].data,h,e,o,s);r&&h-1>=0&&h+1<l&&e-1>=0&&e+1<o&&p&&c(u,h,e,o,1)}},f=0;f<a.length;f++)p(f)},f=0;f<o;f+=1)p(f);return new ImageData(u,o,l)}var iG=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};let oG=null,lG=null;const uG={architecture:"MobileNetV1",outputStride:16,multiplier:.75,quantBytes:2},cG=()=>iG(void 0,void 0,void 0,(function*(){return oG||(lG||(lG=iG(void 0,void 0,void 0,(function*(){try{if("webgl"!==Bl()&&!(yield zl("webgl")))throw new Error("WebGL is not available. TensorFlow.js requires WebGL support.");return yield Pl(),oG=yield sG(uG),oG}catch(e){throw lG=null,e}})),lG))})),dG=e=>iG(void 0,void 0,void 0,(function*(){try{yield Pl();const n="string"==typeof e?yield hG(e):e,r=yield(t=n,iG(void 0,void 0,void 0,(function*(){try{const e=yield cG();let n;if("string"==typeof t)n=yield hG(t);else if(t instanceof HTMLImageElement||t instanceof HTMLCanvasElement)n=t;else{const e=document.createElement("canvas");e.width=t.width,e.height=t.height;const r=e.getContext("2d");if(!r)throw new Error("Could not get canvas context");r.putImageData(t,0,0),n=e}const r=n.width,s=n.height,a=yield e.segmentPerson(n,{flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7}),i={r:0,g:0,b:0,a:0},o={r:0,g:0,b:0,a:0},l=yield aG(a,i,o),u=document.createElement("canvas");u.width=r,u.height=s;const c=u.getContext("2d");if(!c)throw new Error("Could not get canvas context");c.drawImage(n,0,0);const d=c.getImageData(0,0,r,s),h=l.data,p=d.data;for(let e=0;e<h.length;e+=4)0===h[e]&&0===h[e+1]&&0===h[e+2]&&(p[e+3]=0);return d}catch(e){throw e}}))),s=document.createElement("canvas");s.width=r.width,s.height=r.height;const a=s.getContext("2d");if(!a)throw new Error("Could not get canvas context");a.putImageData(r,0,0);return{success:!0,imageUrl:s.toDataURL("image/png"),method:ve.TENSORFLOW}}catch(e){return{success:!1,error:e instanceof Error?e.message:String(e),method:ve.TENSORFLOW}}var t})),hG=e=>new Promise(((t,n)=>{const r=new Image;r.crossOrigin="anonymous",r.onload=()=>t(r),r.onerror=e=>n(e),r.src=e}));var pG=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const fG=e=>{switch(e){case"preview":return"preview";case"high":case"full":return"full";default:return"auto"}},mG=e=>new Promise(((t,n)=>{const r=new FileReader;r.onload=e=>{var r;(null===(r=e.target)||void 0===r?void 0:r.result)?t(e.target.result):n(new Error("Failed to convert file to data URL"))},r.onerror=e=>n(e),r.readAsDataURL(e)})),gG=()=>iG(void 0,void 0,void 0,(function*(){try{yield Pl();if(!("webgl"===Bl()||(yield zl("webgl"))))return!1;try{const e=Dm([[1,2],[3,4]]),t=e.add(e);return e.dispose(),t.dispose(),!0}catch(e){return!1}}catch(e){return!1}})),yG=()=>{setTimeout((()=>{cG().catch((e=>{}))}),1e3)};var bG=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const vG=e=>{const[t,n]=(0,j.useState)(!1),[r,s]=(0,j.useState)(0),[a,i]=(0,j.useState)(null),o=Se((e=>e.settings)),l=Se((e=>e.updateUserImage)),[u,c]=(0,j.useState)(null);(0,j.useEffect)((()=>{bG(void 0,void 0,void 0,(function*(){try{const e=yield gG();c(e),e&&yG()}catch(e){c(!1)}}))}),[]);const d=(0,j.useCallback)((t=>bG(void 0,void 0,void 0,(function*(){try{n(!0),s(10),i(null),l({processingStatus:be.REMOVING_BACKGROUND});let r=o.preferredBackgroundRemovalMethod;r===ve.TENSORFLOW&&!1===u&&(r=ve.REMOVE_BG_API),s(25);const a=yield((e,t)=>pG(void 0,void 0,void 0,(function*(){let n;try{switch(t.method){case ve.REMOVE_BG_API:if(!t.apiKey)throw new Error("API key is required for Remove.bg API");n=yield xn(e,{apiKey:t.apiKey,size:fG(t.quality)});break;case ve.TENSORFLOW:if("string"==typeof e)n=yield dG(e);else{const t=yield mG(e);n=yield dG(t)}break;case ve.MANUAL:n={success:!1,error:"Manual background removal not implemented",method:ve.MANUAL};break;default:n={success:!1,error:`Unknown removal method: ${t.method}`,method:t.method}}if(!n.success&&t.fallbackToTensorflow&&t.method!==ve.TENSORFLOW)if("string"==typeof e)n=yield dG(e);else{const t=yield mG(e);n=yield dG(t)}return n}catch(e){return{success:!1,error:e instanceof Error?e.message:String(e),method:t.method}}})))(t.url,{method:r,apiKey:o.apiKey,fallbackToTensorflow:r===ve.REMOVE_BG_API&&!0===u});if(s(90),!a.success||!a.imageUrl)throw new Error(a.error||"Failed to remove background");const c=Object.assign(Object.assign({},t),{url:a.imageUrl,backgroundRemoved:!0,processingStatus:be.COMPLETED});return l(c),s(100),(null==e?void 0:e.onSuccess)&&e.onSuccess(c),c}catch(n){const r=n instanceof Error?n.message:String(n);return i(r),l({processingStatus:be.FAILED,processingError:r}),(null==e?void 0:e.onError)&&e.onError(r),Object.assign(Object.assign({},t),{processingStatus:be.FAILED,processingError:r})}finally{n(!1)}}))),[o,u,l,e]);return{removeImageBackground:d,isProcessing:t,progress:r,error:a,tensorflowSupported:u,reset:()=>{i(null),s(0)}}};var xG=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const wG=e=>{const[t,n]=(0,j.useState)(!1),[r,s]=(0,j.useState)(0),[a,i]=(0,j.useState)(null),o=Se((e=>e.settings)),l=Se((e=>e.setUserImage)),u=Se((e=>e.updateUserImage)),{removeImageBackground:c}=vG({onError:e=>i(e)}),d=(0,j.useCallback)((t=>xG(void 0,void 0,void 0,(function*(){try{if(n(!0),s(0),i(null),!t.type.startsWith("image/"))throw new Error("File is not an image");const r={id:`img_${Date.now()}`,url:"",file:t,processingStatus:be.UPLOADING};l(r),s(10);const a=yield sn(t);s(20);const d=yield rn(a),h=a;let p=d;const f=(null==e?void 0:e.maxWidth)||1200,m=(null==e?void 0:e.maxHeight)||1600;(d.width>f||d.height>m)&&(s(30),p=((e,t,n,r,s,a)=>{let i=e,o=t;return n&&(i=n,o=t*n/e),r&&(o=r,n||(i=e*r/t)),s&&i>s&&(o=o*s/i,i=s),a&&o>a&&(i=i*a/o,o=a),{width:Math.round(i),height:Math.round(o)}})(d.width,d.height,void 0,void 0,f,m));const g=Object.assign(Object.assign({},r),{url:h,dimensions:p,originalDimensions:d,processingStatus:be.PROCESSING});l(g),s(40);const y=void 0!==(null==e?void 0:e.autoRemoveBackground)?e.autoRemoveBackground:o.removeBackgroundAutomatically;let b=g;return y?(u({processingStatus:be.REMOVING_BACKGROUND}),b=yield c(g)):(b=Object.assign(Object.assign({},g),{processingStatus:be.COMPLETED}),u(b)),s(100),(null==e?void 0:e.onProcessingComplete)&&e.onProcessingComplete(b),b}catch(e){const t=e instanceof Error?e.message:String(e);return i(t),u({processingStatus:be.FAILED,processingError:t}),null}finally{n(!1)}}))),[e,o.removeBackgroundAutomatically,l,u,c]);return{processImage:d,isProcessing:t,progress:r,error:a,reset:()=>{i(null),s(0)}}};var kG=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const SG=()=>{const{currentOutfit:e,userImage:t,settings:n,isLoading:r,error:s,canvasWidth:a,canvasHeight:i,setCurrentOutfit:o,addGarmentToOutfit:l,removeGarmentFromOutfit:u,updateGarment:c,clearUserImage:d,setLoading:h,setError:p,saveResult:f,openTryOnModal:m,closeTryOnModal:g}=Se(),{processImage:y}=wG(),[b,v]=(0,j.useState)(null);(0,j.useEffect)((()=>{e||o({id:`outfit_${Date.now()}`,garments:[],createdAt:new Date})}),[e,o]);const x=(0,j.useCallback)((e=>kG(void 0,void 0,void 0,(function*(){h(!0),p(null);try{yield y(e)}catch(e){p(e instanceof Error?e.message:String(e))}finally{h(!1)}}))),[y,h,p]),w=(0,j.useCallback)(((t,r)=>kG(void 0,void 0,void 0,(function*(){h(!0);try{let s,a;if("string"==typeof t)s=t,a=yield rn(s);else{const e=new FileReader;s=yield new Promise(((n,r)=>{e.onload=()=>n(e.result),e.onerror=r,e.readAsDataURL(t)})),a=yield rn(s)}const i={id:`garment_${Date.now()}_${Math.floor(1e3*Math.random())}`,url:s,type:r,bodyPosition:xe(r),zIndex:we(r),layerIndex:(null==e?void 0:e.garments.length)||0,dimensions:a,originalDimensions:a,scale:n.defaultGarmentScale[r],offset:n.defaultGarmentOffset[r]};l(i)}catch(e){p(e instanceof Error?e.message:String(e))}finally{h(!1)}}))),[null==e?void 0:e.garments.length,n.defaultGarmentScale,n.defaultGarmentOffset,l,h,p]),k=(0,j.useCallback)((e=>{u(e)}),[u]),S=(0,j.useCallback)(((e,t)=>{c(e,t)}),[c]),I=(0,j.useCallback)((()=>kG(void 0,void 0,void 0,(function*(){var n;if(b&&e&&t)try{h(!0);const r=yield(n=b,new Promise(((e,t)=>{try{e(n.toDataURL("image/png"))}catch(e){t(e)}}))),s={id:`result_${Date.now()}`,outfitId:e.id,userId:"current_user",userImageUrl:t.url,resultImageUrl:r,garmentIds:e.garments.map((e=>e.id)),createdAt:new Date};return f(s),s}catch(e){return p(e instanceof Error?e.message:String(e)),null}finally{h(!1)}}))),[b,e,t,h,p,f]),N=(0,j.useCallback)(((e,t)=>{const n={id:`outfit_${Date.now()}`,garments:[],createdAt:new Date};o(n),e&&t&&w(e,t),m()}),[o,w,m]),T=(0,j.useCallback)((e=>{o(e),m()}),[o,m]);return{currentOutfit:e,userImage:t,isLoading:r,error:s,canvasWidth:a,canvasHeight:i,showGuidelines:n.showGuidelines,canvasRef:b,setCanvasRef:v,uploadUserImage:x,addGarment:w,removeGarment:k,updateGarmentProperties:S,clearUserImage:d,saveTryOnResult:I,startNewTryOn:N,tryOnOutfit:T,closeTryOnModal:g}};var IG=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const NG=({onClose:e,onSave:t,onAddToLookbook:n})=>{const{currentOutfit:r,userImage:s,isLoading:a,error:i,canvasRef:o,setCanvasRef:l,uploadUserImage:u,addGarment:c,removeGarment:d,updateGarmentProperties:h,clearUserImage:p,saveTryOnResult:f,closeTryOnModal:m}=SG(),[g,y]=(0,j.useState)(null),[b,v]=(0,j.useState)(!s),[x,w]=(0,j.useState)(!1),[k,S]=(0,j.useState)(!1);(0,j.useEffect)((()=>{yG()}),[]),(0,j.useEffect)((()=>{if(g&&r){if(r.garments.find((e=>e.id===g))){const e=document.getElementById(`garment-${g}`);e&&e.scrollIntoView({behavior:"smooth",block:"nearest"})}}}),[g,r]),(0,j.useEffect)((()=>{s||v(!0)}),[s]);const I=()=>{e?e():m()},N=()=>{p(),v(!0),y(null),S(!1)};return(0,U.jsxs)("div",Object.assign({className:"stylist-virtual-try-on"},{children:[(0,U.jsxs)("div",Object.assign({className:"stylist-virtual-try-on__header"},{children:[(0,U.jsx)("h2",Object.assign({className:"stylist-virtual-try-on__title"},{children:"Virtual Try-On"})),(0,U.jsx)("button",Object.assign({className:"stylist-virtual-try-on__close-btn",onClick:I,"aria-label":"Close"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"24",height:"24"},{children:(0,U.jsx)("path",{d:"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"})}))}))]})),(0,U.jsxs)("div",Object.assign({className:"stylist-virtual-try-on__content"},{children:[b?(0,U.jsx)(yn,{onUpload:e=>IG(void 0,void 0,void 0,(function*(){yield u(e),v(!1)})),title:"Upload or Take a Photo",description:"Upload a photo or use your webcam to try on clothes"}):(0,U.jsxs)("div",Object.assign({className:"stylist-virtual-try-on__canvas-container"},{children:[(0,U.jsx)(hn,{outfit:r,userImage:s,setCanvasRef:l,onGarmentSelect:y,showBodyGuide:!s}),(null==s?void 0:s.processingStatus)===be.REMOVING_BACKGROUND&&(0,U.jsxs)("div",Object.assign({className:"stylist-virtual-try-on__processing"},{children:[(0,U.jsx)("div",{className:"stylist-virtual-try-on__spinner"}),(0,U.jsx)("p",{children:"Removing background..."})]})),i&&(0,U.jsxs)("div",Object.assign({className:"stylist-virtual-try-on__error"},{children:[(0,U.jsx)("p",{children:i}),(0,U.jsx)("button",Object.assign({className:"stylist-virtual-try-on__retry-btn",onClick:N},{children:"Try Again"}))]}))]})),!b&&s&&(0,U.jsx)(fn,{outfit:r,activeGarmentId:g,onGarmentSelect:y,onGarmentRemove:d,onGarmentUpdate:h,onGarmentAdd:(e,t)=>IG(void 0,void 0,void 0,(function*(){yield c(e,t)})),onChangePhoto:N,disabled:a})]})),k&&(0,U.jsxs)("div",Object.assign({className:"stylist-virtual-try-on__success"},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-virtual-try-on__success-icon"},{children:(0,U.jsx)("svg",Object.assign({xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",width:"24",height:"24"},{children:(0,U.jsx)("path",{d:"M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"})}))})),(0,U.jsx)("p",Object.assign({className:"stylist-virtual-try-on__success-message"},{children:"Saved to your Lookbook!"}))]})),(0,U.jsxs)("div",Object.assign({className:"stylist-virtual-try-on__footer"},{children:[(0,U.jsx)("button",Object.assign({className:"stylist-virtual-try-on__secondary-btn",onClick:I},{children:"Close"})),(0,U.jsx)("button",Object.assign({className:"stylist-virtual-try-on__primary-btn",onClick:()=>IG(void 0,void 0,void 0,(function*(){if(o&&r)try{w(!0);const s=yield f();if(s){if(t&&t(s.resultImageUrl),n){const e={userId:"current_user",outfitId:s.id,name:`Try-On Result ${(new Date).toLocaleDateString()}`,items:r.garments.map((e=>e.id)),savedAt:new Date};n(e)}S(!0),setTimeout((()=>{e?e():m()}),1500)}}catch(e){}finally{w(!1)}})),disabled:a||!s||s.processingStatus!==be.COMPLETED||!(null==r?void 0:r.garments.length)||x||k},{children:x?"Saving...":k?"Saved!":"Save to Lookbook"}))]}))]}))},TG=NG,CG=({onClose:e,onSave:t})=>{const n=Se((e=>e.isTryOnModalOpen)),r=Se((e=>e.closeTryOnModal)),s=j.useCallback((()=>{e?e():r()}),[e,r]);return(0,j.useEffect)((()=>{const e=e=>{"Escape"===e.key&&n&&s()};return document.addEventListener("keydown",e),()=>{document.removeEventListener("keydown",e)}}),[n,s]),(0,j.useEffect)((()=>(document.body.style.overflow=n?"hidden":"",()=>{document.body.style.overflow=""})),[n]),n?(0,U.jsxs)("div",Object.assign({className:"stylist-try-on-modal"},{children:[(0,U.jsx)("div",{className:"stylist-try-on-modal__overlay",onClick:s}),(0,U.jsx)("div",Object.assign({className:"stylist-try-on-modal__container"},{children:(0,U.jsx)(TG,{onClose:s,onSave:t})}))]})):null},EG=CG;var $G=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};class _G{constructor(e){this.client=e}getUserProfile(e){return $G(this,void 0,void 0,(function*(){return this.client.get(`/api/v1/users/${e}`)}))}createUser(e){return $G(this,void 0,void 0,(function*(){return this.client.post("/api/v1/users",{email:e})}))}updatePreferences(e,t){return $G(this,void 0,void 0,(function*(){return this.client.put(`/api/v1/users/${e}/preferences`,t)}))}getStyleQuiz(){return $G(this,void 0,void 0,(function*(){return this.client.get("/api/v1/style-quiz")}))}submitStyleQuiz(e,t){return $G(this,void 0,void 0,(function*(){return this.client.post(`/api/v1/users/${e}/style-quiz`,{answers:t})}))}addClosetItem(e,t){return $G(this,void 0,void 0,(function*(){return this.client.post(`/api/v1/users/${e}/closet`,t)}))}removeClosetItem(e,t){return $G(this,void 0,void 0,(function*(){return this.client.delete(`/api/v1/users/${e}/closet/${t}`)}))}updateClosetItem(e,t,n){return $G(this,void 0,void 0,(function*(){return this.client.put(`/api/v1/users/${e}/closet/${t}`,n)}))}toggleFavoriteItem(e,t,n){return $G(this,void 0,void 0,(function*(){return this.client.put(`/api/v1/users/${e}/closet/${t}/favorite`,{favorite:n})}))}}function OG(e,t){return function(){return e.apply(t,arguments)}}const{toString:RG}=Object.prototype,{getPrototypeOf:AG}=Object,DG=(FG=Object.create(null),e=>{const t=RG.call(e);return FG[t]||(FG[t]=t.slice(8,-1).toLowerCase())});var FG;const MG=e=>(e=e.toLowerCase(),t=>DG(t)===e),LG=e=>t=>typeof t===e,{isArray:zG}=Array,PG=LG("undefined");const BG=MG("ArrayBuffer");const UG=LG("string"),jG=LG("function"),WG=LG("number"),VG=e=>null!==e&&"object"==typeof e,GG=e=>{if("object"!==DG(e))return!1;const t=AG(e);return!(null!==t&&t!==Object.prototype&&null!==Object.getPrototypeOf(t)||Symbol.toStringTag in e||Symbol.iterator in e)},HG=MG("Date"),qG=MG("File"),KG=MG("Blob"),XG=MG("FileList"),YG=MG("URLSearchParams"),[QG,JG,ZG,eH]=["ReadableStream","Request","Response","Headers"].map(MG);function tH(e,t,{allOwnKeys:n=!1}={}){if(null==e)return;let r,s;if("object"!=typeof e&&(e=[e]),zG(e))for(r=0,s=e.length;r<s;r++)t.call(null,e[r],r,e);else{const s=n?Object.getOwnPropertyNames(e):Object.keys(e),a=s.length;let i;for(r=0;r<a;r++)i=s[r],t.call(null,e[i],i,e)}}function nH(e,t){t=t.toLowerCase();const n=Object.keys(e);let r,s=n.length;for(;s-- >0;)if(r=n[s],t===r.toLowerCase())return r;return null}const rH="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:global,sH=e=>!PG(e)&&e!==rH;const aH=(iH="undefined"!=typeof Uint8Array&&AG(Uint8Array),e=>iH&&e instanceof iH);var iH;const oH=MG("HTMLFormElement"),lH=(({hasOwnProperty:e})=>(t,n)=>e.call(t,n))(Object.prototype),uH=MG("RegExp"),cH=(e,t)=>{const n=Object.getOwnPropertyDescriptors(e),r={};tH(n,((n,s)=>{let a;!1!==(a=t(n,s,e))&&(r[s]=a||n)})),Object.defineProperties(e,r)};const dH=MG("AsyncFunction"),hH=(pH="function"==typeof setImmediate,fH=jG(rH.postMessage),pH?setImmediate:fH?((e,t)=>(rH.addEventListener("message",(({source:n,data:r})=>{n===rH&&r===e&&t.length&&t.shift()()}),!1),n=>{t.push(n),rH.postMessage(e,"*")}))(`axios@${Math.random()}`,[]):e=>setTimeout(e));var pH,fH;const mH="undefined"!=typeof queueMicrotask?queueMicrotask.bind(rH):"undefined"!=typeof process&&process.nextTick||hH,gH={isArray:zG,isArrayBuffer:BG,isBuffer:function(e){return null!==e&&!PG(e)&&null!==e.constructor&&!PG(e.constructor)&&jG(e.constructor.isBuffer)&&e.constructor.isBuffer(e)},isFormData:e=>{let t;return e&&("function"==typeof FormData&&e instanceof FormData||jG(e.append)&&("formdata"===(t=DG(e))||"object"===t&&jG(e.toString)&&"[object FormData]"===e.toString()))},isArrayBufferView:function(e){let t;return t="undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&BG(e.buffer),t},isString:UG,isNumber:WG,isBoolean:e=>!0===e||!1===e,isObject:VG,isPlainObject:GG,isReadableStream:QG,isRequest:JG,isResponse:ZG,isHeaders:eH,isUndefined:PG,isDate:HG,isFile:qG,isBlob:KG,isRegExp:uH,isFunction:jG,isStream:e=>VG(e)&&jG(e.pipe),isURLSearchParams:YG,isTypedArray:aH,isFileList:XG,forEach:tH,merge:function e(){const{caseless:t}=sH(this)&&this||{},n={},r=(r,s)=>{const a=t&&nH(n,s)||s;GG(n[a])&&GG(r)?n[a]=e(n[a],r):GG(r)?n[a]=e({},r):zG(r)?n[a]=r.slice():n[a]=r};for(let e=0,t=arguments.length;e<t;e++)arguments[e]&&tH(arguments[e],r);return n},extend:(e,t,n,{allOwnKeys:r}={})=>(tH(t,((t,r)=>{n&&jG(t)?e[r]=OG(t,n):e[r]=t}),{allOwnKeys:r}),e),trim:e=>e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,""),stripBOM:e=>(65279===e.charCodeAt(0)&&(e=e.slice(1)),e),inherits:(e,t,n,r)=>{e.prototype=Object.create(t.prototype,r),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),n&&Object.assign(e.prototype,n)},toFlatObject:(e,t,n,r)=>{let s,a,i;const o={};if(t=t||{},null==e)return t;do{for(s=Object.getOwnPropertyNames(e),a=s.length;a-- >0;)i=s[a],r&&!r(i,e,t)||o[i]||(t[i]=e[i],o[i]=!0);e=!1!==n&&AG(e)}while(e&&(!n||n(e,t))&&e!==Object.prototype);return t},kindOf:DG,kindOfTest:MG,endsWith:(e,t,n)=>{e=String(e),(void 0===n||n>e.length)&&(n=e.length),n-=t.length;const r=e.indexOf(t,n);return-1!==r&&r===n},toArray:e=>{if(!e)return null;if(zG(e))return e;let t=e.length;if(!WG(t))return null;const n=new Array(t);for(;t-- >0;)n[t]=e[t];return n},forEachEntry:(e,t)=>{const n=(e&&e[Symbol.iterator]).call(e);let r;for(;(r=n.next())&&!r.done;){const n=r.value;t.call(e,n[0],n[1])}},matchAll:(e,t)=>{let n;const r=[];for(;null!==(n=e.exec(t));)r.push(n);return r},isHTMLForm:oH,hasOwnProperty:lH,hasOwnProp:lH,reduceDescriptors:cH,freezeMethods:e=>{cH(e,((t,n)=>{if(jG(e)&&-1!==["arguments","caller","callee"].indexOf(n))return!1;const r=e[n];jG(r)&&(t.enumerable=!1,"writable"in t?t.writable=!1:t.set||(t.set=()=>{throw Error("Can not rewrite read-only method '"+n+"'")}))}))},toObjectSet:(e,t)=>{const n={},r=e=>{e.forEach((e=>{n[e]=!0}))};return zG(e)?r(e):r(String(e).split(t)),n},toCamelCase:e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,(function(e,t,n){return t.toUpperCase()+n})),noop:()=>{},toFiniteNumber:(e,t)=>null!=e&&Number.isFinite(e=+e)?e:t,findKey:nH,global:rH,isContextDefined:sH,isSpecCompliantForm:function(e){return!!(e&&jG(e.append)&&"FormData"===e[Symbol.toStringTag]&&e[Symbol.iterator])},toJSONObject:e=>{const t=new Array(10),n=(e,r)=>{if(VG(e)){if(t.indexOf(e)>=0)return;if(!("toJSON"in e)){t[r]=e;const s=zG(e)?[]:{};return tH(e,((e,t)=>{const a=n(e,r+1);!PG(a)&&(s[t]=a)})),t[r]=void 0,s}}return e};return n(e,0)},isAsyncFn:dH,isThenable:e=>e&&(VG(e)||jG(e))&&jG(e.then)&&jG(e.catch),setImmediate:hH,asap:mH};function yH(e,t,n,r,s){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack,this.message=e,this.name="AxiosError",t&&(this.code=t),n&&(this.config=n),r&&(this.request=r),s&&(this.response=s,this.status=s.status?s.status:null)}gH.inherits(yH,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:gH.toJSONObject(this.config),code:this.code,status:this.status}}});const bH=yH.prototype,vH={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach((e=>{vH[e]={value:e}})),Object.defineProperties(yH,vH),Object.defineProperty(bH,"isAxiosError",{value:!0}),yH.from=(e,t,n,r,s,a)=>{const i=Object.create(bH);return gH.toFlatObject(e,i,(function(e){return e!==Error.prototype}),(e=>"isAxiosError"!==e)),yH.call(i,e.message,t,n,r,s),i.cause=e,i.name=e.name,a&&Object.assign(i,a),i};const xH=yH;function wH(e){return gH.isPlainObject(e)||gH.isArray(e)}function kH(e){return gH.endsWith(e,"[]")?e.slice(0,-2):e}function SH(e,t,n){return e?e.concat(t).map((function(e,t){return e=kH(e),!n&&t?"["+e+"]":e})).join(n?".":""):t}const IH=gH.toFlatObject(gH,{},null,(function(e){return/^is[A-Z]/.test(e)}));const NH=function(e,t,n){if(!gH.isObject(e))throw new TypeError("target must be an object");t=t||new FormData;const r=(n=gH.toFlatObject(n,{metaTokens:!0,dots:!1,indexes:!1},!1,(function(e,t){return!gH.isUndefined(t[e])}))).metaTokens,s=n.visitor||u,a=n.dots,i=n.indexes,o=(n.Blob||"undefined"!=typeof Blob&&Blob)&&gH.isSpecCompliantForm(t);if(!gH.isFunction(s))throw new TypeError("visitor must be a function");function l(e){if(null===e)return"";if(gH.isDate(e))return e.toISOString();if(!o&&gH.isBlob(e))throw new xH("Blob is not supported. Use a Buffer instead.");return gH.isArrayBuffer(e)||gH.isTypedArray(e)?o&&"function"==typeof Blob?new Blob([e]):Buffer.from(e):e}function u(e,n,s){let o=e;if(e&&!s&&"object"==typeof e)if(gH.endsWith(n,"{}"))n=r?n:n.slice(0,-2),e=JSON.stringify(e);else if(gH.isArray(e)&&function(e){return gH.isArray(e)&&!e.some(wH)}(e)||(gH.isFileList(e)||gH.endsWith(n,"[]"))&&(o=gH.toArray(e)))return n=kH(n),o.forEach((function(e,r){!gH.isUndefined(e)&&null!==e&&t.append(!0===i?SH([n],r,a):null===i?n:n+"[]",l(e))})),!1;return!!wH(e)||(t.append(SH(s,n,a),l(e)),!1)}const c=[],d=Object.assign(IH,{defaultVisitor:u,convertValue:l,isVisitable:wH});if(!gH.isObject(e))throw new TypeError("data must be an object");return function e(n,r){if(!gH.isUndefined(n)){if(-1!==c.indexOf(n))throw Error("Circular reference detected in "+r.join("."));c.push(n),gH.forEach(n,(function(n,a){!0===(!(gH.isUndefined(n)||null===n)&&s.call(t,n,gH.isString(a)?a.trim():a,r,d))&&e(n,r?r.concat(a):[a])})),c.pop()}}(e),t};function TH(e){const t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,(function(e){return t[e]}))}function CH(e,t){this._pairs=[],e&&NH(e,this,t)}const EH=CH.prototype;EH.append=function(e,t){this._pairs.push([e,t])},EH.toString=function(e){const t=e?function(t){return e.call(this,t,TH)}:TH;return this._pairs.map((function(e){return t(e[0])+"="+t(e[1])}),"").join("&")};const $H=CH;function _H(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function OH(e,t,n){if(!t)return e;const r=n&&n.encode||_H;gH.isFunction(n)&&(n={serialize:n});const s=n&&n.serialize;let a;if(a=s?s(t,n):gH.isURLSearchParams(t)?t.toString():new $H(t,n).toString(r),a){const t=e.indexOf("#");-1!==t&&(e=e.slice(0,t)),e+=(-1===e.indexOf("?")?"?":"&")+a}return e}const RH=class{constructor(){this.handlers=[]}use(e,t,n){return this.handlers.push({fulfilled:e,rejected:t,synchronous:!!n&&n.synchronous,runWhen:n?n.runWhen:null}),this.handlers.length-1}eject(e){this.handlers[e]&&(this.handlers[e]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(e){gH.forEach(this.handlers,(function(t){null!==t&&e(t)}))}},AH={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},DH={isBrowser:!0,classes:{URLSearchParams:"undefined"!=typeof URLSearchParams?URLSearchParams:$H,FormData:"undefined"!=typeof FormData?FormData:null,Blob:"undefined"!=typeof Blob?Blob:null},protocols:["http","https","file","blob","url","data"]},FH="undefined"!=typeof window&&"undefined"!=typeof document,MH="object"==typeof navigator&&navigator||void 0,LH=FH&&(!MH||["ReactNative","NativeScript","NS"].indexOf(MH.product)<0),zH="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&"function"==typeof self.importScripts,PH=FH&&window.location.href||"http://localhost",BH={...B,...DH};const UH=function(e){function t(e,n,r,s){let a=e[s++];if("__proto__"===a)return!0;const i=Number.isFinite(+a),o=s>=e.length;if(a=!a&&gH.isArray(r)?r.length:a,o)return gH.hasOwnProp(r,a)?r[a]=[r[a],n]:r[a]=n,!i;r[a]&&gH.isObject(r[a])||(r[a]=[]);return t(e,n,r[a],s)&&gH.isArray(r[a])&&(r[a]=function(e){const t={},n=Object.keys(e);let r;const s=n.length;let a;for(r=0;r<s;r++)a=n[r],t[a]=e[a];return t}(r[a])),!i}if(gH.isFormData(e)&&gH.isFunction(e.entries)){const n={};return gH.forEachEntry(e,((e,r)=>{t(function(e){return gH.matchAll(/\w+|\[(\w*)]/g,e).map((e=>"[]"===e[0]?"":e[1]||e[0]))}(e),r,n,0)})),n}return null};const jH={transitional:AH,adapter:["xhr","http","fetch"],transformRequest:[function(e,t){const n=t.getContentType()||"",r=n.indexOf("application/json")>-1,s=gH.isObject(e);s&&gH.isHTMLForm(e)&&(e=new FormData(e));if(gH.isFormData(e))return r?JSON.stringify(UH(e)):e;if(gH.isArrayBuffer(e)||gH.isBuffer(e)||gH.isStream(e)||gH.isFile(e)||gH.isBlob(e)||gH.isReadableStream(e))return e;if(gH.isArrayBufferView(e))return e.buffer;if(gH.isURLSearchParams(e))return t.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();let a;if(s){if(n.indexOf("application/x-www-form-urlencoded")>-1)return function(e,t){return NH(e,new BH.classes.URLSearchParams,Object.assign({visitor:function(e,t,n,r){return BH.isNode&&gH.isBuffer(e)?(this.append(t,e.toString("base64")),!1):r.defaultVisitor.apply(this,arguments)}},t))}(e,this.formSerializer).toString();if((a=gH.isFileList(e))||n.indexOf("multipart/form-data")>-1){const t=this.env&&this.env.FormData;return NH(a?{"files[]":e}:e,t&&new t,this.formSerializer)}}return s||r?(t.setContentType("application/json",!1),function(e,t,n){if(gH.isString(e))try{return(t||JSON.parse)(e),gH.trim(e)}catch(e){if("SyntaxError"!==e.name)throw e}return(n||JSON.stringify)(e)}(e)):e}],transformResponse:[function(e){const t=this.transitional||jH.transitional,n=t&&t.forcedJSONParsing,r="json"===this.responseType;if(gH.isResponse(e)||gH.isReadableStream(e))return e;if(e&&gH.isString(e)&&(n&&!this.responseType||r)){const n=!(t&&t.silentJSONParsing)&&r;try{return JSON.parse(e)}catch(e){if(n){if("SyntaxError"===e.name)throw xH.from(e,xH.ERR_BAD_RESPONSE,this,null,this.response);throw e}}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:BH.classes.FormData,Blob:BH.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};gH.forEach(["delete","get","head","post","put","patch"],(e=>{jH.headers[e]={}}));const WH=jH,VH=gH.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),GH=Symbol("internals");function HH(e){return e&&String(e).trim().toLowerCase()}function qH(e){return!1===e||null==e?e:gH.isArray(e)?e.map(qH):String(e)}function KH(e,t,n,r,s){return gH.isFunction(r)?r.call(this,t,n):(s&&(t=n),gH.isString(t)?gH.isString(r)?-1!==t.indexOf(r):gH.isRegExp(r)?r.test(t):void 0:void 0)}class XH{constructor(e){e&&this.set(e)}set(e,t,n){const r=this;function s(e,t,n){const s=HH(t);if(!s)throw new Error("header name must be a non-empty string");const a=gH.findKey(r,s);(!a||void 0===r[a]||!0===n||void 0===n&&!1!==r[a])&&(r[a||t]=qH(e))}const a=(e,t)=>gH.forEach(e,((e,n)=>s(e,n,t)));if(gH.isPlainObject(e)||e instanceof this.constructor)a(e,t);else if(gH.isString(e)&&(e=e.trim())&&!/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()))a((e=>{const t={};let n,r,s;return e&&e.split("\n").forEach((function(e){s=e.indexOf(":"),n=e.substring(0,s).trim().toLowerCase(),r=e.substring(s+1).trim(),!n||t[n]&&VH[n]||("set-cookie"===n?t[n]?t[n].push(r):t[n]=[r]:t[n]=t[n]?t[n]+", "+r:r)})),t})(e),t);else if(gH.isHeaders(e))for(const[t,r]of e.entries())s(r,t,n);else null!=e&&s(t,e,n);return this}get(e,t){if(e=HH(e)){const n=gH.findKey(this,e);if(n){const e=this[n];if(!t)return e;if(!0===t)return function(e){const t=Object.create(null),n=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let r;for(;r=n.exec(e);)t[r[1]]=r[2];return t}(e);if(gH.isFunction(t))return t.call(this,e,n);if(gH.isRegExp(t))return t.exec(e);throw new TypeError("parser must be boolean|regexp|function")}}}has(e,t){if(e=HH(e)){const n=gH.findKey(this,e);return!(!n||void 0===this[n]||t&&!KH(0,this[n],n,t))}return!1}delete(e,t){const n=this;let r=!1;function s(e){if(e=HH(e)){const s=gH.findKey(n,e);!s||t&&!KH(0,n[s],s,t)||(delete n[s],r=!0)}}return gH.isArray(e)?e.forEach(s):s(e),r}clear(e){const t=Object.keys(this);let n=t.length,r=!1;for(;n--;){const s=t[n];e&&!KH(0,this[s],s,e,!0)||(delete this[s],r=!0)}return r}normalize(e){const t=this,n={};return gH.forEach(this,((r,s)=>{const a=gH.findKey(n,s);if(a)return t[a]=qH(r),void delete t[s];const i=e?function(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,((e,t,n)=>t.toUpperCase()+n))}(s):String(s).trim();i!==s&&delete t[s],t[i]=qH(r),n[i]=!0})),this}concat(...e){return this.constructor.concat(this,...e)}toJSON(e){const t=Object.create(null);return gH.forEach(this,((n,r)=>{null!=n&&!1!==n&&(t[r]=e&&gH.isArray(n)?n.join(", "):n)})),t}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map((([e,t])=>e+": "+t)).join("\n")}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(e){return e instanceof this?e:new this(e)}static concat(e,...t){const n=new this(e);return t.forEach((e=>n.set(e))),n}static accessor(e){const t=(this[GH]=this[GH]={accessors:{}}).accessors,n=this.prototype;function r(e){const r=HH(e);t[r]||(!function(e,t){const n=gH.toCamelCase(" "+t);["get","set","has"].forEach((r=>{Object.defineProperty(e,r+n,{value:function(e,n,s){return this[r].call(this,t,e,n,s)},configurable:!0})}))}(n,e),t[r]=!0)}return gH.isArray(e)?e.forEach(r):r(e),this}}XH.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]),gH.reduceDescriptors(XH.prototype,(({value:e},t)=>{let n=t[0].toUpperCase()+t.slice(1);return{get:()=>e,set(e){this[n]=e}}})),gH.freezeMethods(XH);const YH=XH;function QH(e,t){const n=this||WH,r=t||n,s=YH.from(r.headers);let a=r.data;return gH.forEach(e,(function(e){a=e.call(n,a,s.normalize(),t?t.status:void 0)})),s.normalize(),a}function JH(e){return!(!e||!e.__CANCEL__)}function ZH(e,t,n){xH.call(this,null==e?"canceled":e,xH.ERR_CANCELED,t,n),this.name="CanceledError"}gH.inherits(ZH,xH,{__CANCEL__:!0});const eq=ZH;function tq(e,t,n){const r=n.config.validateStatus;n.status&&r&&!r(n.status)?t(new xH("Request failed with status code "+n.status,[xH.ERR_BAD_REQUEST,xH.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n)):e(n)}const nq=function(e,t){e=e||10;const n=new Array(e),r=new Array(e);let s,a=0,i=0;return t=void 0!==t?t:1e3,function(o){const l=Date.now(),u=r[i];s||(s=l),n[a]=o,r[a]=l;let c=i,d=0;for(;c!==a;)d+=n[c++],c%=e;if(a=(a+1)%e,a===i&&(i=(i+1)%e),l-s<t)return;const h=u&&l-u;return h?Math.round(1e3*d/h):void 0}};const rq=function(e,t){let n,r,s=0,a=1e3/t;const i=(t,a=Date.now())=>{s=a,n=null,r&&(clearTimeout(r),r=null),e.apply(null,t)};return[(...e)=>{const t=Date.now(),o=t-s;o>=a?i(e,t):(n=e,r||(r=setTimeout((()=>{r=null,i(n)}),a-o)))},()=>n&&i(n)]},sq=(e,t,n=3)=>{let r=0;const s=nq(50,250);return rq((n=>{const a=n.loaded,i=n.lengthComputable?n.total:void 0,o=a-r,l=s(o);r=a;e({loaded:a,total:i,progress:i?a/i:void 0,bytes:o,rate:l||void 0,estimated:l&&i&&a<=i?(i-a)/l:void 0,event:n,lengthComputable:null!=i,[t?"download":"upload"]:!0})}),n)},aq=(e,t)=>{const n=null!=e;return[r=>t[0]({lengthComputable:n,total:e,loaded:r}),t[1]]},iq=e=>(...t)=>gH.asap((()=>e(...t))),oq=BH.hasStandardBrowserEnv?((e,t)=>n=>(n=new URL(n,BH.origin),e.protocol===n.protocol&&e.host===n.host&&(t||e.port===n.port)))(new URL(BH.origin),BH.navigator&&/(msie|trident)/i.test(BH.navigator.userAgent)):()=>!0,lq=BH.hasStandardBrowserEnv?{write(e,t,n,r,s,a){const i=[e+"="+encodeURIComponent(t)];gH.isNumber(n)&&i.push("expires="+new Date(n).toGMTString()),gH.isString(r)&&i.push("path="+r),gH.isString(s)&&i.push("domain="+s),!0===a&&i.push("secure"),document.cookie=i.join("; ")},read(e){const t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove(e){this.write(e,"",Date.now()-864e5)}}:{write(){},read:()=>null,remove(){}};function uq(e,t,n){let r=!/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);return e&&(r||0==n)?function(e,t){return t?e.replace(/\/?\/$/,"")+"/"+t.replace(/^\/+/,""):e}(e,t):t}const cq=e=>e instanceof YH?{...e}:e;function dq(e,t){t=t||{};const n={};function r(e,t,n,r){return gH.isPlainObject(e)&&gH.isPlainObject(t)?gH.merge.call({caseless:r},e,t):gH.isPlainObject(t)?gH.merge({},t):gH.isArray(t)?t.slice():t}function s(e,t,n,s){return gH.isUndefined(t)?gH.isUndefined(e)?void 0:r(void 0,e,0,s):r(e,t,0,s)}function a(e,t){if(!gH.isUndefined(t))return r(void 0,t)}function i(e,t){return gH.isUndefined(t)?gH.isUndefined(e)?void 0:r(void 0,e):r(void 0,t)}function o(n,s,a){return a in t?r(n,s):a in e?r(void 0,n):void 0}const l={url:a,method:a,data:a,baseURL:i,transformRequest:i,transformResponse:i,paramsSerializer:i,timeout:i,timeoutMessage:i,withCredentials:i,withXSRFToken:i,adapter:i,responseType:i,xsrfCookieName:i,xsrfHeaderName:i,onUploadProgress:i,onDownloadProgress:i,decompress:i,maxContentLength:i,maxBodyLength:i,beforeRedirect:i,transport:i,httpAgent:i,httpsAgent:i,cancelToken:i,socketPath:i,responseEncoding:i,validateStatus:o,headers:(e,t,n)=>s(cq(e),cq(t),0,!0)};return gH.forEach(Object.keys(Object.assign({},e,t)),(function(r){const a=l[r]||s,i=a(e[r],t[r],r);gH.isUndefined(i)&&a!==o||(n[r]=i)})),n}const hq=e=>{const t=dq({},e);let n,{data:r,withXSRFToken:s,xsrfHeaderName:a,xsrfCookieName:i,headers:o,auth:l}=t;if(t.headers=o=YH.from(o),t.url=OH(uq(t.baseURL,t.url,t.allowAbsoluteUrls),e.params,e.paramsSerializer),l&&o.set("Authorization","Basic "+btoa((l.username||"")+":"+(l.password?unescape(encodeURIComponent(l.password)):""))),gH.isFormData(r))if(BH.hasStandardBrowserEnv||BH.hasStandardBrowserWebWorkerEnv)o.setContentType(void 0);else if(!1!==(n=o.getContentType())){const[e,...t]=n?n.split(";").map((e=>e.trim())).filter(Boolean):[];o.setContentType([e||"multipart/form-data",...t].join("; "))}if(BH.hasStandardBrowserEnv&&(s&&gH.isFunction(s)&&(s=s(t)),s||!1!==s&&oq(t.url))){const e=a&&i&&lq.read(i);e&&o.set(a,e)}return t},pq="undefined"!=typeof XMLHttpRequest&&function(e){return new Promise((function(t,n){const r=hq(e);let s=r.data;const a=YH.from(r.headers).normalize();let i,o,l,u,c,{responseType:d,onUploadProgress:h,onDownloadProgress:p}=r;function f(){u&&u(),c&&c(),r.cancelToken&&r.cancelToken.unsubscribe(i),r.signal&&r.signal.removeEventListener("abort",i)}let m=new XMLHttpRequest;function g(){if(!m)return;const r=YH.from("getAllResponseHeaders"in m&&m.getAllResponseHeaders());tq((function(e){t(e),f()}),(function(e){n(e),f()}),{data:d&&"text"!==d&&"json"!==d?m.response:m.responseText,status:m.status,statusText:m.statusText,headers:r,config:e,request:m}),m=null}m.open(r.method.toUpperCase(),r.url,!0),m.timeout=r.timeout,"onloadend"in m?m.onloadend=g:m.onreadystatechange=function(){m&&4===m.readyState&&(0!==m.status||m.responseURL&&0===m.responseURL.indexOf("file:"))&&setTimeout(g)},m.onabort=function(){m&&(n(new xH("Request aborted",xH.ECONNABORTED,e,m)),m=null)},m.onerror=function(){n(new xH("Network Error",xH.ERR_NETWORK,e,m)),m=null},m.ontimeout=function(){let t=r.timeout?"timeout of "+r.timeout+"ms exceeded":"timeout exceeded";const s=r.transitional||AH;r.timeoutErrorMessage&&(t=r.timeoutErrorMessage),n(new xH(t,s.clarifyTimeoutError?xH.ETIMEDOUT:xH.ECONNABORTED,e,m)),m=null},void 0===s&&a.setContentType(null),"setRequestHeader"in m&&gH.forEach(a.toJSON(),(function(e,t){m.setRequestHeader(t,e)})),gH.isUndefined(r.withCredentials)||(m.withCredentials=!!r.withCredentials),d&&"json"!==d&&(m.responseType=r.responseType),p&&([l,c]=sq(p,!0),m.addEventListener("progress",l)),h&&m.upload&&([o,u]=sq(h),m.upload.addEventListener("progress",o),m.upload.addEventListener("loadend",u)),(r.cancelToken||r.signal)&&(i=t=>{m&&(n(!t||t.type?new eq(null,e,m):t),m.abort(),m=null)},r.cancelToken&&r.cancelToken.subscribe(i),r.signal&&(r.signal.aborted?i():r.signal.addEventListener("abort",i)));const y=function(e){const t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""}(r.url);y&&-1===BH.protocols.indexOf(y)?n(new xH("Unsupported protocol "+y+":",xH.ERR_BAD_REQUEST,e)):m.send(s||null)}))},fq=(e,t)=>{const{length:n}=e=e?e.filter(Boolean):[];if(t||n){let n,r=new AbortController;const s=function(e){if(!n){n=!0,i();const t=e instanceof Error?e:this.reason;r.abort(t instanceof xH?t:new eq(t instanceof Error?t.message:t))}};let a=t&&setTimeout((()=>{a=null,s(new xH(`timeout ${t} of ms exceeded`,xH.ETIMEDOUT))}),t);const i=()=>{e&&(a&&clearTimeout(a),a=null,e.forEach((e=>{e.unsubscribe?e.unsubscribe(s):e.removeEventListener("abort",s)})),e=null)};e.forEach((e=>e.addEventListener("abort",s)));const{signal:o}=r;return o.unsubscribe=()=>gH.asap(i),o}},mq=function*(e,t){let n=e.byteLength;if(!t||n<t)return void(yield e);let r,s=0;for(;s<n;)r=s+t,yield e.slice(s,r),s=r},gq=async function*(e){if(e[Symbol.asyncIterator])return void(yield*e);const t=e.getReader();try{for(;;){const{done:e,value:n}=await t.read();if(e)break;yield n}}finally{await t.cancel()}},yq=(e,t,n,r)=>{const s=async function*(e,t){for await(const n of gq(e))yield*mq(n,t)}(e,t);let a,i=0,o=e=>{a||(a=!0,r&&r(e))};return new ReadableStream({async pull(e){try{const{done:t,value:r}=await s.next();if(t)return o(),void e.close();let a=r.byteLength;if(n){let e=i+=a;n(e)}e.enqueue(new Uint8Array(r))}catch(e){throw o(e),e}},cancel:e=>(o(e),s.return())},{highWaterMark:2})},bq="function"==typeof fetch&&"function"==typeof Request&&"function"==typeof Response,vq=bq&&"function"==typeof ReadableStream,xq=bq&&("function"==typeof TextEncoder?(wq=new TextEncoder,e=>wq.encode(e)):async e=>new Uint8Array(await new Response(e).arrayBuffer()));var wq;const kq=(e,...t)=>{try{return!!e(...t)}catch(e){return!1}},Sq=vq&&kq((()=>{let e=!1;const t=new Request(BH.origin,{body:new ReadableStream,method:"POST",get duplex(){return e=!0,"half"}}).headers.has("Content-Type");return e&&!t})),Iq=vq&&kq((()=>gH.isReadableStream(new Response("").body))),Nq={stream:Iq&&(e=>e.body)};var Tq;bq&&(Tq=new Response,["text","arrayBuffer","blob","formData","stream"].forEach((e=>{!Nq[e]&&(Nq[e]=gH.isFunction(Tq[e])?t=>t[e]():(t,n)=>{throw new xH(`Response type '${e}' is not supported`,xH.ERR_NOT_SUPPORT,n)})})));const Cq=async(e,t)=>{const n=gH.toFiniteNumber(e.getContentLength());return null==n?(async e=>{if(null==e)return 0;if(gH.isBlob(e))return e.size;if(gH.isSpecCompliantForm(e)){const t=new Request(BH.origin,{method:"POST",body:e});return(await t.arrayBuffer()).byteLength}return gH.isArrayBufferView(e)||gH.isArrayBuffer(e)?e.byteLength:(gH.isURLSearchParams(e)&&(e+=""),gH.isString(e)?(await xq(e)).byteLength:void 0)})(t):n},Eq=bq&&(async e=>{let{url:t,method:n,data:r,signal:s,cancelToken:a,timeout:i,onDownloadProgress:o,onUploadProgress:l,responseType:u,headers:c,withCredentials:d="same-origin",fetchOptions:h}=hq(e);u=u?(u+"").toLowerCase():"text";let p,f=fq([s,a&&a.toAbortSignal()],i);const m=f&&f.unsubscribe&&(()=>{f.unsubscribe()});let g;try{if(l&&Sq&&"get"!==n&&"head"!==n&&0!==(g=await Cq(c,r))){let e,n=new Request(t,{method:"POST",body:r,duplex:"half"});if(gH.isFormData(r)&&(e=n.headers.get("content-type"))&&c.setContentType(e),n.body){const[e,t]=aq(g,sq(iq(l)));r=yq(n.body,65536,e,t)}}gH.isString(d)||(d=d?"include":"omit");const s="credentials"in Request.prototype;p=new Request(t,{...h,signal:f,method:n.toUpperCase(),headers:c.normalize().toJSON(),body:r,duplex:"half",credentials:s?d:void 0});let a=await fetch(p);const i=Iq&&("stream"===u||"response"===u);if(Iq&&(o||i&&m)){const e={};["status","statusText","headers"].forEach((t=>{e[t]=a[t]}));const t=gH.toFiniteNumber(a.headers.get("content-length")),[n,r]=o&&aq(t,sq(iq(o),!0))||[];a=new Response(yq(a.body,65536,n,(()=>{r&&r(),m&&m()})),e)}u=u||"text";let y=await Nq[gH.findKey(Nq,u)||"text"](a,e);return!i&&m&&m(),await new Promise(((t,n)=>{tq(t,n,{data:y,headers:YH.from(a.headers),status:a.status,statusText:a.statusText,config:e,request:p})}))}catch(t){if(m&&m(),t&&"TypeError"===t.name&&/fetch/i.test(t.message))throw Object.assign(new xH("Network Error",xH.ERR_NETWORK,e,p),{cause:t.cause||t});throw xH.from(t,t&&t.code,e,p)}}),$q={http:null,xhr:pq,fetch:Eq};gH.forEach($q,((e,t)=>{if(e){try{Object.defineProperty(e,"name",{value:t})}catch(e){}Object.defineProperty(e,"adapterName",{value:t})}}));const _q=e=>`- ${e}`,Oq=e=>gH.isFunction(e)||null===e||!1===e,Rq=e=>{e=gH.isArray(e)?e:[e];const{length:t}=e;let n,r;const s={};for(let a=0;a<t;a++){let t;if(n=e[a],r=n,!Oq(n)&&(r=$q[(t=String(n)).toLowerCase()],void 0===r))throw new xH(`Unknown adapter '${t}'`);if(r)break;s[t||"#"+a]=r}if(!r){const e=Object.entries(s).map((([e,t])=>`adapter ${e} `+(!1===t?"is not supported by the environment":"is not available in the build")));let n=t?e.length>1?"since :\n"+e.map(_q).join("\n"):" "+_q(e[0]):"as no adapter specified";throw new xH("There is no suitable adapter to dispatch the request "+n,"ERR_NOT_SUPPORT")}return r};function Aq(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new eq(null,e)}function Dq(e){Aq(e),e.headers=YH.from(e.headers),e.data=QH.call(e,e.transformRequest),-1!==["post","put","patch"].indexOf(e.method)&&e.headers.setContentType("application/x-www-form-urlencoded",!1);return Rq(e.adapter||WH.adapter)(e).then((function(t){return Aq(e),t.data=QH.call(e,e.transformResponse,t),t.headers=YH.from(t.headers),t}),(function(t){return JH(t)||(Aq(e),t&&t.response&&(t.response.data=QH.call(e,e.transformResponse,t.response),t.response.headers=YH.from(t.response.headers))),Promise.reject(t)}))}const Fq="1.8.4",Mq={};["object","boolean","number","function","string","symbol"].forEach(((e,t)=>{Mq[e]=function(n){return typeof n===e||"a"+(t<1?"n ":" ")+e}}));const Lq={};Mq.transitional=function(e,t,n){return(r,s,a)=>{if(!1===e)throw new xH(function(e,t){return"[Axios v1.8.4] Transitional option '"+e+"'"+t+(n?". "+n:"")}(s," has been removed"+(t?" in "+t:"")),xH.ERR_DEPRECATED);return t&&!Lq[s]&&(Lq[s]=!0),!e||e(r,s,a)}},Mq.spelling=function(e){return(e,t)=>!0};const zq={assertOptions:function(e,t,n){if("object"!=typeof e)throw new xH("options must be an object",xH.ERR_BAD_OPTION_VALUE);const r=Object.keys(e);let s=r.length;for(;s-- >0;){const a=r[s],i=t[a];if(i){const t=e[a],n=void 0===t||i(t,a,e);if(!0!==n)throw new xH("option "+a+" must be "+n,xH.ERR_BAD_OPTION_VALUE)}else if(!0!==n)throw new xH("Unknown option "+a,xH.ERR_BAD_OPTION)}},validators:Mq},Pq=zq.validators;class Bq{constructor(e){this.defaults=e,this.interceptors={request:new RH,response:new RH}}async request(e,t){try{return await this._request(e,t)}catch(e){if(e instanceof Error){let t={};Error.captureStackTrace?Error.captureStackTrace(t):t=new Error;const n=t.stack?t.stack.replace(/^.+\n/,""):"";try{e.stack?n&&!String(e.stack).endsWith(n.replace(/^.+\n.+\n/,""))&&(e.stack+="\n"+n):e.stack=n}catch(e){}}throw e}}_request(e,t){"string"==typeof e?(t=t||{}).url=e:t=e||{},t=dq(this.defaults,t);const{transitional:n,paramsSerializer:r,headers:s}=t;void 0!==n&&zq.assertOptions(n,{silentJSONParsing:Pq.transitional(Pq.boolean),forcedJSONParsing:Pq.transitional(Pq.boolean),clarifyTimeoutError:Pq.transitional(Pq.boolean)},!1),null!=r&&(gH.isFunction(r)?t.paramsSerializer={serialize:r}:zq.assertOptions(r,{encode:Pq.function,serialize:Pq.function},!0)),void 0!==t.allowAbsoluteUrls||(void 0!==this.defaults.allowAbsoluteUrls?t.allowAbsoluteUrls=this.defaults.allowAbsoluteUrls:t.allowAbsoluteUrls=!0),zq.assertOptions(t,{baseUrl:Pq.spelling("baseURL"),withXsrfToken:Pq.spelling("withXSRFToken")},!0),t.method=(t.method||this.defaults.method||"get").toLowerCase();let a=s&&gH.merge(s.common,s[t.method]);s&&gH.forEach(["delete","get","head","post","put","patch","common"],(e=>{delete s[e]})),t.headers=YH.concat(a,s);const i=[];let o=!0;this.interceptors.request.forEach((function(e){"function"==typeof e.runWhen&&!1===e.runWhen(t)||(o=o&&e.synchronous,i.unshift(e.fulfilled,e.rejected))}));const l=[];let u;this.interceptors.response.forEach((function(e){l.push(e.fulfilled,e.rejected)}));let c,d=0;if(!o){const e=[Dq.bind(this),void 0];for(e.unshift.apply(e,i),e.push.apply(e,l),c=e.length,u=Promise.resolve(t);d<c;)u=u.then(e[d++],e[d++]);return u}c=i.length;let h=t;for(d=0;d<c;){const e=i[d++],t=i[d++];try{h=e(h)}catch(e){t.call(this,e);break}}try{u=Dq.call(this,h)}catch(e){return Promise.reject(e)}for(d=0,c=l.length;d<c;)u=u.then(l[d++],l[d++]);return u}getUri(e){return OH(uq((e=dq(this.defaults,e)).baseURL,e.url,e.allowAbsoluteUrls),e.params,e.paramsSerializer)}}gH.forEach(["delete","get","head","options"],(function(e){Bq.prototype[e]=function(t,n){return this.request(dq(n||{},{method:e,url:t,data:(n||{}).data}))}})),gH.forEach(["post","put","patch"],(function(e){function t(t){return function(n,r,s){return this.request(dq(s||{},{method:e,headers:t?{"Content-Type":"multipart/form-data"}:{},url:n,data:r}))}}Bq.prototype[e]=t(),Bq.prototype[e+"Form"]=t(!0)}));const Uq=Bq;class jq{constructor(e){if("function"!=typeof e)throw new TypeError("executor must be a function.");let t;this.promise=new Promise((function(e){t=e}));const n=this;this.promise.then((e=>{if(!n._listeners)return;let t=n._listeners.length;for(;t-- >0;)n._listeners[t](e);n._listeners=null})),this.promise.then=e=>{let t;const r=new Promise((e=>{n.subscribe(e),t=e})).then(e);return r.cancel=function(){n.unsubscribe(t)},r},e((function(e,r,s){n.reason||(n.reason=new eq(e,r,s),t(n.reason))}))}throwIfRequested(){if(this.reason)throw this.reason}subscribe(e){this.reason?e(this.reason):this._listeners?this._listeners.push(e):this._listeners=[e]}unsubscribe(e){if(!this._listeners)return;const t=this._listeners.indexOf(e);-1!==t&&this._listeners.splice(t,1)}toAbortSignal(){const e=new AbortController,t=t=>{e.abort(t)};return this.subscribe(t),e.signal.unsubscribe=()=>this.unsubscribe(t),e.signal}static source(){let e;return{token:new jq((function(t){e=t})),cancel:e}}}const Wq=jq;const Vq={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(Vq).forEach((([e,t])=>{Vq[t]=e}));const Gq=Vq;const Hq=function e(t){const n=new Uq(t),r=OG(Uq.prototype.request,n);return gH.extend(r,Uq.prototype,n,{allOwnKeys:!0}),gH.extend(r,n,null,{allOwnKeys:!0}),r.create=function(n){return e(dq(t,n))},r}(WH);Hq.Axios=Uq,Hq.CanceledError=eq,Hq.CancelToken=Wq,Hq.isCancel=JH,Hq.VERSION=Fq,Hq.toFormData=NH,Hq.AxiosError=xH,Hq.Cancel=Hq.CanceledError,Hq.all=function(e){return Promise.all(e)},Hq.spread=function(e){return function(t){return e.apply(null,t)}},Hq.isAxiosError=function(e){return gH.isObject(e)&&!0===e.isAxiosError},Hq.mergeConfig=dq,Hq.AxiosHeaders=YH,Hq.formToJSON=e=>UH(gH.isHTMLForm(e)?new FormData(e):e),Hq.getAdapter=Rq,Hq.HttpStatusCode=Gq,Hq.default=Hq;const qq=Hq;var Kq=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};class Xq{constructor(e){this.maxRetries=e.maxRetries||3,this.getAuthHeader=e.getAuthHeader;const t={baseURL:e.baseURL,timeout:e.timeout||15e3},n={"Content-Type":"application/json",Accept:"application/json"};e.apiKey&&(n["X-API-Key"]=e.apiKey),e.headers&&Object.assign(n,e.headers),this.client=qq.create(Object.assign(Object.assign({},t),{headers:n})),this.client.interceptors.request.use((e=>{const t=Object.assign({},e);return t.headers&&"X-API-Key"in t.headers&&(t.headers=Object.assign(Object.assign({},t.headers),{"X-API-Key":"[REDACTED]"})),e}),(e=>Promise.reject(e))),this.client.interceptors.response.use((e=>e),(e=>Promise.reject(e)))}get(e,t){return Kq(this,void 0,void 0,(function*(){return this.requestWithRetry("get",e,void 0,t)}))}post(e,t,n){return Kq(this,void 0,void 0,(function*(){return this.requestWithRetry("post",e,t,n)}))}put(e,t,n){return Kq(this,void 0,void 0,(function*(){return this.requestWithRetry("put",e,t,n)}))}delete(e,t){return Kq(this,void 0,void 0,(function*(){return this.requestWithRetry("delete",e,void 0,t)}))}requestWithRetry(e,t,n,r){return Kq(this,void 0,void 0,(function*(){let s=0,a=null,i=Object.assign({},r);for(this.getAuthHeader&&(i.headers=Object.assign(Object.assign({},i.headers),this.getAuthHeader()));s<=this.maxRetries;)try{let r;switch(e){case"get":r=yield this.client.get(t,i);break;case"post":r=yield this.client.post(t,n,i);break;case"put":r=yield this.client.put(t,n,i);break;case"delete":r=yield this.client.delete(t,i)}return r.data}catch(e){if(a=e,!(this.isRetryableError(e)&&s<this.maxRetries))break;{s++;const e=1e3*Math.pow(2,s);yield new Promise((t=>setTimeout(t,e)))}}throw this.handleError(a),a}))}isRetryableError(e){return!e.response||e.response&&e.response.status>=500}handleError(e){if(e.response){const t=e.response.status;if(401===t)throw new Error("Unauthorized: Please check your API key or log in again");if(403===t)throw new Error("Forbidden: You do not have permission to access this resource");if(404===t)throw new Error("Resource not found");if(t>=500)throw new Error("Server error, please try again later");{const t=e.response.data||{};throw new Error(`API Error: ${t.message||e.message}`)}}throw e.request?new Error("No response received from server. Please check your connection"):new Error(`Request setup error: ${e.message}`)}}var Yq=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const Qq="stylist_last_sync",Jq="stylist_sync_queue";var Zq;!function(e){e.ADD_CLOSET_ITEM="ADD_CLOSET_ITEM",e.REMOVE_CLOSET_ITEM="REMOVE_CLOSET_ITEM",e.UPDATE_CLOSET_ITEM="UPDATE_CLOSET_ITEM",e.TOGGLE_FAVORITE="TOGGLE_FAVORITE",e.UPDATE_PREFERENCES="UPDATE_PREFERENCES",e.SUBMIT_QUIZ="SUBMIT_QUIZ",e.ADD_LIKED_ITEM="ADD_LIKED_ITEM",e.ADD_DISLIKED_ITEM="ADD_DISLIKED_ITEM",e.REMOVE_LIKED_ITEM="REMOVE_LIKED_ITEM",e.REMOVE_DISLIKED_ITEM="REMOVE_DISLIKED_ITEM",e.SAVE_OUTFIT="SAVE_OUTFIT",e.REMOVE_OUTFIT="REMOVE_OUTFIT"}(Zq||(Zq={}));const eK=()=>{const[e,t]=(0,j.useState)({isOnline:navigator.onLine,isSyncing:!1,lastSyncTimestamp:Number(localStorage.getItem(Qq))||null,pendingOperations:0,syncQueue:[]}),n=me(),r=(Ne(),(0,j.useRef)(null)),s=(0,j.useRef)((()=>{const e=new Xq({baseURL:process.env.REACT_APP_API_URL||"http://localhost:8000",timeout:1e4,maxRetries:3,getAuthHeader:()=>{const e=localStorage.getItem("stylist_auth_token");return e?{Authorization:`Bearer ${e}`}:{Authorization:""}}});return new _G(e)})()),a=(0,j.useCallback)((()=>{const e=localStorage.getItem(Jq);if(!e)return[];try{return JSON.parse(e)}catch(e){return[]}}),[]),i=(0,j.useCallback)((e=>{try{localStorage.setItem(Jq,JSON.stringify(e))}catch(e){}}),[]);(0,j.useEffect)((()=>{const e=a();t((t=>Object.assign(Object.assign({},t),{syncQueue:e,pendingOperations:e.filter((e=>!e.resolved)).length})))}),[a]),(0,j.useEffect)((()=>{const e=()=>{t((e=>Object.assign(Object.assign({},e),{isOnline:!0}))),d()},n=()=>{t((e=>Object.assign(Object.assign({},e),{isOnline:!1})))};return window.addEventListener("online",e),window.addEventListener("offline",n),()=>{window.removeEventListener("online",e),window.removeEventListener("offline",n)}}),[]);const o=(0,j.useCallback)(((e,n,r)=>{const s={id:`sync_${Date.now()}_${Math.random().toString(36).substring(2,9)}`,timestamp:Date.now(),userId:r,operation:e,data:n,retryCount:0,resolved:!1};t((e=>{const t=[...e.syncQueue,s];return i(t),Object.assign(Object.assign({},e),{syncQueue:t,pendingOperations:t.filter((e=>!e.resolved)).length})})),navigator.onLine&&d()}),[i]),l=(0,j.useCallback)((e=>Yq(void 0,void 0,void 0,(function*(){const{operation:t,data:n,userId:r}=e;try{switch(t){case Zq.ADD_CLOSET_ITEM:yield s.current.addClosetItem(r,n);break;case Zq.REMOVE_CLOSET_ITEM:yield s.current.removeClosetItem(r,n.itemId);break;case Zq.UPDATE_CLOSET_ITEM:yield s.current.updateClosetItem(r,n.itemId,n.updates);break;case Zq.TOGGLE_FAVORITE:yield s.current.toggleFavoriteItem(r,n.itemId,n.favorite);break;case Zq.UPDATE_PREFERENCES:yield s.current.updatePreferences(r,n);break;case Zq.SUBMIT_QUIZ:yield s.current.submitStyleQuiz(r,n);break;case Zq.SAVE_OUTFIT:case Zq.REMOVE_OUTFIT:case Zq.ADD_LIKED_ITEM:case Zq.ADD_DISLIKED_ITEM:case Zq.REMOVE_LIKED_ITEM:case Zq.REMOVE_DISLIKED_ITEM:break;default:return!1}return!0}catch(e){return!1}}))),[]),u=(0,j.useCallback)(((e,t)=>{if(!e||!t)return t||e;const n=new Date(e.lastActive).getTime();let r=new Date(t.lastActive).getTime()>n?Object.assign({},t):Object.assign({},e);const s=new Map;t.closet.forEach((e=>{s.set(e.id,e)})),e.closet.forEach((e=>{const t=s.get(e.id);if(t){new Date(e.dateAdded).getTime()>new Date(t.dateAdded).getTime()&&s.set(e.id,e)}else s.set(e.id,e)})),r.closet=Array.from(s.values());const a=new Set([...t.feedback.likedItems,...e.feedback.likedItems]),i=new Set([...t.feedback.dislikedItems,...e.feedback.dislikedItems]),o=new Set([...t.feedback.viewedItems,...e.feedback.viewedItems]),l=[...t.feedback.savedOutfits];return e.feedback.savedOutfits.forEach((e=>{l.some((t=>t.length===e.length&&t.every((t=>e.includes(t)))))||l.push(e)})),r.feedback=Object.assign(Object.assign({},r.feedback),{likedItems:Array.from(a),dislikedItems:Array.from(i),viewedItems:Array.from(o),savedOutfits:l,lastInteraction:new Date(Math.max(new Date(e.feedback.lastInteraction).getTime(),new Date(t.feedback.lastInteraction).getTime()))}),r}),[]),c=(0,j.useCallback)((e=>Yq(void 0,void 0,void 0,(function*(){if(e)try{const r=yield s.current.getUserProfile(e),a=n.user;if(r&&a){const e=u(a,r);n.setUser(e)}else r&&n.setUser(r);const i=Date.now();localStorage.setItem(Qq,i.toString()),t((e=>Object.assign(Object.assign({},e),{lastSyncTimestamp:i})))}catch(e){}}))),[n,u]),d=(0,j.useCallback)((()=>Yq(void 0,void 0,void 0,(function*(){var r;if(!e.isSyncing&&navigator.onLine&&n.user){t((e=>Object.assign(Object.assign({},e),{isSyncing:!0})));try{const e=a(),s=e.filter((e=>!e.resolved));if(s.length>0){const n=[...e];for(const e of s){if(e.resolved)continue;if(yield l(e)){const t=n.findIndex((t=>t.id===e.id));-1!==t&&(n[t]=Object.assign(Object.assign({},n[t]),{resolved:!0}))}else{const t=n.findIndex((t=>t.id===e.id));if(-1!==t){const e=n[t].retryCount+1,r=e>=5;n[t]=Object.assign(Object.assign({},n[t]),{retryCount:e,resolved:r})}}}i(n),t((e=>Object.assign(Object.assign({},e),{syncQueue:n,pendingOperations:n.filter((e=>!e.resolved)).length})))}yield c((null===(r=n.user)||void 0===r?void 0:r.userId)||"")}catch(e){}finally{t((e=>Object.assign(Object.assign({},e),{isSyncing:!1})))}}}))),[e.isSyncing,n.user,a,l,i,c]);return(0,j.useEffect)((()=>(r.current&&window.clearInterval(r.current),r.current=window.setInterval((()=>{navigator.onLine&&n.user&&d()}),3e4),()=>{r.current&&window.clearInterval(r.current)})),[d,n.user]),{state:e,syncNow:d,addClosetItem:(e,t)=>{o(Zq.ADD_CLOSET_ITEM,e,t)},removeClosetItem:(e,t)=>{o(Zq.REMOVE_CLOSET_ITEM,{itemId:e},t)},updateClosetItem:(e,t,n)=>{o(Zq.UPDATE_CLOSET_ITEM,{itemId:e,updates:t},n)},toggleFavorite:(e,t,n)=>{o(Zq.TOGGLE_FAVORITE,{itemId:e,favorite:t},n)},updatePreferences:(e,t)=>{o(Zq.UPDATE_PREFERENCES,e,t)},submitQuiz:(e,t)=>{o(Zq.SUBMIT_QUIZ,e,t)},saveOutfit:(e,t)=>{o(Zq.SAVE_OUTFIT,e,t)},removeOutfit:(e,t)=>{o(Zq.REMOVE_OUTFIT,{outfitId:e},t)}}},tK=()=>{const e=me(),t=Ne(),n=eK(),r=(0,j.useCallback)((t=>{if(!e.user)return;const r=new Date,s=`item_${r.getTime()}_${Math.random().toString(36).substring(2,9)}`,a=Object.assign(Object.assign({},t),{id:s,dateAdded:r,favorite:t.favorite||!1,tags:t.tags||[]});e.addToCloset(a),n.addClosetItem(t,e.user.userId)}),[e,n]),s=(0,j.useCallback)((t=>{e.user&&(e.removeFromCloset(t),n.removeClosetItem(t,e.user.userId))}),[e,n]),a=(0,j.useCallback)(((t,r)=>{e.user&&(e.toggleItemFavorite(t,r),n.toggleFavorite(t,r,e.user.userId))}),[e,n]),i=(0,j.useCallback)((t=>{e.user&&(e.updateUser({preferences:Object.assign(Object.assign({},e.user.preferences),t)}),n.updatePreferences(t,e.user.userId))}),[e,n]),o=(0,j.useCallback)((t=>{e.user&&n.submitQuiz(t,e.user.userId)}),[e,n]),l=(0,j.useCallback)((t=>{e.user&&e.addLikedItem(t)}),[e]),u=(0,j.useCallback)((t=>{e.user&&e.addDislikedItem(t)}),[e]),c=(0,j.useCallback)((r=>{e.user&&(t.saveOutfit(r),n.saveOutfit(r,e.user.userId))}),[e,t,n]),d=(0,j.useCallback)((r=>{e.user&&(t.removeSavedOutfit(r),n.removeOutfit(r,e.user.userId))}),[e,t,n]);return(0,j.useEffect)((()=>{e.user&&n.syncNow()}),[e.user,n]),{syncState:n.state,syncNow:n.syncNow,addToCloset:r,removeFromCloset:s,toggleItemFavorite:a,updatePreferences:i,submitStyleQuiz:o,addLikedItem:l,addDislikedItem:u,saveOutfit:c,removeSavedOutfit:d}},nK=({onSubmit:e,onClose:t,primaryColor:n})=>{const[r,s]=(0,j.useState)([]),[a,i]=(0,j.useState)(!1),o=me(),l=tK(),u=()=>{if(r.length>0&&r.length<25){const e=Ce();Bt(Lt.STYLE_QUIZ_ABANDON,e,{questionCount:25,answeredCount:r.length,completionRate:Math.round(r.length/25*100)})}t()};return(0,j.useEffect)((()=>{const e=e=>{"Escape"===e.key&&u()};return document.addEventListener("keydown",e),()=>{document.removeEventListener("keydown",e)}}),[t,r]),(0,j.useEffect)((()=>(document.body.style.overflow="hidden",()=>{document.body.style.overflow=""})),[]),(0,U.jsxs)("div",Object.assign({className:"stylist-style-quiz-modal"},{children:[(0,U.jsx)("div",{className:"stylist-style-quiz-modal__overlay",onClick:u}),(0,U.jsxs)("div",Object.assign({className:"stylist-style-quiz-modal__container"},{children:[(0,U.jsx)("button",{className:"stylist-style-quiz-modal__close-button",onClick:u,"aria-label":"Close style quiz"}),(0,U.jsx)(Qt,{quizId:"style-quiz-1",title:"Your Style Profile",description:"Help us understand your fashion preferences to create personalized style recommendations just for you.",onSubmit:t=>{s(t),(25===t.length||a)&&(i(!0),o.user&&l.submitStyleQuiz(t),e(t))},primaryColor:n})]}))]}))},rK=({items:e,outfits:t,savedOutfits:n,tryOnResults:r=[],onItemFeedback:s,onOutfitFeedback:a,onAddToWishlist:i,onAddToCart:o,onSaveOutfit:l,onSaveTryOnResult:u,primaryColor:c})=>{const{addTextMessage:d}=oe(),[h,p]=(0,j.useState)("items"),[f,m]=(0,j.useState)(!1),[g,y]=(0,j.useState)(null),b=[...n],v=r||[],x=e=>{if(l){const n=t.find((t=>t.id===e));n&&(l(n),d("I've saved this outfit to your lookbook! You can access it anytime.","assistant"))}},w=e=>{var t;y(e);let n=ge.TOP;e.category.toLowerCase().includes("dress")?n=ge.DRESS:e.category.toLowerCase().includes("bottom")||e.category.toLowerCase().includes("pant")||e.category.toLowerCase().includes("short")||e.category.toLowerCase().includes("skirt")?n=ge.BOTTOM:e.category.toLowerCase().includes("jacket")||e.category.toLowerCase().includes("coat")?n=ge.OUTERWEAR:e.category.toLowerCase().includes("shoes")?n=ge.SHOES:e.category.toLowerCase().includes("accessory")&&(n=ge.ACCESSORY);const r=(null===(t=e.imageUrls)||void 0===t?void 0:t[0])||"";r&&(((e,t)=>{const{startNewTryOn:n}=Se.getState();n(e,t)})(r,n),(()=>{const{openTryOnModal:e}=Se.getState();e()})())};return(0,U.jsxs)("div",Object.assign({className:"stylist-lookbook"},{children:[(0,U.jsxs)("div",Object.assign({className:"stylist-lookbook__header"},{children:[(0,U.jsx)("h3",Object.assign({className:"stylist-lookbook__title"},{children:"Your Lookbook"})),(0,U.jsxs)("div",Object.assign({className:"stylist-lookbook__tabs"},{children:[(0,U.jsxs)("button",Object.assign({className:"stylist-lookbook__tab "+("items"===h?"stylist-lookbook__tab--active":""),onClick:()=>p("items"),style:"items"===h&&c?{borderBottomColor:c}:void 0},{children:["Items (",e.length,")"]})),(0,U.jsxs)("button",Object.assign({className:"stylist-lookbook__tab "+("outfits"===h?"stylist-lookbook__tab--active":""),onClick:()=>p("outfits"),style:"outfits"===h&&c?{borderBottomColor:c}:void 0},{children:["Outfits (",t.length,")"]})),(0,U.jsxs)("button",Object.assign({className:"stylist-lookbook__tab "+("saved"===h?"stylist-lookbook__tab--active":""),onClick:()=>p("saved"),style:"saved"===h&&c?{borderBottomColor:c}:void 0},{children:["Saved (",b.length,")"]})),(0,U.jsxs)("button",Object.assign({className:"stylist-lookbook__tab "+("try-on"===h?"stylist-lookbook__tab--active":""),onClick:()=>p("try-on"),style:"try-on"===h&&c?{borderBottomColor:c}:void 0},{children:["Try-On (",v.length,")"]}))]}))]})),(0,U.jsx)("div",Object.assign({className:"stylist-lookbook__content"},{children:(()=>{switch(h){case"items":return(0,U.jsx)("div",Object.assign({className:"stylist-lookbook__items"},{children:e.length>0?e.map((e=>(0,U.jsx)(Ht,{item:e,onFeedback:s,onAddToWishlist:()=>i&&i(e),onAddToCart:()=>o&&o(e),showDetails:!0,primaryColor:c,onClick:()=>(e=>{d(`${e.name} by ${e.brand} is a great choice! Would you like to know more about this item or see similar styles?`,"assistant")})(e),onTryOn:()=>w(e)},e.id))):(0,U.jsxs)("div",Object.assign({className:"stylist-lookbook__empty"},{children:[(0,U.jsx)("p",{children:"No recommended items yet."}),(0,U.jsx)("p",{children:"Ask me for recommendations to see items here!"})]}))}));case"outfits":return(0,U.jsx)("div",Object.assign({className:"stylist-lookbook__outfits"},{children:t.length>0?t.map((e=>{const t={id:e.id,name:e.name||"",occasion:e.occasion,matchScore:e.matchScore,matchReasons:e.matchReasons,items:e.items.map((e=>({id:e.id,name:e.name,brand:e.brand,category:e.category,price:e.price,salePrice:e.salePrice,imageUrl:e.imageUrls[0]||"",url:e.url,matchScore:e.matchScore,matchReasons:e.matchReasons})))};return(0,U.jsx)(Kt,{outfit:t,onFeedback:a,onSaveOutfit:x,primaryColor:c},e.id)})):(0,U.jsxs)("div",Object.assign({className:"stylist-lookbook__empty"},{children:[(0,U.jsx)("p",{children:"No outfit recommendations yet."}),(0,U.jsx)("p",{children:"Ask me to create outfits for you!"})]}))}));case"saved":return(0,U.jsx)("div",Object.assign({className:"stylist-lookbook__saved"},{children:b.length>0?(0,U.jsx)("div",Object.assign({className:"stylist-lookbook__saved-items"},{children:b.map((e=>(0,U.jsxs)("div",Object.assign({className:"stylist-lookbook__saved-item"},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-lookbook__saved-image"},{children:(0,U.jsx)("img",{src:e.imageUrl,alt:e.name})})),(0,U.jsxs)("div",Object.assign({className:"stylist-lookbook__saved-details"},{children:[(0,U.jsx)("h4",{children:e.name}),(0,U.jsx)("p",{children:new Date(e.createdAt).toLocaleDateString()})]}))]}),e.id)))})):(0,U.jsxs)("div",Object.assign({className:"stylist-lookbook__empty"},{children:[(0,U.jsx)("p",{children:"No saved outfits yet."}),(0,U.jsx)("p",{children:"Save outfits you like to access them later!"})]}))}));case"try-on":return(0,U.jsx)("div",Object.assign({className:"stylist-lookbook__try-on"},{children:v.length>0?(0,U.jsx)("div",Object.assign({className:"stylist-lookbook__try-on-items"},{children:v.map((e=>(0,U.jsxs)("div",Object.assign({className:"stylist-lookbook__try-on-item"},{children:[(0,U.jsx)("div",Object.assign({className:"stylist-lookbook__try-on-image"},{children:(0,U.jsx)("img",{src:e.imageUrl,alt:e.name})})),(0,U.jsxs)("div",Object.assign({className:"stylist-lookbook__try-on-details"},{children:[(0,U.jsx)("h4",{children:e.name}),(0,U.jsx)("p",{children:new Date(e.createdAt).toLocaleDateString()})]}))]}),e.id)))})):(0,U.jsxs)("div",Object.assign({className:"stylist-lookbook__empty"},{children:[(0,U.jsx)("p",{children:"No try-on results yet."}),(0,U.jsx)("p",{children:"Use the try-on feature on items to see them here!"})]}))}));default:return null}})()})),(0,U.jsx)(EG,{onSave:e=>{if(u&&g){const t={id:`tryon-${Date.now()}`,imageUrl:e,name:`Try-on: ${g.name}`};u(t),p("try-on"),y(null)}}})]}))};var sK=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const aK={items:[{id:"mock1",name:"Classic White T-Shirt",brand:"Essentials",category:"Tops",price:24.99,retailerId:"demo_retailer",colors:["white"],sizes:["S","M","L","XL"],imageUrls:["https://via.placeholder.com/300?text=White+T-Shirt"],url:"#",matchScore:.95,matchReasons:["Versatile staple","Matches your style profile"],inStock:!0},{id:"mock2",name:"Slim Fit Jeans",brand:"DenimCo",category:"Bottoms",price:59.99,retailerId:"demo_retailer",colors:["blue"],sizes:["28","30","32","34"],imageUrls:["https://via.placeholder.com/300?text=Slim+Jeans"],url:"#",matchScore:.92,matchReasons:["Versatile staple","Complements your wardrobe"],inStock:!0},{id:"mock3",name:"Casual Sneakers",brand:"UrbanStep",category:"Shoes",price:79.99,retailerId:"demo_retailer",colors:["white","black"],sizes:["8","9","10","11"],imageUrls:["https://via.placeholder.com/300?text=Sneakers"],url:"#",matchScore:.89,matchReasons:["Comfortable","Versatile footwear"],inStock:!0},{id:"mock4",name:"Oversized Hoodie",brand:"Comfort+",category:"Tops",price:49.99,retailerId:"demo_retailer",colors:["gray","black","blue"],sizes:["S","M","L","XL"],imageUrls:["https://via.placeholder.com/300?text=Hoodie"],url:"#",matchScore:.87,matchReasons:["Casual comfort","Trending style"],inStock:!0}],outfits:[{id:"outfit1",name:"Casual Weekend Look",occasion:"Casual",matchScore:.93,matchReasons:["Perfect for weekends","Easy to style"],items:[{id:"mock1",name:"Classic White T-Shirt",brand:"Essentials",category:"Tops",price:24.99,retailerId:"demo_retailer",colors:["white"],sizes:["S","M","L","XL"],imageUrls:["https://via.placeholder.com/300?text=White+T-Shirt"],url:"#",matchScore:.95,matchReasons:["Versatile staple"],inStock:!0},{id:"mock2",name:"Slim Fit Jeans",brand:"DenimCo",category:"Bottoms",price:59.99,retailerId:"demo_retailer",colors:["blue"],sizes:["28","30","32","34"],imageUrls:["https://via.placeholder.com/300?text=Slim+Jeans"],url:"#",matchScore:.92,matchReasons:["Versatile staple"],inStock:!0},{id:"mock3",name:"Casual Sneakers",brand:"UrbanStep",category:"Shoes",price:79.99,retailerId:"demo_retailer",colors:["white","black"],sizes:["8","9","10","11"],imageUrls:["https://via.placeholder.com/300?text=Sneakers"],url:"#",matchScore:.89,matchReasons:["Comfortable"],inStock:!0}]}]};class iK{constructor(e){this.apiClient=e}getRecommendations(e){return sK(this,void 0,void 0,(function*(){try{return yield this.apiClient.post("/api/v1/recommendations",e)}catch(e){return aK}}))}getOutfitRecommendations(e,t,n){return sK(this,void 0,void 0,(function*(){try{const r={};return t&&(r.occasion=t),n&&(r.limit=n.toString()),yield this.apiClient.get(`/api/v1/users/${e}/outfits/recommendations`,{params:r})}catch(e){return aK.outfits}}))}addItemFeedback(e){return sK(this,void 0,void 0,(function*(){try{return yield this.apiClient.post(`/api/v1/users/${e.userId}/feedback/items/${e.itemId}`,{liked:e.liked,context:e.context})}catch(e){}}))}addOutfitFeedback(e){return sK(this,void 0,void 0,(function*(){try{return yield this.apiClient.post(`/api/v1/users/${e.userId}/feedback/outfits/${e.outfitId}`,{liked:e.liked,context:e.context})}catch(e){}}))}saveOutfit(e){return sK(this,void 0,void 0,(function*(){return this.apiClient.post(`/api/v1/users/${e.userId}/outfits`,{outfitId:e.outfitId,items:e.items,name:e.name,notes:e.notes})}))}getSavedOutfits(e){return sK(this,void 0,void 0,(function*(){return this.apiClient.get(`/api/v1/users/${e}/outfits`)}))}deleteSavedOutfit(e,t){return sK(this,void 0,void 0,(function*(){return this.apiClient.delete(`/api/v1/users/${e}/outfits/${t}`)}))}getSimilarItems(e){return sK(this,void 0,void 0,(function*(){return this.apiClient.post("/api/v1/similar-items",e)}))}completeOutfit(e){return sK(this,void 0,void 0,(function*(){return this.apiClient.post("/api/v1/complete-outfit",e)}))}logItemView(e,t){return sK(this,void 0,void 0,(function*(){return this.apiClient.post(`/api/v1/users/${e}/view-item/${t}`,{})}))}}var oK=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};class lK{constructor(e){this.apiClient=e}syncFeedback(e){return oK(this,void 0,void 0,(function*(){try{return yield this.apiClient.post(`/api/v1/users/${e.userId}/feedback/sync`,{feedbackItems:e.feedbackItems})}catch(e){return{syncedItemIds:[],success:!1,message:e instanceof Error?e.message:"Unknown error"}}}))}}const uK=e=>{const t=(e=>new Xq(e))({baseURL:e.apiUrl||"http://localhost:8000/api",apiKey:e.apiKey,timeout:e.timeout||15e3,headers:{"X-Retailer-ID":e.retailerId}});return{user:new _G(t),recommendation:new iK(t),feedback:new lK(t)}};var cK=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};class dK{constructor(e,t){this.conversationContext=[],this.recommendationApi=e,this.userId=t,this.claudeConfig={apiKey:process.env.ANTHROPIC_API_KEY,baseUrl:process.env.CLAUDE_API_URL||"https://api.anthropic.com/v1",modelName:process.env.CLAUDE_MODEL||"claude-3-haiku-20240307",fallbackMode:!process.env.ANTHROPIC_API_KEY},this.conversationContext=[`You are an AI style assistant for a fashion recommendation platform called "The Stylist". \n      The current date is ${(new Date).toLocaleDateString()}.\n      You help users discover clothing items and outfits that match their personal style.\n      Keep responses concise, helpful, and focus on providing personalized fashion advice.\n      When you recommend items, focus on why they would work for the user.\n      If you don't know something specific about fashion, you can suggest general style principles.`]}processMessage(e){return cK(this,void 0,void 0,(function*(){((e,t)=>{Bt(Lt.MESSAGE_SENT,e,{text:t})})(this.userId,e);const t=[];if(!this.claudeConfig.fallbackMode)try{const n=yield this.callClaudeAPI(e);return t.push(this.createTextMessage(n,ie.ASSISTANT)),this.containsRecommendationIntent(n,e)&&(yield this.addRecommendationMessage(t)),t}catch(e){}switch(this.categorizeIntent(e)){case"recommendation":t.push(this.createTextMessage("I found some items that match your style! Here are my recommendations:",ie.ASSISTANT)),yield this.addRecommendationMessage(t,this.extractContext(e));break;case"style_quiz":t.push(this.createTextMessage("Would you like to take our style quiz? It will help me understand your preferences better so I can make more personalized recommendations.",ie.ASSISTANT));break;case"virtual_try_on":t.push(this.createTextMessage('You can try on any clothing item by clicking the "Try On" button on a recommendation. Upload your photo, and see how the item looks on you!',ie.ASSISTANT));break;case"greeting":t.push(this.createTextMessage("Hello! I'm your personal AI style assistant. I can help you discover clothing that matches your unique style. Would you like some personalized recommendations?",ie.ASSISTANT));break;case"help":t.push(this.createTextMessage("I can help you with: \n- Finding clothing recommendations based on your style\n- Creating complete outfits\n- Virtual try-on of garments\n- Style advice and tips\n\nJust let me know what you're looking for!",ie.ASSISTANT));break;default:t.push(this.createTextMessage("I can help you discover fashion items that match your style. Would you like to see some personalized recommendations?",ie.ASSISTANT))}return t}))}callClaudeAPI(e){return cK(this,void 0,void 0,(function*(){try{this.conversationContext.push(e);const t=this.recommendationApi.apiClient?`${this.recommendationApi.apiClient.baseURL||""}/chat`:"/api/chat",n=yield fetch(t,{method:"POST",headers:{"Content-Type":"application/json","X-API-Key":this.recommendationApi.apiClient.apiKey||""},body:JSON.stringify({userId:this.userId,message:e,context:this.conversationContext.slice(-5)})});if(!n.ok)return"I'm having trouble connecting to my backend services. Let me show you some recommendations based on your request.";const r=yield n.json();return this.conversationContext.push(r.response),r.response}catch(e){return"I'm having trouble connecting right now. Let me show you some recommendations instead."}}))}containsRecommendationIntent(e,t){const n=e.toLowerCase(),r=t.toLowerCase(),s=["here are some recommendations","i recommend","would you like to see","i can show you","i'll show you some items","i can recommend"],a=["show me","recommend","what should i wear","find me","can you show","give me ideas","what would look good"];for(const e of s)if(n.includes(e))return!0;for(const e of a)if(r.includes(e))return!0;return!1}addRecommendationMessage(e,t){return cK(this,void 0,void 0,(function*(){try{const n=yield this.recommendationApi.getRecommendations({userId:this.userId,context:t,limit:4});if(n.items.length>0){const t=n.items.map((e=>({id:e.id,name:e.name,brand:e.brand,category:e.category,price:e.price,salePrice:e.salePrice,imageUrl:e.imageUrls[0]||"",url:e.url,matchScore:e.matchScore,matchReasons:e.matchReasons})));e.push(this.createRecommendationMessage(t))}if(n.outfits.length>0){e.push(this.createTextMessage("I also created a complete outfit for you:",ie.ASSISTANT));const t=n.outfits[0],r={id:t.id,name:t.name,occasion:t.occasion,matchScore:t.matchScore,matchReasons:t.matchReasons,items:t.items.map((e=>({id:e.id,name:e.name,brand:e.brand,category:e.category,price:e.price,salePrice:e.salePrice,imageUrl:e.imageUrls[0]||"",url:e.url,matchScore:e.matchScore,matchReasons:e.matchReasons})))};e.push(this.createOutfitMessage(r))}}catch(t){e.push(this.createTextMessage("Sorry, I had trouble getting recommendations. Please try again.",ie.SYSTEM))}}))}categorizeIntent(e){const t=e.toLowerCase();return t.includes("recommend")||t.includes("suggestion")||t.includes("find")||t.includes("show me")?"recommendation":t.includes("quiz")||t.includes("style profile")||t.includes("preferences")?"style_quiz":t.includes("try on")||t.includes("virtual")||t.includes("how does it look")?"virtual_try_on":t.includes("hello")||t.includes("hi")||t.includes("hey")?"greeting":t.includes("help")||t.includes("what can you do")||t.includes("how does this work")?"help":"general"}extractContext(e){const t=e.toLowerCase(),n=["tops","shirts","t-shirts","blouses","bottoms","pants","jeans","shorts","skirts","dresses","gowns","outerwear","jackets","coats","shoes","sneakers","boots","heels","accessories"];for(const e of n)if(t.includes(e))return e;const r=["casual","formal","business","work","party","date","wedding","weekend","vacation","summer","winter","spring","fall"];for(const e of r)if(t.includes(e))return e}createTextMessage(e,t){return{id:se(),type:ae.TEXT,sender:t,text:e,timestamp:new Date}}createRecommendationMessage(e){return{id:se(),type:ae.RECOMMENDATION,sender:ie.ASSISTANT,items:e,timestamp:new Date}}createOutfitMessage(e){return{id:se(),type:ae.OUTFIT,sender:ie.ASSISTANT,outfit:e,timestamp:new Date}}}var hK=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const pK=({apiKey:e,retailerId:t,apiUrl:n,position:r="bottom-right",primaryColor:s="#4361ee",greeting:a="Hi there! I'm your AI style assistant. How can I help you today?"})=>{const[i,o]=(0,j.useState)(!1),[l,u]=(0,j.useState)(null),[c,d]=(0,j.useState)(!1),{messages:h,isOpen:p,isMinimized:f,isLoading:m,currentView:g,addTextMessage:y,addMessage:b,setLoading:v,setError:x,setCurrentView:w}=oe(),{user:k,setUser:S,addLikedItem:I,addDislikedItem:N}=me(),{recommendedItems:T,recommendedOutfits:C,savedOutfits:E,setRecommendedItems:$,setRecommendedOutfits:_,addToWishlist:O,addToCart:R,saveOutfit:A}=Ne(),{addMessageThumbsUp:D}=_e(),F=uK({apiKey:e,retailerId:t,apiUrl:n}),M=(0,j.useCallback)((()=>hK(void 0,void 0,void 0,(function*(){try{v(!0);const e=Ce();let t;try{t=yield F.user.getUserProfile(e)}catch(e){t=yield F.user.createUser()}if(S(t),a&&(y(a,"assistant"),yield new Promise((e=>setTimeout(e,1200))),y("I can help you with:\n Finding clothes that match your style\n Creating complete outfits\n Virtual try-ons\n\nTo get started, would you like to take our quick style quiz or see some recommended items?","assistant")),Bt(Lt.WIDGET_OPEN,t.userId),0===T.length)try{const e=yield F.recommendation.getRecommendations({userId:t.userId,limit:6}),n=e.items.map((e=>({id:e.id,retailerId:"default",name:e.name,brand:e.brand,category:e.category,price:e.price,salePrice:e.salePrice,colors:[],sizes:[],imageUrls:[e.imageUrls[0]||""],url:e.url,matchScore:e.matchScore,matchReasons:e.matchReasons,inStock:!0})));if($(n),e.outfits&&e.outfits.length>0){const t=e.outfits.map((e=>({id:e.id,name:e.name||"",occasion:e.occasion,matchScore:e.matchScore,matchReasons:e.matchReasons,items:e.items.map((e=>({id:e.id,retailerId:"default",name:e.name,brand:e.brand,category:e.category,price:e.price,salePrice:e.salePrice,colors:[],sizes:[],imageUrls:[e.imageUrls[0]||""],url:e.url,matchScore:e.matchScore,matchReasons:e.matchReasons,inStock:!0})))})));_(t)}}catch(e){}}catch(e){x("Sorry, I had trouble connecting. Please try again later."),y("Sorry, I had trouble connecting. Please try again later.","system")}finally{v(!1)}}))),[F,a,y,S,v,x,T.length,$,_]);(0,j.useEffect)((()=>{i||(M(),o(!0))}),[i,M]),(0,j.useEffect)((()=>{if(window.__StylistShowStyleQuiz&&(d(!0),window.__StylistShowStyleQuiz=!1),window.__StylistShowVirtualTryOn){if(T.length>0){const e=T[0];try{y(`Let's see how ${e.name} looks on you!`,"assistant")}catch(e){}}window.__StylistShowVirtualTryOn=!1}}),[]),(0,j.useEffect)((()=>{k&&F&&u(new dK(F.recommendation,k.userId))}),[k,F]),(0,j.useEffect)((()=>{s&&(document.documentElement.style.setProperty("--stylist-primary-color",s),document.documentElement.style.setProperty("--stylist-primary-color-light",L(s,.2)),document.documentElement.style.setProperty("--stylist-primary-color-dark",z(s,.2)))}),[s]);const L=(e,t)=>{try{e=e.replace("#","");const n=parseInt(e.substring(0,2),16),r=parseInt(e.substring(2,4),16),s=parseInt(e.substring(4,6),16),a=Math.min(255,Math.floor(n+(255-n)*t)),i=Math.min(255,Math.floor(r+(255-r)*t)),o=Math.min(255,Math.floor(s+(255-s)*t));return`#${a.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}${o.toString(16).padStart(2,"0")}`}catch(t){return e}},z=(e,t)=>{try{e=e.replace("#","");const n=parseInt(e.substring(0,2),16),r=parseInt(e.substring(2,4),16),s=parseInt(e.substring(4,6),16),a=Math.max(0,Math.floor(n*(1-t))),i=Math.max(0,Math.floor(r*(1-t))),o=Math.max(0,Math.floor(s*(1-t)));return`#${a.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}${o.toString(16).padStart(2,"0")}`}catch(t){return e}},P=(e,t)=>hK(void 0,void 0,void 0,(function*(){if(k)try{t?(I(e),Bt(Lt.ITEM_LIKE,k.userId,{itemId:e})):(N(e),Bt(Lt.ITEM_DISLIKE,k.userId,{itemId:e})),yield F.recommendation.addItemFeedback({userId:k.userId,itemId:e,liked:t,timestamp:new Date}),"chat"===g&&t&&y("Great! I've noted that you like this item. I'll keep this in mind for future recommendations.",ie.ASSISTANT)}catch(e){x("Failed to save your feedback. Please try again.")}})),B=(e,t)=>hK(void 0,void 0,void 0,(function*(){if(k)try{Bt(t?Lt.OUTFIT_LIKE:Lt.OUTFIT_DISLIKE,k.userId,{outfitId:e}),yield F.recommendation.addOutfitFeedback({userId:k.userId,outfitId:e,liked:t,timestamp:new Date}),"chat"===g&&t&&y("Great! I'm glad you like this outfit. I'll remember your preference for future recommendations.","assistant")}catch(e){x("Failed to save your feedback. Please try again.")}})),W=e=>{if(k)try{O({itemId:e.id,retailerId:t,addedAt:new Date}),"chat"===g&&y(`I've added ${e.name} to your wishlist!`,"assistant"),Bt(Lt.ADD_TO_WISHLIST,k.userId,{itemId:e.id})}catch(e){x("Failed to add item to wishlist. Please try again.")}},V=(e,n=1,r,s)=>{if(k)try{R({itemId:e.id,retailerId:t,quantity:n,size:r,color:s,addedAt:new Date}),"chat"===g&&y(`I've added ${e.name} to your shopping cart!`,"assistant"),Bt(Lt.ADD_TO_CART,k.userId,{itemId:e.id,quantity:n,size:r,color:s})}catch(e){x("Failed to add item to cart. Please try again.")}};if(!p)return null;const G=`stylist-chat-widget ${{"bottom-right":"stylist-chat-widget--bottom-right","bottom-left":"stylist-chat-widget--bottom-left","top-right":"stylist-chat-widget--top-right","top-left":"stylist-chat-widget--top-left"}[r]} ${f?"stylist-chat-widget--minimized":""}`;return(0,U.jsxs)(U.Fragment,{children:[(0,U.jsxs)("div",Object.assign({className:G,"data-testid":"stylist-chat-widget"},{children:[(0,U.jsx)(Oe,{title:"chat"===g?"The Stylist":"Your Lookbook",primaryColor:s,onSwitchView:e=>{w(e),"lookbook"===e&&Bt(Lt.VIEW_LOOKBOOK,(null==k?void 0:k.userId)||"anonymous")},currentView:g}),(0,U.jsx)("div",Object.assign({className:"stylist-chat-widget__content"},{children:"chat"===g?(0,U.jsxs)(U.Fragment,{children:[(0,U.jsx)(Zt,{messages:h,onItemFeedback:P,onOutfitFeedback:B,onMessageFeedback:(e,t)=>hK(void 0,void 0,void 0,(function*(){if(k&&t)try{D(e),Bt(Lt.MESSAGE_THUMBS_UP,k.userId,{messageId:e})}catch(e){}})),onAddToWishlist:W,onAddToCart:V,isLoading:m,primaryColor:s}),(0,U.jsx)(en,{onSendMessage:e=>hK(void 0,void 0,void 0,(function*(){if(y(e,"user"),!k||!l)return;v(!0);const t=e.toLowerCase();if(t.includes("lookbook")||t.includes("show recommendations")||t.includes("show items"))return yield new Promise((e=>setTimeout(e,500))),y("Here's your lookbook with all recommended items and outfits!","assistant"),w("lookbook"),void v(!1);if(t.includes("back to chat")||t.includes("return to chat"))return yield new Promise((e=>setTimeout(e,500))),y("Switching back to chat view. How else can I help you?","assistant"),w("chat"),void v(!1);if(t.includes("quiz")||t.includes("style profile")||t.includes("preferences"))return yield new Promise((e=>setTimeout(e,500))),y("Let's find out more about your style preferences! Please answer a few quick questions.","assistant"),k&&Bt(Lt.STYLE_QUIZ_START,k.userId),d(!0),void v(!1);try{const t=yield l.processMessage(e);for(let e=0;e<t.length;e++){e>0&&(yield new Promise((e=>setTimeout(e,800))));const n=t[e];if(b(n),"recommendation"===n.type){const e=n.items.map((e=>({id:e.id,retailerId:"default",name:e.name,brand:e.brand,category:e.category,price:e.price,salePrice:e.salePrice,colors:[],sizes:[],imageUrls:[e.imageUrl||""],url:e.url,matchScore:e.matchScore,matchReasons:e.matchReasons,inStock:!0})));$(e)}if("outfit"===n.type){const e={id:n.outfit.id,name:n.outfit.name,occasion:n.outfit.occasion,matchScore:n.outfit.matchScore,matchReasons:n.outfit.matchReasons,items:n.outfit.items.map((e=>({id:e.id,retailerId:"default",name:e.name,brand:e.brand,category:e.category,price:e.price,salePrice:e.salePrice,colors:[],sizes:[],imageUrls:[e.imageUrl||""],url:e.url,matchScore:e.matchScore,matchReasons:e.matchReasons,inStock:!0})))};C.some((t=>t.id===e.id))||_([...C,e])}}}catch(e){x(e instanceof Error?e.message:String(e)),y("Sorry, I encountered an error while processing your request. Please try again.","system")}finally{v(!1)}})),placeholder:"Type your question here...",disabled:m,primaryColor:s})]}):(0,U.jsx)(rK,{items:T,outfits:C,savedOutfits:E,onItemFeedback:P,onOutfitFeedback:B,onAddToWishlist:W,onAddToCart:V,onSaveOutfit:e=>{if(k)try{A({outfitId:e.id,userId:k.userId,name:e.name||`Outfit for ${e.occasion}`,items:e.items.map((e=>e.id)),savedAt:new Date}),"chat"===g&&y("I've saved this outfit to your lookbook!","assistant"),Bt(Lt.OUTFIT_SAVE,k.userId,{outfitId:e.id})}catch(e){x("Failed to save outfit. Please try again.")}},primaryColor:s})}))]})),(0,U.jsx)(EG,{onSave:e=>{k&&(Bt(Lt.TRY_ON_SAVED,k.userId,{resultUrl:e}),y("Great! I've saved your virtual try-on. How does it look?","assistant"))}}),c&&(0,U.jsx)(nK,{onSubmit:e=>hK(void 0,void 0,void 0,(function*(){if(k)try{v(!0);const t=25;if(e.length<t){const n=e.map((e=>e.questionId)),r=Array.from({length:t},((e,t)=>`q${t+1}`)).filter((e=>!n.includes(e)));Bt(Lt.STYLE_QUIZ_PARTIAL,k.userId,{unansweredCount:r.length})}try{localStorage.removeItem("stylist_quiz_progress_style-quiz-1")}catch(e){}try{yield F.user.submitStyleQuiz(k.userId,e)}catch(e){x("There was an issue saving your style preferences, but we can still provide recommendations.")}let n;d(!1),y("Thanks for completing the style quiz! I now have a better understanding of your preferences. Let me show you some recommendations based on your style profile.","assistant");try{n=yield F.recommendation.getRecommendations({userId:k.userId,limit:4,includeOutfits:!0})}catch(e){return x("Sorry, there was an issue getting your personalized recommendations."),void v(!1)}yield new Promise((e=>setTimeout(e,1e3))),b({type:ae.RECOMMENDATION,sender:ie.ASSISTANT,items:n.items});const r=n.items.map((e=>({id:e.id,retailerId:"default",name:e.name,brand:e.brand,category:e.category,price:e.price,salePrice:e.salePrice,colors:[],sizes:[],imageUrls:[e.imageUrl||""],url:e.url,matchScore:e.matchScore,matchReasons:e.matchReasons,inStock:!0})));if($(r),n.outfits&&n.outfits.length>0){yield new Promise((e=>setTimeout(e,1e3))),y("I've also created a complete outfit based on your style:","assistant"),yield new Promise((e=>setTimeout(e,500))),b({type:ae.OUTFIT,sender:ie.ASSISTANT,outfit:n.outfits[0]});const e=n.outfits.map((e=>({id:e.id,name:e.name,occasion:e.occasion,matchScore:e.matchScore,matchReasons:e.matchReasons,items:e.items.map((e=>({id:e.id,retailerId:"default",name:e.name,brand:e.brand,category:e.category,price:e.price,salePrice:e.salePrice,colors:[],sizes:[],imageUrls:[e.imageUrl||""],url:e.url,matchScore:e.matchScore,matchReasons:e.matchReasons,inStock:!0})))})));_(e)}Bt(Lt.STYLE_QUIZ_COMPLETE,k.userId),yield new Promise((e=>setTimeout(e,1e3))),y("You can see all your recommendations in your lookbook. Would you like to view it now?","assistant")}catch(e){x("Failed to process the style quiz. Please try again later."),d(!1)}finally{v(!1)}})),onClose:()=>d(!1),primaryColor:s})]})};var fK=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const mK=()=>{const[e,t]=(0,j.useState)({isOnline:navigator.onLine,isSlowConnection:!1,effectiveType:null,lastChecked:Date.now()}),n=(0,j.useCallback)((()=>{if("connection"in navigator){const e=navigator.connection;t((t=>Object.assign(Object.assign({},t),{isSlowConnection:"slow-2g"===e.effectiveType||"2g"===e.effectiveType||!0===e.saveData,effectiveType:e.effectiveType,lastChecked:Date.now()})))}}),[]),r=(0,j.useCallback)((()=>{t((e=>Object.assign(Object.assign({},e),{isOnline:!0,lastChecked:Date.now()}))),n()}),[n]),s=(0,j.useCallback)((()=>{t((e=>Object.assign(Object.assign({},e),{isOnline:!1,lastChecked:Date.now()})))}),[]),a=(0,j.useCallback)((()=>{n()}),[n]);(0,j.useEffect)((()=>{if(n(),window.addEventListener("online",r),window.addEventListener("offline",s),"connection"in navigator){navigator.connection.addEventListener("change",a)}return()=>{if(window.removeEventListener("online",r),window.removeEventListener("offline",s),"connection"in navigator){navigator.connection.removeEventListener("change",a)}}}),[r,s,a,n]);const i=(0,j.useCallback)((()=>fK(void 0,void 0,void 0,(function*(){try{const e=new AbortController,n=setTimeout((()=>e.abort()),5e3),r=yield fetch("/api/ping",{method:"HEAD",signal:e.signal});clearTimeout(n);const s=r.ok;return t((e=>Object.assign(Object.assign({},e),{isOnline:s,lastChecked:Date.now()}))),s}catch(e){return t((e=>Object.assign(Object.assign({},e),{isOnline:!1,lastChecked:Date.now()}))),!1}}))),[]);return Object.assign(Object.assign({},e),{checkConnection:i})},gK=(0,j.createContext)(void 0),yK=({children:e})=>{const t=eK(),n=mK(),r=me(),[s,a]=(0,j.useState)(!1);(0,j.useEffect)((()=>{s?r.user&&n.isOnline&&t.syncNow():a(!0)}),[s,r.user,n.isOnline,t]),(0,j.useEffect)((()=>{if(n.isOnline&&r.user){const e=setTimeout((()=>{t.syncNow()}),2e3);return()=>clearTimeout(e)}}),[n.isOnline,r.user,t]),(0,j.useEffect)((()=>{const e=()=>{"visible"===document.visibilityState&&n.isOnline&&r.user&&t.syncNow()};return document.addEventListener("visibilitychange",e),()=>{document.removeEventListener("visibilitychange",e)}}),[n.isOnline,r.user,t]);const i={syncState:t.state,syncNow:t.syncNow,isOnline:n.isOnline,isSlowConnection:n.isSlowConnection};return(0,U.jsx)(gK.Provider,Object.assign({value:i},{children:e}))},bK=()=>{const{syncState:e,isOnline:t,isSlowConnection:n}=(()=>{const e=(0,j.useContext)(gK);if(void 0===e)throw new Error("useSyncContext must be used within a SyncProvider");return e})();if(0===e.pendingOperations&&!e.isSyncing)return null;let r="syncing",s="Syncing...";return t?e.isSyncing?(r="syncing",s="Syncing..."):e.pendingOperations>0&&(r="pending",s=`${e.pendingOperations} change${1!==e.pendingOperations?"s":""} pending`):(r="offline",s=`${e.pendingOperations} change${1!==e.pendingOperations?"s":""} pending`),(0,U.jsxs)("div",Object.assign({className:`sync-status-indicator sync-status-${r}`},{children:[(0,U.jsxs)("div",Object.assign({className:"sync-status-icon"},{children:["syncing"===r&&(0,U.jsx)("svg",Object.assign({className:"sync-spinner",viewBox:"0 0 24 24"},{children:(0,U.jsx)("circle",{className:"sync-spinner-path",cx:"12",cy:"12",r:"10",fill:"none",stroke:"currentColor",strokeWidth:"4"})})),"pending"===r&&(0,U.jsx)("span",{children:""}),"offline"===r&&(0,U.jsx)("span",{children:""})]})),(0,U.jsx)("span",Object.assign({className:"sync-status-message"},{children:s}))]}))};var vK=function(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))};const xK=new class{constructor(){this.syncIntervalId=null,this.syncInterval=6e4,this.isInitialized=!1,this.apiConfig=null}initialize(e){this.isInitialized||(this.apiConfig=e,this.isInitialized=!0,window.addEventListener("online",this.handleOnline.bind(this)),window.addEventListener("offline",this.handleOffline.bind(this)),navigator.onLine&&this.startSyncInterval())}startSyncInterval(){null===this.syncIntervalId&&(this.syncFeedback(),this.syncIntervalId=window.setInterval((()=>{this.syncFeedback()}),this.syncInterval))}stopSyncInterval(){null!==this.syncIntervalId&&(window.clearInterval(this.syncIntervalId),this.syncIntervalId=null)}handleOnline(){this.startSyncInterval()}handleOffline(){this.stopSyncInterval()}syncFeedback(){return vK(this,void 0,void 0,(function*(){if(!this.isInitialized||!this.apiConfig)return;const e=_e.getState(),t=e.getPendingSyncItems();if(0!==t.length&&!e.isSyncing)try{e.setIsSyncing(!0);const n=Ce(),r=uK(this.apiConfig),s=yield r.feedback.syncFeedback({userId:n,feedbackItems:t});s.success&&s.syncedItemIds.length>0&&(e.markAsSynced(s.syncedItemIds),Bt(Lt.FEEDBACK_SYNCED,n,{count:s.syncedItemIds.length}))}catch(e){}finally{e.setIsSyncing(!1)}}))}cleanup(){this.stopSyncInterval(),window.removeEventListener("online",this.handleOnline.bind(this)),window.removeEventListener("offline",this.handleOffline.bind(this)),this.isInitialized=!1}},wK=e=>{const{isOpen:t,toggleOpen:n,setIsOpen:r}=oe();(0,j.useEffect)((()=>(t||setTimeout((()=>{n()}),100),xK.initialize({apiKey:e.apiKey,retailerId:e.retailerId,apiUrl:e.apiUrl}),()=>{xK.cleanup()})),[]),(0,j.useEffect)((()=>{e.primaryColor&&(document.documentElement.style.setProperty("--stylist-primary-color",e.primaryColor),document.documentElement.style.setProperty("--stylist-primary-color-light",s(e.primaryColor,.2)),document.documentElement.style.setProperty("--stylist-primary-color-dark",a(e.primaryColor,.2)))}),[e.primaryColor]);const s=(e,t)=>{try{e=e.replace("#","");const n=parseInt(e.substring(0,2),16),r=parseInt(e.substring(2,4),16),s=parseInt(e.substring(4,6),16),a=Math.min(255,Math.floor(n+(255-n)*t)),i=Math.min(255,Math.floor(r+(255-r)*t)),o=Math.min(255,Math.floor(s+(255-s)*t));return`#${a.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}${o.toString(16).padStart(2,"0")}`}catch(t){return e}},a=(e,t)=>{try{e=e.replace("#","");const n=parseInt(e.substring(0,2),16),r=parseInt(e.substring(2,4),16),s=parseInt(e.substring(4,6),16),a=Math.max(0,Math.floor(n*(1-t))),i=Math.max(0,Math.floor(r*(1-t))),o=Math.max(0,Math.floor(s*(1-t)));return`#${a.toString(16).padStart(2,"0")}${i.toString(16).padStart(2,"0")}${o.toString(16).padStart(2,"0")}`}catch(t){return e}};return(0,U.jsx)(yK,{children:(0,U.jsxs)(U.Fragment,{children:[(0,U.jsx)(pK,Object.assign({},e)),(0,U.jsx)(bK,{})]})})},kK=document.getElementById("stylist-widget-container")||NK(),SK=(0,W.H)(kK),IK=window.__StylistWidgetConfig||{apiKey:"demo_key",retailerId:"demo_retailer"};function NK(){const e=document.createElement("div");return e.id="stylist-widget-container",document.body.appendChild(e),e}SK.render((0,U.jsx)(j.StrictMode,{children:(0,U.jsx)(wK,Object.assign({},IK))}));const TK=wK,CK={init:e=>{window.__StylistWidgetConfig=Object.assign(Object.assign({},window.__StylistWidgetConfig),e),document.getElementById("stylist-widget-container")||NK()},open:()=>{const e=oe.getState();e.isOpen||e.toggleOpen()},close:()=>{const e=oe.getState();e.isOpen&&e.toggleOpen()},minimize:()=>{oe.getState().toggleMinimize()},switchView:e=>{oe.getState().setCurrentView(e)},__debug:{addMockItems:()=>{const e=Ne.getState(),t=[{id:"mock1",name:"Stylish Jeans",brand:"DenimCo",category:"Pants",price:79.99,retailerId:"demo",imageUrls:["https://via.placeholder.com/150"],colors:[],sizes:[],url:"#",matchScore:.95,matchReasons:["Based on your style profile"],inStock:!0},{id:"mock2",name:"Casual T-Shirt",brand:"Basics",category:"Tops",price:24.99,retailerId:"demo",imageUrls:["https://via.placeholder.com/150"],colors:[],sizes:[],url:"#",matchScore:.92,matchReasons:["Matches your preferences"],inStock:!0},{id:"mock3",name:"Leather Boots",brand:"Footwear",category:"Shoes",price:129.99,retailerId:"demo",imageUrls:["https://via.placeholder.com/150"],colors:[],sizes:[],url:"#",matchScore:.88,matchReasons:["Complements your style"],inStock:!0}],n={id:"outfit1",name:"Casual Weekend Look",occasion:"Casual",items:t,matchScore:.93,matchReasons:["Perfect for weekends"]};e.setRecommendedItems(t),e.setRecommendedOutfits([n])}}};window.StylistWidget=CK})(),r})()));