"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[5208],{20771:function(n,t,e){e.d(t,{$:function(){return o}});var r=e(27575);class o{constructor(n,t){this.variableNames=["A"];const e=new Array(n.length);for(let r=0;r<e.length;r++)e[r]=n[r]*t[r];this.outputShape=e,this.rank=e.length;const o=(0,r.b)(this.rank),u=function(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let o=0;o<n.length;o++)r.push(`imod(${e[o]}, ${n[o]})`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        setOutput(getA(${u}));\n      }\n    `}}},23601:function(n,t,e){e.d(t,{R:function(){return r}});class r{constructor(n,t,e,r,o,u){this.variableNames=["Image","Transforms"],this.outputShape=u;const i="nearest"===e?1:2;let a;switch(r){case"constant":default:a=1;break;case"reflect":a=2;break;case"wrap":a=3;break;case"nearest":a=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${a} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${n}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}},46969:function(n,t,e){e.d(t,{z:function(){return u}});var r=e(75694),o=e(27575);class u{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n;const t=n.length,e=(0,r.Jp)("rc",t),u=(0,o.b)(t),i=(0,r.kp)(t,e),a=e.slice(-2),l=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${u} rc = getOutputCoords();\n        vec4 packedInput = getA(${i});\n\n        setOutput(getChannel(packedInput, ${l}));\n      }\n    `}}},55315:function(n,t,e){e.d(t,{Y:function(){return u}});var r=e(75694),o=e(27575);class u{constructor(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const e=new Array(n.length);for(let r=0;r<e.length;r++)e[r]=n[t[r]];if(this.outputShape=e,this.rank=e.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const u=(0,o.b)(this.rank),i=(0,r.Fd)("rc",this.rank),a=new Array(this.rank);for(let r=0;r<t.length;r++)a[t[r]]=i[r];const l=`vec2(${a.slice(-2).join()})`,f=`++${i[this.rank-1]} < ${e[this.rank-1]}`,s=`getChannel(getA(${a.join()}), ${l})`;this.userCode=`\n    void main() {\n      ${u} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${s};\n      if(${f}) {\n        result[1] = ${s};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${e[this.rank-2]}) {\n        result[2] = ${s};\n        if(${f}) {\n          result[3] = ${s};\n        }\n      }\n      setOutput(result);\n    }\n    `}}},68173:function(n,t,e){e.d(t,{Hq:function(){return c},Nb:function(){return f},UC:function(){return s},X0:function(){return a},X8:function(){return l},_Q:function(){return u},dR:function(){return o},hE:function(){return r},pd:function(){return i}});class r{constructor(n,t){this.variableNames=["A"],this.outputShape=n,this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const o="if (isnan(x)) return x;",u="return x;",i="return abs(x);";const a="return (x >= 0.0) ? x : (exp(x) - 1.0);",l=o+"\n  return (x < 0.0) ? 0.0 : x;\n",f=o+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",s="return x;",c="return 1.0 / (1.0 + exp(-1.0 * x));"},74890:function(n,t,e){e.d(t,{Hq:function(){return a},Nb:function(){return i},X0:function(){return o},X8:function(){return u},_Q:function(){return r},rf:function(){return l}});const r="return x;",o="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",u="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",i="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",a="return 1.0 / (1.0 + exp(-1.0 * x));";class l{constructor(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}},77104:function(n,t,e){e.d(t,{r:function(){return r}});const r="3.6.0"},80393:function(n,t,e){e.d(t,{bP:function(){return o}});var r=e(9495);function o(){(0,r.env)().set("WEBGL_FORCE_F16_TEXTURES",!0)}},81322:function(n,t,e){e.d(t,{u:function(){return o}});var r=e(27575);class o{constructor(n,t){this.variableNames=["A"];const e=new Array(n.length);for(let r=0;r<e.length;r++)e[r]=n[t[r]];this.outputShape=e,this.rank=e.length;const o=(0,r.b)(this.rank),u=function(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let o=0;o<n.length;o++)r[n[o]]=e[o];return r.join()}(t);this.userCode=`\n    void main() {\n      ${o} resRC = getOutputCoords();\n      setOutput(getA(${u}));\n    }\n    `}}},88380:function(n,t,e){e.d(t,{$e:function(){return b},CE:function(){return j},FP:function(){return L},HM:function(){return s},HW:function(){return R},I2:function(){return Y},N0:function(){return v},N6:function(){return G},P0:function(){return y},Ph:function(){return I},Ql:function(){return V},R7:function(){return T},Rh:function(){return x},SO:function(){return U},Se:function(){return k},Ut:function(){return H},VJ:function(){return P},Yn:function(){return A},Zj:function(){return W},bz:function(){return F},dm:function(){return f},fA:function(){return X},jL:function(){return D},oN:function(){return m},ph:function(){return g},rC:function(){return d},rw:function(){return _},s6:function(){return O},sA:function(){return N},sZ:function(){return p},ul:function(){return i},yG:function(){return E},y_:function(){return C},yr:function(){return c}});var r=e(9495),o=e(597),u=e(28560);function i(n,t){const e=t();return(0,r.env)().getBool("DEBUG")&&function(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}const a=5.96e-8,l=65504;function f(n){return!!((0,r.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||a<Math.abs(n)&&Math.abs(n)<l)}function s(n,t){return M(n,(()=>n.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function c(n,t){const e=M(n,(()=>n.createShader(n.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(i(n,(()=>n.shaderSource(e,t))),i(n,(()=>n.compileShader(e))),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw new Error("Failed to compile vertex shader.");return e}function E(n,t){const e=M(n,(()=>n.createShader(n.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(i(n,(()=>n.shaderSource(e,t))),i(n,(()=>n.compileShader(e))),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw function(n,t){const e=h.exec(t);if(null==e)return;const o=+e[1],u=n.split("\n"),i=u.length.toString().length+2,a=u.map(((n,t)=>r.util.rightPad((t+1).toString(),i)+n));let l=0;for(let r=0;r<a.length;r++)l=Math.max(a[r].length,l);a.slice(0,o-1),a.slice(o-1,o),a.slice(o)}(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}const h=/ERROR: [0-9]+:([0-9]+):/g;function d(n){return M(n,(()=>n.createProgram()),"Unable to create WebGLProgram.")}function T(n,t){if(i(n,(()=>n.linkProgram(t))),!1===n.getProgramParameter(t,n.LINK_STATUS))throw new Error("Failed to link vertex and fragment shaders.")}function F(n,t){if(i(n,(()=>n.validateProgram(t))),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw new Error("Shader program validation failed.")}function R(n,t){const e=M(n,(()=>n.createBuffer()),"Unable to create WebGLBuffer");return i(n,(()=>n.bindBuffer(n.ARRAY_BUFFER,e))),i(n,(()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW))),e}function b(n,t){const e=M(n,(()=>n.createBuffer()),"Unable to create WebGLBuffer");return i(n,(()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e))),i(n,(()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW))),e}function p(n){return M(n,(()=>n.createTexture()),"Unable to create WebGLTexture.")}function g(n,t){const e=(0,r.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0){throw new Error("Requested texture size "+`[${n}x${t}]`+" is invalid.")}if(n>e||t>e){throw new Error("Requested texture size "+`[${n}x${t}]`+" greater than WebGL maximum on this browser / GPU "+`[${e}x${e}]`+".")}}function m(n){return M(n,(()=>n.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function _(n,t,e,r,o,u,a){const l=n.getAttribLocation(t,e);return-1!==l&&(i(n,(()=>n.bindBuffer(n.ARRAY_BUFFER,r))),i(n,(()=>n.vertexAttribPointer(l,o,n.FLOAT,!1,u,a))),i(n,(()=>n.enableVertexAttribArray(l))),!0)}function x(n,t,e){return M(n,(()=>n.getUniformLocation(t,e)),'uniform "'+e+'" not present in program.')}function A(n,t,e){return n.getUniformLocation(t,e)}function C(n,t,e,r){i(n,(()=>function(n,t,e){S(n,e),i(n,(()=>n.activeTexture(n.TEXTURE0+e))),i(n,(()=>n.bindTexture(n.TEXTURE_2D,t)))}(n,t,r))),i(n,(()=>n.uniform1i(e,r)))}function U(n,t,e){i(n,(()=>n.bindFramebuffer(n.FRAMEBUFFER,e))),i(n,(()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0)))}function N(n,t){i(n,(()=>n.bindFramebuffer(n.FRAMEBUFFER,t))),i(n,(()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0)))}function O(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function M(n,t,e){const r=i(n,(()=>t()));if(null==r)throw new Error(e);return r}function S(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${e}]`}.`)}}function v(n,t=2){return r.util.sizeFromShape(n.slice(0,n.length-t))}function I(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function L(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[v(n),...I(n)]),t}function X(n,t=!1){let e=(0,r.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(e*=2,1===(n=n.map(((t,e)=>e>=n.length-2?r.util.nearestLargerEven(n[e]):n[e]))).length&&(n=[2,n[0]])),2!==n.length){const t=r.util.squeezeShape(n);n=t.newShape}let o=r.util.sizeFromShape(n);if(n.length<=1&&o<=e)return[1,o];if(2===n.length&&n[0]<=e&&n[1]<=e)return n;if(3===n.length&&n[0]*n[1]<=e&&n[2]<=e)return[n[0]*n[1],n[2]];if(3===n.length&&n[0]<=e&&n[1]*n[2]<=e)return[n[0],n[1]*n[2]];if(4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e)return[n[0]*n[1]*n[2],n[3]];if(4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e)return[n[0],n[1]*n[2]*n[3]];if(t){const t=v(n);let e=2,u=2;return n.length&&([e,u]=I(n)),o=t*(e/2)*(u/2),r.util.sizeToSquarishShape(o).map((n=>2*n))}return r.util.sizeToSquarishShape(o)}function $(n){return n%2===0}function y(n,t){if(n=n.slice(-2),t=t.slice(-2),r.util.arraysEqual(n,t))return!0;if(!n.length||!t.length)return!0;if(0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n.slice(-1)[0],r=t.slice(-1)[0];if(e===r)return!0;if($(e)&&$(r)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&$(n[0])&&$(t[0])}let B,w;function k(n){if(null==B){const t=(0,o.bU)(n);B=t.getParameter(t.MAX_TEXTURE_SIZE)}return B}function D(n){if(null==w){const t=(0,o.bU)(n);w=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,w)}function P(n){if(0===n)return 0;let t;const e=(0,o.bU)(n);return t=V(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:V(e,"EXT_disjoint_timer_query")?1:0,t}function V(n,t){return null!=n.getExtension(t)}function W(n){try{if(null!=(0,o.bU)(n))return!0}catch(t){return!1}return!1}function Y(n){if(0===n)return!1;const t=(0,o.bU)(n);if(1===n){if(!V(t,"OES_texture_float"))return!1}else if(!V(t,"EXT_color_buffer_float"))return!1;return z(t)}function G(n){if(0===n)return!1;const t=(0,o.bU)(n);if(1!==n){if(V(t,"EXT_color_buffer_float"))return z(t);const n="EXT_color_buffer_half_float";if(V(t,n)){const e=t.getExtension(n);return function(n,t){const e=(0,u.EZ)(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);const o=1,i=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,o,i,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const l=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(a),l}(t,e)}return!1}if(!V(t,"OES_texture_float"))return!1;if(!V(t,"WEBGL_color_buffer_float"))return!1;return z(t)}function z(n){const t=(0,u.EZ)(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e);n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,r),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(r),o}function H(n){if(2!==n)return!1;return null!=(0,o.bU)(n).fenceSync}function j(n,t){Array.isArray(n)||(n=[n]),n.forEach((n=>{null!=n&&r.util.assert("complex64"!==n.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}}}]);
//# sourceMappingURL=stylist-vendors-0005df24.4922f85daa881a100a28.js.map