{"version":3,"file":"stylist-vendors-6cadb9c0.db44f3b8e658d3424b7a.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/real.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/squeeze.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/slice2d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/random_gamma.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/reverse_1d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/spectral/rfft.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/tensor6d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/step.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/space_to_batch_nd.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/spectral/ifft.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/signal/frame.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_reshape.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/reverse_3d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/rsqrt.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/slice.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/signal_ops_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/tensor2d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/tensor_ops_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/reciprocal.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/spectral/irfft.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/setdiff1d_async.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/random_normal.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/tensor4d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/round.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/scatter_nd_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/selu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/softmax.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/reverse_4d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/selu_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sigmoid.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/rotate_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/reduce_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sin.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/slice_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/tensor5d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/slice3d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/spectral/fft.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/tensor3d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/reverse_2d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/range.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/scalar.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/square.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/strided_slice.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/segment_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/slice1d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sign.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/reverse.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/squared_difference.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/stack.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/signal/stft.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/split_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/tanh.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sinh.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/tensor1d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/slice4d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/reshape.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/rand.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_fill_empty_rows.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/prelu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/softplus.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/split.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/prod.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/signal/hann_window.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/tensor.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/print.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sub.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/tan.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sqrt.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/random_uniform.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/relu6.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sum.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/rand_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/separable_conv2d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/relu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/scatter_nd.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sparse_to_dense.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sparse_to_dense_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/signal/hamming_window.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Real } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Returns the real part of a complex (or real) tensor.\n *\n * Given a tensor input, this operation returns a tensor of type float that is\n * the real part of each element in input considered as a complex number.\n *\n * If the input is real, it simply makes a clone.\n *\n * ```js\n * const x = tf.complex([-2.25, 3.25], [4.75, 5.75]);\n * tf.real(x).print();\n * ```\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nfunction real_(input) {\n    const $input = convertToTensor(input, 'input', 'real');\n    const inputs = { input: $input };\n    return ENGINE.runKernel(Real, inputs);\n}\nexport const real = op({ real_ });\n//# sourceMappingURL=real.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport { squeezeShape } from '../util';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * Removes dimensions of size 1 from the shape of a `tf.Tensor`.\n *\n * ```js\n * const x = tf.tensor([1, 2, 3, 4], [1, 1, 4]);\n * x.squeeze().print();\n * ```\n *\n * @param x The input tensor to be squeezed.\n * @param axis An optional list of numbers. If specified, only\n *     squeezes the dimensions listed. The dimension index starts at 0. It\n * is an error to squeeze a dimension that is not 1.\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction squeeze_(x, axis) {\n    const $x = convertToTensor(x, 'x', 'squeeze');\n    return reshape($x, squeezeShape($x.shape, axis).newShape);\n}\nexport const squeeze = op({ squeeze_ });\n//# sourceMappingURL=squeeze.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\nimport { slice } from './slice';\n/**\n * Extracts a 2D slice from a 2D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\nfunction slice2d_(x, begin, size) {\n    const $x = convertToTensor(x, 'x', 'slice2d');\n    util.assert($x.rank === 2, () => `slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`);\n    return slice($x, begin, size);\n}\nexport const slice2d = op({ slice2d_ });\n//# sourceMappingURL=slice2d.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from './buffer';\nimport { op } from './operation';\nimport { RandGamma } from './rand_util';\n/**\n * Creates a `tf.Tensor` with values sampled from a gamma distribution.\n *\n * ```js\n * tf.randomGamma([2, 2], 1).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param alpha The shape parameter of the gamma distribution.\n * @param beta The inverse scale parameter of the gamma distribution. Defaults\n *     to 1.\n * @param dtype The data type of the output. Defaults to float32.\n * @param seed The seed for the random number generator.\n *\n * @doc {heading: 'Tensors', subheading: 'Random'}\n */\nfunction randomGamma_(shape, alpha, beta = 1, dtype = 'float32', seed) {\n    if (beta == null) {\n        beta = 1;\n    }\n    if (dtype == null) {\n        dtype = 'float32';\n    }\n    if (dtype !== 'float32' && dtype !== 'int32') {\n        throw new Error(`Unsupported data type ${dtype}`);\n    }\n    const rgamma = new RandGamma(alpha, beta, dtype, seed);\n    const res = buffer(shape, dtype);\n    for (let i = 0; i < res.values.length; i++) {\n        res.values[i] = rgamma.nextValue();\n    }\n    return res.toTensor();\n}\nexport const randomGamma = op({ randomGamma_ });\n//# sourceMappingURL=random_gamma.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\nimport { reverse } from './reverse';\n/**\n * Reverses a `tf.Tensor1D`.\n *\n * @param x The input tensor.\n */\nfunction reverse1d_(x) {\n    const $x = convertToTensor(x, 'x', 'reverse');\n    util.assert($x.rank === 1, () => `Error in reverse1D: x must be rank 1 but got rank ${$x.rank}.`);\n    return reverse($x, 0);\n}\nexport const reverse1d = op({ reverse1d_ });\n//# sourceMappingURL=reverse_1d.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from '../../util';\nimport { complex } from '../complex';\nimport { concat } from '../concat';\nimport { imag } from '../imag';\nimport { op } from '../operation';\nimport { real } from '../real';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { split } from '../split';\nimport { zeros } from '../zeros';\nimport { zerosLike } from '../zeros_like';\nimport { fft } from './fft';\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction rfft_(input, fftLength) {\n    assert(input.dtype === 'float32', () => `The dtype for rfft() must be real value but got ${input.dtype}`);\n    let innerDimensionSize = input.shape[input.shape.length - 1];\n    const batch = input.size / innerDimensionSize;\n    let adjustedInput;\n    if (fftLength != null && fftLength < innerDimensionSize) {\n        // Need to crop\n        const begin = input.shape.map(v => 0);\n        const size = input.shape.map(v => v);\n        size[input.shape.length - 1] = fftLength;\n        adjustedInput = slice(input, begin, size);\n        innerDimensionSize = fftLength;\n    }\n    else if (fftLength != null && fftLength > innerDimensionSize) {\n        // Need to pad with zeros\n        const zerosShape = input.shape.map(v => v);\n        zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n        adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);\n        innerDimensionSize = fftLength;\n    }\n    else {\n        adjustedInput = input;\n    }\n    // Complement the input with zero imaginary numbers.\n    const zerosInput = zerosLike(adjustedInput);\n    const complexInput = reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);\n    const ret = fft(complexInput);\n    // Exclude complex conjugations. These conjugations are put symmetrically.\n    const half = Math.floor(innerDimensionSize / 2) + 1;\n    const realValues = real(ret);\n    const imagValues = imag(ret);\n    const realComplexConjugate = split(realValues, [half, innerDimensionSize - half], realValues.shape.length - 1);\n    const imagComplexConjugate = split(imagValues, [half, innerDimensionSize - half], imagValues.shape.length - 1);\n    const outputShape = adjustedInput.shape.slice();\n    outputShape[adjustedInput.shape.length - 1] = half;\n    return reshape(complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);\n}\nexport const rfft = op({ rfft_ });\n//# sourceMappingURL=rfft.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { inferShape } from '../tensor_util_env';\nimport { assertNonNull } from '../util';\nimport { makeTensor } from './tensor_ops_util';\n/**\n * Creates rank-6 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor6d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor6d([[[[[[1],[2]],[[3],[4]]],[[[5],[6]],[[7],[8]]]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor6d([1, 2, 3, 4, 5, 6, 7, 8], [1, 1, 2, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor6d(values, shape, dtype) {\n    assertNonNull(values);\n    if (shape != null && shape.length !== 6) {\n        throw new Error('tensor6d() requires shape to have six numbers');\n    }\n    const inferredShape = inferShape(values, dtype);\n    if (inferredShape.length !== 6 && inferredShape.length !== 1) {\n        throw new Error('tensor6d() requires values to be number[][][][][][] or ' +\n            'flat/TypedArray');\n    }\n    if (inferredShape.length === 1 && shape == null) {\n        throw new Error('tensor6d() requires shape to be provided when `values` ' +\n            'are a flat array');\n    }\n    shape = shape ||\n        inferredShape;\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n//# sourceMappingURL=tensor6d.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Step } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes step of the input `tf.Tensor` element-wise: `x > 0 ? 1 : alpha * x`\n *\n * ```js\n * const x = tf.tensor1d([0, 2, -1, -3]);\n *\n * x.step(.5).print();  // or tf.step(x, .5)\n * ```\n * @param x The input tensor.\n * @param alpha The gradient when input is negative.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction step_(x, alpha = 0.0) {\n    const $x = convertToTensor(x, 'x', 'step');\n    const inputs = { x: $x };\n    const attrs = { alpha };\n    return ENGINE.runKernel(Step, inputs, attrs);\n}\nexport const step = op({ step_ });\n//# sourceMappingURL=step.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { SpaceToBatchND } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\n/**\n * This operation divides \"spatial\" dimensions `[1, ..., M]` of the input into\n * a grid of blocks of shape `blockShape`, and interleaves these blocks with\n * the \"batch\" dimension (0) such that in the output, the spatial\n * dimensions `[1, ..., M]` correspond to the position within the grid,\n * and the batch dimension combines both the position within a spatial block\n * and the original batch position. Prior to division into blocks,\n * the spatial dimensions of the input are optionally zero padded\n * according to `paddings`. See below for a precise description.\n *\n * ```js\n * const x = tf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]);\n * const blockShape = [2, 2];\n * const paddings = [[0, 0], [0, 0]];\n *\n * x.spaceToBatchND(blockShape, paddings).print();\n * ```\n *\n * @param x A `tf.Tensor`. N-D with `x.shape` = `[batch] + spatialShape +\n * remainingShape`, where spatialShape has `M` dimensions.\n * @param blockShape A 1-D array. Must have shape `[M]`, all values must\n * be >= 1.\n * @param paddings A 2-D array. Must have shape `[M, 2]`, all values must be >=\n *     0. `paddings[i] = [padStart, padEnd]` specifies the amount to zero-pad\n * from input dimension `i + 1`, which corresponds to spatial dimension `i`. It\n * is required that\n * `(inputShape[i + 1] + padStart + padEnd) % blockShape[i] === 0`\n *\n * This operation is equivalent to the following steps:\n *\n * 1. Zero-pad the start and end of dimensions `[1, ..., M]` of the input\n * according to `paddings` to produce `padded` of shape paddedShape.\n *\n * 2. Reshape `padded` to `reshapedPadded` of shape:\n * `[batch] + [paddedShape[1] / blockShape[0], blockShape[0], ...,\n * paddedShape[M] / blockShape[M-1], blockShape[M-1]] + remainingShape`\n *\n * 3. Permute dimensions of `reshapedPadded` to produce `permutedReshapedPadded`\n * of shape: `blockShape + [batch] + [paddedShape[1] / blockShape[0], ...,\n * paddedShape[M] / blockShape[M-1]] + remainingShape`\n *\n * 4. Reshape `permutedReshapedPadded` to flatten `blockShape` into the\n * batch dimension, producing an output tensor of shape:\n * `[batch * prod(blockShape)] + [paddedShape[1] / blockShape[0], ...,\n * paddedShape[M] / blockShape[M-1]] + remainingShape`\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction spaceToBatchND_(x, blockShape, paddings) {\n    const $x = convertToTensor(x, 'x', 'spaceToBatchND');\n    util.assert($x.rank >= 1 + blockShape.length, () => `input rank ${$x.rank} should be > than [blockShape] ${blockShape.length}`);\n    util.assert(paddings.length === blockShape.length, () => `paddings.shape[0] ${paddings.length} must be equal to [blockShape] ${blockShape.length}`);\n    util.assert($x.shape.reduce((a, b, i) => {\n        if (i > 0 && i <= blockShape.length) {\n            return a &&\n                ((b + paddings[i - 1][0] + paddings[i - 1][1]) %\n                    blockShape[i - 1] ===\n                    0);\n        }\n        return a;\n    }, true), () => `input spatial dimensions ${$x.shape.slice(1)} with paddings ${paddings.toString()} must be divisible by blockShapes ${blockShape.toString()}`);\n    const inputs = { x: $x };\n    const attrs = { blockShape, paddings };\n    return ENGINE.runKernel(SpaceToBatchND, inputs, attrs);\n}\nexport const spaceToBatchND = op({ spaceToBatchND_ });\n//# sourceMappingURL=space_to_batch_nd.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { IFFT } from '../../kernel_names';\nimport { assert } from '../../util';\nimport { op } from '../operation';\n/**\n * Inverse fast Fourier transform.\n *\n * Computes the inverse 1-dimensional discrete Fourier transform over the\n * inner-most dimension of input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([1, 2, 3]);\n * const x = tf.complex(real, imag);\n *\n * x.ifft().print();  // tf.spectral.ifft(x).print();\n * ```\n * @param input The complex input to compute an ifft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction ifft_(input) {\n    assert(input.dtype === 'complex64', () => `The dtype for tf.spectral.ifft() must be complex64 ` +\n        `but got ${input.dtype}.`);\n    const inputs = { input };\n    return ENGINE.runKernel(IFFT, inputs);\n}\nexport const ifft = op({ ifft_ });\n//# sourceMappingURL=ifft.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { concat } from '../concat';\nimport { fill } from '../fill';\nimport { op } from '../operation';\nimport { reshape } from '../reshape';\nimport { slice } from '../slice';\nimport { tensor2d } from '../tensor2d';\n/**\n * Expands input into frames of frameLength.\n * Slides a window size with frameStep.\n *\n * ```js\n * tf.signal.frame([1, 2, 3], 2, 1).print();\n * ```\n * @param signal The input tensor to be expanded\n * @param frameLength Length of each frame\n * @param frameStep The frame hop size in samples.\n * @param padEnd Whether to pad the end of signal with padValue.\n * @param padValue An number to use where the input signal does\n *     not exist when padEnd is True.\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction frame_(signal, frameLength, frameStep, padEnd = false, padValue = 0) {\n    let start = 0;\n    const output = [];\n    while (start + frameLength <= signal.size) {\n        output.push(slice(signal, start, frameLength));\n        start += frameStep;\n    }\n    if (padEnd) {\n        while (start < signal.size) {\n            const padLen = (start + frameLength) - signal.size;\n            const pad = concat([\n                slice(signal, start, frameLength - padLen), fill([padLen], padValue)\n            ]);\n            output.push(pad);\n            start += frameStep;\n        }\n    }\n    if (output.length === 0) {\n        return tensor2d([], [0, frameLength]);\n    }\n    return reshape(concat(output), [output.length, frameLength]);\n}\nexport const frame = op({ frame_ });\n//# sourceMappingURL=frame.js.map","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { SparseReshape } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * This operation has the same semantics as reshape on the represented dense\n * tensor. The `inputIndices` are recomputed based on the requested `newShape`.\n * If one component of `newShape` is the special value -1, the size of that\n * dimension is computed so that the total dense size remains constant. At most\n * one component of `newShape` can be -1. The number of dense elements implied\n * by `newShape` must be the same as the number of dense elements originally\n * implied by `inputShape`. Reshaping does not affect the order of values in the\n * SparseTensor. If the input tensor has rank R_in and N non-empty values, and\n * `newShape` has length R_out, then `inputIndices` has shape [N, R_in],\n * `inputShape` has length R_in, `outputIndices` has shape [N, R_out], and\n * `outputShape` has length R_out.\n *\n * ```js\n * const result = tf.sparse.sparseReshape(\n *   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],\n *   [2, 3, 6], [9, -1]);\n * console.log(result);\n * result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]\n * result['outputShape'].print(); // [9, 4]\n * ```\n * @param inputIndices: 2-D. N x R_in matrix with the indices of non-empty\n * values in a SparseTensor.\n * @param inputShape: 1-D. R_in Tensor1D with the input SparseTensor's dense\n * shape.\n * @param newShape: 1-D. R_out Tensor1D with the requested new dense shape.\n * @return A map with the following properties:\n *     - outputIndices: 2-D. N x R_out matrix with the updated indices of\n *       non-empty values in the output SparseTensor.\n *     - outputShape: 1-D. R_out vector with the full dense shape of the output\n *       SparseTensor. This is the same as newShape but with any -1 dimensions\n *        filled in.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseReshape_(inputIndices, inputShape, newShape) {\n    const $inputIndices = convertToTensor(inputIndices, 'inputIndices', 'sparseReshape');\n    const $inputShape = convertToTensor(inputShape, 'inputShape', 'sparseReshape');\n    const $newShape = convertToTensor(newShape, 'newShape', 'sparseReshape');\n    if ($inputIndices.rank !== 2) {\n        throw new Error(`Input indices should be Tensor2D but received shape\n        ${$inputIndices.shape}`);\n    }\n    if ($inputShape.rank !== 1) {\n        throw new Error(`Input shape should be Tensor1D but received shape ${$inputShape.shape}`);\n    }\n    if ($newShape.rank !== 1) {\n        throw new Error(`New shape should be Tensor1D but received shape ${$newShape.shape}`);\n    }\n    const inputs = {\n        inputIndices: $inputIndices,\n        inputShape: $inputShape,\n        newShape: $newShape\n    };\n    const result = ENGINE.runKernel(SparseReshape, inputs);\n    return { outputIndices: result[0], outputShape: result[1] };\n}\nexport const sparseReshape = op({ sparseReshape_ });\n//# sourceMappingURL=sparse_reshape.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\nimport { reverse } from './reverse';\n/**\n * Reverses a `tf.Tensor3D` along a specified axis.\n *\n * @param x The input tensor.\n * @param axis The set of dimensions to reverse. Must be in the\n *     range [-rank(x), rank(x)). Defaults to all axes.\n */\nfunction reverse3d_(x, axis) {\n    const $x = convertToTensor(x, 'x', 'reverse');\n    util.assert($x.rank === 3, () => `Error in reverse3D: x must be rank 3 but got rank ${$x.rank}.`);\n    return reverse($x, axis);\n}\nexport const reverse3d = op({ reverse3d_ });\n//# sourceMappingURL=reverse_3d.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Rsqrt } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes reciprocal of square root of the input `tf.Tensor` element-wise:\n * `y = 1 / sqrt(x)`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 4, -1]);\n *\n * x.rsqrt().print();  // or tf.rsqrt(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction rsqrt_(x) {\n    const $x = convertToTensor(x, 'x', 'rsqrt');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Rsqrt, inputs);\n}\nexport const rsqrt = op({ rsqrt_ });\n//# sourceMappingURL=rsqrt.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Slice } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Extracts a slice from a `tf.Tensor` starting at coordinates `begin`\n * and is of size `size`.\n *\n * Also available are stricter rank-specific methods with the same signature\n * as this method that assert that `x` is of the given rank:\n *   - `tf.slice1d`\n *   - `tf.slice2d`\n *   - `tf.slice3d`\n *   - `tf.slice4d`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.slice([1], [2]).print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * x.slice([1, 0], [1, 2]).print();\n * ```\n * @param x The input `tf.Tensor` to slice from.\n * @param begin The coordinates to start the slice from. The length can be\n *     less than the rank of x - the rest of the axes will have implicit 0 as\n *     start. Can also be a single number, in which case it specifies the\n *     first axis.\n * @param size The size of the slice. The length can be less than the rank of\n *     x - the rest of the axes will have implicit -1. A value of -1 requests\n *     the rest of the dimensions in the axis. Can also be a single number,\n *     in which case it specifies the size of the first axis.\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction slice_(x, begin, size) {\n    const $x = convertToTensor(x, 'x', 'slice', 'string_or_numeric');\n    if ($x.rank === 0) {\n        throw new Error('Slicing scalar is not possible');\n    }\n    const inputs = { x: $x };\n    const attrs = { begin, size };\n    return ENGINE.runKernel(Slice, inputs, attrs);\n}\nexport const slice = op({ slice_ });\n//# sourceMappingURL=slice.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tensor1d } from './tensor1d';\nexport function enclosingPowerOfTwo(value) {\n    // Return 2**N for integer N such that 2**N >= value.\n    return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2.0))));\n}\nexport function cosineWindow(windowLength, a, b) {\n    const even = 1 - windowLength % 2;\n    const newValues = new Float32Array(windowLength);\n    for (let i = 0; i < windowLength; ++i) {\n        const cosArg = (2.0 * Math.PI * i) / (windowLength + even - 1);\n        newValues[i] = a - b * Math.cos(cosArg);\n    }\n    return tensor1d(newValues, 'float32');\n}\n//# sourceMappingURL=signal_ops_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { inferShape } from '../tensor_util_env';\nimport { assertNonNull } from '../util';\nimport { makeTensor } from './tensor_ops_util';\n/**\n * Creates rank-2 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor2d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor2d([[1, 2], [3, 4]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor2d([1, 2, 3, 4], [2, 2]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. If not provided, it is inferred from\n *     `values`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor2d(values, shape, dtype) {\n    assertNonNull(values);\n    if (shape != null && shape.length !== 2) {\n        throw new Error('tensor2d() requires shape to have two numbers');\n    }\n    const inferredShape = inferShape(values, dtype);\n    if (inferredShape.length !== 2 && inferredShape.length !== 1) {\n        throw new Error('tensor2d() requires values to be number[][] or flat/TypedArray');\n    }\n    if (inferredShape.length === 1 && shape == null) {\n        throw new Error('tensor2d() requires shape to be provided when `values` ' +\n            'are a flat/TypedArray');\n    }\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n//# sourceMappingURL=tensor2d.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(values, shape, inferredShape, dtype) {\n    if (dtype == null) {\n        dtype = inferDtype(values);\n    }\n    if (dtype === 'complex64') {\n        throw new Error(`Cannot construct a complex64 tensor directly. ` +\n            `Please use tf.complex(real, imag).`);\n    }\n    if (!isTypedArray(values) && !Array.isArray(values) &&\n        typeof values !== 'number' && typeof values !== 'boolean' &&\n        typeof values !== 'string') {\n        throw new Error('values passed to tensor(values) must be a number/boolean/string or ' +\n            'an array of numbers/booleans/strings, or a TypedArray');\n    }\n    if (shape != null) {\n        assertNonNegativeIntegerDimensions(shape);\n        const providedSize = sizeFromShape(shape);\n        const inferredSize = sizeFromShape(inferredShape);\n        assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` +\n            `${providedSize} values but has ${inferredSize}`);\n        for (let i = 0; i < inferredShape.length; ++i) {\n            const inferred = inferredShape[i];\n            const flatDimsDontMatch = i === inferredShape.length - 1 ?\n                inferred !== sizeFromShape(shape.slice(i)) :\n                true;\n            assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` +\n                `(${inferredShape}) does not match the provided ` +\n                `shape (${shape}). `);\n        }\n    }\n    if (!isTypedArray(values) && !Array.isArray(values)) {\n        values = [values];\n    }\n    shape = shape || inferredShape;\n    values = dtype !== 'string' ?\n        toTypedArray(values, dtype) :\n        flatten(values, [], true);\n    return ENGINE.makeTensor(values, shape, dtype);\n}\n//# sourceMappingURL=tensor_ops_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Reciprocal } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes reciprocal of x element-wise: `1 / x`\n *\n * ```js\n * const x = tf.tensor1d([0, 1, 2]);\n *\n * x.reciprocal().print();  // or tf.reciprocal(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction reciprocal_(x) {\n    const $x = convertToTensor(x, 'x', 'reciprocal');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Reciprocal, inputs);\n}\nexport const reciprocal = op({ reciprocal_ });\n//# sourceMappingURL=reciprocal.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { complex } from '../complex';\nimport { concat } from '../concat';\nimport { imag } from '../imag';\nimport { mul } from '../mul';\nimport { op } from '../operation';\nimport { real } from '../real';\nimport { reshape } from '../reshape';\nimport { reverse } from '../reverse';\nimport { scalar } from '../scalar';\nimport { slice } from '../slice';\nimport { ifft } from './ifft';\n/**\n * Inversed real value input fast Fourier transform.\n *\n * Computes the 1-dimensional inversed discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([0, 0, 0]);\n * const x = tf.complex(real, imag);\n *\n * x.irfft().print();\n * ```\n * @param input The real value input to compute an irfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction irfft_(input) {\n    const innerDimensionSize = input.shape[input.shape.length - 1];\n    const batch = input.size / innerDimensionSize;\n    let ret;\n    if (innerDimensionSize <= 2) {\n        const complexInput = reshape(input, [batch, innerDimensionSize]);\n        ret = ifft(complexInput);\n    }\n    else {\n        // The length of unique components of the DFT of a real-valued signal\n        // is 2 * (input_len - 1)\n        const outputShape = [batch, 2 * (innerDimensionSize - 1)];\n        const realInput = reshape(real(input), [batch, innerDimensionSize]);\n        const imagInput = reshape(imag(input), [batch, innerDimensionSize]);\n        const realConjugate = reverse(slice(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);\n        const imagConjugate = mul(reverse(slice(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1), scalar(-1));\n        const r = concat([realInput, realConjugate], 1);\n        const i = concat([imagInput, imagConjugate], 1);\n        const complexInput = reshape(complex(r, i), [outputShape[0], outputShape[1]]);\n        ret = ifft(complexInput);\n    }\n    ret = real(ret);\n    // reshape the result if the input is 3D tensor.\n    if (input.rank === 3 && input.shape[0] !== 0) {\n        const temp = ret;\n        const batch = input.shape[0];\n        ret = reshape(ret, [batch, ret.shape[0] / batch, ret.shape[1]]);\n        temp.dispose();\n    }\n    return ret;\n}\nexport const irfft = op({ irfft_ });\n//# sourceMappingURL=irfft.js.map","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { TensorBuffer } from '../tensor';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\n/**\n * Computes the difference between two lists of numbers.\n *\n * Given a Tensor `x` and a Tensor `y`, this operation returns a Tensor `out`\n * that represents all values that are in `x` but not in `y`. The returned\n * Tensor `out` is sorted in the same order that the numbers appear in `x`\n * (duplicates are preserved). This operation also returns a Tensor indices that\n * represents the position of each out element in `x`. In other words:\n *\n * `out[i] = x[idx[i]] for i in [0, 1, ..., out.length - 1]`\n *\n * ```js\n * const x = [1, 2, 3, 4, 5, 6];\n * const y = [1, 3, 5];\n *\n * const [out, indices] = await tf.setdiff1dAsync(x, y);\n * out.print(); // [2, 4, 6]\n * indices.print(); // [1, 3, 5]\n * ```\n *\n * @param x 1-D Tensor. Values to keep.\n * @param y 1-D Tensor. Must have the same type as x. Values to exclude in the\n *     output.\n * @returns Promise of Tensor tuple [out, indices].\n *  out: Tensor with the same type as x.\n *  indices: A Tensor of type int32.\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nasync function setdiff1dAsync_(x, y) {\n    const $x = convertToTensor(x, 'x', 'setdiff1d');\n    const $y = convertToTensor(y, 'y', 'setdiff1d');\n    util.assert($x.dtype === $y.dtype, () => `x and y should have the same dtype, but got x (${$x.dtype}) and y (${$y.dtype}).`);\n    util.assert($x.rank === 1, () => `x should be 1D tensor, but got x (${$x.shape}).`);\n    util.assert($y.rank === 1, () => `y should be 1D tensor, but got y (${$y.shape}).`);\n    const xVals = await $x.data();\n    const yVals = await $y.data();\n    const ySet = new Set(yVals);\n    let outputSize = 0;\n    for (let i = 0; i < xVals.length; i++) {\n        if (!ySet.has(xVals[i])) {\n            outputSize++;\n        }\n    }\n    const buffer = new TensorBuffer([outputSize], $x.dtype);\n    const indices = new TensorBuffer([outputSize], 'int32');\n    for (let i = 0, p = 0; i < xVals.length; i++) {\n        if (!ySet.has(xVals[i])) {\n            buffer.values[p] = xVals[i];\n            indices.values[p] = i;\n            p++;\n        }\n    }\n    return [buffer.toTensor(), indices.toTensor()];\n}\nexport const setdiff1dAsync = setdiff1dAsync_;\n//# sourceMappingURL=setdiff1d_async.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from './buffer';\nimport { op } from './operation';\nimport { MPRandGauss } from './rand_util';\n/**\n * Creates a `tf.Tensor` with values sampled from a normal distribution.\n *\n * ```js\n * tf.randomNormal([2, 2]).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param mean The mean of the normal distribution.\n * @param stdDev The standard deviation of the normal distribution.\n * @param dtype The data type of the output.\n * @param seed The seed for the random number generator.\n *\n * @doc {heading: 'Tensors', subheading: 'Random'}\n */\nfunction randomNormal_(shape, mean = 0, stdDev = 1, dtype, seed) {\n    if (dtype != null && dtype === 'bool') {\n        throw new Error(`Unsupported data type ${dtype}`);\n    }\n    const randGauss = new MPRandGauss(mean, stdDev, dtype, false /* truncated */, seed);\n    const res = buffer(shape, dtype);\n    for (let i = 0; i < res.values.length; i++) {\n        res.values[i] = randGauss.nextValue();\n    }\n    return res.toTensor();\n}\nexport const randomNormal = op({ randomNormal_ });\n//# sourceMappingURL=random_normal.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { inferShape } from '../tensor_util_env';\nimport { assertNonNull } from '../util';\nimport { makeTensor } from './tensor_ops_util';\n/**\n * Creates rank-4 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor4d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor4d([[[[1], [2]], [[3], [4]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor4d(values, shape, dtype) {\n    assertNonNull(values);\n    if (shape != null && shape.length !== 4) {\n        throw new Error('tensor4d() requires shape to have four numbers');\n    }\n    const inferredShape = inferShape(values, dtype);\n    if (inferredShape.length !== 4 && inferredShape.length !== 1) {\n        throw new Error('tensor4d() requires values to be number[][][][] or flat/TypedArray');\n    }\n    if (inferredShape.length === 1 && shape == null) {\n        throw new Error('tensor4d() requires shape to be provided when `values` ' +\n            'are a flat array');\n    }\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n//# sourceMappingURL=tensor4d.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Round } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes round of input `tf.Tensor` element-wise: `round(x)`.\n * It implements banker's rounding.\n *\n * ```js\n * const x = tf.tensor1d([.6, 1.1, -3.3]);\n *\n * x.round().print();  // or tf.round(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction round_(x) {\n    const $x = convertToTensor(x, 'x', 'round');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Round, inputs);\n}\nexport const round = op({ round_ });\n//# sourceMappingURL=round.js.map","import { computeStrides, sizeFromShape } from '../util';\n/**\n * Check whether updates.shape = indices.shape[:batchDim] +\n * shape[sliceDim:]\n *\n * @param x The input tensor.\n */\nexport function validateUpdateShape(shape, indices, updates) {\n    const sliceDim = (indices.rank > 1) ? indices.shape[indices.rank - 1] : 1;\n    const batchDim = (indices.rank > 1) ? indices.rank - 1 : 1;\n    const shapeError = 'Must have updates.shape = indices.shape[:batchDim] + ' +\n        `shape[sliceDim:], got updates.shape: ${updates.shape}` +\n        `, indices.shape: ${indices.shape}, shape: ${shape}` +\n        `, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;\n    if (updates.rank < batchDim) {\n        throw new Error(shapeError + ` update.rank < ${batchDim}. `);\n    }\n    if (shape.length < sliceDim + (updates.rank - batchDim)) {\n        throw new Error(shapeError +\n            ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);\n    }\n    if (updates.rank !== batchDim + shape.length - sliceDim) {\n        throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);\n    }\n    for (let d = 0; d < batchDim; ++d) {\n        if (updates.shape[d] !== indices.shape[d]) {\n            throw new Error(shapeError +\n                ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);\n        }\n    }\n    for (let d = 0; d < updates.rank - batchDim; ++d) {\n        if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {\n            throw new Error(shapeError +\n                ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);\n        }\n    }\n}\n/**\n * Validate scatter nd inputs.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n */\nexport function validateInput(updates, indices, shape) {\n    if (indices.rank < 1) {\n        throw new Error('tf.scatterND() expects the indices to be rank 1 or higher,' +\n            ` but the rank was ${indices.rank}.`);\n    }\n    if (updates.rank < 1) {\n        throw new Error('tf.scatterND() expects the updates to be rank 1 or higher,' +\n            ` but the rank was ${updates.rank}.`);\n    }\n    if (indices.dtype !== 'int32') {\n        throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);\n    }\n    if (shape.length < 1) {\n        throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);\n    }\n    if (shape.length === 0) {\n        if (indices.size === 0) {\n            throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);\n        }\n        if (updates.size === 0) {\n            throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);\n        }\n    }\n    validateUpdateShape(shape, indices, updates);\n}\n/**\n * Calculate the shape information for the output.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n *\n * @returns ScatterShapeInfo\n */\nexport function calculateShapes(updates, indices, shape) {\n    // Calculate the number of dimensions in indices\n    const indicesRank = indices.shape.length;\n    const sliceRank = (indicesRank > 1) ? indices.shape[indicesRank - 1] : 1;\n    // Calculate the number of elements that make up each slice of our updated\n    // tensor. This allows us to work with flattened tensors and copy over whole\n    // slices at a time.\n    const totalNd = shape.length;\n    let sliceSize = 1;\n    for (let i = sliceRank; i < totalNd; ++i) {\n        sliceSize *= shape[i];\n    }\n    const safeSliceDim = (sliceRank < 1) ? 1 : sliceRank;\n    const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;\n    const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];\n    const outputSize = sizeFromShape(shape);\n    return { sliceRank, numUpdates, sliceSize, strides, outputSize };\n}\n//# sourceMappingURL=scatter_nd_util.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Selu } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes scaled exponential linear element-wise.\n *\n * `x < 0 ? scale * alpha * (exp(x) - 1) : x`\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n *\n * x.selu().print();  // or tf.selu(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction selu_(x) {\n    const $x = convertToTensor(x, 'x', 'selu');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Selu, inputs);\n}\nexport const selu = op({ selu_ });\n//# sourceMappingURL=selu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Softmax } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes the softmax normalized vector given the logits.\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n *\n * a.softmax().print();  // or tf.softmax(a)\n * ```\n *\n * ```js\n * const a = tf.tensor2d([2, 4, 6, 1, 2, 3], [2, 3]);\n *\n * a.softmax().print();  // or tf.softmax(a)\n * ```\n *\n * @param logits The logits array.\n * @param dim The dimension softmax would be performed on. Defaults to `-1`\n *     which indicates the last dimension.\n *\n * @doc {heading: 'Operations', subheading: 'Normalization'}\n */\nfunction softmax_(logits, dim = -1) {\n    const $logits = convertToTensor(logits, 'logits', 'softmax', 'float32');\n    if (dim === -1) {\n        dim = $logits.rank - 1;\n    }\n    if (dim !== $logits.rank - 1) {\n        throw Error('Softmax along a non-last dimension is not yet supported. ' +\n            `Logits was rank ${$logits.rank} and dim was ${dim}`);\n    }\n    const inputs = { logits: $logits };\n    const attrs = { dim };\n    return ENGINE.runKernel(Softmax, inputs, attrs);\n}\nexport const softmax = op({ softmax_ });\n//# sourceMappingURL=softmax.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\nimport { reverse } from './reverse';\n/**\n * Reverses a `tf.Tensor4D` along a specified axis.\n *\n * @param x The input tensor.\n * @param axis The set of dimensions to reverse. Must be in the\n *     range [-rank(x), rank(x)). Defaults to all axes.\n */\nfunction reverse4d_(x, axis) {\n    const $x = convertToTensor(x, 'x', 'reverse');\n    util.assert($x.rank === 4, () => `Error in reverse4D: x must be rank 4 but got rank ${$x.rank}.`);\n    return reverse($x, axis);\n}\nexport const reverse4d = op({ reverse4d_ });\n//# sourceMappingURL=reverse_4d.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport const SELU_SCALEALPHA = 1.7580993408473768599402175208123;\nexport const SELU_SCALE = 1.0507009873554804934193349852946;\n//# sourceMappingURL=selu_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Sigmoid } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes sigmoid element-wise, `1 / (1 + exp(-x))`\n *\n * ```js\n * const x = tf.tensor1d([0, -1, 2, -3]);\n *\n * x.sigmoid().print();  // or tf.sigmoid(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction sigmoid_(x) {\n    const $x = convertToTensor(x, 'x', 'sigmoid');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Sigmoid, inputs);\n}\nexport const sigmoid = op({ sigmoid_ });\n//# sourceMappingURL=sigmoid.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Returns the image center in pixels.\nexport function getImageCenter(center, imageHeight, imageWidth) {\n    const centerX = imageWidth * (typeof center === 'number' ? center : center[0]);\n    const centerY = imageHeight * (typeof center === 'number' ? center : center[1]);\n    return [centerX, centerY];\n}\n//# sourceMappingURL=rotate_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Inputs of size above this threshold will be parallelized by calling multiple\n * shader programs.\n */\nimport { nearestDivisor } from '../util';\nexport const PARALLELIZE_THRESHOLD = 30;\nexport function computeOptimalWindowSize(inSize) {\n    if (inSize <= PARALLELIZE_THRESHOLD) {\n        return inSize;\n    }\n    return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));\n}\n//# sourceMappingURL=reduce_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Sin } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes sin of the input Tensor element-wise: `sin(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);\n *\n * x.sin().print();  // or tf.sin(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction sin_(x) {\n    const $x = convertToTensor(x, 'x', 'sin');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Sin, inputs);\n}\nexport const sin = op({ sin_ });\n//# sourceMappingURL=sin.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\nexport function assertParamsValid(input, begin, size) {\n    const inputRank = input.shape.length;\n    util.assert(inputRank === begin.length, () => `Error in slice${inputRank}D: Length of begin ${begin} must ` +\n        `match the rank of the array (${inputRank}).`);\n    util.assert(inputRank === size.length, () => `Error in slice${inputRank}D: Length of size ${size} must ` +\n        `match the rank of the array (${inputRank}).`);\n    for (let i = 0; i < inputRank; ++i) {\n        util.assert(begin[i] + size[i] <= input.shape[i], () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` +\n            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${input.shape[i]})`);\n    }\n}\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask) {\n    const axes = [];\n    let axis = 0;\n    while (mask > 0) {\n        if (mask & 1) {\n            axes.push(axis);\n        }\n        mask /= 2;\n        axis++;\n    }\n    return axes;\n}\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(begin, end, strides) {\n    const size = [];\n    for (let axis = 0; axis < begin.length; axis++) {\n        size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n    }\n    return size;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(strides, ellipsisInsertionIndex, numElidedAxes, inputShape) {\n    const newStrides = [...strides];\n    for (let i = newStrides.length; i < inputShape.length; i++) {\n        newStrides.push(1);\n    }\n    for (let i = 0; i < numElidedAxes; i++) {\n        if (i === 0) {\n            newStrides[ellipsisInsertionIndex] = 1;\n        }\n        else {\n            newStrides.splice(ellipsisInsertionIndex, 0 /* num elements to delete */, 1 /* element to add */);\n            newStrides.pop();\n        }\n    }\n    return newStrides;\n}\nfunction unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, normalizedAxis) {\n    if (normalizedAxis <= ellipsisInsertionIndex) {\n        return normalizedAxis;\n    }\n    return normalizedAxis - (numElidedAxes - 1);\n}\nfunction getElidedAxes(numElidedAxes, ellipsisInsertionIndex) {\n    const elidedAxes = [];\n    for (let i = 0; i < numElidedAxes; i++) {\n        elidedAxes.push(ellipsisInsertionIndex + i);\n    }\n    return elidedAxes;\n}\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(inputShape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask) {\n    const inputRank = inputShape.length;\n    let normalizedBegin = new Array(inputRank), normalizedEnd = new Array(inputRank), normalizedStrides = new Array(inputRank);\n    if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n        const fullIndex = ellipsisAxes[0];\n        // The ellipsis applies to the masked index as well as any dimensions\n        // that are interpolated.\n        const numElidedAxes = numInterpolatedAxes + 1;\n        normalizedBegin = startIndicesWithElidedDims(beginMask, fullIndex, numElidedAxes, begin, inputShape);\n        normalizedEnd = stopIndicesWithElidedDims(endMask, fullIndex, numElidedAxes, end, inputShape);\n        normalizedStrides =\n            stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n    }\n    else {\n        for (let axis = 0; axis < inputRank; axis++) {\n            normalizedBegin[axis] = startForAxis(beginMask, begin, strides, inputShape, axis, ellipsisMask);\n            normalizedEnd[axis] =\n                stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n            normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n        }\n    }\n    return {\n        begin: normalizedBegin,\n        end: normalizedEnd,\n        strides: normalizedStrides\n    };\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(beginMask, ellipsisInsertionIndex, numElidedAxes, originalBegin, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = 0;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalBegin[originalAxis];\n            if (beginMask & 1 << originalAxis) {\n                originalValue = 0;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    return newIndices;\n}\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(endMask, ellipsisInsertionIndex, numElidedAxes, originalEnd, inputShape) {\n    const newIndices = [...inputShape];\n    const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n    for (let axis = 0; axis < newIndices.length; axis++) {\n        if (elidedAxes.indexOf(axis) > -1) {\n            newIndices[axis] = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            const originalAxis = unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n            let originalValue = originalEnd[originalAxis];\n            if (endMask & 1 << originalAxis) {\n                originalValue = Number.MAX_SAFE_INTEGER;\n            }\n            newIndices[axis] = originalValue;\n        }\n    }\n    for (let i = 0; i < newIndices.length; i++) {\n        // Handle negative indices\n        const axisSize = inputShape[i];\n        if (newIndices[i] < 0) {\n            newIndices[i] += axisSize;\n        }\n        newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n    }\n    return newIndices;\n}\nexport function stridesForAxis(strides, axis, ellipsisMask) {\n    let stride = strides[axis];\n    if (ellipsisMask & (1 << axis) || stride == null) {\n        stride = 1;\n    }\n    return stride;\n}\nexport function startForAxis(beginMask, startIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let start = startIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or the begin index is not set\n    // for the axis.\n    if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n        if (stride > 0) {\n            // Forward iteration - use the first element. These values will get\n            // clamped below (Note: We could have set them to 0 and axis_size-1, but\n            // use lowest() and max() to maintain symmetry with StopForAxis())\n            start = Number.MIN_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the last element.\n            start = Number.MAX_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (start < 0) {\n        start += axisSize;\n    }\n    // Clamping\n    start = util.clamp(0, start, axisSize - 1);\n    return start;\n}\nexport function stopForAxis(endMask, stopIndices, strides, inputShape, axis, ellipsisMask) {\n    // Begin with the specified index\n    let stop = stopIndices[axis];\n    const stride = strides[axis] || 1;\n    // Check the axis bit from right of masked axes, or if the stop index is not\n    // set for this axis.\n    if (endMask & (1 << axis) || ellipsisMask & (1 << axis) || stop == null) {\n        if (stride > 0) {\n            // Forward iteration - use the last element. These values will get\n            // clamped below\n            stop = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            // Backward iteration - use the first element.\n            stop = Number.MIN_SAFE_INTEGER;\n        }\n    }\n    // Handle negative indices\n    const axisSize = inputShape[axis];\n    if (stop < 0) {\n        stop += axisSize;\n    }\n    // Clamping\n    // Because the end index points one past the last element, we need slightly\n    // different clamping ranges depending on the direction.\n    if (stride > 0) {\n        // Forward iteration\n        stop = util.clamp(0, stop, axisSize);\n    }\n    else {\n        // Backward iteration\n        stop = util.clamp(-1, stop, axisSize - 1);\n    }\n    return stop;\n}\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(shape, begin, size) {\n    // Index of the first axis that has size > 1.\n    let firstNonOneAxis = size.length;\n    for (let i = 0; i < size.length; i++) {\n        if (size[i] > 1) {\n            firstNonOneAxis = i;\n            break;\n        }\n    }\n    for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n        if (begin[i] > 0 || size[i] !== shape[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function computeFlatOffset(begin, strides) {\n    let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n    for (let i = 0; i < begin.length - 1; i++) {\n        flatOffset += begin[i] * strides[i];\n    }\n    return flatOffset;\n}\nexport function parseSliceParams(x, begin, size) {\n    // The following logic allows for more ergonomic calls.\n    let begin_;\n    const xRank = x.shape.length;\n    if (typeof begin === 'number') {\n        begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n    }\n    else if (begin.length < xRank) {\n        begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n    }\n    else {\n        begin_ = begin.slice();\n    }\n    begin_.forEach(d => {\n        util.assert(d !== -1, () => 'slice() does not support negative begin indexing.');\n    });\n    let size_;\n    if (size == null) {\n        size_ = new Array(xRank).fill(-1);\n    }\n    else if (typeof size === 'number') {\n        size_ = [size, ...new Array(xRank - 1).fill(-1)];\n    }\n    else if (size.length < xRank) {\n        size_ = size.concat(new Array(xRank - size.length).fill(-1));\n    }\n    else {\n        size_ = size;\n    }\n    size_ = size_.map((d, i) => {\n        if (d >= 0) {\n            return d;\n        }\n        else {\n            util.assert(d === -1, () => `Negative size values should be exactly -1 but got ` +\n                `${d} for the slice() size at index ${i}.`);\n            return x.shape[i] - begin_[i];\n        }\n    });\n    return [begin_, size_];\n}\nexport function sliceInfo(xShape, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {\n    // make a copy because it may be modified further down.\n    let $begin = begin.slice();\n    let $end = end.slice();\n    let $strides = strides;\n    if (strides == null) {\n        $strides = new Array($begin.length);\n    }\n    const ellipsisAxes = maskToAxes(ellipsisMask);\n    if (ellipsisAxes.length > 1) {\n        throw new Error('Multiple ellipses in slice is not allowed.');\n    }\n    if (ellipsisMask !== 0 && newAxisMask !== 0) {\n        throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');\n    }\n    if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n        throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n    }\n    const numInterpolatedAxes = xShape.length - $begin.length;\n    // Expand the dims of x based on the newAxisMask.\n    const expandAxes = maskToAxes(newAxisMask);\n    const newShape = xShape.slice();\n    expandAxes.forEach(axis => {\n        $begin[axis] = 0;\n        $end[axis] = 1;\n        newShape.splice(axis, 0, 1);\n    });\n    const { begin: normalizedBegin, end: normalizedEnd, strides: normalizedStrides } = getNormalizedAxes(newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides, beginMask, endMask, ellipsisMask);\n    $begin = normalizedBegin;\n    $end = normalizedEnd;\n    $strides = normalizedStrides;\n    const shrinkAxes = maskToAxes(shrinkAxisMask);\n    // Adjust the ends based on the shrink mask.\n    shrinkAxes.forEach(axis => {\n        $end[axis] = $begin[axis] + 1;\n        $strides[axis] = 1;\n    });\n    // Figure out the output shape.\n    const size = computeOutShape($begin, $end, $strides);\n    // Remove the axes based on shrinkMask.\n    const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n    const nonStrided = $strides.every(v => v === 1);\n    return { nonStrided, $begin, $end, $strides, size, newShape, outShape };\n}\n//# sourceMappingURL=slice_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { inferShape } from '../tensor_util_env';\nimport { assertNonNull } from '../util';\nimport { makeTensor } from './tensor_ops_util';\n/**\n * Creates rank-5 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor5d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor5d([[[[[1],[2]],[[3],[4]]],[[[5],[6]],[[7],[8]]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor5d(values, shape, dtype) {\n    assertNonNull(values);\n    if (shape != null && shape.length !== 5) {\n        throw new Error('tensor5d() requires shape to have five numbers');\n    }\n    const inferredShape = inferShape(values, dtype);\n    if (inferredShape.length !== 5 && inferredShape.length !== 1) {\n        throw new Error('tensor5d() requires values to be ' +\n            'number[][][][][] or flat/TypedArray');\n    }\n    if (inferredShape.length === 1 && shape == null) {\n        throw new Error('tensor5d() requires shape to be provided when `values` ' +\n            'are a flat array');\n    }\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n//# sourceMappingURL=tensor5d.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\nimport { slice } from './slice';\n/**\n * Extracts a 3D slice from a 3D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\nfunction slice3d_(x, begin, size) {\n    const $x = convertToTensor(x, 'x', 'slice3d');\n    util.assert($x.rank === 3, () => `slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`);\n    return slice($x, begin, size);\n}\nexport const slice3d = op({ slice3d_ });\n//# sourceMappingURL=slice3d.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { FFT } from '../../kernel_names';\nimport { assert } from '../../util';\nimport { op } from '../operation';\n/**\n * Fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the inner-most\n * dimension of input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([1, 2, 3]);\n * const x = tf.complex(real, imag);\n *\n * x.fft().print();  // tf.spectral.fft(x).print();\n * ```\n * @param input The complex input to compute an fft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction fft_(input) {\n    assert(input.dtype === 'complex64', () => `The dtype for tf.spectral.fft() must be complex64 ` +\n        `but got ${input.dtype}.`);\n    const inputs = { input };\n    return ENGINE.runKernel(FFT, inputs);\n}\nexport const fft = op({ fft_ });\n//# sourceMappingURL=fft.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { inferShape } from '../tensor_util_env';\nimport { assertNonNull } from '../util';\nimport { makeTensor } from './tensor_ops_util';\n/**\n * Creates rank-3 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor3d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor3d([[[1], [2]], [[3], [4]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor3d([1, 2, 3, 4], [2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. If not provided,  it is inferred from\n *     `values`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor3d(values, shape, dtype) {\n    assertNonNull(values);\n    if (shape != null && shape.length !== 3) {\n        throw new Error('tensor3d() requires shape to have three numbers');\n    }\n    const inferredShape = inferShape(values, dtype);\n    if (inferredShape.length !== 3 && inferredShape.length !== 1) {\n        throw new Error('tensor3d() requires values to be number[][][] or flat/TypedArray');\n    }\n    if (inferredShape.length === 1 && shape == null) {\n        throw new Error('tensor3d() requires shape to be provided when `values` ' +\n            'are a flat array');\n    }\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n//# sourceMappingURL=tensor3d.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\nimport { reverse } from './reverse';\n/**\n * Reverses a `tf.Tensor2D` along a specified axis.\n *\n * @param x The input tensor.\n * @param axis The set of dimensions to reverse. Must be in the\n *     range [-rank(x), rank(x)). Defaults to all axes.\n */\nfunction reverse2d_(x, axis) {\n    const $x = convertToTensor(x, 'x', 'reverse');\n    util.assert($x.rank === 2, () => `Error in reverse2D: x must be rank 2 but got rank ${$x.rank}.`);\n    return reverse($x, axis);\n}\nexport const reverse2d = op({ reverse2d_ });\n//# sourceMappingURL=reverse_2d.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Range } from '../kernel_names';\n/**\n * Creates a new `tf.Tensor1D` filled with the numbers in the range provided.\n *\n * The tensor is a is half-open interval meaning it includes start, but\n * excludes stop. Decrementing ranges and negative step values are also\n * supported.sv\n *\n *\n * ```js\n * tf.range(0, 9, 2).print();\n * ```\n *\n * @param start An integer start value\n * @param stop An integer stop value\n * @param step An integer increment (will default to 1 or -1)\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function range(start, stop, step = 1, dtype = 'float32') {\n    if (step === 0) {\n        throw new Error('Cannot have a step of zero');\n    }\n    const attrs = { start, stop, step, dtype };\n    return ENGINE.runKernel(Range, {} /* inputs */, attrs);\n}\n//# sourceMappingURL=range.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { isTypedArray } from '../util';\nimport { makeTensor } from './tensor_ops_util';\n/**\n * Creates rank-0 `tf.Tensor` (scalar) with the provided value and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.scalar` as it makes the code more readable.\n *\n * ```js\n * tf.scalar(3.14).print();\n * ```\n *\n * @param value The value of the scalar.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function scalar(value, dtype) {\n    if (((isTypedArray(value) && dtype !== 'string') || Array.isArray(value)) &&\n        dtype !== 'complex64') {\n        throw new Error('Error creating a new Scalar: value must be a primitive ' +\n            '(number|boolean|string)');\n    }\n    if (dtype === 'string' && isTypedArray(value) &&\n        !(value instanceof Uint8Array)) {\n        throw new Error('When making a scalar from encoded string, ' +\n            'the value must be `Uint8Array`.');\n    }\n    const shape = [];\n    const inferredShape = [];\n    return makeTensor(value, shape, inferredShape, dtype);\n}\n//# sourceMappingURL=scalar.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes square of `x` element-wise: `x ^ 2`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, Math.sqrt(2), -1]);\n *\n * x.square().print();  // or tf.square(x)\n * ```\n * @param x The input Tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction square_(x) {\n    const $x = convertToTensor(x, 'x', 'square');\n    const attrs = {};\n    return ENGINE.runKernel('Square', { x: $x }, attrs);\n}\nexport const square = op({ square_ });\n//# sourceMappingURL=square.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { StridedSlice } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Extracts a strided slice of a tensor.\n *\n * Roughly speaking, this op extracts a slice of size (end-begin)/stride from\n * the given input tensor (x). Starting at the location specified by begin the\n * slice continues by adding stride to the index until all dimensions are not\n * less than end. Note that a stride can be negative, which causes a reverse\n * slice.\n *\n * ```js\n * const t = tf.tensor3d([1, 1, 1 ,2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6],\n *    [3, 2, 3]);\n * t.stridedSlice([1, 0, 0], [2, 1, 3], [1, 1, 1]).print()  // [[[3, 3, 3]]]\n * t.stridedSlice([1, 0, 0], [2, 2, 3], [1, 1, 1]).print()  // [[[3, 3, 3],\n *                                                     // [4, 4, 4]]]\n * t.stridedSlice([1, -1, 0], [2, -3, 3], [1, -1, 1]).print() // [[[4, 4, 4],\n *                                                     // [3, 3, 3]]]\n * ```\n *\n * @param x The tensor to stride slice.\n * @param begin The coordinates to start the slice from.\n * @param end: The coordinates to end the slice at.\n * @param strides: The size of the slice.\n * @param beginMask: If the ith bit of beginMask is set, begin[i] is ignored\n *      and the fullest possible range in that dimension is used instead.\n * @param endMask: If the ith bit of endMask is set, end[i] is ignored\n *      and the fullest possible range in that dimension is used instead.\n * @param shrinkAxisMask: a bitmask where bit i implies that\n * the ith specification should shrink the dimensionality. begin and end must\n * imply a slice of size 1 in the dimension.\n *\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\n */\nfunction stridedSlice_(x, begin, end, strides, beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0, shrinkAxisMask = 0) {\n    const $x = convertToTensor(x, 'x', 'stridedSlice');\n    const inputs = { x: $x };\n    const attrs = {\n        begin,\n        end,\n        strides,\n        beginMask,\n        endMask,\n        ellipsisMask,\n        newAxisMask,\n        shrinkAxisMask\n    };\n    return ENGINE.runKernel(StridedSlice, inputs, attrs);\n}\nexport const stridedSlice = op({ stridedSlice_ });\n//# sourceMappingURL=strided_slice.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { nearestDivisor } from '../util';\nimport { PARALLELIZE_THRESHOLD } from './reduce_util';\nexport function segOpComputeOptimalWindowSize(inSize, numSegments) {\n    let done = false;\n    let res;\n    if (inSize <= PARALLELIZE_THRESHOLD) {\n        res = inSize;\n        done = true;\n    }\n    else {\n        res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));\n    }\n    while (!done) {\n        if (res > numSegments || res === inSize) {\n            done = true;\n        }\n        else {\n            res = nearestDivisor(inSize, res + 1);\n        }\n    }\n    return res;\n}\nexport function computeOutShape(aShape, axis, numSegments) {\n    const outShape = [];\n    const rank = aShape.length;\n    for (let dim = 0; dim < rank; dim++) {\n        if (dim !== axis) {\n            outShape.push(aShape[dim]);\n        }\n        else {\n            outShape.push(numSegments);\n        }\n    }\n    return outShape;\n}\nexport function collectGatherOpShapeInfo(x, indices, axis, batchDims) {\n    const indicesRank = indices.shape.length;\n    const xRank = x.shape.length;\n    if (batchDims !== 0) {\n        if (batchDims < -indicesRank || batchDims > indicesRank) {\n            throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${indicesRank}], but got ${batchDims}`);\n        }\n    }\n    if (batchDims < 0) {\n        batchDims += indicesRank;\n    }\n    if (batchDims > xRank) {\n        throw new Error(`batchDims (${batchDims}) must be less than rank(x) (\n    ${xRank}).`);\n    }\n    if (axis < batchDims) {\n        throw new Error(`batchDims (${batchDims}) must be less than or equal to axis (${axis}).`);\n    }\n    for (let i = 0; i < batchDims; ++i) {\n        if (x.shape[i] !== indices.shape[i]) {\n            throw new Error(`x.shape[${i}]: ${x.shape[i]} should be equal to indices.shape[${i}]: ${indices.shape[i]}.`);\n        }\n    }\n    const dimSize = x.shape[axis];\n    const outputShape = [];\n    let batchSize = 1;\n    let outerSize = 1;\n    let sliceSize = 1;\n    for (let i = 0; i < batchDims; ++i) {\n        outputShape.push(x.shape[i]);\n        batchSize *= x.shape[i];\n    }\n    for (let i = batchDims; i < axis; i++) {\n        outputShape.push(x.shape[i]);\n        outerSize *= x.shape[i];\n    }\n    for (let i = batchDims; i < indicesRank; i++) {\n        outputShape.push(indices.shape[i]);\n    }\n    for (let i = axis + 1; i < xRank; i++) {\n        outputShape.push(x.shape[i]);\n        sliceSize *= x.shape[i];\n    }\n    return { batchSize, sliceSize, outerSize, dimSize, outputShape };\n}\n//# sourceMappingURL=segment_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\nimport { slice } from './slice';\n/**\n * Extracts a 1D slice from 1D array starting at coordinates `begin` and is\n * of length `size`. See `slice` for details.\n */\nfunction slice1d_(x, begin, size) {\n    const $x = convertToTensor(x, 'x', 'slice1d');\n    util.assert($x.rank === 1, () => `slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`);\n    return slice($x, [begin], [size]);\n}\nexport const slice1d = op({ slice1d_ });\n//# sourceMappingURL=slice1d.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Sign } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Returns an element-wise indication of the sign of a number.\n *\n * ```js\n * const x = tf.tensor1d([.6, 1.1, -3.3, NaN, 0]);\n *\n * x.sign().print();  // or tf.sign(x)\n * ```\n * @param x The input Tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction sign_(x) {\n    const $x = convertToTensor(x, 'x', 'sign');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Sign, inputs);\n}\nexport const sign = op({ sign_ });\n//# sourceMappingURL=sign.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Reverse } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Reverses a `tf.Tensor` along a specified axis.\n *\n * Also available are stricter rank-specific methods that assert that `x` is\n * of the given rank:\n *   - `tf.reverse1d`\n *   - `tf.reverse2d`\n *   - `tf.reverse3d`\n *   - `tf.reverse4d`\n *\n * Except `tf.reverse1d` (which does not have axis param), all methods have\n * same signature as this method.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.reverse().print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.reverse(axis).print();\n * ```\n * @param x The input tensor to be reversed.\n * @param axis The set of dimensions to reverse. Must be in the\n *     range [-rank(x), rank(x)). Defaults to all axes.\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction reverse_(x, axis) {\n    const $x = convertToTensor(x, 'x', 'reverse');\n    const inputs = { x: $x };\n    const attrs = { dims: axis };\n    return ENGINE.runKernel(Reverse, inputs, attrs);\n}\nexport const reverse = op({ reverse_ });\n//# sourceMappingURL=reverse.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { SquaredDifference } from '../kernel_names';\nimport { makeTypesMatch } from '../tensor_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport { assertAndGetBroadcastShape } from './broadcast_util';\nimport { op } from './operation';\n/**\n * Returns (a - b) * (a - b) element-wise.\n * Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([1, 4, 3, 16]);\n * const b = tf.tensor1d([1, 2, 9, 4]);\n *\n * a.squaredDifference(b).print();  // or tf.squaredDifference(a, b)\n * ```\n *\n * ```js\n * // Broadcast squared difference  a with b.\n * const a = tf.tensor1d([2, 4, 6, 8]);\n * const b = tf.scalar(5);\n *\n * a.squaredDifference(b).print();  // or tf.squaredDifference(a, b)\n * ```\n *\n * @param a The first tensor.\n * @param b The second tensor. Must have the same type as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction squaredDifference_(a, b) {\n    let $a = convertToTensor(a, 'a', 'squaredDifference');\n    let $b = convertToTensor(b, 'b', 'squaredDifference');\n    [$a, $b] = makeTypesMatch($a, $b);\n    assertAndGetBroadcastShape($a.shape, $b.shape);\n    const inputs = { a: $a, b: $b };\n    const attrs = {};\n    return ENGINE.runKernel(SquaredDifference, inputs, attrs);\n}\nexport const squaredDifference = op({ squaredDifference_ });\n//# sourceMappingURL=squared_difference.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Pack } from '../kernel_names';\nimport { convertToTensorArray } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\n/**\n * Stacks a list of rank-`R` `tf.Tensor`s into one rank-`(R+1)` `tf.Tensor`.\n *\n * ```js\n * const a = tf.tensor1d([1, 2]);\n * const b = tf.tensor1d([3, 4]);\n * const c = tf.tensor1d([5, 6]);\n * tf.stack([a, b, c]).print();\n * ```\n *\n * @param tensors A list of tensor objects with the same shape and dtype.\n * @param axis The axis to stack along. Defaults to 0 (the first dim).\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction stack_(tensors, axis = 0) {\n    const $tensors = convertToTensorArray(tensors, 'tensors', 'stack', 'string_or_numeric');\n    util.assert($tensors.length >= 1, () => 'Pass at least one tensor to tf.stack');\n    if ($tensors.length > 0) {\n        util.assert(axis <= $tensors[0].rank, () => 'Axis must be <= rank of the tensor');\n    }\n    const inputs = $tensors;\n    const attrs = { axis };\n    return ENGINE.runKernel(Pack, inputs, attrs);\n}\nexport const stack = op({ stack_ });\n//# sourceMappingURL=stack.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { mul } from '../mul';\nimport { op } from '../operation';\nimport { enclosingPowerOfTwo } from '../signal_ops_util';\nimport { rfft } from '../spectral/rfft';\nimport { frame } from './frame';\nimport { hannWindow } from './hann_window';\n/**\n * Computes the Short-time Fourier Transform of signals\n * See: https://en.wikipedia.org/wiki/Short-time_Fourier_transform\n *\n * ```js\n * const input = tf.tensor1d([1, 1, 1, 1, 1])\n * tf.signal.stft(input, 3, 1).print();\n * ```\n * @param signal 1-dimensional real value tensor.\n * @param frameLength The window length of samples.\n * @param frameStep The number of samples to step.\n * @param fftLength The size of the FFT to apply.\n * @param windowFn A callable that takes a window length and returns 1-d tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction stft_(signal, frameLength, frameStep, fftLength, windowFn = hannWindow) {\n    if (fftLength == null) {\n        fftLength = enclosingPowerOfTwo(frameLength);\n    }\n    const framedSignal = frame(signal, frameLength, frameStep);\n    const windowedSignal = mul(framedSignal, windowFn(frameLength));\n    return rfft(windowedSignal, fftLength);\n}\nexport const stft = op({ stft_ });\n//# sourceMappingURL=stft.js.map","import { assert } from '../util';\n/**\n * Prepare the split size array. When the input is a number, the axis is evenly\n * divided among the split size. When the input contains the negative value, the\n * rest of the axis is allocated toward that.\n */\nexport function prepareSplitSize(x, numOrSizeSplits, axis = 0) {\n    let splitSizes = [];\n    if (typeof (numOrSizeSplits) === 'number') {\n        assert(x.shape[axis] % numOrSizeSplits === 0, () => 'Number of splits must evenly divide the axis.');\n        splitSizes =\n            new Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);\n    }\n    else {\n        const numOfNegs = numOrSizeSplits.reduce((count, value) => {\n            if (value === -1) {\n                count += 1;\n            }\n            return count;\n        }, 0);\n        assert(numOfNegs <= 1, () => 'There should be only one negative value in split array.');\n        const negIndex = numOrSizeSplits.indexOf(-1);\n        // Allow the number of split array to be -1, which indicates the rest\n        // of dimension is allocated to that split.\n        if (negIndex !== -1) {\n            const total = numOrSizeSplits.reduce((a, b) => b > 0 ? a + b : a);\n            numOrSizeSplits[negIndex] = x.shape[axis] - total;\n        }\n        assert(x.shape[axis] === numOrSizeSplits.reduce((a, b) => a + b), () => 'The sum of sizes must match the size of the axis dimension.');\n        splitSizes = numOrSizeSplits;\n    }\n    return splitSizes;\n}\n//# sourceMappingURL=split_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Tanh } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes hyperbolic tangent of the input `tf.Tensor` element-wise: `tanh(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, 1, -1, 70]);\n *\n * x.tanh().print();  // or tf.tanh(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction tanh_(x) {\n    const $x = convertToTensor(x, 'x', 'tanh');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Tanh, inputs);\n}\nexport const tanh = op({ tanh_ });\n//# sourceMappingURL=tanh.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Sinh } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes hyperbolic sin of the input `tf.Tensor` element-wise: `sinh(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, 1, -1, .7]);\n *\n * x.sinh().print();  // or tf.sinh(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction sinh_(x) {\n    const $x = convertToTensor(x, 'x', 'sinh');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Sinh, inputs);\n}\nexport const sinh = op({ sinh_ });\n//# sourceMappingURL=sinh.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { inferShape } from '../tensor_util_env';\nimport { assertNonNull } from '../util';\nimport { makeTensor } from './tensor_ops_util';\n/**\n * Creates rank-1 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor1d` as it makes the code more readable.\n *\n * ```js\n * tf.tensor1d([1, 2, 3]).print();\n * ```\n *\n * @param values The values of the tensor. Can be array of numbers,\n *     or a `TypedArray`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor1d(values, dtype) {\n    assertNonNull(values);\n    const inferredShape = inferShape(values, dtype);\n    if (inferredShape.length !== 1) {\n        throw new Error('tensor1d() requires values to be a flat/TypedArray');\n    }\n    const shape = null;\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n//# sourceMappingURL=tensor1d.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\nimport { slice } from './slice';\n/**\n * Extracts a 4D slice from a 4D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\nfunction slice4d_(x, begin, size) {\n    const $x = convertToTensor(x, 'x', 'slice4d');\n    util.assert($x.rank === 4, () => `slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`);\n    return slice($x, begin, size);\n}\nexport const slice4d = op({ slice4d_ });\n//# sourceMappingURL=slice4d.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Reshape } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Reshapes a `tf.Tensor` to a given shape.\n *\n * Given an input tensor, returns a new tensor with the same values as the\n * input tensor with shape `shape`.\n *\n * If one component of shape is the special value -1, the size of that\n * dimension is computed so that the total size remains constant. In\n * particular, a shape of [-1] flattens into 1-D. At most one component of\n * shape can be -1.\n *\n * If shape is 1-D or higher, then the operation returns a tensor with shape\n * shape filled with the values of tensor. In this case, the number of\n * elements implied by shape must be the same as the number of elements in\n * tensor.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * x.reshape([2, 2]).print();\n * ```\n *\n * @param x The input tensor to be reshaped.\n * @param shape An array of integers defining the output tensor shape.\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction reshape_(x, shape) {\n    const $x = convertToTensor(x, 'x', 'reshape', 'string_or_numeric');\n    const inputs = { x: $x };\n    const attrs = { shape };\n    return ENGINE.runKernel(Reshape, inputs, attrs);\n}\nexport const reshape = op({ reshape_ });\n//# sourceMappingURL=reshape.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { sizeFromShape } from '../util';\nimport { op } from './operation';\n/**\n * Creates a `tf.Tensor` with values sampled from a random number generator\n * function defined by the user.\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param randFunction A random number generator function which is called\n * for each element in the output tensor.\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n *\n * @doc {heading: 'Tensors', subheading: 'Random'}\n */\nfunction rand_(shape, randFunction, dtype) {\n    const size = sizeFromShape(shape);\n    let values = null;\n    if (dtype == null || dtype === 'float32') {\n        values = new Float32Array(size);\n    }\n    else if (dtype === 'int32') {\n        values = new Int32Array(size);\n    }\n    else if (dtype === 'bool') {\n        values = new Uint8Array(size);\n    }\n    else {\n        throw new Error(`Unknown data type ${dtype}`);\n    }\n    for (let i = 0; i < size; i++) {\n        values[i] = randFunction();\n    }\n    return ENGINE.makeTensor(values, shape, dtype);\n}\nexport const rand = op({ rand_ });\n//# sourceMappingURL=rand.js.map","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { SparseFillEmptyRows } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * The input SparseTensor is represented via the map of inputs {`indices`,\n * `values`, `denseShape`}. The output SparseTensor has the same `denseShape`\n * but with indices `outputIndices` and values `outputValues`. This op inserts a\n * single entry for every row that doesn't have any values. The index is created\n * as `[row, 0, ..., 0]` and the inserted value is `defaultValue`.\n *\n * For example, suppose `spInput` has shape [5, 6] and non-empty values:\n * [0, 1]: a\n * [0, 3]: b\n * [2, 0]: c\n * [3, 1]: d\n *\n * Rows 1 and 4 are empty, so the output will be of shape [5, 6] with values:\n * [0, 1]: a\n * [0, 3]: b\n * [1, 0]: `defaultValue`\n * [2, 0]: c\n * [3, 1]: d\n * [4, 0]: `defaultValue`\n *\n * The output SparseTensor will be in row-major order and will have the same\n * shape as the input.\n *\n * This op also returns an indicator vector shaped [dense_shape[0]] such that\n * emptyRowIndicator[i] = True iff row i was an empty row.\n *\n * And a reverse index map vector shaped [indices.shape[0]] that is used during\n * backpropagation, reverseIndexMap[i] = outi s.t. indices[i, j] ==\n * outputIndices[outi, j] for all j\n *\n * ```js\n * const result = tf.sparse.sparseFillEmptyRows(\n *   [[0, 0], [1, 0], [1, 3], [1, 4], [3, 2], [3, 3]],\n *   [0, 10, 13, 14, 32, 33], [5, 6], -1);\n * console.log(result);\n * result['outputIndices'].print(); // [[0, 0], [1, 0], [1, 3], [1, 4],\n *                                  //  [2, 0], [3, 2], [3, 3], [4, 0]]\n * result['outputValues'].print(); // [0, 10, 13, 14,-1, 32, 33, -1]\n * result['emptyRowIndicator'].print(); // [0, 0, 1, 0, 1]\n * result['reverseIndexMap'].print(); // [0, 1, 2, 3, 5, 6]\n * ```\n * @param indices: 2-D. the indices of the sparse tensor.\n * @param values: 1-D. the values of the sparse tensor.\n * @param denseShape: 1-D. the shape of the sparse tensor.\n * @param defaultValue: 0-D. default value to insert into location [row, 0, ...,\n *     0] for rows missing from the input sparse tensor.\n * @return A map with the following properties:\n *     - outputIndices\n *     - outputValues: 1-D. the values of the filled sparse tensor.\n *     - emptyRowIndicator: 1-D. whether the dense row was missing in the input\n * sparse tensor.\n *     - reverseIndexMap: 1-D. a map from the input indices to the output\n * indices.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseFillEmptyRows_(indices, values, denseShape, defaultValue) {\n    const $indices = convertToTensor(indices, 'indices', 'sparseFillEmptyRows');\n    const $values = convertToTensor(values, 'values', 'sparseFillEmptyRows');\n    const $denseShape = convertToTensor(denseShape, 'denseShape', 'sparseFillEmptyRows');\n    const $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'sparseFillEmptyRows', $values.dtype);\n    if ($indices.rank !== 2) {\n        throw new Error(`Indices should be Tensor2D but received shape\n        ${$indices.shape}`);\n    }\n    if ($values.rank !== 1) {\n        throw new Error(`Values should be Tensor1D but received shape ${$values.shape}`);\n    }\n    if ($denseShape.rank !== 1) {\n        throw new Error(`Dense shape should be Tensor1D but received shape ${$denseShape.shape}`);\n    }\n    if ($defaultValue.rank !== 0) {\n        throw new Error(`Default value should be a scalar but received shape ${$defaultValue.shape}`);\n    }\n    const inputs = {\n        indices: $indices,\n        values: $values,\n        denseShape: $denseShape,\n        defaultValue: $defaultValue\n    };\n    const result = ENGINE.runKernel(SparseFillEmptyRows, inputs);\n    return {\n        outputIndices: result[0],\n        outputValues: result[1],\n        emptyRowIndicator: result[2],\n        reverseIndexMap: result[3]\n    };\n}\nexport const sparseFillEmptyRows = op({ sparseFillEmptyRows_ });\n//# sourceMappingURL=sparse_fill_empty_rows.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Prelu } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes leaky rectified linear element-wise with parametric alphas.\n *\n * `x < 0 ? alpha * x : f(x) = x`\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n * const alpha = tf.scalar(0.1);\n *\n * x.prelu(alpha).print();  // or tf.prelu(x, alpha)\n * ```\n * @param x The input tensor.\n * @param alpha Scaling factor for negative values.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction prelu_(x, alpha) {\n    const $x = convertToTensor(x, 'x', 'prelu');\n    const $alpha = convertToTensor(alpha, 'alpha', 'prelu');\n    const inputs = { x: $x, alpha: $alpha };\n    return ENGINE.runKernel(Prelu, inputs);\n}\nexport const prelu = op({ prelu_ });\n//# sourceMappingURL=prelu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Softplus } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes softplus of the input `tf.Tensor` element-wise: `log(exp(x) + 1)`\n *\n * ```js\n * const x = tf.tensor1d([0, 1, -1, .7]);\n *\n * x.softplus().print();  // or tf.softplus(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction softplus_(x) {\n    const $x = convertToTensor(x, 'x', 'softplus');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Softplus, inputs);\n}\nexport const softplus = op({ softplus_ });\n//# sourceMappingURL=softplus.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { SplitV } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Splits a `tf.Tensor` into sub tensors.\n *\n * If `numOrSizeSplits` is a number, splits `x` along dimension `axis`\n * into `numOrSizeSplits` smaller tensors.\n * Requires that `numOrSizeSplits` evenly divides `x.shape[axis]`.\n *\n * If `numOrSizeSplits` is a number array, splits `x` into\n * `numOrSizeSplits.length` pieces. The shape of the `i`-th piece has the\n * same size as `x` except along dimension `axis` where the size is\n * `numOrSizeSplits[i]`.\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4, 5, 6, 7, 8], [2, 4]);\n * const [a, b] = tf.split(x, 2, 1);\n * a.print();\n * b.print();\n *\n * const [c, d, e] = tf.split(x, [1, 2, 1], 1);\n * c.print();\n * d.print();\n * e.print();\n * ```\n *\n * @param x The input tensor to split.\n * @param numOrSizeSplits Either an integer indicating the number of\n * splits along the axis or an array of integers containing the sizes of\n * each output tensor along the axis. If a number then it must evenly divide\n * `x.shape[axis]`; otherwise the sum of sizes must match `x.shape[axis]`.\n * Can contain one -1 indicating that dimension is to be inferred.\n * @param axis The dimension along which to split. Defaults to 0 (the first\n * dim).\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction split_(x, numOrSizeSplits, axis = 0) {\n    const $x = convertToTensor(x, 'x', 'split');\n    const inputs = { x: $x };\n    const attr = { numOrSizeSplits, axis };\n    return ENGINE.runKernel(SplitV, inputs, attr);\n}\nexport const split = op({ split_ });\n//# sourceMappingURL=split.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Prod } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { cast } from './cast';\nimport { op } from './operation';\n/**\n * Computes the product of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If `axes` has no entries, all dimensions are reduced, and a\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.prod().print();  // or tf.prod(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.prod(axis).print();  // or tf.prod(x, axis)\n * ```\n *\n * @param x The input tensor to compute the product over. If the dtype is `bool`\n *   it will be converted to `int32` and the output dtype will be `int32`.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction prod_(x, axis = null, keepDims = false) {\n    let $x = convertToTensor(x, 'x', 'prod');\n    if ($x.dtype === 'bool') {\n        // bool is not an allowed type for the underlying kernel.\n        $x = cast($x, 'int32');\n    }\n    const inputs = { x: $x };\n    const attrs = { axis, keepDims };\n    return ENGINE.runKernel(Prod, inputs, attrs);\n}\nexport const prod = op({ prod_ });\n//# sourceMappingURL=prod.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { op } from '../operation';\nimport { cosineWindow } from '../signal_ops_util';\n/**\n * Generate a Hann window.\n *\n * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n *\n * ```js\n * tf.signal.hannWindow(10).print();\n * ```\n * @param The length of window\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction hannWindow_(windowLength) {\n    return cosineWindow(windowLength, 0.5, 0.5);\n}\nexport const hannWindow = op({ hannWindow_ });\n//# sourceMappingURL=hann_window.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { inferShape } from '../tensor_util_env';\nimport { makeTensor } from './tensor_ops_util';\n/**\n * Creates a `tf.Tensor` with the provided values, shape and dtype.\n *\n * ```js\n * // Pass an array of values to create a vector.\n * tf.tensor([1, 2, 3, 4]).print();\n * ```\n *\n * ```js\n * // Pass a nested array of values to make a matrix or a higher\n * // dimensional tensor.\n * tf.tensor([[1, 2], [3, 4]]).print();\n * ```\n *\n * ```js\n * // Pass a flat array and specify a shape yourself.\n * tf.tensor([1, 2, 3, 4], [2, 2]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`. If the values are strings,\n *     they will be encoded as utf-8 and kept as `Uint8Array[]`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor(values, shape, dtype) {\n    const inferredShape = inferShape(values, dtype);\n    return makeTensor(values, shape, inferredShape, dtype);\n}\n//# sourceMappingURL=tensor.js.map","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Prints information about the `tf.Tensor` including its data.\n *\n * ```js\n * const verbose = true;\n * tf.tensor2d([1, 2, 3, 4], [2, 2]).print(verbose);\n * ```\n * @param x The tensor to be printed.\n * @param verbose Whether to print verbose information about the ` Tensor`,\n * including dtype and size.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function print(x, verbose = false) {\n    console.log(x.toString(verbose));\n}\n//# sourceMappingURL=print.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Sub } from '../kernel_names';\nimport { makeTypesMatch } from '../tensor_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Subtracts two `tf.Tensor`s element-wise, A - B. Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([10, 20, 30, 40]);\n * const b = tf.tensor1d([1, 2, 3, 4]);\n *\n * a.sub(b).print();  // or tf.sub(a, b)\n * ```\n *\n * ```js\n * // Broadcast subtract a with b.\n * const a = tf.tensor1d([10, 20, 30, 40]);\n * const b = tf.scalar(5);\n *\n * a.sub(b).print();  // or tf.sub(a, b)\n * ```\n * @param a The first `tf.Tensor` to subtract from.\n * @param b The second `tf.Tensor` to be subtracted. Must have the same dtype as\n * `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction sub_(a, b) {\n    let $a = convertToTensor(a, 'a', 'sub');\n    let $b = convertToTensor(b, 'b', 'sub');\n    [$a, $b] = makeTypesMatch($a, $b);\n    const inputs = { a: $a, b: $b };\n    return ENGINE.runKernel(Sub, inputs);\n}\nexport const sub = op({ sub_ });\n//# sourceMappingURL=sub.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Tan } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes tan of the input `tf.Tensor` element-wise, `tan(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);\n *\n * x.tan().print();  // or tf.tan(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction tan_(x) {\n    const $x = convertToTensor(x, 'x', 'tan');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Tan, inputs);\n}\nexport const tan = op({ tan_ });\n//# sourceMappingURL=tan.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Sqrt } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes square root of the input `tf.Tensor` element-wise: `y = sqrt(x)`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 4, -1]);\n *\n * x.sqrt().print();  // or tf.sqrt(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction sqrt_(x) {\n    const $x = convertToTensor(x, 'x', 'sqrt');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Sqrt, inputs);\n}\nexport const sqrt = op({ sqrt_ });\n//# sourceMappingURL=sqrt.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from './buffer';\nimport { op } from './operation';\nimport { UniformRandom } from './rand_util';\n/**\n * Creates a `tf.Tensor` with values sampled from a uniform distribution.\n *\n * The generated values follow a uniform distribution in the range [minval,\n * maxval). The lower bound minval is included in the range, while the upper\n * bound maxval is excluded.\n *\n * ```js\n * tf.randomUniform([2, 2]).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param minval The lower bound on the range of random values to generate.\n *   Defaults to 0.\n * @param maxval The upper bound on the range of random values to generate.\n *   Defaults to 1.\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n *\n * @doc {heading: 'Tensors', subheading: 'Random'}\n */\nfunction randomUniform_(shape, minval = 0, maxval = 1, dtype = 'float32', seed) {\n    const res = buffer(shape, dtype);\n    const random = new UniformRandom(minval, maxval, null, seed);\n    for (let i = 0; i < res.values.length; i++) {\n        res.values[i] = random.nextValue();\n    }\n    return res.toTensor();\n}\nexport const randomUniform = op({ randomUniform_ });\n//# sourceMappingURL=random_uniform.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Relu6 } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes rectified linear 6 element-wise: `min(max(x, 0), 6)`.\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 8]);\n *\n * x.relu6().print();  // or tf.relu6(x)\n * ```\n * @param x The input tensor. If the dtype is `bool`, the output dtype will be\n *     `int32'.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction relu6_(x) {\n    const $x = convertToTensor(x, 'x', 'relu6');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Relu6, inputs);\n}\nexport const relu6 = op({ relu6_ });\n//# sourceMappingURL=relu6.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Sum } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { cast } from './cast';\nimport { op } from './operation';\n/**\n * Computes the sum of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If axes has no entries, all dimensions are reduced, and a\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.sum().print();  // or tf.sum(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.sum(axis).print();  // or tf.sum(x, axis)\n * ```\n *\n * @param x The input tensor to compute the sum over. If the dtype is `bool`\n *   it will be converted to `int32` and the output dtype will be `int32`.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction sum_(x, axis = null, keepDims = false) {\n    let $x = convertToTensor(x, 'x', 'sum');\n    if ($x.dtype === 'bool') {\n        $x = cast($x, 'int32');\n    }\n    const inputs = { x: $x };\n    const attrs = { axis, keepDims };\n    return ENGINE.runKernel(Sum, inputs, attrs);\n}\nexport const sum = op({ sum_ });\n//# sourceMappingURL=sum.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as seedrandom from 'seedrandom';\nimport { expectNumbersClose, testEpsilon } from '../test_util';\n// https://en.wikipedia.org/wiki/Marsaglia_polar_method\nexport class MPRandGauss {\n    constructor(mean, stdDeviation, dtype, truncated, seed) {\n        this.mean = mean;\n        this.stdDev = stdDeviation;\n        this.dtype = dtype;\n        this.nextVal = NaN;\n        this.truncated = truncated;\n        if (this.truncated) {\n            this.upper = this.mean + this.stdDev * 2;\n            this.lower = this.mean - this.stdDev * 2;\n        }\n        const seedValue = seed ? seed : Math.random();\n        this.random = seedrandom.alea(seedValue.toString());\n    }\n    /** Returns next sample from a Gaussian distribution. */\n    nextValue() {\n        if (!isNaN(this.nextVal)) {\n            const value = this.nextVal;\n            this.nextVal = NaN;\n            return value;\n        }\n        let resultX, resultY;\n        let isValid = false;\n        while (!isValid) {\n            let v1, v2, s;\n            do {\n                v1 = 2 * this.random() - 1;\n                v2 = 2 * this.random() - 1;\n                s = v1 * v1 + v2 * v2;\n            } while (s >= 1 || s === 0);\n            const mul = Math.sqrt(-2.0 * Math.log(s) / s);\n            resultX = this.mean + this.stdDev * v1 * mul;\n            resultY = this.mean + this.stdDev * v2 * mul;\n            if (!this.truncated || this.isValidTruncated(resultX)) {\n                isValid = true;\n            }\n        }\n        if (!this.truncated || this.isValidTruncated(resultY)) {\n            this.nextVal = this.convertValue(resultY);\n        }\n        return this.convertValue(resultX);\n    }\n    /** Handles proper rounding for non-floating-point numbers. */\n    convertValue(value) {\n        if (this.dtype == null || this.dtype === 'float32') {\n            return value;\n        }\n        return Math.round(value);\n    }\n    /** Returns true if less than 2-standard-deviations from the mean. */\n    isValidTruncated(value) {\n        return value <= this.upper && value >= this.lower;\n    }\n}\n// Marsaglia, George, and Wai Wan Tsang. 2000. \"A Simple Method for Generating\n// Gamma Variables.\"\nexport class RandGamma {\n    constructor(alpha, beta, dtype, seed) {\n        this.alpha = alpha;\n        this.beta = 1 / beta; // convert rate to scale parameter\n        this.dtype = dtype;\n        const seedValue = seed ? seed : Math.random();\n        this.randu = seedrandom.alea(seedValue.toString());\n        this.randn = new MPRandGauss(0, 1, dtype, false, this.randu());\n        if (alpha < 1) {\n            this.d = alpha + (2 / 3);\n        }\n        else {\n            this.d = alpha - (1 / 3);\n        }\n        this.c = 1 / Math.sqrt(9 * this.d);\n    }\n    /** Returns next sample from a gamma distribution. */\n    nextValue() {\n        let x2, v0, v1, x, u, v;\n        while (true) {\n            do {\n                x = this.randn.nextValue();\n                v = 1 + (this.c * x);\n            } while (v <= 0);\n            v *= v * v;\n            x2 = x * x;\n            v0 = 1 - (0.331 * x2 * x2);\n            v1 = (0.5 * x2) + (this.d * (1 - v + Math.log(v)));\n            u = this.randu();\n            if (u < v0 || Math.log(u) < v1) {\n                break;\n            }\n        }\n        v = (1 / this.beta) * this.d * v;\n        if (this.alpha < 1) {\n            v *= Math.pow(this.randu(), 1 / this.alpha);\n        }\n        return this.convertValue(v);\n    }\n    /** Handles proper rounding for non-floating-point numbers. */\n    convertValue(value) {\n        if (this.dtype === 'float32') {\n            return value;\n        }\n        return Math.round(value);\n    }\n}\nexport class UniformRandom {\n    constructor(min = 0, max = 1, dtype, seed) {\n        /** Handles proper rounding for non floating point numbers. */\n        this.canReturnFloat = () => (this.dtype == null || this.dtype === 'float32');\n        this.min = min;\n        this.range = max - min;\n        this.dtype = dtype;\n        if (seed == null) {\n            seed = Math.random();\n        }\n        if (typeof seed === 'number') {\n            seed = seed.toString();\n        }\n        if (!this.canReturnFloat() && this.range <= 1) {\n            throw new Error(`The difference between ${min} - ${max} <= 1 and dtype is not float`);\n        }\n        this.random = seedrandom.alea(seed);\n    }\n    convertValue(value) {\n        if (this.canReturnFloat()) {\n            return value;\n        }\n        return Math.round(value);\n    }\n    nextValue() {\n        return this.convertValue(this.min + this.range * this.random());\n    }\n}\nexport function jarqueBeraNormalityTest(values) {\n    // https://en.wikipedia.org/wiki/Jarque%E2%80%93Bera_test\n    const n = values.length;\n    const s = skewness(values);\n    const k = kurtosis(values);\n    const jb = n / 6 * (Math.pow(s, 2) + 0.25 * Math.pow(k - 3, 2));\n    // JB test requires 2-degress of freedom from Chi-Square @ 0.95:\n    // http://www.itl.nist.gov/div898/handbook/eda/section3/eda3674.htm\n    const CHI_SQUARE_2DEG = 5.991;\n    if (jb > CHI_SQUARE_2DEG) {\n        throw new Error(`Invalid p-value for JB: ${jb}`);\n    }\n}\nexport function expectArrayInMeanStdRange(actual, expectedMean, expectedStdDev, epsilon) {\n    if (epsilon == null) {\n        epsilon = testEpsilon();\n    }\n    const actualMean = mean(actual);\n    expectNumbersClose(actualMean, expectedMean, epsilon);\n    expectNumbersClose(standardDeviation(actual, actualMean), expectedStdDev, epsilon);\n}\nfunction mean(values) {\n    let sum = 0;\n    for (let i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n    return sum / values.length;\n}\nfunction standardDeviation(values, mean) {\n    let squareDiffSum = 0;\n    for (let i = 0; i < values.length; i++) {\n        const diff = values[i] - mean;\n        squareDiffSum += diff * diff;\n    }\n    return Math.sqrt(squareDiffSum / values.length);\n}\nfunction kurtosis(values) {\n    // https://en.wikipedia.org/wiki/Kurtosis\n    const valuesMean = mean(values);\n    const n = values.length;\n    let sum2 = 0;\n    let sum4 = 0;\n    for (let i = 0; i < n; i++) {\n        const v = values[i] - valuesMean;\n        sum2 += Math.pow(v, 2);\n        sum4 += Math.pow(v, 4);\n    }\n    return (1 / n) * sum4 / Math.pow((1 / n) * sum2, 2);\n}\nfunction skewness(values) {\n    // https://en.wikipedia.org/wiki/Skewness\n    const valuesMean = mean(values);\n    const n = values.length;\n    let sum2 = 0;\n    let sum3 = 0;\n    for (let i = 0; i < n; i++) {\n        const v = values[i] - valuesMean;\n        sum2 += Math.pow(v, 2);\n        sum3 += Math.pow(v, 3);\n    }\n    return (1 / n) * sum3 / Math.pow((1 / (n - 1)) * sum2, 3 / 2);\n}\n//# sourceMappingURL=rand_util.js.map","import { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { conv2d } from './conv2d';\nimport { depthwiseConv2d } from './depthwise_conv2d';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * 2-D convolution with separable filters.\n *\n * Performs a depthwise convolution that acts separately on channels followed\n * by a pointwise convolution that mixes channels. Note that this is\n * separability between dimensions [1, 2] and 3, not spatial separability\n * between dimensions 1 and 2.\n *\n * See\n * [https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d](\n *     https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d)\n * for more details.\n *\n * @param x The input tensor, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n * assumed.\n * @param depthwiseFilter The depthwise filter tensor, rank 4, of shape\n *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`. This is\n *     the filter used in the first step.\n * @param pointwiseFilter The pointwise filter tensor, rank 4, of shape\n *     `[1, 1, inChannels * channelMultiplier, outChannels]`. This is\n *     the filter used in the second step.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`. If strides is a single number, then `strideHeight ==\n * strideWidth`.\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *          https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels]. Only \"NHWC\" is currently supported.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction separableConv2d_(x, depthwiseFilter, pointwiseFilter, strides, pad, dilation = [1, 1], dataFormat = 'NHWC') {\n    const $x = convertToTensor(x, 'x', 'separableConv2d');\n    const $depthwiseFilter = convertToTensor(depthwiseFilter, 'depthwiseFilter', 'separableConv2d');\n    const $pointwiseFilter = convertToTensor(pointwiseFilter, 'pointwiseFilter', 'separableConv2d');\n    let x4D = $x;\n    let reshapedTo4D = false;\n    if ($x.rank === 3) {\n        reshapedTo4D = true;\n        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n    }\n    if (dataFormat === 'NCHW') {\n        throw new Error('separableConv2d currently does not support dataFormat NCHW; only ' +\n            'NHWC is supported');\n    }\n    util.assert(x4D.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got ` +\n        `rank ${x4D.rank}.`);\n    util.assert($depthwiseFilter.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but ` +\n        `got rank ${$depthwiseFilter.rank}.`);\n    util.assert($pointwiseFilter.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but ` +\n        `got rank ${$depthwiseFilter.rank}.`);\n    util.assert($pointwiseFilter.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter ` +\n        ` must be 1, but got ${$pointwiseFilter.shape[0]}.`);\n    util.assert($pointwiseFilter.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise ` +\n        `filter must be 1, but got ${$pointwiseFilter.shape[1]}.`);\n    const inChannels = $depthwiseFilter.shape[2];\n    const channelMultiplier = $depthwiseFilter.shape[3];\n    util.assert($pointwiseFilter.shape[2] === inChannels * channelMultiplier, () => `Error in separableConv2d: the third dimension of pointwise filter ` +\n        `must be ${inChannels * channelMultiplier}, ` +\n        `but got ${$pointwiseFilter.shape[2]}.`);\n    const depthwise = depthwiseConv2d(x4D, $depthwiseFilter, strides, pad, dataFormat, dilation);\n    const pointwiseStride = 1;\n    const res = conv2d(depthwise, $pointwiseFilter, pointwiseStride, 'valid', dataFormat);\n    if (reshapedTo4D) {\n        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);\n    }\n    return res;\n}\nexport const separableConv2d = op({ separableConv2d_ });\n//# sourceMappingURL=separable_conv2d.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Relu } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes rectified linear element-wise: `max(x, 0)`.\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n *\n * x.relu().print();  // or tf.relu(x)\n * ```\n * @param x The input tensor. If the dtype is `bool`, the output dtype will be\n *     `int32'.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction relu_(x) {\n    const $x = convertToTensor(x, 'x', 'relu');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Relu, inputs);\n}\nexport const relu = op({ relu_ });\n//# sourceMappingURL=relu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { ScatterNd } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\nimport * as scatter_nd_util from './scatter_nd_util';\n/**\n * Creates a new tensor by applying sparse updates to individual\n * values or slices within a zero tensor of the given shape tensor according to\n * indices. This operator is the inverse of the `tf.gatherND` operator which\n * extracts values or slices from a given tensor.\n *\n * ```js\n * const indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');\n * const updates = tf.tensor1d([9, 10, 11, 12]);\n * const shape = [8];\n * tf.scatterND(indices, updates, shape).print() //[0, 11, 0, 10, 9, 0, 0, 12]\n * ```\n *\n * @param indices The tensor contains the indices into the output tensor.\n * @param updates The tensor contains the value for the indices.\n * @param shape: The shape of the output tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\n */\nfunction scatterND_(indices, updates, shape) {\n    const $indices = convertToTensor(indices, 'indices', 'scatterND', 'int32');\n    const $updates = convertToTensor(updates, 'updates', 'scatterND');\n    scatter_nd_util.validateInput($updates, $indices, shape);\n    const inputs = { indices: $indices, updates: $updates };\n    const attrs = { shape };\n    // tslint:disable-next-line: no-unnecessary-type-assertion\n    return ENGINE.runKernel(ScatterNd, inputs, attrs);\n}\nexport const scatterND = op({ scatterND_ });\n//# sourceMappingURL=scatter_nd.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { SparseToDense } from '../kernel_names';\nimport * as sparse_to_dense from '../ops/sparse_to_dense_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Converts a sparse representation into a dense tensor.\n *\n * Builds an array dense with shape outputShape such that:\n *\n * // If sparseIndices is scalar\n * dense[i] = (i == sparseIndices ? sparseValues : defaultValue)\n *\n * // If sparseIndices is a vector, then for each i\n * dense[sparseIndices[i]] = sparseValues[i]\n *\n * // If sparseIndices is an n by d matrix, then for each i in [0, n)\n * dense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i]\n * All other values in dense are set to defaultValue. If sparseValues is a\n * scalar, all sparse indices are set to this single value.\n *\n * If indices are repeated the final value is summed over all values for those\n * indices.\n *\n * ```js\n * const indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');\n * const values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');\n * const shape = [8];\n * tf.sparseToDense(indices, values, shape).print();\n * ```\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape Shape of the dense output tensor. the type is inferred.\n * @param defaultValue Scalar. Value to set for indices not specified in\n * sparseIndices. Defaults to zero.\n *\n * @doc {heading: 'Operations', subheading: 'Normalization'}\n */\nfunction sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue = 0) {\n    const $sparseIndices = convertToTensor(sparseIndices, 'sparseIndices', 'sparseToDense', 'int32');\n    const $sparseValues = convertToTensor(sparseValues, 'sparseValues', 'sparseToDense');\n    const $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'sparseToDense', $sparseValues.dtype);\n    sparse_to_dense.validateInput($sparseIndices, $sparseValues, outputShape, $defaultValue);\n    const inputs = {\n        sparseIndices: $sparseIndices,\n        sparseValues: $sparseValues,\n        defaultValue: $defaultValue\n    };\n    const attrs = { outputShape };\n    return ENGINE.runKernel(SparseToDense, inputs, attrs);\n}\nexport const sparseToDense = op({ sparseToDense_ });\n//# sourceMappingURL=sparse_to_dense.js.map","/**\n * Validate sparseToDense inputs.\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape number[]. Shape of the dense output tensor.\n * @param validateIndices boolean. indice validation is not supported, error\n * will be thrown if it is set.\n */\nexport function validateInput(sparseIndices, sparseValues, outputShape, defaultValues) {\n    if (sparseIndices.dtype !== 'int32') {\n        throw new Error('tf.sparseToDense() expects the indices to be int32 type,' +\n            ` but the dtype was ${sparseIndices.dtype}.`);\n    }\n    if (sparseIndices.rank > 2) {\n        throw new Error('sparseIndices should be a scalar, vector, or matrix,' +\n            ` but got shape ${sparseIndices.shape}.`);\n    }\n    const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\n    const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\n    if (outputShape.length !== numDims) {\n        throw new Error('outputShape has incorrect number of elements:,' +\n            ` ${outputShape.length}, should be: ${numDims}.`);\n    }\n    const numValues = sparseValues.size;\n    if (!(sparseValues.rank === 0 ||\n        sparseValues.rank === 1 && numValues === numElems)) {\n        throw new Error('sparseValues has incorrect shape ' +\n            `${sparseValues.shape}, should be [] or [${numElems}]`);\n    }\n    if (sparseValues.dtype !== defaultValues.dtype) {\n        throw new Error('sparseValues.dtype must match defaultValues.dtype');\n    }\n}\n//# sourceMappingURL=sparse_to_dense_util.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { op } from '../operation';\nimport { cosineWindow } from '../signal_ops_util';\n/**\n * Generate a hamming window.\n *\n * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n *\n * ```js\n * tf.signal.hammingWindow(10).print();\n * ```\n * @param The length of window\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction hammingWindow_(windowLength) {\n    return cosineWindow(windowLength, 0.54, 0.46);\n}\nexport const hammingWindow = op({ hammingWindow_ });\n//# sourceMappingURL=hamming_window.js.map"],"names":["real","op","real_","input","inputs","runKernel","squeeze","squeeze_","x","axis","$x","shape","newShape","slice2d","slice2d_","begin","size","rank","randomGamma","randomGamma_","alpha","beta","dtype","seed","Error","rgamma","res","i","values","length","nextValue","toTensor","reverse1d","reverse1d_","rfft","rfft_","fftLength","innerDimensionSize","batch","adjustedInput","map","v","zerosShape","zerosInput","complexInput","ret","half","Math","floor","realValues","imagValues","realComplexConjugate","imagComplexConjugate","outputShape","slice","tensor6d","inferredShape","step","step_","attrs","spaceToBatchND","spaceToBatchND_","blockShape","paddings","reduce","a","b","toString","ifft","ifft_","frame","frame_","signal","frameLength","frameStep","padEnd","padValue","start","output","push","padLen","pad","sparseReshape","sparseReshape_","inputIndices","inputShape","$inputIndices","$inputShape","$newShape","result","outputIndices","reverse3d","reverse3d_","rsqrt","rsqrt_","slice_","enclosingPowerOfTwo","value","pow","ceil","log","cosineWindow","windowLength","even","newValues","Float32Array","cosArg","PI","cos","t","tensor2d","makeTensor","Array","isArray","providedSize","inferredSize","inferred","flatDimsDontMatch","toTypedArray","reciprocal","reciprocal_","irfft","irfft_","realInput","imagInput","realConjugate","imagConjugate","r","temp","dispose","setdiff1dAsync","async","y","$y","xVals","data","yVals","ySet","Set","outputSize","has","buffer","indices","p","randomNormal","randomNormal_","mean","stdDev","randGauss","tensor4d","round","round_","validateUpdateShape","updates","sliceDim","batchDim","shapeError","d","validateInput","calculateShapes","indicesRank","sliceRank","totalNd","sliceSize","safeSliceDim","numUpdates","strides","selu","selu_","softmax","softmax_","logits","dim","$logits","reverse4d","reverse4d_","SELU_SCALEALPHA","SELU_SCALE","sigmoid","sigmoid_","getImageCenter","center","imageHeight","imageWidth","PARALLELIZE_THRESHOLD","computeOptimalWindowSize","inSize","sqrt","sin","sin_","assertParamsValid","inputRank","maskToAxes","mask","axes","computeOutShape","end","stridesWithElidedDims","ellipsisInsertionIndex","numElidedAxes","newStrides","splice","pop","unnormalizeAxis","normalizedAxis","getElidedAxes","elidedAxes","getNormalizedAxes","ellipsisAxes","numInterpolatedAxes","beginMask","endMask","ellipsisMask","normalizedBegin","normalizedEnd","normalizedStrides","fullIndex","startIndicesWithElidedDims","stopIndicesWithElidedDims","startForAxis","stopForAxis","stridesForAxis","originalBegin","newIndices","indexOf","originalAxis","originalValue","originalEnd","Number","MAX_SAFE_INTEGER","axisSize","stride","startIndices","MIN_SAFE_INTEGER","stopIndices","stop","isSliceContinous","firstNonOneAxis","computeFlatOffset","flatOffset","parseSliceParams","begin_","xRank","size_","fill","concat","forEach","sliceInfo","xShape","newAxisMask","shrinkAxisMask","$begin","$end","$strides","expandAxes","shrinkAxes","outShape","filter","_","nonStrided","every","tensor5d","slice3d","slice3d_","fft","fft_","tensor3d","reverse2d","reverse2d_","range","scalar","Uint8Array","square","square_","stridedSlice","stridedSlice_","segOpComputeOptimalWindowSize","numSegments","done","aShape","collectGatherOpShapeInfo","batchDims","dimSize","batchSize","outerSize","slice1d","slice1d_","sign","sign_","reverse","reverse_","dims","squaredDifference","squaredDifference_","$a","$b","makeTypesMatch","stack","stack_","tensors","$tensors","stft","stft_","windowFn","framedSignal","windowedSignal","prepareSplitSize","numOrSizeSplits","splitSizes","numOfNegs","count","negIndex","total","tanh","tanh_","sinh","sinh_","tensor1d","slice4d","slice4d_","reshape","reshape_","rand","rand_","randFunction","Int32Array","sparseFillEmptyRows","sparseFillEmptyRows_","denseShape","defaultValue","$indices","$values","$denseShape","$defaultValue","outputValues","emptyRowIndicator","reverseIndexMap","prelu","prelu_","softplus","softplus_","split","split_","attr","prod","prod_","keepDims","hannWindow","hannWindow_","tensor","print","verbose","sub","sub_","tan","tan_","sqrt_","randomUniform","randomUniform_","minval","maxval","random","relu6","relu6_","sum","sum_","MPRandGauss","constructor","stdDeviation","truncated","this","nextVal","NaN","upper","lower","seedValue","isNaN","resultX","resultY","isValid","v1","v2","s","mul","isValidTruncated","convertValue","RandGamma","randu","randn","c","x2","v0","u","UniformRandom","min","max","canReturnFloat","separableConv2d","separableConv2d_","depthwiseFilter","pointwiseFilter","dilation","dataFormat","$depthwiseFilter","$pointwiseFilter","x4D","reshapedTo4D","inChannels","channelMultiplier","depthwise","relu","relu_","scatterND","scatterND_","$updates","sparseToDense","sparseToDense_","sparseIndices","sparseValues","$sparseIndices","$sparseValues","defaultValues","numElems","numDims","numValues","hammingWindow","hammingWindow_"],"sourceRoot":""}