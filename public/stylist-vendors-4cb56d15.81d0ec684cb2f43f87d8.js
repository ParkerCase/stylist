"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[4109],{14899:function(e,n,s){s.d(n,{CN:function(){return o},DH:function(){return u},HK:function(){return i}});var t=s(9495),a=s(22897),r=s(46334);const u="return (a < 0.) ? b * a : a;",o="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const i={kernelName:t.Prelu,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:s}=e,{x:i,alpha:c}=n,p=(0,t.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new r.VI(o,i.shape,c.shape):new a.x(u,i.shape,c.shape);return s.runWebGLProgram(p,[i,c],"float32")}}},48223:function(e,n,s){s.d(n,{j:function(){return i}});var t=s(9495),a=s(46334),r=s(15411);const u="\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+a.qq+"\n  return result;\n",o=(0,r.j0)({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:u}),i={kernelName:t.Pow,backendName:"webgl",kernelFunc:o}},74952:function(e,n,s){s.d(n,{S:function(){return i}});var t=s(9495),a=s(68754),r=s(76905),u=s(94043),o=s(58246);const i={kernelName:t.Prod,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:s,attrs:i}=e,{x:c}=n,{axis:p,keepDims:l}=i,d=c.shape.length,b=[],h=t.util.parseAxisParam(p,c.shape);let N=h;const k=t.backend_util.getAxesPermutation(N,d);let m,f=c;if(null!=k&&(f=(0,o.m)({inputs:{x:c},backend:s,attrs:{perm:k}}),N=t.backend_util.getInnerMostAxes(N.length,d),b.push(f)),t.backend_util.assertAxesAreInnerMostDims("prod",N,d),s.shouldExecuteOnCPU([f])){const e=s.texData.get(f.dataId).values,{outVals:n,outShape:t,outDtype:a}=(0,r.Og)(f.shape,f.dtype,e,N);m=s.makeTensorInfo(t,a,n)}else{const[e,n]=t.backend_util.computeOutAndReduceShapes(f.shape,N),r=t.util.sizeFromShape(n),o=(0,u.t)({inputs:{x:f},backend:s,attrs:{shape:[-1,r]}}),i=(0,t.sumOutType)(c.dtype),p=(0,a.T)(o,i,"prod",s);m=(0,u.t)({inputs:{x:p},backend:s,attrs:{shape:e}}),b.push(o),b.push(p)}if(l){b.push(m);const e=t.backend_util.expandShapeToKeepDim(m.shape,h);m=(0,u.t)({inputs:{x:m},backend:s,attrs:{shape:e}})}return b.forEach((e=>s.disposeIntermediateTensorInfo(e))),m}}}}]);
//# sourceMappingURL=stylist-vendors-4cb56d15.81d0ec684cb2f43f87d8.js.map