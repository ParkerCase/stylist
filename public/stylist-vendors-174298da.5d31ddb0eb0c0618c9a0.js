"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[941],{1903:function(t,e,n){n.d(e,{Y:function(){return s}});var a=n(9495),o=n(86995);const s={kernelName:a.DenseBincount,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:a}=t,{x:s,weights:i}=e,{size:r,binaryOutput:d}=a;if(1===s.shape.length){const t=n.data.get(s.dataId).values,e=n.data.get(i.dataId).values,a=(0,o.X)(t,e,i.dtype,i.shape,r);return n.makeTensorInfo([r],i.dtype,a)}if(2===s.shape.length){const t=n.bufferSync(s),e=n.bufferSync(i),a=(0,o.N)(t,e,r,d);return n.makeTensorInfo(a.shape,i.dtype,a.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}}},6941:function(t,e,n){n.d(e,{e:function(){return s}});var a=n(9495),o=n(97870);const s={kernelName:a.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:i,filter:r}=e,{pad:d,strides:l,inputShape:c}=s;(0,o.C)([i],"conv3dBackpropInputV2");const u=a.util.computeStrides(i.shape),h=a.util.computeStrides(r.shape),f=a.backend_util.computeConv3DInfo(c,r.shape,l,1,d),p=new a.TensorBuffer(f.inShape,"float32"),m=p.values,[k,v,g,I]=p.strides,b=n.data.get(i.dataId).values,[C,M,S,x]=u,W=n.data.get(r.dataId).values,[y,D,H,N]=h,{batchSize:T,filterDepth:F,filterHeight:w,filterWidth:B,inChannels:_,inDepth:z,inHeight:A,inWidth:$,outChannels:R,outDepth:P,outHeight:E,outWidth:O,strideDepth:V,strideHeight:U,strideWidth:L}=f,G=F-1-f.padInfo.front,J=w-1-f.padInfo.top,X=B-1-f.padInfo.left;for(let a=0;a<T;++a)for(let t=0;t<_;++t)for(let e=0;e<z;++e){const n=e-G,o=Math.max(0,Math.ceil(n/V)),s=Math.min(P,(F+n)/V);for(let i=0;i<A;++i){const r=i-J,d=Math.max(0,Math.ceil(r/U)),l=Math.min(E,(w+r)/U);for(let c=0;c<$;++c){const u=c-X,h=Math.max(0,Math.ceil(u/L)),f=Math.min(O,(B+u)/L);let p=0;for(let e=o;e<s;++e){const o=e*V-n;for(let n=d;n<l;++n){const s=n*U-r;for(let i=h;i<f;++i){const r=C*a+M*e+S*n+x*i,d=y*(F-1-o)+D*(w-1-s)+H*(B-1-(i*L-u))+N*t;for(let t=0;t<R;++t){p+=b[r+t]*W[d+t]}}}}m[k*a+v*e+g*i+I*c+t]=p}}}return n.makeTensorInfo(p.shape,p.dtype,p.values)}}},11355:function(t,e,n){n.d(e,{k:function(){return s}});var a=n(9495);const o=(0,n(21694).v)(a.Cosh,(t=>Math.cosh(t))),s={kernelName:a.Cosh,backendName:"cpu",kernelFunc:o}},14666:function(t,e,n){n.d(e,{n:function(){return s}});var a=n(9495),o=n(97870);const s={kernelName:a.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:i,dy:r}=e,{strides:d,dilations:l,pad:c,dimRoundingMode:u,filterShape:h}=s;(0,o.C)([i,r],"depthwiseConv2dNativeBackpropFilter");const f=a.backend_util.computeConv2DInfo(i.shape,h,d,l,c,u,!0),{strideHeight:p,strideWidth:m,filterHeight:k,filterWidth:v}=f,g=new a.TensorBuffer(f.filterShape,"float32"),I=f.padInfo.left,b=f.padInfo.top,C=f.outChannels/f.inChannels,M=n.data.get(i.dataId).values,S=new a.TensorBuffer(i.shape,i.dtype,M),x=n.data.get(r.dataId).values,W=new a.TensorBuffer(r.shape,r.dtype,x);for(let a=0;a<k;++a){const t=Math.max(0,Math.ceil((b-a)/p)),e=Math.min(f.outHeight,(f.inHeight+b-a)/p);for(let n=0;n<v;++n){const o=Math.max(0,Math.ceil((I-n)/m)),s=Math.min(f.outWidth,(f.inWidth+I-n)/m);for(let i=0;i<f.outChannels;++i){const r=Math.trunc(i/C),d=i%C;let l=0;for(let c=0;c<f.batchSize;++c)for(let d=t;d<e;++d){const t=a+d*p-b;for(let e=o;e<s;++e){const a=n+e*m-I;l+=S.get(c,t,a,r)*W.get(c,d,e,i)}}g.set(l,a,n,r,d)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}}},23530:function(t,e,n){n.d(e,{r:function(){return s}});var a=n(9495),o=n(97870);const s={kernelName:a.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:i,dy:r}=e,{strides:d,pad:l,dataFormat:c,dimRoundingMode:u,filterShape:h}=s;(0,o.C)([i,r],"conv2dBackpropFilter");const f=a.backend_util.convertConv2DDataFormat(c),p=a.backend_util.computeConv2DInfo(i.shape,h,d,1,l,u,!1,f),{strideHeight:m,strideWidth:k,filterHeight:v,filterWidth:g}=p,I="channelsLast"===p.dataFormat,b=new a.TensorBuffer(p.filterShape,"float32"),C=p.padInfo.left,M=p.padInfo.top,S=n.data.get(i.dataId).values,x=n.data.get(r.dataId).values,W=new a.TensorBuffer(i.shape,i.dtype,S),y=new a.TensorBuffer(r.shape,r.dtype,x);for(let a=0;a<v;++a){const t=Math.max(0,Math.ceil((M-a)/m)),e=Math.min(p.outHeight,(p.inHeight+M-a)/m);for(let n=0;n<g;++n){const o=Math.max(0,Math.ceil((C-n)/k)),s=Math.min(p.outWidth,(p.inWidth+C-n)/k);for(let i=0;i<p.inChannels;++i)for(let r=0;r<p.outChannels;++r){let d=0;for(let l=0;l<p.batchSize;++l)for(let c=t;c<e;++c){const t=a+c*m-M;for(let e=o;e<s;++e){const a=n+e*k-C;d+=I?W.get(l,t,a,i)*y.get(l,c,e,r):W.get(l,i,t,a)*y.get(l,r,c,e)}}b.set(d,a,n,i,r)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}}},33910:function(t,e,n){n.d(e,{f:function(){return s}});var a=n(9495),o=n(97870);const s={kernelName:a.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:i,filter:r}=e,{inputShape:d,strides:l,pad:c,dataFormat:u,dimRoundingMode:h}=s;(0,o.C)([i,r],"conv2dBackpropInput");const f=a.util.computeStrides(r.shape),p=a.util.computeStrides(i.shape);let m=a.backend_util.convertConv2DDataFormat(u);const k=a.backend_util.computeConv2DInfo(d,r.shape,l,1,c,h,!1,m),v=new a.TensorBuffer(k.inShape,"float32"),g=v.values,I=n.data.get(i.dataId).values,b=n.data.get(r.dataId).values,[C,M,S]=f,{batchSize:x,filterHeight:W,filterWidth:y,inChannels:D,inHeight:H,inWidth:N,outChannels:T,outHeight:F,outWidth:w,strideHeight:B,strideWidth:_}=k;m=k.dataFormat;const z=W-1-k.padInfo.top,A=y-1-k.padInfo.left,$="channelsLast"===m,R=v.strides[0],P=$?v.strides[1]:v.strides[2],E=$?v.strides[2]:1,O=$?1:v.strides[1],V=p[0],U=$?p[1]:p[2],L=$?p[2]:1,G=$?1:p[1];for(let a=0;a<x;++a)for(let t=0;t<D;++t)for(let e=0;e<H;++e){const n=e-z,o=Math.max(0,Math.ceil(n/B)),s=Math.min(F,(W+n)/B);for(let i=0;i<N;++i){const r=i-A,d=Math.max(0,Math.ceil(r/_)),l=Math.min(w,(y+r)/_);let c=0;for(let e=o;e<s;++e){const o=e*B-n;for(let n=d;n<l;++n){const s=V*a+U*e+L*n,i=C*(W-1-o)+M*(y-1-(n*_-r))+S*t;for(let t=0;t<T;++t){c+=I[s+G*t]*b[i+t]}}}g[R*a+P*e+E*i+O*t]=c}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}}},41347:function(t,e,n){n.d(e,{o:function(){return s}});var a=n(9495);const o=(0,n(21694).v)(a.Cos,(t=>Math.cos(t))),s={kernelName:a.Cos,backendName:"cpu",kernelFunc:o}},43898:function(t,e,n){n.d(e,{J:function(){return s},x:function(){return i}});var a=n(9495),o=n(97870);function s(t){const{inputs:e,backend:n,attrs:s}=t,{x:i,filter:r}=e,{strides:d,pad:l,dataFormat:c,dilations:u,dimRoundingMode:h}=s;(0,o.C)([i,r],"conv2d");const f=a.backend_util.convertConv2DDataFormat(c),p=a.backend_util.computeConv2DInfo(i.shape,r.shape,d,u,l,h,!1,f),m=p.filterHeight,k=p.filterWidth,v=p.dilationHeight,g=p.dilationWidth,I=p.padInfo.left,b=p.padInfo.top,C="channelsLast"===p.dataFormat,M=new a.TensorBuffer(p.outShape,i.dtype),S=a.util.computeStrides(i.shape),x=a.util.computeStrides(r.shape),W=S[0],y=C?S[1]:S[2],D=C?S[2]:1,H=C?1:S[1],N=M.strides[0],T=C?M.strides[1]:M.strides[2],F=C?M.strides[2]:1,w=C?1:M.strides[1],B=n.data.get(i.dataId).values,_=n.data.get(r.dataId).values,z=M.values;for(let a=0;a<p.batchSize;++a){const t=a*W,e=a*N;for(let n=0;n<p.outHeight;++n){const a=e+n*T,o=n*p.strideHeight-b;for(let e=0;e<m;++e){const n=o+e*v;if(n<0||n>=p.inHeight)continue;const s=e*x[0],i=t+n*y;for(let t=0;t<p.outWidth;++t){const e=a+t*F,n=t*p.strideWidth-I;for(let t=0;t<k;++t){const a=n+t*g;if(a<0||a>=p.inWidth)continue;const o=i+a*D;let r=s+t*x[1];for(let t=0;t<p.inChannels;++t){const n=B[o+t*H];for(let t=0;t<p.outChannels;++t)z[e+t*w]+=n*_[r+t];r+=p.outChannels}}}}}}return n.makeTensorInfo(M.shape,M.dtype,z)}const i={kernelName:a.Conv2D,backendName:"cpu",kernelFunc:s}},45655:function(t,e,n){n.d(e,{i:function(){return s}});var a=n(9495),o=n(97870);const s={kernelName:a.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:i,dy:r}=e,{strides:d,pad:l,filterShape:c}=s;(0,o.C)([i,r],"conv3dBackpropFilterV2");const u=a.util.computeStrides(i.shape),h=a.util.computeStrides(r.shape),f=a.backend_util.computeConv3DInfo(i.shape,c,d,1,l),p=f.strideDepth,m=f.strideHeight,k=f.strideWidth,v=f.filterDepth,g=f.filterHeight,I=f.filterWidth,b=new a.TensorBuffer(f.filterShape,"float32"),C=b.values,[M,S,x,W]=b.strides,y=n.data.get(r.dataId).values,[D,H,N,T]=h,F=n.data.get(i.dataId).values,[w,B,_,z]=u,A=f.padInfo.front,$=f.padInfo.left,R=f.padInfo.top;for(let a=0;a<v;++a){const t=Math.max(0,Math.ceil((A-a)/p)),e=Math.min(f.outDepth,(f.inDepth+A-a)/p),n=a*M;for(let o=0;o<g;++o){const s=Math.max(0,Math.ceil((R-o)/m)),i=Math.min(f.outHeight,(f.inHeight+R-o)/m),r=o*S+n;for(let n=0;n<I;++n){const d=Math.max(0,Math.ceil(($-n)/k)),l=Math.min(f.outWidth,(f.inWidth+$-n)/k),c=n*x+r;for(let r=0;r<f.inChannels;++r){const u=r*W+c;for(let c=0;c<f.outChannels;++c){let h=0;for(let u=0;u<f.batchSize;++u){const f=u*w,v=u*D;for(let u=t;u<e;++u){const t=(a+u*p-A)*B+f,e=u*H+v;for(let a=s;a<i;++a){const s=(o+a*m-R)*_+t,i=a*N+e;for(let t=d;t<l;++t){const e=t*T+i;h+=F[(n+t*k-$)*z+s+r]*y[e+c]}}}}C[u+c]=h}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}}},50120:function(t,e,n){n.d(e,{$:function(){return i}});var a=n(9495),o=n(97870),s=n(85655);const i={kernelName:a.Cumsum,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:d,exclusive:l,reverse:c}=i;(0,o.C)(r,"cumsum");const u=a.backend_util.getAxesPermutation([d],r.shape.length);let h=r;null!=u&&(h=(0,s.m)({inputs:{x:r},backend:n,attrs:{perm:u}}));const f=a.backend_util.getInnerMostAxes(1,r.shape.length)[0];if(f!==h.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${f}`);const p=(0,a.upcastType)(h.dtype,"int32"),m=a.util.makeZerosTypedArray(a.util.sizeFromShape(h.shape),p),k=n.data.get(h.dataId).values,v=h.shape[h.shape.length-1],g=c?(t,e)=>t+v-e-1:(t,e)=>t+e;for(let a=0;a<k.length;a+=v)for(let t=0;t<v;t++){const e=g(a,t);if(0===t)m[e]=l?0:k[e];else{const n=g(a,t-1);m[e]=l?k[n]+m[n]:k[e]+m[n]}}const I=n.makeTensorInfo(h.shape,p,m);if(null!=u){const t=a.backend_util.getUndoAxesPermutation(u),e=(0,s.m)({inputs:{x:I},backend:n,attrs:{perm:t}});return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(h),e}return I}}},55671:function(t,e,n){n.d(e,{O:function(){return o}});var a=n(9495);const o={kernelName:a.CropAndResize,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:o}=t,{image:s,boxes:i,boxInd:r}=e,{cropSize:d,method:l,extrapolationValue:c}=o,[u,h,f,p]=s.shape,m=i.shape[0],[k,v]=d,g=(0,a.buffer)([m,k,v,p],"float32"),I=n.data.get(i.dataId).values,b=n.data.get(r.dataId).values,C=n.data.get(s.dataId).values,M=a.util.computeStrides(s.shape),S=a.util.computeStrides(g.shape);for(let a=0;a<m;a++){const t=4*a,e=I[t],n=I[t+1],o=I[t+2],s=I[t+3],i=b[a];if(i>=u)continue;const r=k>1?(o-e)*(h-1)/(k-1):0,d=v>1?(s-n)*(f-1)/(v-1):0;for(let u=0;u<k;u++){const t=k>1?e*(h-1)+u*r:.5*(e+o)*(h-1);if(t<0||t>h-1)for(let e=0;e<v;e++)for(let t=0;t<p;t++){const n=t+e*S[2]+u*S[1]+a*S[0];g.values[n]=c}else if("bilinear"===l){const e=Math.floor(t),o=Math.ceil(t),r=t-e;for(let t=0;t<v;t++){const l=v>1?n*(f-1)+t*d:.5*(n+s)*(f-1);if(l<0||l>f-1){for(let e=0;e<p;e++){const n=e+t*S[2]+u*S[1]+a*S[0];g.values[n]=c}continue}const h=Math.floor(l),m=Math.ceil(l),k=l-h;for(let n=0;n<p;n++){let s=n+h*M[2]+e*M[1]+i*M[0];const d=C[s];s=n+m*M[2]+e*M[1]+i*M[0];const l=C[s];s=n+h*M[2]+o*M[1]+i*M[0];const c=C[s];s=n+m*M[2]+o*M[1]+i*M[0];const f=d+(l-d)*k,p=c+(C[s]-c)*k;s=n+t*S[2]+u*S[1]+a*S[0],g.values[s]=f+(p-f)*r}}}else for(let e=0;e<v;++e){const o=v>1?n*(f-1)+e*d:.5*(n+s)*(f-1);if(o<0||o>f-1){for(let t=0;t<p;t++){const n=t+e*S[2]+u*S[1]+a*S[0];g.values[n]=c}continue}const r=Math.round(o),l=Math.round(t);for(let t=0;t<p;t++){const n=t+r*M[2]+l*M[1]+i*M[0],o=t+e*S[2]+u*S[1]+a*S[0];g.values[o]=C[n]}}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}}},57152:function(t,e,n){n.d(e,{R:function(){return o}});var a=n(9495);const o={kernelName:a.DepthToSpace,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:o}=t,{x:s}=e,{blockSize:i,dataFormat:r}=o;a.util.assert("NHWC"===r,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${r}`));const d=s.shape[0],l=s.shape[1],c=s.shape[2],u=s.shape[3],h=l*i,f=c*i,p=u/(i*i),m=n.data.get(s.dataId).values,k=new Float32Array(d*h*f*p);let v=0;for(let a=0;a<d;++a)for(let t=0;t<h;++t){const e=Math.floor(t/i),n=t%i;for(let t=0;t<f;++t){const o=Math.floor(t/i),s=(n*i+t%i)*p;for(let t=0;t<p;++t){const n=t+s+u*(o+c*(e+l*a));k[v++]=m[n]}}}return n.makeTensorInfo([d,h,f,p],s.dtype,k)}}},62590:function(t,e,n){n.d(e,{T:function(){return i}});var a=n(9495),o=n(97870),s=n(85655);const i={kernelName:a.Cumprod,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:i}=t,{x:r}=e,{axis:d,exclusive:l,reverse:c}=i;(0,o.C)(r,"cumprod");const u=a.backend_util.getAxesPermutation([d],r.shape.length);let h=r;null!=u&&(h=(0,s.m)({inputs:{x:r},backend:n,attrs:{perm:u}}));const f=a.backend_util.getInnerMostAxes(1,r.shape.length)[0];if(f!==h.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${h.shape.length-1} but got axis=${f}`);const p=(0,a.upcastType)(h.dtype,"int32"),m=a.util.makeOnesTypedArray(a.util.sizeFromShape(h.shape),p),k=n.data.get(h.dataId).values,v=h.shape[h.shape.length-1],g=c?(t,e)=>t+v-e-1:(t,e)=>t+e;for(let a=0;a<k.length;a+=v)for(let t=0;t<v;t++){const e=g(a,t);if(0===t)m[e]=l?1:k[e];else{const n=g(a,t-1);m[e]=l?k[n]*m[n]:k[e]*m[n]}}const I=n.makeTensorInfo(h.shape,p,m);if(null!=u){const t=a.backend_util.getUndoAxesPermutation(u),e=(0,s.m)({inputs:{x:I},backend:n,attrs:{perm:t}});return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(h),e}return I}}},70583:function(t,e,n){n.d(e,{i:function(){return s}});var a=n(9495),o=n(97870);const s={kernelName:a.Conv3D,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{x:i,filter:r}=e,{strides:d,pad:l,dilations:c}=s;(0,o.C)([i,r],"conv3d");const u=a.backend_util.computeConv3DInfo(i.shape,r.shape,d,c,l),{filterDepth:h,filterHeight:f,filterWidth:p,dilationDepth:m,dilationHeight:k,dilationWidth:v,padInfo:g}=u,I=g.front,b=g.left,C=g.top,M=new a.TensorBuffer(u.outShape,i.dtype),S=n.data.get(i.dataId).values,x=n.data.get(r.dataId).values,W=M.values,y=a.util.computeStrides(i.shape),D=a.util.computeStrides(r.shape);for(let a=0;a<u.batchSize;++a){const t=a*y[0],e=a*M.strides[0];for(let n=0;n<u.outDepth;++n){const a=e+n*M.strides[1],o=n*u.strideDepth-I;for(let e=0;e<h;++e){const n=o+e*m;if(n<0||n>=u.inDepth)continue;const s=e*D[0],i=t+n*y[1];for(let t=0;t<u.outHeight;++t){const e=a+t*M.strides[2],n=t*u.strideHeight-C;for(let t=0;t<f;++t){const a=n+t*k;if(a<0||a>=u.inHeight)continue;const o=s+t*D[1],r=i+a*y[2];for(let t=0;t<u.outWidth;++t){const n=e+t*u.outChannels,a=t*u.strideWidth-b;for(let t=0;t<p;++t){const e=a+t*v;if(e<0||e>=u.inWidth)continue;const s=o+t*D[2],i=r+e*u.inChannels;let d=s;for(let t=0;t<u.inChannels;++t){const e=S[i+t];for(let t=0;t<u.outChannels;++t)W[n+t]+=e*x[d+t];d+=u.outChannels}}}}}}}}return n.makeTensorInfo(M.shape,M.dtype,M.values)}}},85046:function(t,e,n){n.d(e,{V:function(){return s}});var a=n(9495),o=n(97870);const s={kernelName:a.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:s}=t,{dy:i,filter:r}=e,{strides:d,dilations:l,pad:c,dimRoundingMode:u,inputShape:h}=s;(0,o.C)([i,r],"depthwiseConv2DNativeBackpropInput");const f=a.util.computeStrides(i.shape),p=a.util.computeStrides(r.shape),m=a.backend_util.computeConv2DInfo(h,r.shape,d,l,c,u,!0),k=new a.TensorBuffer(m.inShape,"float32"),v=k.values,[g,I,b]=k.strides,C=n.data.get(i.dataId).values,[M,S,x]=f,W=n.data.get(r.dataId).values,[y,D,H]=p,{batchSize:N,filterHeight:T,filterWidth:F,inChannels:w,inHeight:B,inWidth:_,outChannels:z,outHeight:A,outWidth:$,strideHeight:R,strideWidth:P}=m,E=T-1-m.padInfo.top,O=F-1-m.padInfo.left,V=z/w;for(let a=0;a<N;++a)for(let t=0;t<w;++t)for(let e=0;e<B;++e){const n=e-E,o=Math.max(0,Math.ceil(n/R)),s=Math.min(A,(T+n)/R);for(let i=0;i<_;++i){const r=i-O,d=Math.max(0,Math.ceil(r/P)),l=Math.min($,(F+r)/P);let c=0;for(let e=o;e<s;++e){const o=e*R-n;for(let n=d;n<l;++n){const s=M*a+S*e+x*n,i=y*(T-1-o)+D*(F-1-(n*P-r))+H*t;for(let e=0;e<V;++e){c+=C[s+(t*V+e)]*W[i+e]}}}v[g*a+I*e+b*i+t]=c}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}}},87994:function(t,e,n){n.d(e,{n:function(){return s},v:function(){return i}});var a=n(9495),o=n(97870);function s(t){const{inputs:e,backend:n,attrs:s}=t,{x:i,filter:r}=e,{strides:d,pad:l,dilations:c,dimRoundingMode:u}=s;(0,o.C)([i,r],"depthwiseConv2DNative");const h=a.util.computeStrides(i.shape),f=a.util.computeStrides(r.shape);let p=c;null==p&&(p=[1,1]),a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(d,p),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${d} and dilations '${p}'`));const m=a.backend_util.computeConv2DInfo(i.shape,r.shape,d,p,l,u,!0),{filterHeight:k,filterWidth:v,dilationHeight:g,dilationWidth:I,padInfo:b}=m,C=b.left,M=b.top,S=m.outChannels/m.inChannels,x=new a.TensorBuffer(m.outShape,i.dtype),W=n.data.get(i.dataId).values,y=n.data.get(r.dataId).values,D=x.values;for(let a=0;a<m.batchSize;++a){const t=a*h[0],e=a*x.strides[0];for(let n=0;n<m.outHeight;++n){const a=e+n*x.strides[1],o=n*m.strideHeight-M;for(let e=0;e<k;++e){const n=o+e*g;if(n<0||n>=m.inHeight)continue;const s=e*f[0],i=t+n*h[1];for(let t=0;t<m.outWidth;++t){const e=a+t*x.strides[2],n=t*m.strideWidth-C;for(let t=0;t<v;++t){const a=n+t*I;if(a<0||a>=m.inWidth)continue;const o=s+t*f[1],r=i+a*m.inChannels;let d=e,l=o;for(let t=0;t<m.inChannels;++t){const e=W[r+t];for(let t=0;t<S;++t)D[d+t]+=e*y[l+t];d+=S,l+=S}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}const i={kernelName:a.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:s}}}]);
//# sourceMappingURL=stylist-vendors-174298da.5d31ddb0eb0c0618c9a0.js.map