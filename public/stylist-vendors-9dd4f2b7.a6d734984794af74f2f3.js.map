{"version":3,"file":"stylist-vendors-9dd4f2b7.a6d734984794af74f2f3.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/canvas_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu_depthwise.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/fill_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/diag_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/depth_to_space_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/flags_webgl.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/decode_matrix_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_float_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_context.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_math.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/backend_webgl.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/base.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/cumsum_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/gpgpu_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/fft_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/flip_left_right_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/im2col_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/crop_and_resize_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/binaryop_complex_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/complex_abs_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/batchnorm_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/dilation_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/clip_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/addn_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/avg_pool_backprop_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/gather_nd_gpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nconst contexts = {};\nconst WEBGL_ATTRIBUTES = {\n    alpha: false,\n    antialias: false,\n    premultipliedAlpha: false,\n    preserveDrawingBuffer: false,\n    depth: false,\n    stencil: false,\n    failIfMajorPerformanceCaveat: true\n};\nexport function clearWebGLContext(webGLVersion) {\n    delete contexts[webGLVersion];\n}\nexport function setWebGLContext(webGLVersion, gl) {\n    contexts[webGLVersion] = gl;\n}\nexport function getWebGLContext(webGLVersion) {\n    if (!(webGLVersion in contexts)) {\n        const newCtx = getWebGLRenderingContext(webGLVersion);\n        if (newCtx !== null) {\n            contexts[webGLVersion] = newCtx;\n        }\n        else {\n            console.log('Could not get context for WebGL version', webGLVersion);\n            return null;\n        }\n    }\n    const gl = contexts[webGLVersion];\n    if (gl.isContextLost()) {\n        delete contexts[webGLVersion];\n        return getWebGLContext(webGLVersion);\n    }\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.STENCIL_TEST);\n    gl.disable(gl.BLEND);\n    gl.disable(gl.DITHER);\n    gl.disable(gl.POLYGON_OFFSET_FILL);\n    gl.disable(gl.SAMPLE_COVERAGE);\n    gl.enable(gl.SCISSOR_TEST);\n    gl.enable(gl.CULL_FACE);\n    gl.cullFace(gl.BACK);\n    return contexts[webGLVersion];\n}\nfunction createCanvas(webGLVersion) {\n    if (typeof OffscreenCanvas !== 'undefined' && webGLVersion === 2) {\n        return new OffscreenCanvas(300, 150);\n    }\n    else if (typeof document !== 'undefined') {\n        return document.createElement('canvas');\n    }\n    else {\n        throw new Error('Cannot create a canvas in this context');\n    }\n}\nfunction getWebGLRenderingContext(webGLVersion) {\n    if (webGLVersion !== 1 && webGLVersion !== 2) {\n        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');\n    }\n    const canvas = createCanvas(webGLVersion);\n    canvas.addEventListener('webglcontextlost', (ev) => {\n        ev.preventDefault();\n        delete contexts[webGLVersion];\n    }, false);\n    if (webGLVersion === 1) {\n        return (canvas.getContext('webgl', WEBGL_ATTRIBUTES) ||\n            canvas.getContext('experimental-webgl', WEBGL_ATTRIBUTES));\n    }\n    return canvas.getContext('webgl2', WEBGL_ATTRIBUTES);\n}\n//# sourceMappingURL=canvas_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DepthwiseConv2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const xNumRows = convInfo.inHeight;\n        const xNumCols = convInfo.inWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyReluAlpha) {\n                activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyReluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${xNumRows}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${xNumCols}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_gpu_depthwise.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ClipPackedProgram {\n    constructor(aShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = aShape;\n        this.userCode = `\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    `;\n    }\n    getCustomSetupFunc(min, max) {\n        return (gpgpu, webGLProgram) => {\n            if (this.minLoc == null) {\n                this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n                this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n            }\n            gpgpu.gl.uniform1f(this.minLoc, min);\n            gpgpu.gl.uniform1f(this.maxLoc, max);\n        };\n    }\n}\n//# sourceMappingURL=clip_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport class DepthwiseConvPacked2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = convInfo.outShape;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        const xNumRows = convInfo.inHeight;\n        const xNumCols = convInfo.inWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const texelsAcross = filterWidth;\n        let mainLoop = `\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;`;\n        for (let c = 0; c < filterWidth; c++) {\n            mainLoop += `\n          vec4 xTexelC${c * 2};\n          int xTexelC${c * 2}Ready;\n          vec4 xC${c};`;\n        }\n        /**\n         * This vectorized implementation works by gathering the values needed for\n         * each output channel's dot product into vec4's and then multiplying them\n         * all together (this happens in the final double for-loop below). Most of\n         * the main loop consists of constructing these vec4's with the minimum\n         * number of texture2D calls, which means making use of all four returned\n         * values from a texture2D call at once.\n         */\n        for (let r = 0; r < filterHeight; r++) {\n            for (let c = 0; c < filterWidth; c++) {\n                mainLoop += `\n          xTexelC${c * 2} = vec4(0.0);\n          xTexelC${c * 2}Ready = 0;\n          xC${c} = vec4(0.0);`;\n            }\n            mainLoop += `\n        xR = xRCorner + ${r * dilationHeight};\n        if (xR >=0 && xR < ${xNumRows}) {\n      `;\n            for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {\n                const colIndex = texelC * 2;\n                const c = colIndex * dilationWidth;\n                mainLoop += `\n          xC = xCCorner + ${c};\n          `;\n                if (strideWidth === 1) {\n                    if (colIndex < filterWidth) {\n                        // If padding is odd, the outer texels have to be composed.\n                        if (padLeft % 2 === 1) {\n                            // TODO: Ensure vec4 previous does not result in redundant sample,\n                            // and avoid setting xTexelRC's that exceed the boundary in the\n                            // first place rather than resetting them to vec4(0)).\n                            // To compute xCOffset:\n                            // - If padding is odd, we must add 1 to ensure we ask for an\n                            // even-numbered row.\n                            // - We subtract 2 to access the previous texel.\n                            mainLoop += `\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${c}Ready == 0) {\n                  xTexelC${c} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${xNumCols}) {\n                    xTexelC${c}.zw = vec2(0.0);\n                  }\n                  xTexelC${c}Ready = 1;\n                }\n              `;\n                            // This texel has been read in previous iteration if the dilation\n                            // is 1.\n                            if (dilationWidth === 1 && c > 0) {\n                                mainLoop += `\n                xC${colIndex} = vec4(xTexelC${c - 2}.zw, xTexelC${c}.xy);\n                `;\n                            }\n                            else {\n                                mainLoop += `\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${xNumCols}) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${colIndex} = vec4(previous.zw, xTexelC${c}.xy);\n                  } else {\n                    xC${colIndex} = vec4(0.0, 0.0, xTexelC${c}.xy);\n                  }\n                  `;\n                            }\n                        }\n                        else {\n                            // Padding is even, so xRC corresponds to a single texel.\n                            mainLoop += `\n                if (xC >= 0 && xC < ${xNumCols} && xTexelC${c}Ready == 0) {\n                  xTexelC${c} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${xNumCols}) {\n                    xTexelC${c}.zw = vec2(0.0);\n                  }\n                  xTexelC${c}Ready = 1;\n                }\n\n                xC${colIndex} = xTexelC${c};\n                `;\n                        }\n                        if (c + 1 < filterWidth) {\n                            // If dilation is even, the second entry should match the first\n                            // (either both are composed or both are single samples). But if\n                            // dilation is odd, then the second entry should be the opposite\n                            // of the first (if the first is composed, the second is a single\n                            // sample, and vice versa.)\n                            const nextTexelOffset = padLeft % 2 === 0 ?\n                                util.nearestLargerEven(dilationWidth) :\n                                dilationWidth;\n                            if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                                (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n                                mainLoop += `\n                  xCOffset = xC + ${padLeft % 2} + ${nextTexelOffset};\n\n                  if (xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${c + 2}Ready == 0) {\n                    xTexelC${c + 2} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${xNumCols}) {\n                      xTexelC${c + 2}.zw = vec2(0.0);\n                    }\n                    xTexelC${c + 2}Ready = 1;\n                  }\n                  `;\n                                // If dilation > 1 then the xRC's will not be able to share any\n                                // values, so each xRC will require two unique calls to getX.\n                                if (dilationWidth > 1) {\n                                    mainLoop += `\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${c}Ready == 0) {\n                      xTexelC${c} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${c}Ready = 1;\n                    }\n                    `;\n                                }\n                                mainLoop += `\n                  xC${colIndex + 1} = vec4(xTexelC${c}.zw, xTexelC${c + 2}.xy);\n                  `;\n                            }\n                            else {\n                                // If dilation is 1 and padding is odd, we have already read the\n                                // texel when constructing the previous x value. Here we can\n                                // simply skip the texture read.\n                                if (nextTexelOffset === 1) {\n                                    mainLoop += `\n                    xC${colIndex + 1} = xTexelC${c};\n                    `;\n                                }\n                                else {\n                                    mainLoop += `\n                    xCOffset = xC + ${nextTexelOffset};\n\n                    if (xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${c + 2}Ready == 0) {\n                      xTexelC${c + 2} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ${xNumCols}) {\n                        xTexelC${c + 2}.zw = vec2(0.0);\n                      }\n                      xTexelC${c + 2}Ready = 1;\n                    }\n\n                    xC${colIndex + 1} = xTexelC${c + 2};\n                    `;\n                                }\n                            }\n                        }\n                    }\n                }\n                else { // stride === 2\n                    if (c < filterWidth) {\n                        // Depending on whether padLeft is even or odd, we want either the\n                        // xy or zw channels from X texels for xC${colIndex}. If padLeft is\n                        // even, xC${colIndex +1} is simply the zw channels of texels we've\n                        // already sampled. But if padLeft is odd, xC{$c + 1}.zw will\n                        // need to come from the xy channels of a new texel, hence the `\n                        // vec4\n                        // final` initialized below.\n                        if (padLeft % 2 === 1) {\n                            mainLoop += `\n                xCOffset = xC + 1 - ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${c}Ready == 0) {\n                  xTexelC${c} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${xNumCols}) {\n                    xTexelC${c}.zw = vec2(0.0);\n                  }\n                  xTexelC${c}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${xNumCols} && xTexelC${c + 2}Ready == 0) {\n                  xTexelC${c + 2} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ${xNumCols}) {\n                    xTexelC${c + 2}.zw = vec2(0.0);\n                  }\n                  xTexelC${c + 2}Ready = 1;\n                }\n\n                xC${colIndex} = vec4(xTexelC${c}.zw, xTexelC${c + 2}.zw);\n              `;\n                            if (c + 1 < filterWidth) {\n                                mainLoop += `\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ${strideWidth};\n                  if(xCOffset >= 0 && xCOffset < ${xNumCols}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${colIndex + 1} = vec4(xTexelC${c + 2}.xy, final.xy);\n                `;\n                            }\n                        }\n                        else {\n                            mainLoop += `\n                if(xC >= 0 && xC < ${xNumCols} && xTexelC${c}Ready == 0) {\n                  xTexelC${c} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${xNumCols}) {\n                    xTexelC${c}.zw = vec2(0.0);\n                  }\n                  xTexelC${c}Ready = 1;\n                }\n\n                xCOffset = xC + ${strideWidth};\n                if(xCOffset >= 0 && xCOffset < ${xNumCols} && xTexelC${c + 2}Ready == 0) {\n                  xTexelC${c + 2} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ${xNumCols}) {\n                    xTexelC${c + 2}.zw = vec2(0.);\n                  }\n                  xTexelC${c + 2}Ready = 1;\n                }\n\n                xC${colIndex} = vec4(\n                  xTexelC${c}.xy, xTexelC${c + 2}.xy);\n              `;\n                            if (c + 1 < filterWidth) {\n                                mainLoop += `\n                  xC${colIndex + 1} = vec4(xTexelC${c}.zw, xTexelC${c + 2}.zw);\n                `;\n                            }\n                        }\n                    }\n                }\n                // localize the dotProd accumulation within the loop, the theory is for\n                // GPU with limited cache, accumulate sum across large amount of\n                // veriables will cause lots of cache misses. (i.e. 5x5 filter will have\n                // 50 variables)\n                if (colIndex < filterWidth) {\n                    mainLoop += `\n            wTexel = getW(${r}, ${c}, d1, q);\n            dotProd += xC${colIndex} * vec4(wTexel.xz, wTexel.xz);\n          `;\n                    if (c + 1 < filterWidth) {\n                        mainLoop += `\n              wTexel = getW(${r}, ${c + 1}, d1, q);\n              dotProd += xC${colIndex + 1} * vec4(wTexel.xz, wTexel.xz);\n            `;\n                    }\n                }\n            }\n            mainLoop += `\n        }\n      `;\n        }\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyReluAlpha) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyReluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${mainLoop}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_packed_gpu_depthwise.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport class ConcatProgram {\n    // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().\n    constructor(shapes) {\n        this.outputShape = [];\n        this.outputShape = backend_util.computeOutShape(shapes, 1 /* axis */);\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][1];\n        for (let i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][1];\n        }\n        const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];\n        for (let i = 1; i < offsets.length; i++) {\n            const shift = offsets[i - 1];\n            snippets.push(`else if (yC < ${offsets[i]}) ` +\n                `setOutput(getT${i}(yR, yC-${shift}));`);\n        }\n        const lastIndex = offsets.length;\n        const lastShift = offsets[offsets.length - 1];\n        snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);\n        this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${snippets.join('\\n        ')}\n      }\n    `;\n    }\n}\n//# sourceMappingURL=concat_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nexport function getGlslDifferences() {\n    let version;\n    let attribute;\n    let varyingVs;\n    let varyingFs;\n    let texture2D;\n    let output;\n    let defineOutput;\n    let defineSpecialNaN;\n    let defineSpecialInf;\n    let defineRound;\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n        version = '#version 300 es';\n        attribute = 'in';\n        varyingVs = 'out';\n        varyingFs = 'in';\n        texture2D = 'texture';\n        output = 'outputColor';\n        defineOutput = 'out vec4 outputColor;';\n        // Use custom isnan definition to work across differences between\n        // implementations on various platforms. While this should happen in ANGLE\n        // we still see differences between android and windows (on chrome) when\n        // using isnan directly.\n        defineSpecialNaN = `\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    `;\n        // In webgl 2 we do not need to specify a custom isinf so there is no\n        // need for a special INFINITY constant.\n        defineSpecialInf = ``;\n        defineRound = `\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n    }\n    else {\n        version = '';\n        attribute = 'attribute';\n        varyingVs = 'varying';\n        varyingFs = 'varying';\n        texture2D = 'texture2D';\n        output = 'gl_FragColor';\n        defineOutput = '';\n        // WebGL1 has no built in isnan so we define one here.\n        defineSpecialNaN = `\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    `;\n        defineSpecialInf = `\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    `;\n        defineRound = `\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    `;\n    }\n    return {\n        version,\n        attribute,\n        varyingVs,\n        varyingFs,\n        texture2D,\n        output,\n        defineOutput,\n        defineSpecialNaN,\n        defineSpecialInf,\n        defineRound\n    };\n}\n//# sourceMappingURL=glsl_version.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Conv2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        const inputDepthVec4Remainder = convInfo.inChannels % 4;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const rowDim = isChannelsLast ? 1 : 2;\n        const colDim = isChannelsLast ? 2 : 3;\n        const channelDim = isChannelsLast ? 3 : 1;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivationWeights) {\n                activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyreluAlpha) {\n                activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivationWeights) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyreluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${channelDim}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${convInfo.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${inputDepthVec4Remainder === 1}) {\n\n              if (${isChannelsLast}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              }\n\n            } else if (${inputDepthVec4Remainder === 2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${inputDepthVec4Remainder === 3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\nexport class Conv3DProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        const inputDepthVec4Remainder = convInfo.inChannels % 4;\n        this.userCode = `\n      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          int xF = xFCorner + wF * ${dilationDepth};\n\n          if (xF < 0 || xF >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            int xR = xRCorner + wR * ${dilationHeight};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${inputDepthVec4Remainder === 1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);\n              } else if (${inputDepthVec4Remainder === 2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${inputDepthVec4Remainder === 3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport const CHECK_NAN_SNIPPET = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n`;\nexport const SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\nexport class BinaryOpProgram {\n    constructor(op, aShape, bShape) {\n        this.variableNames = ['A', 'B'];\n        this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        this.userCode = `\n      float binaryOperation(float a, float b) {\n        ${op}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=binaryop_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class FillProgram {\n    constructor(shape, value) {\n        this.outputShape = [];\n        this.variableNames = ['x'];\n        this.outputShape = shape;\n        this.userCode = `\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    `;\n    }\n    getCustomSetupFunc(value) {\n        return (gpgpu, webGLProgram) => {\n            if (this.valueLoc == null) {\n                this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'value');\n            }\n            gpgpu.gl.uniform1f(this.valueLoc, value);\n        };\n    }\n}\n//# sourceMappingURL=fill_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport class BatchNormProgram {\n    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {\n        this.outputShape = [];\n        this.variableNames = ['x', 'mean', 'variance'];\n        backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n        backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n        let offsetSnippet = '0.0';\n        if (offsetShape != null) {\n            backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n            this.variableNames.push('offset');\n            offsetSnippet = 'getOffsetAtOutCoords()';\n        }\n        let scaleSnippet = '1.0';\n        if (scaleShape != null) {\n            backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n            this.variableNames.push('scale');\n            scaleSnippet = 'getScaleAtOutCoords()';\n        }\n        this.outputShape = xShape;\n        this.userCode = `\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${offsetSnippet};\n        float scale = ${scaleSnippet};\n        float inv = scale * inversesqrt(variance + float(${varianceEpsilon}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=batchnorm_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class AddNPackedProgram {\n    constructor(outputShape, shapes) {\n        this.outputShape = [];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const snippets = [];\n        // Get target elements from every input tensor.\n        this.variableNames.forEach(variable => {\n            snippets.push(`vec4 v${variable} = get${variable}AtOutCoords();`);\n        });\n        // Calculate the sum of all elements.\n        const operation = this.variableNames\n            .map(variable => {\n            return `v${variable}`;\n        })\n            .join(' + ');\n        this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        vec4 result = ${operation};\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=addn_packed_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DiagProgram {\n    constructor(size) {\n        this.variableNames = ['X'];\n        this.outputShape = [size, size];\n        this.userCode = `\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=diag_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DepthToSpaceProgram {\n    constructor(outputShape, blockSize, dataFormat) {\n        this.variableNames = ['x'];\n        this.outputShape = [];\n        this.outputShape = outputShape;\n        this.blockSize = blockSize;\n        this.dataFormat = dataFormat;\n        this.userCode = `\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${blockSize};\n      int offset_h = imod(h, ${blockSize});\n      int in_w = w / ${blockSize};\n      int offset_w = imod(w, ${blockSize});\n      int offset_d = (offset_h * ${blockSize} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `;\n    }\n    getHeightCoordString() {\n        if (this.dataFormat === 'NHWC') {\n            return `coords[1]`;\n        }\n        else {\n            return `coords[2]`;\n        }\n    }\n    getWidthCoordString() {\n        if (this.dataFormat === 'NHWC') {\n            return `coords[2]`;\n        }\n        else {\n            return `coords[3]`;\n        }\n    }\n    getDepthCoordString() {\n        if (this.dataFormat === 'NHWC') {\n            return `coords[3]`;\n        }\n        else {\n            return `coords[1]`;\n        }\n    }\n    getOutputDepthSize() {\n        if (this.dataFormat === 'NHWC') {\n            return this.outputShape[3];\n        }\n        else {\n            return this.outputShape[1];\n        }\n    }\n    getInputSamplingString() {\n        if (this.dataFormat === 'NHWC') {\n            return `getX(b, in_h, in_w, in_d)`;\n        }\n        else {\n            return `getX(b, in_d, in_h, in_w)`;\n        }\n    }\n}\n//# sourceMappingURL=depth_to_space_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { device_util, env } from '@tensorflow/tfjs-core';\nimport { getMaxTexturesInShader, getWebGLDisjointQueryTimerVersion, getWebGLMaxTextureSize, isCapableOfRenderingToFloatTexture, isDownloadFloatTextureEnabled, isWebGLFenceEnabled, isWebGLVersionEnabled } from './webgl_util';\nconst ENV = env();\n/**\n * This file contains WebGL-specific flag registrations.\n */\n/**\n * True if WebGL is supported.\n */\nENV.registerFlag('HAS_WEBGL', () => ENV.getNumber('WEBGL_VERSION') > 0);\n/** 0: No WebGL, 1: WebGL 1.0, 2: WebGL 2.0. */\nENV.registerFlag('WEBGL_VERSION', () => {\n    if (isWebGLVersionEnabled(2)) {\n        return 2;\n    }\n    else if (isWebGLVersionEnabled(1)) {\n        return 1;\n    }\n    return 0;\n});\n/** Whether to check for numerical representation problems. */\nENV.registerFlag('WEBGL_CHECK_NUMERICAL_PROBLEMS', () => false);\nENV.registerFlag('WEBGL_BUFFER_SUPPORTED', () => ENV.get('WEBGL_VERSION') === 2);\n/** Whether the WebGL backend will sometimes forward ops to the CPU. */\nENV.registerFlag('WEBGL_CPU_FORWARD', () => true);\n/** Whether the WebGL backend will always use f16 textures for rendering. */\nENV.registerFlag('WEBGL_FORCE_F16_TEXTURES', () => false);\n/** Whether to turn all packing related flags on. */\nENV.registerFlag('WEBGL_PACK', () => ENV.getBool('HAS_WEBGL'));\n/** Whether we will pack the batchnormalization op. */\nENV.registerFlag('WEBGL_PACK_NORMALIZATION', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack the clip op. */\nENV.registerFlag('WEBGL_PACK_CLIP', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack the depthwise conv op. */\nENV.registerFlag('WEBGL_PACK_DEPTHWISECONV', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack binary ops. */\nENV.registerFlag('WEBGL_PACK_BINARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack unary ops. */\nENV.registerFlag('WEBGL_PACK_UNARY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack array ops. */\nENV.registerFlag('WEBGL_PACK_ARRAY_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack image ops. */\nENV.registerFlag('WEBGL_PACK_IMAGE_OPERATIONS', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will pack reduce ops. */\nENV.registerFlag('WEBGL_PACK_REDUCE', () => ENV.getBool('WEBGL_PACK'));\n/** Whether packed WebGL kernels lazily unpack their outputs. */\nENV.registerFlag('WEBGL_LAZILY_UNPACK', () => ENV.getBool('WEBGL_PACK'));\n/** Whether we will use the im2col algorithm to speed up convolutions. */\nENV.registerFlag('WEBGL_CONV_IM2COL', () => ENV.getBool('WEBGL_PACK'));\n/** The maximum texture dimension. */\nENV.registerFlag('WEBGL_MAX_TEXTURE_SIZE', () => getWebGLMaxTextureSize(ENV.getNumber('WEBGL_VERSION')));\n/** The maximum texture dimension. */\nENV.registerFlag('WEBGL_MAX_TEXTURES_IN_SHADER', () => getMaxTexturesInShader(ENV.getNumber('WEBGL_VERSION')));\n/**\n * The disjoint_query_timer extension version.\n * 0: disabled, 1: EXT_disjoint_timer_query, 2:\n * EXT_disjoint_timer_query_webgl2.\n * In Firefox with WebGL 2.0,\n * EXT_disjoint_timer_query_webgl2 is not available, so we must use the\n * WebGL 1.0 extension.\n */\nENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', () => {\n    const webGLVersion = ENV.getNumber('WEBGL_VERSION');\n    if (webGLVersion === 0) {\n        return 0;\n    }\n    return getWebGLDisjointQueryTimerVersion(webGLVersion);\n});\n/**\n * Whether the timer object from the disjoint_query_timer extension gives\n * timing information that is reliable.\n */\nENV.registerFlag('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', () => ENV.getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 &&\n    !device_util.isMobile());\n/**\n * Whether the device is physically capable of rendering to float32 textures.\n */\nENV.registerFlag('WEBGL_RENDER_FLOAT32_CAPABLE', () => isCapableOfRenderingToFloatTexture(ENV.getNumber('WEBGL_VERSION')));\n/**\n * Whether rendering to float32 textures is enabled. If disabled, renders to\n * float16 textures.\n */\nENV.registerFlag('WEBGL_RENDER_FLOAT32_ENABLED', () => {\n    return ENV.getBool('WEBGL_FORCE_F16_TEXTURES') ?\n        false :\n        ENV.getBool('WEBGL_RENDER_FLOAT32_CAPABLE');\n});\n/**\n * Whether downloading float textures is enabled (16 or 32 bit). If disabled,\n * uses IEEE 754 encoding of the float32 values to 4 uint8 when downloading.\n */\nENV.registerFlag('WEBGL_DOWNLOAD_FLOAT_ENABLED', () => isDownloadFloatTextureEnabled(ENV.getNumber('WEBGL_VERSION')));\n/** Whether the fence API is available. */\nENV.registerFlag('WEBGL_FENCE_API_ENABLED', () => isWebGLFenceEnabled(ENV.getNumber('WEBGL_VERSION')));\n/**\n * Tensors with size <= than this will be uploaded as uniforms, not textures.\n */\nENV.registerFlag('WEBGL_SIZE_UPLOAD_UNIFORM', () => {\n    // Use uniform uploads only when 32bit floats are supported. In\n    // 16bit\n    // environments there are problems with comparing a 16bit texture value\n    // with a 32bit uniform value.\n    const useUniforms = ENV.getBool('WEBGL_RENDER_FLOAT32_ENABLED');\n    return useUniforms ? 4 : 0;\n});\n/**\n * If the total number of bytes allocated on the GPU is greater than this\n * number, we will aggressively delete textures upon disposal with\n * gl.deleteMatrixTexture, rather than making them available for reuse.\n *\n * Default value -1 indicates that we will never aggressively delete textures.\n */\nENV.registerFlag('WEBGL_DELETE_TEXTURE_THRESHOLD', () => {\n    return -1;\n}, threshold => {\n    if (threshold < 0 && threshold !== -1) {\n        throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never ` +\n            `delete) or at least 0, but got ${threshold}.`);\n    }\n});\n/**\n * Trigger a manual GL command flush if the threshold of time has passed since\n * previous Kernel execution. This can be useful for Andorid device where GL\n * command flush are delayed un til the end of javascript task. This value is\n * measured in millisecond. Typically you want to set this value to close to 1.\n *\n * Default value 1 for mobile chrome, and -1 for rest cases. -1 indicates that\n * we will not enforce manual flush and depend on system default flush schedule.\n */\nENV.registerFlag('WEBGL_FLUSH_THRESHOLD', () => {\n    return device_util.isMobile() && ENV.getBool('IS_CHROME') ? 1 : -1;\n}, threshold => {\n    if (threshold < 0 && threshold !== -1) {\n        throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never ` +\n            `manual flush) or at least 0, but got ${threshold}.`);\n    }\n});\n//# sourceMappingURL=flags_webgl.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\nimport { getDenseTexShape, PackingScheme } from './tex_util';\nexport class DecodeMatrixProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        this.outPackingScheme = PackingScheme.DENSE;\n        const texShape = getDenseTexShape(outputShape);\n        const glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${texShape[0]}, ${texShape[1]}));\n        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n    }\n}\n//# sourceMappingURL=decode_matrix_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\nimport { getDenseTexShape, PackingScheme } from './tex_util';\nexport class DecodeMatrixPackedProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outPackingScheme = PackingScheme.DENSE;\n        const texShape = getDenseTexShape(outputShape);\n        const glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = `\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], outputShape)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${texShape[0]}, ${texShape[1]}));\n        int index = 4 * (resTexRC.x * ${texShape[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${glsl.output} = result;\n      }\n    `;\n    }\n}\n//# sourceMappingURL=decode_matrix_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport { ENCODE_FLOAT_SNIPPET } from './shader_compiler_util';\nimport { TextureUsage } from './tex_util';\nexport class EncodeFloatProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.outTexUsage = TextureUsage.DOWNLOAD;\n        const glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=encode_float_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport { ENCODE_FLOAT_SNIPPET } from './shader_compiler_util';\nimport { TextureUsage } from './tex_util';\nexport class EncodeFloatPackedProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = false;\n        this.outTexUsage = TextureUsage.DOWNLOAD;\n        const glsl = getGlslDifferences();\n        this.outputShape = outputShape;\n        this.userCode = `\n      ${ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${glsl.output} = encode_float(x);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=encode_float_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\nexport class EncodeMatrixProgram {\n    constructor(outputShape, texShape, inputIsUnsignedByte = false) {\n        this.variableNames = ['A'];\n        const glsl = getGlslDifferences();\n        const [height, width] = texShape;\n        this.outputShape = outputShape;\n        let output = `result`;\n        if (inputIsUnsignedByte) {\n            output = `floor(result * 255. + 0.5)`;\n        }\n        this.userCode = `\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${width};\n        int c = imod(flatIndex, ${width});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);\n        vec4 values = ${glsl.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${glsl.output} = vec4(${output}, 0., 0., 0.);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=encode_matrix_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\n/*\nThis is how the shader encodes a tensor with shape = [2, 3, 5]\n(indices are [batch, row, col]).\n\n000|001   002|003   004|xxx   020|021   022|023   024|xxx\n-------   -------   -------   -------   -------   -------\n010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\n100|101   102|103   104|xxx   120|121   122|123   124|xxx\n-------   -------   -------   -------   -------   -------\n110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n\nSingle texels contain only values from the same batch, and from adjacent rows\nand columns.\n */\nexport class EncodeMatrixPackedProgram {\n    constructor(outputShape, texShape, inputIsUnsignedByte = false) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        const glsl = getGlslDifferences();\n        const [height, width] = texShape;\n        this.outputShape = outputShape;\n        let mainLoop = '';\n        let output = 'result';\n        if (inputIsUnsignedByte) {\n            output = 'floor(result * 255. + 0.5)';\n        }\n        for (let row = 0; row <= 1; row++) {\n            for (let col = 0; col <= 1; col++) {\n                const channel = row * 2 + col;\n                mainLoop += `\n          localCoords = coords;\n          if(localCoords[2] + ${col} < ${outputShape[2]}) {\n            localCoords[2] += ${col};\n            if(localCoords[1] + ${row} < ${outputShape[1]}) {\n              localCoords[1] += ${row};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${width};\n              c = imod(flatIndex, ${width});\n              uv = (vec2(c, r) + halfCR) / vec2(${width}.0, ${height}.0);\n              values = ${glsl.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${channel}] = values[0];\n              } else if(offset == 1) {\n                result[${channel}] = values[1];\n              } else if(offset == 2) {\n                result[${channel}] = values[2];\n              } else {\n                result[${channel}] = values[3];\n              }\n            }\n          }\n        `;\n            }\n        }\n        this.userCode = `\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${mainLoop}\n\n        ${glsl.output} = ${output};\n      }\n    `;\n    }\n}\n//# sourceMappingURL=encode_matrix_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext, setWebGLContext } from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport class GPGPUContext {\n    constructor(gl) {\n        this.outputTexture = null;\n        this.program = null;\n        this.disposed = false;\n        this.vertexAttrsAreBound = false;\n        this.itemsToPoll = [];\n        const glVersion = env().getNumber('WEBGL_VERSION');\n        if (gl != null) {\n            this.gl = gl;\n            setWebGLContext(glVersion, gl);\n        }\n        else {\n            this.gl = getWebGLContext(glVersion);\n        }\n        // WebGL 2.0 enables texture floats without an extension.\n        let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n        if (env().getNumber('WEBGL_VERSION') === 1) {\n            const TEXTURE_FLOAT = 'OES_texture_float';\n            const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n            this.textureFloatExtension =\n                webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n            if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n                this.textureHalfFloatExtension =\n                    webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n            }\n            else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n                throw new Error('GL context does not support half float textures, yet the ' +\n                    'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n            }\n            this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n            if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n                this.colorBufferHalfFloatExtension =\n                    webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n            }\n            else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n                throw new Error('GL context does not support color renderable half floats, yet ' +\n                    'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n            }\n        }\n        else {\n            COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n            if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n                this.colorBufferFloatExtension =\n                    this.gl.getExtension(COLOR_BUFFER_FLOAT);\n            }\n            else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n                this.colorBufferHalfFloatExtension =\n                    this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n            }\n            else {\n                throw new Error('GL context does not support color renderable floats');\n            }\n        }\n        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n        this.framebuffer = webgl_util.createFramebuffer(this.gl);\n        this.textureConfig =\n            tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n    }\n    get debug() {\n        return env().getBool('DEBUG');\n    }\n    dispose() {\n        if (this.disposed) {\n            return;\n        }\n        if (this.program != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n                ' This is probably a resource leak, delete the program with ' +\n                'GPGPUContext.deleteProgram before disposing.');\n        }\n        if (this.outputTexture != null) {\n            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +\n                'texture.  This is probably a resource leak, delete the output ' +\n                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n                'disposing.');\n        }\n        const gl = this.gl;\n        webgl_util.callAndCheck(gl, () => gl.finish());\n        webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n        webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n        webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n        this.disposed = true;\n    }\n    createFloat32MatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createFloat16MatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createUnsignedBytesMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    uploadPixelDataToTexture(texture, pixels) {\n        this.throwIfDisposed();\n        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n    }\n    uploadDenseMatrixToTexture(texture, width, height, data) {\n        this.throwIfDisposed();\n        gpgpu_util.uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);\n    }\n    createFloat16PackedMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    createPackedMatrixTexture(rows, columns) {\n        this.throwIfDisposed();\n        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n    deleteMatrixTexture(texture) {\n        this.throwIfDisposed();\n        if (this.outputTexture === texture) {\n            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n            this.outputTexture = null;\n        }\n        webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n    }\n    downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {\n        return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl, rows, columns, this.textureConfig));\n    }\n    downloadPackedMatrixFromBuffer(buffer, batch, rows, columns, physicalRows, physicalCols) {\n        return gpgpu_util.downloadPackedMatrixFromBuffer(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);\n    }\n    downloadFloat32MatrixFromBuffer(buffer, size) {\n        return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n    }\n    createBufferFromTexture(texture, rows, columns) {\n        this.bindTextureToFrameBuffer(texture);\n        const result = gpgpu_util.createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);\n        this.unbindTextureToFrameBuffer();\n        return result;\n    }\n    createAndWaitForFence() {\n        const fenceContext = this.createFence(this.gl);\n        return this.pollFence(fenceContext);\n    }\n    createFence(gl) {\n        let query;\n        let isFencePassed;\n        if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n            const gl2 = gl;\n            const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n            gl.flush();\n            isFencePassed = () => {\n                const status = gl2.clientWaitSync(sync, 0, 0);\n                return status === gl2.ALREADY_SIGNALED ||\n                    status === gl2.CONDITION_SATISFIED;\n            };\n            query = sync;\n        }\n        else if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n            query = this.beginQuery();\n            this.endQuery();\n            isFencePassed = () => this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n        }\n        else {\n            // If we have no way to fence, return true immediately. This will fire in\n            // WebGL 1.0 when there is no disjoint query timer. In this case, because\n            // the fence passes immediately, we'll immediately ask for a download of\n            // the texture, which will cause the UI thread to hang.\n            isFencePassed = () => true;\n        }\n        return { query, isFencePassed };\n    }\n    downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {\n        return this.downloadMatrixDriver(texture, () => gpgpu_util.downloadMatrixFromPackedOutputTexture(this.gl, physicalRows, physicalCols));\n    }\n    createProgram(fragmentShaderSource) {\n        this.throwIfDisposed();\n        const gl = this.gl;\n        const fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);\n        if (this.vertexShader == null) {\n            this.vertexShader = gpgpu_util.createVertexShader(gl);\n        }\n        const program = webgl_util.createProgram(gl);\n        webgl_util.callAndCheck(gl, () => gl.attachShader(program, this.vertexShader));\n        webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n        webgl_util.linkProgram(gl, program);\n        if (this.debug) {\n            webgl_util.validateProgram(gl, program);\n        }\n        if (!this.vertexAttrsAreBound) {\n            this.setProgram(program);\n            this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);\n        }\n        return program;\n    }\n    deleteProgram(program) {\n        this.throwIfDisposed();\n        if (program === this.program) {\n            this.program = null;\n        }\n        if (program != null) {\n            webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n        }\n    }\n    setProgram(program) {\n        this.throwIfDisposed();\n        this.program = program;\n        if ((this.program != null) && this.debug) {\n            webgl_util.validateProgram(this.gl, this.program);\n        }\n        webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n    }\n    getUniformLocation(program, uniformName, shouldThrow = true) {\n        this.throwIfDisposed();\n        if (shouldThrow) {\n            return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);\n        }\n        else {\n            return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);\n        }\n    }\n    getAttributeLocation(program, attribute) {\n        this.throwIfDisposed();\n        return webgl_util.callAndCheck(this.gl, () => this.gl.getAttribLocation(program, attribute));\n    }\n    getUniformLocationNoThrow(program, uniformName) {\n        this.throwIfDisposed();\n        return this.gl.getUniformLocation(program, uniformName);\n    }\n    setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        webgl_util.bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n    }\n    setOutputMatrixTexture(outputMatrixTexture, rows, columns) {\n        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n    }\n    setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {\n        this.throwIfDisposed();\n        const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n    }\n    setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);\n    }\n    setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n    }\n    debugValidate() {\n        if (this.program != null) {\n            webgl_util.validateProgram(this.gl, this.program);\n        }\n        webgl_util.validateFramebuffer(this.gl);\n    }\n    executeProgram() {\n        this.throwIfDisposed();\n        this.throwIfNoProgram();\n        const gl = this.gl;\n        if (this.debug) {\n            this.debugValidate();\n        }\n        webgl_util.callAndCheck(gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n    }\n    blockUntilAllProgramsCompleted() {\n        this.throwIfDisposed();\n        webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n    }\n    getQueryTimerExtension() {\n        if (this.disjointQueryTimerExtension == null) {\n            this.disjointQueryTimerExtension =\n                webgl_util.getExtensionOrThrow(this.gl, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?\n                    'EXT_disjoint_timer_query_webgl2' :\n                    'EXT_disjoint_timer_query');\n        }\n        return this.disjointQueryTimerExtension;\n    }\n    getQueryTimerExtensionWebGL2() {\n        return this.getQueryTimerExtension();\n    }\n    getQueryTimerExtensionWebGL1() {\n        return this.getQueryTimerExtension();\n    }\n    beginQuery() {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            const query = gl2.createQuery();\n            gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n            return query;\n        }\n        const ext = this.getQueryTimerExtensionWebGL1();\n        const query = ext.createQueryEXT();\n        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n        return query;\n    }\n    endQuery() {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            gl2.endQuery(ext.TIME_ELAPSED_EXT);\n            return;\n        }\n        const ext = this.getQueryTimerExtensionWebGL1();\n        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n    }\n    async waitForQueryAndGetTime(query) {\n        await util.repeatedTry(() => this.disposed || // while testing contexts are created / disposed\n            // in rapid succession, so without this check we\n            // may poll for the query timer indefinitely\n            this.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n        return this.getQueryTime(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    }\n    getQueryTime(query, queryTimerVersion) {\n        if (queryTimerVersion === 0) {\n            return null;\n        }\n        if (queryTimerVersion === 2) {\n            const gl2 = this.gl;\n            const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n            // Return milliseconds.\n            return timeElapsedNanos / 1000000;\n        }\n        else {\n            const ext = this.getQueryTimerExtensionWebGL1();\n            const timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n            // Return milliseconds.\n            return timeElapsedNanos / 1000000;\n        }\n    }\n    isQueryAvailable(query, queryTimerVersion) {\n        if (queryTimerVersion === 0) {\n            return true;\n        }\n        if (queryTimerVersion === 2) {\n            const gl2 = this.gl;\n            const ext = this.getQueryTimerExtensionWebGL2();\n            const available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n            if (this.disjoint == null) {\n                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n            }\n            return available && !this.disjoint;\n        }\n        else {\n            const ext = this.getQueryTimerExtensionWebGL1();\n            const available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n            if (this.disjoint == null) {\n                this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n            }\n            return available && !this.disjoint;\n        }\n    }\n    pollFence(fenceContext) {\n        return new Promise(resolve => {\n            this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n        });\n    }\n    pollItems() {\n        // Find the last query that has finished.\n        const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n        for (let i = 0; i <= index; ++i) {\n            const { resolveFn } = this.itemsToPoll[i];\n            resolveFn();\n        }\n        this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n    }\n    addItemToPoll(isDoneFn, resolveFn) {\n        this.itemsToPoll.push({ isDoneFn, resolveFn });\n        if (this.itemsToPoll.length > 1) {\n            // We already have a running loop that polls.\n            return;\n        }\n        // Start a new loop that polls.\n        util.repeatedTry(() => {\n            this.pollItems();\n            // End the loop if no more items to poll.\n            return this.itemsToPoll.length === 0;\n        });\n    }\n    bindTextureToFrameBuffer(texture) {\n        this.throwIfDisposed();\n        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);\n        if (this.debug) {\n            webgl_util.validateFramebuffer(this.gl);\n        }\n    }\n    unbindTextureToFrameBuffer() {\n        if (this.outputTexture != null) {\n            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);\n            if (this.debug) {\n                webgl_util.validateFramebuffer(this.gl);\n            }\n        }\n        else {\n            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n        }\n    }\n    downloadMatrixDriver(texture, downloadAndDecode) {\n        this.bindTextureToFrameBuffer(texture);\n        const result = downloadAndDecode();\n        this.unbindTextureToFrameBuffer();\n        return result;\n    }\n    setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {\n        this.throwIfDisposed();\n        const gl = this.gl;\n        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);\n        if (this.debug) {\n            webgl_util.validateFramebuffer(gl);\n        }\n        this.outputTexture = outputMatrixTextureMaybePacked;\n        webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n        webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n    }\n    setOutputMatrixWriteRegionDriver(x, y, width, height) {\n        this.throwIfDisposed();\n        webgl_util.callAndCheck(this.gl, () => this.gl.scissor(x, y, width, height));\n    }\n    throwIfDisposed() {\n        if (this.disposed) {\n            throw new Error('Attempted to use disposed GPGPUContext.');\n        }\n    }\n    throwIfNoProgram() {\n        if (this.program == null) {\n            throw new Error('No GPU program is currently set.');\n        }\n    }\n}\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nexport function linearSearchLastTrue(arr) {\n    let i = 0;\n    for (; i < arr.length; ++i) {\n        const isDone = arr[i]();\n        if (!isDone) {\n            break;\n        }\n    }\n    return i - 1;\n}\n//# sourceMappingURL=gpgpu_context.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport * as shader_compiler from './shader_compiler';\nexport function compileProgram(gpgpu, program, inputs, output) {\n    const userCode = program.userCode;\n    const inputInfos = inputs.map((input, i) => {\n        const shapeInfo = {\n            logicalShape: input.shape,\n            texShape: input.isUniform ? null : input.texData.texShape,\n            isUniform: input.isUniform,\n            isPacked: input.isUniform ? false : input.texData.isPacked,\n            flatOffset: null\n        };\n        if (input.texData != null && input.texData.slice != null &&\n            input.texData.slice.flatOffset > 0) {\n            shapeInfo.flatOffset = input.texData.slice.flatOffset;\n        }\n        return { name: program.variableNames[i], shapeInfo };\n    });\n    const inShapeInfos = inputInfos.map(x => x.shapeInfo);\n    const outShapeInfo = {\n        logicalShape: output.shape,\n        texShape: output.texData.texShape,\n        isUniform: false,\n        isPacked: output.texData.isPacked,\n        flatOffset: null\n    };\n    const source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.packedInputs);\n    const webGLProgram = gpgpu.createProgram(source);\n    // Add special uniforms (NAN, INFINITY)\n    let infLoc = null;\n    const nanLoc = gpgpu.getUniformLocation(webGLProgram, 'NAN', false);\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n        infLoc = gpgpu.getUniformLocation(webGLProgram, 'INFINITY', false);\n    }\n    // Add user-defined uniforms\n    const uniformLocations = {};\n    for (let i = 0; i < program.variableNames.length; i++) {\n        const varName = program.variableNames[i];\n        const shouldThrow = false;\n        uniformLocations[varName] =\n            gpgpu.getUniformLocation(webGLProgram, varName, shouldThrow);\n        uniformLocations[`offset${varName}`] =\n            gpgpu.getUniformLocation(webGLProgram, `offset${varName}`, shouldThrow);\n    }\n    return {\n        program,\n        source,\n        webGLProgram,\n        uniformLocations,\n        inShapeInfos,\n        outShapeInfo,\n        infLoc,\n        nanLoc,\n    };\n}\nfunction validateBinaryAndProgram(shapeInfos, inputs) {\n    if (shapeInfos.length !== inputs.length) {\n        throw Error(`Binary was compiled with ${shapeInfos.length} inputs, but ` +\n            `was executed with ${inputs.length} inputs`);\n    }\n    shapeInfos.forEach((s, i) => {\n        const shapeA = s.logicalShape;\n        const input = inputs[i];\n        const shapeB = input.shape;\n        if (!util.arraysEqual(shapeA, shapeB)) {\n            throw Error(`Binary was compiled with different shapes than ` +\n                `the current args. Shapes ${shapeA} and ${shapeB} must match`);\n        }\n        // The input is uploaded as uniform.\n        if (s.isUniform && input.isUniform) {\n            return;\n        }\n        const texShapeA = s.texShape;\n        const texShapeB = input.isUniform ? null : input.texData.texShape;\n        if (!util.arraysEqual(texShapeA, texShapeB)) {\n            throw Error(`Binary was compiled with different texture shapes than the` +\n                ` current args. Shape ${texShapeA} and ${texShapeB} must match`);\n        }\n    });\n}\nexport function runProgram(gpgpu, binary, inputs, output, customSetup) {\n    validateBinaryAndProgram(binary.inShapeInfos, inputs);\n    validateBinaryAndProgram([binary.outShapeInfo], [output]);\n    const outTex = output.texData.texture;\n    const outTexShape = output.texData.texShape;\n    if (output.texData.isPacked) {\n        gpgpu.setOutputPackedMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n    }\n    else {\n        gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);\n    }\n    gpgpu.setProgram(binary.webGLProgram);\n    // Set special uniforms (NAN, INFINITY)\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n        if (binary.infLoc !== null) {\n            gpgpu.gl.uniform1f(binary.infLoc, Infinity);\n        }\n    }\n    if (binary.nanLoc !== null) {\n        gpgpu.gl.uniform1f(binary.nanLoc, NaN);\n    }\n    // Set user-defined inputs\n    inputs.forEach((input, i) => {\n        const varName = binary.program.variableNames[i];\n        const varLoc = binary.uniformLocations[varName];\n        const varOffsetLoc = binary.uniformLocations[`offset${varName}`];\n        if (varLoc == null) {\n            // The compiler inferred that this variable is not used in this shader.\n            return;\n        }\n        if (input.isUniform) {\n            // Upload the values of the tensor as uniform.\n            if (util.sizeFromShape(input.shape) < 2) {\n                gpgpu.gl.uniform1f(varLoc, input.uniformValues[0]);\n            }\n            else {\n                let vals = input.uniformValues;\n                if (!(vals instanceof Float32Array)) {\n                    vals = new Float32Array(vals);\n                }\n                gpgpu.gl.uniform1fv(varLoc, vals);\n            }\n            return;\n        }\n        // If the input was sliced, upload the flat offset index.\n        if (input.texData.slice != null && varOffsetLoc != null) {\n            gpgpu.gl.uniform1i(varOffsetLoc, input.texData.slice.flatOffset);\n        }\n        gpgpu.setInputMatrixTexture(input.texData.texture, varLoc, i);\n    });\n    if (customSetup != null) {\n        customSetup(gpgpu, binary.webGLProgram);\n    }\n    gpgpu.executeProgram();\n}\nexport function makeShaderKey(program, inputs, output) {\n    let keyInputs = '';\n    inputs.concat(output).forEach(x => {\n        const hasOffset = x.texData != null && x.texData.slice != null &&\n            x.texData.slice.flatOffset > 0;\n        const texShape = x.isUniform ? 'uniform' : x.texData.texShape;\n        keyInputs += `${x.shape}_${texShape}_${hasOffset}`;\n    });\n    const keyUserCode = program.userCode;\n    let key = program.constructor.name;\n    // Fast string concat. See https://jsperf.com/string-concatenation/14.\n    key += '_' + keyInputs + '_' + keyUserCode;\n    return key;\n}\n//# sourceMappingURL=gpgpu_math.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Import webgl flags.\nimport './flags_webgl';\nimport { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, scalar, tidy, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { DecodeMatrixProgram } from './decode_matrix_gpu';\nimport { DecodeMatrixPackedProgram } from './decode_matrix_packed_gpu';\nimport { EncodeFloatProgram } from './encode_float_gpu';\nimport { EncodeFloatPackedProgram } from './encode_float_packed_gpu';\nimport { EncodeMatrixProgram } from './encode_matrix_gpu';\nimport { EncodeMatrixPackedProgram } from './encode_matrix_packed_gpu';\nimport { GPGPUContext } from './gpgpu_context';\nimport * as gpgpu_math from './gpgpu_math';\nimport { simpleAbsImplCPU } from './kernel_utils/shared';\nimport { PackProgram } from './pack_gpu';\nimport { ReshapePackedProgram } from './reshape_packed_gpu';\nimport * as tex_util from './tex_util';\nimport { TextureUsage } from './tex_util';\nimport { TextureManager } from './texture_manager';\nimport * as unary_op from './unaryop_gpu';\nimport { UnaryOpProgram } from './unaryop_gpu';\nimport { UnaryOpPackedProgram } from './unaryop_packed_gpu';\nimport { UnpackProgram } from './unpack_gpu';\nimport * as webgl_util from './webgl_util';\nconst whereImpl = kernel_impls.whereImpl;\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\nconst binaryCaches = {};\nexport function getBinaryCache(webGLVersion) {\n    if (webGLVersion in binaryCaches) {\n        return binaryCaches[webGLVersion];\n    }\n    binaryCaches[webGLVersion] = {};\n    return binaryCaches[webGLVersion];\n}\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nconst CPU_HANDOFF_SIZE_THRESHOLD = 128;\n// Empirically determined constant used to decide the number of MB on GPU\n// before we warn about high memory use. The MB are this constant * screen area\n// * dpi / 1024 / 1024.\nconst BEFORE_PAGING_CONSTANT = 600;\nfunction numMBBeforeWarning() {\n    if (env().global.screen == null) {\n        return 1024; // 1 GB.\n    }\n    return (env().global.screen.height * env().global.screen.width *\n        window.devicePixelRatio) *\n        BEFORE_PAGING_CONSTANT / 1024 / 1024;\n}\nexport class MathBackendWebGL extends KernelBackend {\n    constructor(gpgpu) {\n        super();\n        // Maps data ids that have a pending read operation, to list of subscribers.\n        this.pendingRead = new WeakMap();\n        // List of data ids that are scheduled for disposal, but are waiting on a\n        // pending read operation.\n        this.pendingDisposal = new WeakSet();\n        // Used to count the number of 'shallow' sliced tensors that point to the\n        // same data id.\n        this.dataRefCount = new WeakMap();\n        this.numBytesInGPU = 0;\n        // Accumulated time spent (including blocking) in uploading data to webgl.\n        this.uploadWaitMs = 0;\n        // Accumulated time spent (including blocking in downloading data from webgl.\n        this.downloadWaitMs = 0;\n        // record the last manual GL Flush time.\n        this.lastGlFlushTime = 0;\n        this.warnedAboutMemory = false;\n        this.pendingDeletes = 0;\n        this.disposed = false;\n        if (!env().getBool('HAS_WEBGL')) {\n            throw new Error('WebGL is not supported on this device');\n        }\n        if (gpgpu == null) {\n            const gl = getWebGLContext(env().getNumber('WEBGL_VERSION'));\n            this.binaryCache = getBinaryCache(env().getNumber('WEBGL_VERSION'));\n            this.gpgpu = new GPGPUContext(gl);\n            this.canvas = gl.canvas;\n            this.gpgpuCreatedLocally = true;\n        }\n        else {\n            this.gpgpu = gpgpu;\n            this.binaryCache = {};\n            this.gpgpuCreatedLocally = false;\n            this.canvas = gpgpu.gl.canvas;\n        }\n        this.textureManager = new TextureManager(this.gpgpu);\n        this.numMBBeforeWarning = numMBBeforeWarning();\n        this.texData = new DataStorage(this, engine());\n    }\n    nextDataId() {\n        return MathBackendWebGL.nextDataId++;\n    }\n    numDataIds() {\n        return this.texData.numDataIds() - this.pendingDeletes;\n    }\n    write(values, shape, dtype) {\n        if (env().getBool('WEBGL_CHECK_NUMERICAL_PROBLEMS') ||\n            env().getBool('DEBUG')) {\n            this.checkNumericalProblems(values);\n        }\n        if (dtype === 'complex64' && values != null) {\n            throw new Error(`Cannot write to a complex64 dtype. ` +\n                `Please use tf.complex(real, imag).`);\n        }\n        const dataId = { id: this.nextDataId() };\n        this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount: 1 });\n        return dataId;\n    }\n    /** Return refCount of a `TensorData`. */\n    refCount(dataId) {\n        if (this.texData.has(dataId)) {\n            const tensorData = this.texData.get(dataId);\n            return tensorData.refCount;\n        }\n        return 0;\n    }\n    /** Increase refCount of a `TextureData`. */\n    incRef(dataId) {\n        const texData = this.texData.get(dataId);\n        texData.refCount++;\n    }\n    /** Decrease refCount of a `TextureData`. */\n    decRef(dataId) {\n        if (this.texData.has(dataId)) {\n            const texData = this.texData.get(dataId);\n            texData.refCount--;\n        }\n    }\n    move(dataId, values, shape, dtype, refCount) {\n        if (env().getBool('DEBUG')) {\n            this.checkNumericalProblems(values);\n        }\n        if (dtype === 'complex64') {\n            throw new Error(`Cannot write to a complex64 dtype. ` +\n                `Please use tf.complex(real, imag).`);\n        }\n        this.texData.set(dataId, { shape, dtype, values, usage: TextureUsage.UPLOAD, refCount });\n    }\n    disposeIntermediateTensorInfo(tensorInfo) {\n        this.disposeData(tensorInfo.dataId);\n    }\n    readSync(dataId) {\n        const texData = this.texData.get(dataId);\n        const { values, dtype, complexTensorInfos, slice, shape, isPacked } = texData;\n        // The presence of `slice` indicates this tensor is a shallow slice of a\n        // different tensor, and is using that original tensor's texture. Run\n        // `clone` in order to copy that texture and read from it.\n        if (slice != null) {\n            let program;\n            if (isPacked) {\n                program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n            }\n            else {\n                program = new UnaryOpProgram(shape, unary_op.CLONE);\n            }\n            const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);\n            const data = this.readSync(res.dataId);\n            this.disposeIntermediateTensorInfo(res);\n            return data;\n        }\n        if (values != null) {\n            return this.convertAndCacheOnCPU(dataId);\n        }\n        if (dtype === 'string') {\n            return values;\n        }\n        const shouldTimeProgram = this.activeTimers != null;\n        let start;\n        if (shouldTimeProgram) {\n            start = util.now();\n        }\n        let result;\n        if (dtype === 'complex64') {\n            const realValues = this.readSync(complexTensorInfos.real.dataId);\n            const imagValues = this.readSync(complexTensorInfos.imag.dataId);\n            result = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        else {\n            result = this.getValuesFromTexture(dataId);\n        }\n        if (shouldTimeProgram) {\n            this.downloadWaitMs += util.now() - start;\n        }\n        return this.convertAndCacheOnCPU(dataId, result);\n    }\n    async read(dataId) {\n        if (this.pendingRead.has(dataId)) {\n            const subscribers = this.pendingRead.get(dataId);\n            return new Promise(resolve => subscribers.push(resolve));\n        }\n        const texData = this.texData.get(dataId);\n        const { values, shape, slice, dtype, complexTensorInfos, isPacked } = texData;\n        // The presence of `slice` indicates this tensor is a shallow slice of a\n        // different tensor, and is using that original tensor's texture. Run\n        // `clone` in order to copy that texture and read from it.\n        if (slice != null) {\n            let program;\n            if (isPacked) {\n                program = new UnaryOpPackedProgram(shape, unary_op.CLONE);\n            }\n            else {\n                program = new UnaryOpProgram(shape, unary_op.CLONE);\n            }\n            const res = this.runWebGLProgram(program, [{ dataId, shape, dtype }], dtype);\n            const data = this.read(res.dataId);\n            this.disposeIntermediateTensorInfo(res);\n            return data;\n        }\n        if (values != null) {\n            return this.convertAndCacheOnCPU(dataId);\n        }\n        if (!env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED') &&\n            env().getNumber('WEBGL_VERSION') === 2) {\n            throw new Error(`tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and ` +\n                `WEBGL_VERSION=2 not yet supported.`);\n        }\n        let buffer = null;\n        let tmpDownloadTarget;\n        if (dtype !== 'complex64' && env().get('WEBGL_BUFFER_SUPPORTED')) {\n            // Possibly copy the texture into a buffer before inserting a fence.\n            tmpDownloadTarget = this.decode(dataId);\n            const tmpData = this.texData.get(tmpDownloadTarget.dataId);\n            buffer = this.gpgpu.createBufferFromTexture(tmpData.texture, ...tex_util.getDenseTexShape(shape));\n        }\n        this.pendingRead.set(dataId, []);\n        if (dtype !== 'complex64') {\n            // Create a fence and wait for it to resolve.\n            await this.gpgpu.createAndWaitForFence();\n        }\n        // Download the values from the GPU.\n        let vals;\n        if (dtype === 'complex64') {\n            const ps = await Promise.all([\n                this.read(complexTensorInfos.real.dataId),\n                this.read(complexTensorInfos.imag.dataId)\n            ]);\n            const realValues = ps[0];\n            const imagValues = ps[1];\n            vals = backend_util.mergeRealAndImagArrays(realValues, imagValues);\n        }\n        else if (buffer == null) {\n            vals = this.getValuesFromTexture(dataId);\n        }\n        else {\n            const size = util.sizeFromShape(shape);\n            vals = this.gpgpu.downloadFloat32MatrixFromBuffer(buffer, size);\n        }\n        if (tmpDownloadTarget != null) {\n            this.disposeIntermediateTensorInfo(tmpDownloadTarget);\n        }\n        const dTypeVals = this.convertAndCacheOnCPU(dataId, vals);\n        const subscribers = this.pendingRead.get(dataId);\n        this.pendingRead.delete(dataId);\n        // Notify all pending reads.\n        subscribers.forEach(resolve => resolve(dTypeVals));\n        if (this.pendingDisposal.has(dataId)) {\n            this.pendingDisposal.delete(dataId);\n            if (this.disposeData(dataId)) {\n                engine().removeDataId(dataId, this);\n            }\n            this.pendingDeletes--;\n        }\n        return dTypeVals;\n    }\n    bufferSync(t) {\n        const data = this.readSync(t.dataId);\n        let decodedData = data;\n        if (t.dtype === 'string') {\n            try {\n                // Decode the bytes into string.\n                decodedData = data.map(d => util.decodeString(d));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode encoded string bytes into utf-8');\n            }\n        }\n        return buffer(t.shape, t.dtype, decodedData);\n    }\n    checkNumericalProblems(values) {\n        if (values == null) {\n            return;\n        }\n        for (let i = 0; i < values.length; i++) {\n            const num = values[i];\n            if (!webgl_util.canBeRepresented(num)) {\n                if (env().getBool('WEBGL_RENDER_FLOAT32_CAPABLE')) {\n                    throw Error(`The value ${num} cannot be represented with your ` +\n                        `current settings. Consider enabling float32 rendering: ` +\n                        `'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);\n                }\n                throw Error(`The value ${num} cannot be represented on this device.`);\n            }\n        }\n    }\n    getValuesFromTexture(dataId) {\n        const { shape, dtype, isPacked } = this.texData.get(dataId);\n        const size = util.sizeFromShape(shape);\n        if (env().getBool('WEBGL_DOWNLOAD_FLOAT_ENABLED')) {\n            const tmpTarget = this.decode(dataId);\n            const tmpData = this.texData.get(tmpTarget.dataId);\n            const vals = this.gpgpu\n                .downloadMatrixFromPackedTexture(tmpData.texture, ...tex_util.getDenseTexShape(shape))\n                .subarray(0, size);\n            this.disposeIntermediateTensorInfo(tmpTarget);\n            return vals;\n        }\n        const shouldUsePackedProgram = env().getBool('WEBGL_PACK') && isPacked === true;\n        const outputShape = shouldUsePackedProgram ? webgl_util.getShapeAs3D(shape) : shape;\n        const program = shouldUsePackedProgram ?\n            new EncodeFloatPackedProgram(outputShape) :\n            new EncodeFloatProgram(outputShape);\n        const output = this.runWebGLProgram(program, [{ shape: outputShape, dtype, dataId }], 'float32');\n        const tmpData = this.texData.get(output.dataId);\n        const vals = this.gpgpu\n            .downloadByteEncodedFloatMatrixFromOutputTexture(tmpData.texture, tmpData.texShape[0], tmpData.texShape[1])\n            .subarray(0, size);\n        this.disposeIntermediateTensorInfo(output);\n        return vals;\n    }\n    timerAvailable() {\n        return env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0;\n    }\n    async time(f) {\n        const oldActiveTimers = this.activeTimers;\n        const newActiveTimers = [];\n        let outerMostTime = false;\n        if (this.programTimersStack == null) {\n            this.programTimersStack = newActiveTimers;\n            outerMostTime = true;\n        }\n        else {\n            this.activeTimers.push(newActiveTimers);\n        }\n        this.activeTimers = newActiveTimers;\n        f();\n        // needing to split these up because util.flatten only accepts certain types\n        const flattenedActiveTimerQueries = util.flatten(this.activeTimers.map((d) => d.query))\n            .filter(d => d != null);\n        const flattenedActiveTimerNames = util.flatten(this.activeTimers.map((d) => d.name))\n            .filter(d => d != null);\n        this.activeTimers = oldActiveTimers;\n        if (outerMostTime) {\n            this.programTimersStack = null;\n        }\n        const res = {\n            uploadWaitMs: this.uploadWaitMs,\n            downloadWaitMs: this.downloadWaitMs,\n            kernelMs: null,\n            wallMs: null // will be filled by the engine\n        };\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            const kernelMs = await Promise.all(flattenedActiveTimerQueries);\n            res['kernelMs'] = util.sum(kernelMs);\n            res['getExtraProfileInfo'] = () => kernelMs.map((d, i) => ({ name: flattenedActiveTimerNames[i], ms: d }))\n                .map(d => `${d.name}: ${d.ms}`)\n                .join(', ');\n        }\n        else {\n            res['kernelMs'] = {\n                error: 'WebGL query timers are not supported in this environment.'\n            };\n        }\n        this.uploadWaitMs = 0;\n        this.downloadWaitMs = 0;\n        return res;\n    }\n    memory() {\n        return {\n            unreliable: false,\n            numBytesInGPU: this.numBytesInGPU,\n            numBytesInGPUAllocated: this.textureManager.numBytesAllocated,\n            numBytesInGPUFree: this.textureManager.numBytesFree\n        };\n    }\n    startTimer() {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            return this.gpgpu.beginQuery();\n        }\n        return { startMs: util.now(), endMs: null };\n    }\n    endTimer(query) {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            this.gpgpu.endQuery();\n            return query;\n        }\n        query.endMs = util.now();\n        return query;\n    }\n    async getQueryTime(query) {\n        if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') > 0) {\n            return this.gpgpu.waitForQueryAndGetTime(query);\n        }\n        const timerQuery = query;\n        return timerQuery.endMs - timerQuery.startMs;\n    }\n    /**\n     * Decrease the RefCount on the dataId and dispose the memory if the dataId\n     * has 0 refCount. If there are pending read on the data, the disposal would\n     * added to the pending delete queue. Return true if the dataId is removed\n     * from backend or the backend does not contain the dataId, false if the\n     * dataId is not removed. Memory may or may not be released even when dataId\n     * is removed, which also depends on dataRefCount, see `releaseGPU`.\n     * @param dataId\n     * @oaram force Optional, remove the data regardless of refCount\n     */\n    disposeData(dataId, force = false) {\n        if (this.pendingDisposal.has(dataId)) {\n            return false;\n        }\n        // No-op if already disposed.\n        if (!this.texData.has(dataId)) {\n            return true;\n        }\n        // if force flag is set, change refCount to 0, this would ensure disposal\n        // when added to the pendingDisposal queue. Memory may or may not be\n        // released, which also depends on dataRefCount, see `releaseGPU`.\n        if (force) {\n            this.texData.get(dataId).refCount = 0;\n        }\n        else {\n            this.texData.get(dataId).refCount--;\n        }\n        if (!force && this.texData.get(dataId).refCount > 0) {\n            return false;\n        }\n        if (this.pendingRead.has(dataId)) {\n            this.pendingDisposal.add(dataId);\n            this.pendingDeletes++;\n            return false;\n        }\n        this.releaseGPUData(dataId);\n        const { complexTensorInfos } = this.texData.get(dataId);\n        if (complexTensorInfos != null) {\n            this.disposeData(complexTensorInfos.real.dataId, force);\n            this.disposeData(complexTensorInfos.imag.dataId, force);\n        }\n        this.texData.delete(dataId);\n        return true;\n    }\n    releaseGPUData(dataId) {\n        const { texture, dtype, texShape, usage, isPacked, slice } = this.texData.get(dataId);\n        const key = slice && slice.origDataId || dataId;\n        const refCount = this.dataRefCount.get(key);\n        if (refCount > 1) {\n            this.dataRefCount.set(key, refCount - 1);\n        }\n        else {\n            this.dataRefCount.delete(key);\n            if (texture != null) {\n                this.numBytesInGPU -= this.computeBytes(texShape, dtype);\n                this.textureManager.releaseTexture(texture, texShape, usage, isPacked);\n            }\n        }\n        const texData = this.texData.get(dataId);\n        texData.texture = null;\n        texData.texShape = null;\n        texData.isPacked = false;\n        texData.slice = null;\n    }\n    getTexture(dataId) {\n        this.uploadToGPU(dataId);\n        return this.texData.get(dataId).texture;\n    }\n    /**\n     * Returns internal information for the specific data bucket. Used in unit\n     * tests.\n     */\n    getDataInfo(dataId) {\n        return this.texData.get(dataId);\n    }\n    /*\n    Tests whether all the inputs to an op are small and on the CPU. This heuristic\n    determines when it would be faster to execute a kernel on the CPU. WebGL\n    kernels opt into running this check and forwarding when appropriate.\n    TODO(https://github.com/tensorflow/tfjs/issues/872): Develop a more\n    sustainable strategy for optimizing backend execution of ops.\n     */\n    shouldExecuteOnCPU(inputs, sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD) {\n        return env().getBool('WEBGL_CPU_FORWARD') &&\n            inputs.every(input => this.texData.get(input.dataId).texture == null &&\n                util.sizeFromShape(input.shape) < sizeThreshold);\n    }\n    getGPGPUContext() {\n        return this.gpgpu;\n    }\n    where(condition) {\n        backend_util.warn('tf.where() in webgl locks the UI thread. ' +\n            'Call tf.whereAsync() instead');\n        const condVals = condition.dataSync();\n        return whereImpl(condition.shape, condVals);\n    }\n    packedUnaryOp(x, op, dtype) {\n        const program = new UnaryOpPackedProgram(x.shape, op);\n        const outInfo = this.compileAndRun(program, [x], dtype);\n        return engine().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);\n    }\n    // TODO(msoulanille) remove this once the backend has been modularized\n    // a copy is needed here to break a circular dependency.\n    // Also remove the op from unary_op.\n    abs(x) {\n        // TODO: handle cases when x is complex.\n        if (this.shouldExecuteOnCPU([x]) && x.dtype !== 'complex64') {\n            const outValues = simpleAbsImplCPU(this.texData.get(x.dataId).values);\n            return this.makeOutput(x.shape, x.dtype, outValues);\n        }\n        if (env().getBool('WEBGL_PACK_UNARY_OPERATIONS')) {\n            return this.packedUnaryOp(x, unary_op.ABS, x.dtype);\n        }\n        const program = new UnaryOpProgram(x.shape, unary_op.ABS);\n        const outInfo = this.compileAndRun(program, [x]);\n        return engine().makeTensorFromDataId(outInfo.dataId, outInfo.shape, outInfo.dtype);\n    }\n    makeTensorInfo(shape, dtype, values) {\n        let dataId;\n        if (dtype === 'string' && values != null && values.length > 0 &&\n            util.isString(values[0])) {\n            const encodedValues = values.map(d => util.encodeString(d));\n            dataId = this.write(encodedValues, shape, dtype);\n        }\n        else {\n            dataId = this.write(values, shape, dtype);\n        }\n        this.texData.get(dataId).usage = null;\n        return { dataId, shape, dtype };\n    }\n    makeOutput(shape, dtype, values) {\n        const { dataId } = this.makeTensorInfo(shape, dtype, values);\n        return engine().makeTensorFromDataId(dataId, shape, dtype, this);\n    }\n    unpackTensor(input) {\n        const program = new UnpackProgram(input.shape);\n        return this.runWebGLProgram(program, [input], input.dtype);\n    }\n    packTensor(input) {\n        const program = new PackProgram(input.shape);\n        const preventEagerUnpackingOutput = true;\n        return this.runWebGLProgram(program, [input], input.dtype, null /* customSetup */, preventEagerUnpackingOutput);\n    }\n    packedReshape(input, afterShape) {\n        const input3DShape = [\n            webgl_util.getBatchDim(input.shape),\n            ...webgl_util.getRowsCols(input.shape)\n        ];\n        const input3D = {\n            dtype: input.dtype,\n            shape: input3DShape,\n            dataId: input.dataId\n        };\n        const afterShapeAs3D = [\n            webgl_util.getBatchDim(afterShape), ...webgl_util.getRowsCols(afterShape)\n        ];\n        const program = new ReshapePackedProgram(afterShapeAs3D, input3DShape);\n        const preventEagerUnpackingOfOutput = true;\n        const output = this.runWebGLProgram(program, [input3D], input.dtype, null /* customSetup */, preventEagerUnpackingOfOutput);\n        return { dataId: output.dataId, shape: afterShape, dtype: output.dtype };\n    }\n    decode(dataId) {\n        const texData = this.texData.get(dataId);\n        const { isPacked, shape, dtype } = texData;\n        const shapeAs3D = webgl_util.getShapeAs3D(shape);\n        let program;\n        if (isPacked) {\n            program = new DecodeMatrixPackedProgram(shapeAs3D);\n        }\n        else {\n            program = new DecodeMatrixProgram(shapeAs3D);\n        }\n        const preventEagerUnpackingOfOutput = true;\n        const out = this.runWebGLProgram(program, [{ shape: shapeAs3D, dtype, dataId }], dtype, null /* customSetup */, preventEagerUnpackingOfOutput);\n        return { dtype, shape, dataId: out.dataId };\n    }\n    runWebGLProgram(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput = false) {\n        const output = this.makeTensorInfo(program.outputShape, outputDtype);\n        const outData = this.texData.get(output.dataId);\n        if (program.packedOutput) {\n            outData.isPacked = true;\n        }\n        if (program.outPackingScheme === tex_util.PackingScheme.DENSE) {\n            const texelShape = tex_util.getDenseTexShape(program.outputShape);\n            // For a densely packed output, we explicitly set texShape\n            // so it doesn't get assigned later according to our typical packing\n            // scheme wherein a single texel can only contain values from adjacent\n            // rows/cols.\n            outData.texShape = texelShape.map(d => d * 2);\n        }\n        if (program.outTexUsage != null) {\n            outData.usage = program.outTexUsage;\n        }\n        if (util.sizeFromShape(output.shape) === 0) {\n            // Short-circuit the computation since the result is empty (has 0 in its\n            // shape).\n            outData.values =\n                util.getTypedArrayFromDType(output.dtype, 0);\n            return output;\n        }\n        const dataToDispose = [];\n        const inputsData = inputs.map(input => {\n            if (input.dtype === 'complex64') {\n                throw new Error(`GPGPUProgram does not support complex64 input. For complex64 ` +\n                    `dtypes, please separate the program into real and imaginary ` +\n                    `parts.`);\n            }\n            let texData = this.texData.get(input.dataId);\n            if (texData.texture == null) {\n                if (!program.packedInputs &&\n                    util.sizeFromShape(input.shape) <=\n                        env().getNumber('WEBGL_SIZE_UPLOAD_UNIFORM')) {\n                    // Upload small tensors that live on the CPU as uniforms, not as\n                    // textures. Do this only when the environment supports 32bit floats\n                    // due to problems when comparing 16bit floats with 32bit floats.\n                    // TODO(https://github.com/tensorflow/tfjs/issues/821): Make it\n                    // possible for packed shaders to sample from uniforms.\n                    return {\n                        shape: input.shape,\n                        texData: null,\n                        isUniform: true,\n                        uniformValues: texData.values\n                    };\n                }\n                // This ensures that if a packed program's inputs have not yet been\n                // uploaded to the GPU, they get uploaded as packed right off the bat.\n                if (program.packedInputs) {\n                    texData.isPacked = true;\n                    texData.shape = input.shape;\n                }\n            }\n            else if (!!texData.isPacked !== !!program.packedInputs) {\n                input = texData.isPacked ? this.unpackTensor(input) :\n                    this.packTensor(input);\n                dataToDispose.push(input);\n                texData = this.texData.get(input.dataId);\n            }\n            else if (texData.isPacked &&\n                !webgl_util.isReshapeFree(texData.shape, input.shape)) {\n                // This is a special case where a texture exists for a tensor\n                // but the shapes are incompatible (due to packing constraints) because\n                // the tensor did not have a chance to go through the packed reshape\n                // shader. This only happens when we reshape the *same* tensor to form\n                // *distinct* inputs to an op, e.g. dotting a vector with itself. This\n                // case will disappear once packed uploading is the default.\n                const savedInput = input;\n                const targetShape = input.shape;\n                input.shape = texData.shape;\n                input = this.packedReshape(input, targetShape);\n                dataToDispose.push(input);\n                texData = this.texData.get(input.dataId);\n                savedInput.shape = targetShape;\n            }\n            this.uploadToGPU(input.dataId);\n            return { shape: input.shape, texData, isUniform: false };\n        });\n        this.uploadToGPU(output.dataId);\n        const outputData = { shape: output.shape, texData: outData, isUniform: false };\n        const key = gpgpu_math.makeShaderKey(program, inputsData, outputData);\n        const binary = this.getAndSaveBinary(key, () => {\n            return gpgpu_math.compileProgram(this.gpgpu, program, inputsData, outputData);\n        });\n        const shouldTimeProgram = this.activeTimers != null;\n        let query;\n        if (shouldTimeProgram) {\n            query = this.startTimer();\n        }\n        gpgpu_math.runProgram(this.gpgpu, binary, inputsData, outputData, customSetup);\n        dataToDispose.forEach(info => this.disposeIntermediateTensorInfo(info));\n        if (shouldTimeProgram) {\n            query = this.endTimer(query);\n            this.activeTimers.push({ name: program.constructor.name, query: this.getQueryTime(query) });\n        }\n        const glFlushThreshold = env().get('WEBGL_FLUSH_THRESHOLD');\n        // Manually GL flush requested\n        if (glFlushThreshold > 0) {\n            const time = util.now();\n            if ((time - this.lastGlFlushTime) > glFlushThreshold) {\n                this.gpgpu.gl.flush();\n                this.lastGlFlushTime = time;\n            }\n        }\n        if (!env().getBool('WEBGL_LAZILY_UNPACK') && outData.isPacked &&\n            preventEagerUnpackingOfOutput === false) {\n            const unpacked = this.unpackTensor(output);\n            this.disposeIntermediateTensorInfo(output);\n            return unpacked;\n        }\n        return output;\n    }\n    compileAndRun(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput = false) {\n        outputDtype = outputDtype || inputs[0].dtype;\n        const outInfo = this.runWebGLProgram(program, inputs, outputDtype, customSetup, preventEagerUnpackingOfOutput);\n        return outInfo;\n    }\n    getAndSaveBinary(key, getBinary) {\n        if (!(key in this.binaryCache)) {\n            this.binaryCache[key] = getBinary();\n        }\n        return this.binaryCache[key];\n    }\n    getTextureManager() {\n        return this.textureManager;\n    }\n    dispose() {\n        if (this.disposed) {\n            return;\n        }\n        // Avoid disposing the compiled webgl programs during unit testing because\n        // it slows down test execution.\n        if (!env().getBool('IS_TEST')) {\n            const allKeys = Object.keys(this.binaryCache);\n            allKeys.forEach(key => {\n                this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);\n                delete this.binaryCache[key];\n            });\n        }\n        this.textureManager.dispose();\n        if (this.canvas != null &&\n            (typeof (HTMLCanvasElement) !== 'undefined' &&\n                this.canvas instanceof HTMLCanvasElement)) {\n            this.canvas.remove();\n        }\n        else {\n            this.canvas = null;\n        }\n        if (this.gpgpuCreatedLocally) {\n            this.gpgpu.program = null;\n            this.gpgpu.dispose();\n        }\n        this.disposed = true;\n    }\n    floatPrecision() {\n        if (this.floatPrecisionValue == null) {\n            this.floatPrecisionValue = tidy(() => {\n                if (!env().get('WEBGL_RENDER_FLOAT32_ENABLED')) {\n                    // Momentarily switching DEBUG flag to false so we don't throw an\n                    // error trying to upload a small value.\n                    const debugFlag = env().getBool('DEBUG');\n                    env().set('DEBUG', false);\n                    const underflowCheckValue = this.abs(scalar(1e-8)).dataSync()[0];\n                    env().set('DEBUG', debugFlag);\n                    if (underflowCheckValue > 0) {\n                        return 32;\n                    }\n                }\n                return 16;\n            });\n        }\n        return this.floatPrecisionValue;\n    }\n    /** Returns the smallest representable number.  */\n    epsilon() {\n        return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n    }\n    uploadToGPU(dataId) {\n        const texData = this.texData.get(dataId);\n        const { shape, dtype, values, texture, usage, isPacked } = texData;\n        if (texture != null) {\n            // Array is already on GPU. No-op.\n            return;\n        }\n        const shouldTimeProgram = this.activeTimers != null;\n        let start;\n        if (shouldTimeProgram) {\n            start = util.now();\n        }\n        let texShape = texData.texShape;\n        if (texShape == null) {\n            texShape = webgl_util.getTextureShapeFromLogicalShape(shape, isPacked);\n            texData.texShape = texShape;\n        }\n        if (values != null) {\n            const shapeAs3D = webgl_util.getShapeAs3D(shape);\n            let program;\n            let width = texShape[1], height = texShape[0];\n            const isByteArray = values instanceof Uint8Array;\n            if (isPacked) {\n                [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(texShape[0], texShape[1]);\n                program = new EncodeMatrixPackedProgram(shapeAs3D, [height, width], isByteArray);\n            }\n            else {\n                program =\n                    new EncodeMatrixProgram(shapeAs3D, [height, width], isByteArray);\n            }\n            const tempDenseInputHandle = this.makeTensorInfo([height, width], dtype);\n            if (isByteArray) {\n                this.texData.get(tempDenseInputHandle.dataId).usage =\n                    TextureUsage.PIXELS;\n            }\n            else {\n                this.texData.get(tempDenseInputHandle.dataId).usage =\n                    TextureUsage.UPLOAD;\n            }\n            this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(tempDenseInputHandle.dataId), width, height, values);\n            // We want the output to remain packed regardless of the value of\n            // WEBGL_PACK.\n            const preventEagerUnpacking = true;\n            const encodedOutputTarget = this.runWebGLProgram(program, [tempDenseInputHandle], dtype, null, preventEagerUnpacking);\n            // Have the original texture assume the identity of the encoded output.\n            const outputTexData = this.texData.get(encodedOutputTarget.dataId);\n            texData.texture = outputTexData.texture;\n            texData.texShape = outputTexData.texShape;\n            texData.isPacked = outputTexData.isPacked;\n            texData.usage = outputTexData.usage;\n            this.disposeIntermediateTensorInfo(tempDenseInputHandle);\n            this.texData.delete(encodedOutputTarget.dataId);\n            // Once uploaded, don't store the values on cpu.\n            texData.values = null;\n            if (shouldTimeProgram) {\n                this.uploadWaitMs += util.now() - start;\n            }\n        }\n        else {\n            const newTexture = this.acquireTexture(texShape, usage, dtype, isPacked);\n            texData.texture = newTexture;\n        }\n    }\n    convertAndCacheOnCPU(dataId, float32Values) {\n        const texData = this.texData.get(dataId);\n        const { dtype } = texData;\n        this.releaseGPUData(dataId);\n        if (float32Values != null) {\n            texData.values = float32ToTypedArray(float32Values, dtype);\n        }\n        return texData.values;\n    }\n    acquireTexture(texShape, texType, dtype, isPacked) {\n        this.numBytesInGPU += this.computeBytes(texShape, dtype);\n        if (!this.warnedAboutMemory &&\n            this.numBytesInGPU > this.numMBBeforeWarning * 1024 * 1024) {\n            const mb = (this.numBytesInGPU / 1024 / 1024).toFixed(2);\n            this.warnedAboutMemory = true;\n            console.warn(`High memory usage in GPU: ${mb} MB, ` +\n                `most likely due to a memory leak`);\n        }\n        return this.textureManager.acquireTexture(texShape, texType, isPacked);\n    }\n    computeBytes(shape, dtype) {\n        return shape[0] * shape[1] * util.bytesPerElement(dtype);\n    }\n}\nMathBackendWebGL.nextDataId = 0;\nfunction float32ToTypedArray(a, dtype) {\n    if (dtype === 'float32' || dtype === 'complex64') {\n        return a;\n    }\n    else if (dtype === 'int32' || dtype === 'bool') {\n        const result = (dtype === 'int32') ? new Int32Array(a.length) :\n            new Uint8Array(a.length);\n        for (let i = 0; i < result.length; ++i) {\n            result[i] = Math.round(a[i]);\n        }\n        return result;\n    }\n    else {\n        throw new Error(`Unknown dtype ${dtype}`);\n    }\n}\n//# sourceMappingURL=backend_webgl.js.map","/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// base.ts is the webgl backend without auto kernel registration.\nimport { device_util, registerBackend } from '@tensorflow/tfjs-core';\nimport { MathBackendWebGL } from './backend_webgl';\nexport { version as version_webgl } from './version';\nif (device_util.isBrowser()) {\n    registerBackend('webgl', () => new MathBackendWebGL(), 2 /* priority */);\n}\n// Export webgl utilities\nexport * from './webgl';\n// Export forceHalfFlost under webgl namespace for the union bundle.\nimport { forceHalfFloat } from './webgl';\nexport const webgl = { forceHalfFloat };\n//# sourceMappingURL=base.js.map","import { getCoordsDataType } from './shader_compiler';\nexport class CumSumProgram {\n    constructor(shape, exclusive, reverse) {\n        this.variableNames = ['x'];\n        this.outputShape = shape;\n        const rank = shape.length;\n        const val = exclusive ? '0.0' : `getX(${getCoords(rank, 'coords')})`;\n        const length = shape[shape.length - 1];\n        let condition = '';\n        let idxString = '';\n        // When exclusive is set, the cumsum op becomes roll op that copies the\n        // value from the previous index based on the direction specified by the\n        // reverse flag.\n        if (exclusive) {\n            condition = reverse ? `end != ${length - 1}` : 'end != 0';\n            idxString = reverse ? 'end + 1' : 'end - 1';\n        }\n        else {\n            condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n            idxString = (reverse ? 'end + pow2' : 'end - pow2');\n        }\n        this.userCode = `\n      uniform float index;\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords')};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords')} = idx;\n          val += getX(${getCoords(rank, 'coords')});\n        }\n        setOutput(val);\n      }\n    `;\n    }\n    getCustomSetupFunc(index) {\n        return (gpgpu, webGLProgram) => {\n            if (this.index == null) {\n                this.index = gpgpu.getUniformLocation(webGLProgram, 'index');\n            }\n            gpgpu.gl.uniform1f(this.index, index);\n        };\n    }\n}\nfunction getCoords(rank, name) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.x, ${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.x, ${name}.y, ${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n    }\n    else {\n        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n    }\n}\nfunction getFinalCoord(rank, name) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.w`;\n    }\n    else {\n        throw Error(`Cumulative sum for rank ${rank} is not yet supported`);\n    }\n}\n//# sourceMappingURL=cumsum_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport const CHECK_NAN_SNIPPET = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n`;\nexport const ELU_DER = `\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n`;\nexport const NOT_EQUAL = `\n  return vec4(notEqual(a, b));\n`;\nexport class BinaryOpPackedProgram {\n    constructor(op, aShape, bShape, checkOutOfBounds = false) {\n        this.variableNames = ['A', 'B'];\n        this.supportsBroadcasting = true;\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        const rank = this.outputShape.length;\n        let checkOutOfBoundsString = '';\n        if (checkOutOfBounds) {\n            if (rank === 0 || util.sizeFromShape(this.outputShape) === 1) {\n                checkOutOfBoundsString = `\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        `;\n            }\n            else {\n                const dtype = getCoordsDataType(rank);\n                checkOutOfBoundsString = `\n          ${dtype} coords = getOutputCoords();\n        `;\n                if (rank === 1) {\n                    checkOutOfBoundsString += `\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;\n                }\n                else {\n                    const channels = getChannels('coords', rank);\n                    checkOutOfBoundsString += `\n            bool nextRowOutOfBounds =\n              (${channels[rank - 2]} + 1) >= ${this.outputShape[rank - 2]};\n            bool nextColOutOfBounds =\n              (${channels[rank - 1]} + 1) >= ${this.outputShape[rank - 1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `;\n                }\n            }\n        }\n        this.userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${op}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${checkOutOfBoundsString}\n\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=binaryop_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport function createVertexShader(gl) {\n    const glsl = getGlslDifferences();\n    const vertexShaderSource = `${glsl.version}\n    precision highp float;\n    ${glsl.attribute} vec3 clipSpacePos;\n    ${glsl.attribute} vec2 uv;\n    ${glsl.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;\n    return webgl_util.createVertexShader(gl, vertexShaderSource);\n}\nexport function createVertexBuffer(gl) {\n    // [x y z u v] * [upper-left, lower-left, upper-right, lower-right]\n    const vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);\n    return webgl_util.createStaticVertexBuffer(gl, vertexArray);\n}\nexport function createIndexBuffer(gl) {\n    // OpenGL (and WebGL) have \"CCW == front\" winding\n    const triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);\n    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);\n}\nfunction createAndConfigureTexture(gl, width, height, internalFormat, textureFormat, textureType) {\n    webgl_util.validateTextureSize(width, height);\n    const texture = webgl_util.createTexture(gl);\n    const tex2d = gl.TEXTURE_2D;\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(tex2d, texture));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST));\n    webgl_util.callAndCheck(gl, () => gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST));\n    webgl_util.callAndCheck(gl, () => gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, textureFormat, textureType, null));\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n    return texture;\n}\nexport function getInternalFormatForFloat32MatrixTexture(textureConfig) {\n    return textureConfig.internalFormatFloat;\n}\nexport function createFloat32MatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat32MatrixTexture(textureConfig), textureConfig.textureFormatFloat, gl.FLOAT);\n}\nexport function getInternalFormatForFloat16MatrixTexture(textureConfig) {\n    return textureConfig.internalFormatHalfFloat;\n}\nexport function createFloat16MatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16MatrixTexture(textureConfig), textureConfig.textureFormatFloat, textureConfig.textureTypeHalfFloat);\n}\nexport function getInternalFormatForUnsignedBytesMatrixTexture(textureConfig) {\n    return textureConfig.downloadTextureFormat;\n}\nexport function createUnsignedBytesMatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForUnsignedBytesMatrixTexture(textureConfig), gl.RGBA, gl.UNSIGNED_BYTE);\n}\nexport function getInternalFormatForPackedMatrixTexture(textureConfig) {\n    return textureConfig.internalFormatPackedFloat;\n}\nexport function createPackedMatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForPackedMatrixTexture(textureConfig), gl.RGBA, gl.FLOAT);\n}\nexport function getInternalFormatForFloat16PackedMatrixTexture(textureConfig) {\n    return textureConfig.internalFormatPackedHalfFloat;\n}\nexport function createFloat16PackedMatrixTexture(gl, rows, columns, textureConfig) {\n    const [width, height] = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    return createAndConfigureTexture(gl, width, height, getInternalFormatForFloat16PackedMatrixTexture(textureConfig), gl.RGBA, textureConfig.textureTypeHalfFloat);\n}\nexport function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {\n    const posOffset = 0; // x is the first buffer element\n    const uvOffset = 3 * 4; // uv comes after [x y z]\n    const stride = (3 * 4) + (2 * 4); // xyz + uv, each entry is 4-byte float.\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer));\n    const success = webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);\n    return success &&\n        webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);\n}\nexport function uploadDenseMatrixToTexture(gl, texture, width, height, data, textureConfig) {\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n    let dataForUpload, texelDataType, internalFormat;\n    if (data instanceof Uint8Array) {\n        dataForUpload = new Uint8Array(width * height * 4);\n        texelDataType = gl.UNSIGNED_BYTE;\n        internalFormat = gl.RGBA;\n    }\n    else {\n        dataForUpload = new Float32Array(width * height * 4);\n        texelDataType = gl.FLOAT;\n        internalFormat = textureConfig.internalFormatPackedFloat;\n    }\n    dataForUpload.set(data);\n    webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, gl.RGBA, texelDataType, dataForUpload));\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function uploadPixelDataToTexture(gl, texture, pixels) {\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n    if (pixels.data instanceof Uint8Array) {\n        webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.width, pixels.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels.data));\n    }\n    else {\n        webgl_util.callAndCheck(gl, () => gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels));\n    }\n    webgl_util.callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function createBufferFromOutputTexture(gl2, rows, columns, textureConfig) {\n    // Create and bind the buffer.\n    const buffer = gl2.createBuffer();\n    webgl_util.callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer));\n    // Initialize the buffer to the size of the texture in bytes.\n    const bytesPerFloat = 4;\n    const valuesPerTexel = 4;\n    const bufferSizeBytes = bytesPerFloat * valuesPerTexel * rows * columns;\n    webgl_util.callAndCheck(gl2, () => gl2.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl2.STREAM_READ));\n    // Enqueue a command on the GPU command queue to copy of texture into the\n    // buffer.\n    webgl_util.callAndCheck(gl2, () => gl2.readPixels(0, 0, columns, rows, gl2.RGBA, gl2.FLOAT, 0));\n    webgl_util.callAndCheck(gl2, () => gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null));\n    return buffer;\n}\nexport function downloadFloat32MatrixFromBuffer(gl, buffer, size) {\n    const gl2 = gl;\n    const downloadTarget = new Float32Array(size);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n    return downloadTarget;\n}\nexport function downloadByteEncodedFloatMatrixFromOutputTexture(gl, rows, columns, textureConfig) {\n    const [w, h] = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns);\n    const numChannels = 4;\n    const downloadTarget = new Uint8Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, numChannels));\n    webgl_util.callAndCheck(gl, () => gl.readPixels(0, 0, w, h, textureConfig.downloadTextureFormat, gl.UNSIGNED_BYTE, downloadTarget));\n    // By wrapping the buffer in a Float32Array, we use native browser IEEE 754\n    // decoding of the 4 bytes that back each 32 bit float.\n    return new Float32Array(downloadTarget.buffer);\n}\nexport function downloadPackedMatrixFromBuffer(gl, buffer, batch, rows, cols, physicalRows, physicalCols, textureConfig) {\n    const gl2 = gl;\n    const downloadTarget = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(physicalRows, physicalCols));\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer);\n    gl2.getBufferSubData(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget);\n    gl2.bindBuffer(gl2.PIXEL_PACK_BUFFER, null);\n    return downloadTarget;\n}\nexport function downloadMatrixFromPackedOutputTexture(gl, physicalRows, physicalCols) {\n    const packedRGBA = new Float32Array(physicalRows * physicalCols * 4);\n    webgl_util.callAndCheck(gl, () => gl.readPixels(0, 0, physicalCols, physicalRows, gl.RGBA, gl.FLOAT, packedRGBA));\n    return packedRGBA;\n}\n//# sourceMappingURL=gpgpu_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class FFTProgram {\n    constructor(component, inputShape, inverse) {\n        this.variableNames = ['real', 'imag'];\n        const innerDim = inputShape[1];\n        this.outputShape = inputShape;\n        const exponentMultiplierSnippet = inverse ? `2.0 * ${Math.PI}` : `-2.0 * ${Math.PI}`;\n        const resultDenominator = inverse ? `${innerDim}.0` : '1.0';\n        let opString;\n        if (component === 'real') {\n            opString = 'return real * expR - imag * expI;';\n        }\n        else if (component === 'imag') {\n            opString = 'return real * expI + imag * expR;';\n        }\n        else {\n            throw new Error(`FFT component must be either \"real\" or \"imag\", got ${component}.`);\n        }\n        this.userCode = `\n      const float exponentMultiplier = ${exponentMultiplierSnippet};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${opString}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${innerDim});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${innerDim}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${resultDenominator};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=fft_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DepthwiseConv2DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${channelMul} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class DepthwiseConv2DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${channelMul}; dm++) {\n              int d2 = d1 * ${channelMul} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_backprop_gpu_depthwise.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class FlipLeftRightProgram {\n    constructor(imageShape) {\n        this.variableNames = ['Image'];\n        this.outputShape = [];\n        const imageWidth = imageShape[2];\n        this.outputShape = imageShape;\n        this.userCode = `\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${imageWidth} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${imageWidth}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `;\n    }\n}\n//# sourceMappingURL=flip_left_right_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlslDifferences } from './glsl_version';\nexport class Im2ColPackedProgram {\n    constructor(outputShape, inputShape, convInfo) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        const { filterWidth, inChannels, strideWidth, strideHeight, padInfo, outWidth, dilationWidth, dilationHeight, dataFormat } = convInfo;\n        const { left, top } = padInfo;\n        const itemsPerBlockRow = inChannels * filterWidth;\n        const glsl = getGlslDifferences();\n        const isChannelsLast = dataFormat === 'channelsLast';\n        const rowDim = isChannelsLast ? 0 : 1;\n        const colDim = isChannelsLast ? 1 : 2;\n        let unrolled = ``;\n        for (let row = 0; row <= 1; row++) {\n            for (let col = 0; col <= 1; col++) {\n                unrolled += `\n          blockIndex = rc.y + ${col};\n          pos = rc.x + ${row};\n\n          if(blockIndex < ${outputShape[1]} && pos < ${outputShape[0]}) {\n            offsetY = int(blockIndex / (${outWidth})) * ${strideHeight} - ${top};\n            d0 = offsetY + ${dilationHeight} * (pos / ${itemsPerBlockRow});\n\n            if(d0 < ${inputShape[rowDim]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${outWidth}.) * ${strideWidth}. - ${left}.);\n              d1 = offsetX + ${dilationWidth} * (int(mod(float(pos), ${itemsPerBlockRow}.) / ${inChannels}.));\n\n              if(d1 < ${inputShape[colDim]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${inChannels}.));\n\n                if (${isChannelsLast}) {\n                  innerDims = vec2(d1, ch);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${row * 2 + col}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;\n            }\n        }\n        this.userCode = `\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${unrolled}\n\n        ${glsl.output} = result;\n      }\n    `;\n    }\n}\n//# sourceMappingURL=im2col_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class CropAndResizeProgram {\n    constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {\n        this.variableNames = ['Image', 'Boxes', 'BoxInd'];\n        this.outputShape = [];\n        const [batch, imageHeight, imageWidth, depth] = imageShape;\n        const [numBoxes,] = boxShape;\n        const [cropHeight, cropWidth] = cropSize;\n        this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n        const methodId = method === 'bilinear' ? 1 : 0;\n        const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];\n        const [heightRatio, heightScale, inY] = cropHeight > 1 ?\n            [\n                `${(imageHeight - 1) / (cropHeight - 1)}`,\n                '(y2-y1) * height_ratio',\n                `y1*${inputHeightFloat} + float(y)*(height_scale)`,\n            ] :\n            [\n                '0.0',\n                '0.0',\n                `0.5 * (y1+y2) * ${inputHeightFloat}`,\n            ];\n        const [widthRatio, widthScale, inX] = cropWidth > 1 ?\n            [\n                `${(imageWidth - 1) / (cropWidth - 1)}`,\n                '(x2-x1) * width_ratio',\n                `x1*${inputWidthFloat} + float(x)*(width_scale)`,\n            ] :\n            [\n                '0.0',\n                '0.0',\n                `0.5 * (x1+x2) * ${inputWidthFloat}`,\n            ];\n        // Reference implementation\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n        this.userCode = `\n      const float height_ratio = float(${heightRatio});\n      const float width_ratio = float(${widthRatio});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${batch}) {\n          return;\n        }\n\n        float height_scale = ${heightScale};\n        float width_scale = ${widthScale};\n\n        float in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n        float in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${methodId} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=crop_and_resize_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ArgMinMaxProgram {\n    constructor(reduceInfo, op, firstPass) {\n        this.variableNames = ['A'];\n        const { windowSize, batchSize, outSize } = reduceInfo;\n        if (!firstPass) {\n            this.variableNames.push('bestIndicesA');\n        }\n        this.outputShape = [batchSize, outSize];\n        const compOp = (op === 'max') ? '>' : '<';\n        const indexSnippet = firstPass ?\n            'inOffset + i;' :\n            'round(getBestIndicesA(batch, inOffset + i));';\n        this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          int inIdx = ${indexSnippet};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${compOp} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=argminmax_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class GatherProgram {\n    constructor(aShape, outputShape) {\n        this.variableNames = ['A', 'indices'];\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        const dtype = getCoordsDataType(this.rank);\n        const sourceCoords = getSourceCoords(aShape, 2);\n        this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        setOutput(getA(${sourceCoords}));\n      }\n    `;\n    }\n}\n// The input and output are always flattened into rank 4 tensors.\nfunction getSourceCoords(aShape, axis) {\n    const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n    const sourceCoords = [];\n    for (let i = 0; i < aShape.length; i++) {\n        if (i === 2) {\n            sourceCoords.push('int(getIndices(resRC.x, resRC.z))');\n        }\n        else {\n            sourceCoords.push(`${currentCoords[i]}`);\n        }\n    }\n    return sourceCoords.join();\n}\n//# sourceMappingURL=gather_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ArgMinMaxPackedProgram {\n    constructor(shape, windowSize, op, firstPass) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        util.assert(shape.length > 2, () => `Packed arg${op.charAt(0).toUpperCase() +\n            op.slice(1)} supports only inputs with rank above 2.`);\n        const inSize = shape[shape.length - 1];\n        const outSize = Math.ceil(inSize / windowSize);\n        this.outputShape = shape.slice(0, -1);\n        if (outSize > 1) {\n            this.outputShape.push(outSize);\n        }\n        if (!firstPass) {\n            this.variableNames.push('bestIndicesA');\n        }\n        const outShape = this.outputShape;\n        const rank = outShape.length;\n        const dtype = getCoordsDataType(rank);\n        const coords = getChannels('coords', rank);\n        let sourceLocSetup;\n        let sourceRank;\n        if (outSize === 1) {\n            sourceRank = rank + 1;\n            const sourceLocDType = getCoordsDataType(sourceRank);\n            sourceLocSetup = `\n        ${sourceLocDType} sourceLocR = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 1]};\n        ${sourceLocDType} sourceLocG = ${sourceLocDType}(${coords.join()}, 0);\n        ++${coords[rank - 2]};\n        ${sourceLocDType} sourceLocA = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 1]};\n        ${sourceLocDType} sourceLocB = ${sourceLocDType}(${coords.join()}, 0);\n        --${coords[rank - 2]};`;\n        }\n        else {\n            sourceRank = rank;\n            sourceLocSetup = `\n        ${dtype} sourceLocR = coords;\n        ++${coords[rank - 1]};\n        ${dtype} sourceLocG = coords;\n        ++${coords[rank - 2]};\n        ${dtype} sourceLocA = coords;\n        --${coords[rank - 1]};\n        ${dtype} sourceLocB = coords;\n        --${coords[rank - 2]};`;\n        }\n        const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, sourceRank);\n        const inChannel = '.' + channels[sourceRank - 1]; // e.g. \".b\" for rank 3.\n        const intChannels = channels.map(x => 'int ' + x);\n        const srcRCoords = getChannels('sourceLocR', sourceRank - 1).concat('inIdx.r');\n        const srcGCoords = getChannels('sourceLocG', sourceRank - 1).concat('inIdx.g');\n        const srcBCoords = getChannels('sourceLocB', sourceRank - 1).concat('inIdx.b');\n        const srcACoords = getChannels('sourceLocA', sourceRank - 1).concat('inIdx.a');\n        const compOp = (op === 'max') ? 'greaterThan' : 'lessThan';\n        const fetchCandidateIdx = firstPass ? '' : `\n          inIdx = round(vec4(getBestIndicesAChannel(${srcRCoords.join()}),\n                             getBestIndicesAChannel(${srcGCoords.join()}),\n                             getBestIndicesAChannel(${srcBCoords.join()}),\n                             getBestIndicesAChannel(${srcACoords.join()})));`;\n        const fetchValue = `vec4(\n            getAChannel(${srcRCoords.join()}),\n            hasNextCol ? getAChannel(${srcGCoords.join()}) : 0.,\n            hasNextRow ? getAChannel(${srcBCoords.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${srcACoords.join()}) : 0.)`;\n        const getBestIndicesAChannelSnippet = firstPass ? '' : `\n      float getBestIndicesAChannel(${intChannels.join()}) {\n        return getChannel(getBestIndicesA(${channels.join()}),\n                                          vec2(${channels.slice(-2).join()}));\n      }`;\n        this.userCode = `\n      float getAChannel(${intChannels.join()}) {\n        return getChannel(getA(${channels.join()}),\n                               vec2(${channels.slice(-2).join()}));\n      }\n      ${getBestIndicesAChannelSnippet}\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        bool hasNextCol = ${coords[rank - 1]} < ${outShape[rank - 1] - 1};\n        bool hasNextRow = ${coords[rank - 2]} < ${outShape[rank - 2] - 1};\n        ${sourceLocSetup}\n        ivec4 srcIdx = ivec4(sourceLocR${inChannel}, sourceLocG${inChannel},\n          sourceLocB${inChannel}, sourceLocA${inChannel}) * ${windowSize};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${fetchValue};\n\n        for (int i = 0; i < ${windowSize}; i++) {\n          inIdx = srcIdx;\n          ${fetchCandidateIdx}\n          vec4 candidate = ${fetchValue};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${compOp}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=argminmax_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\n// (Ar + Ai)(Br + Bi) =\n// ArBr + ArBi + AiBr + AiBi = ArBr - AB + ArBi + AiBr\n// Yr = ArBr - AB\n// Yi = ArBi + AiBr\nexport const COMPLEX_MULTIPLY = {\n    REAL: 'return areal * breal - aimag * bimag;',\n    IMAG: 'return areal * bimag + aimag * breal;'\n};\nexport class BinaryOpComplexProgram {\n    constructor(op, aShape, bShape) {\n        this.variableNames = ['AReal', 'AImag', 'BReal', 'BImag'];\n        this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        this.userCode = `\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${op}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=binaryop_complex_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ComplexAbsProgram {\n    constructor(shape) {\n        this.variableNames = ['real', 'imag'];\n        this.outputShape = shape;\n        this.userCode = `\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    `;\n    }\n}\n//# sourceMappingURL=complex_abs_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport class BatchNormPackedProgram {\n    constructor(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.variableNames = ['x', 'mean', 'variance'];\n        backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n        backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n        let offsetSnippet = 'vec4(0.0)';\n        if (offsetShape != null) {\n            backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n            this.variableNames.push('offset');\n            offsetSnippet = 'getOffsetAtOutCoords()';\n        }\n        let scaleSnippet = 'vec4(1.0)';\n        if (scaleShape != null) {\n            backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n            this.variableNames.push('scale');\n            scaleSnippet = 'getScaleAtOutCoords()';\n        }\n        this.outputShape = xShape;\n        this.userCode = `\n      void main() {\n        vec4 offset = ${offsetSnippet};\n        vec4 scale = ${scaleSnippet};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${varianceEpsilon}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=batchnorm_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Dilation2DProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const { inHeight, inWidth, padInfo, strideHeight, strideWidth, filterHeight, filterWidth, dilationHeight, dilationWidth } = convInfo;\n        const { top: padTop, left: padLeft } = padInfo;\n        this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${filterHeight}; h++) {\n          int hIn = hBeg + h * ${dilationHeight};\n\n          if (hIn >= 0 && hIn < ${inHeight}) {\n            for (int w = 0; w < ${filterWidth}; w++) {\n              int wIn = wBeg + w * ${dilationWidth};\n\n              if (wIn >= 0 && wIn < ${inWidth}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=dilation_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ClipProgram {\n    constructor(aShape) {\n        this.variableNames = ['A'];\n        this.outputShape = aShape;\n        this.userCode = `\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    `;\n    }\n    getCustomSetupFunc(min, max) {\n        return (gpgpu, webGLProgram) => {\n            if (this.minLoc == null) {\n                this.minLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'minVal');\n                this.maxLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'maxVal');\n            }\n            gpgpu.gl.uniform1f(this.minLoc, min);\n            gpgpu.gl.uniform1f(this.maxLoc, max);\n        };\n    }\n}\n//# sourceMappingURL=clip_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Conv2DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              if (${isChannelsLast}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv2DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        const rowDim = isChannelsLast ? 1 : 2;\n        const colDim = isChannelsLast ? 2 : 3;\n        const channelDim = isChannelsLast ? 3 : 1;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${channelDim}];\n\n        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n\n              if (${isChannelsLast}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv3DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.userCode = `\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {\n            int xF = wF + yF * ${strideDepth} - ${padFront};\n\n            if (xF < 0 || xF >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n              int xR = wR + yR * ${strideHeight} - ${padTop};\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n                int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv3DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padFront = filterDepth - 1 - convInfo.padInfo.front;\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${filterDepth} - 1 - wF;\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${filterHeight} - 1 - wR;\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${filterWidth} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=conv_backprop_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ConcatPackedProgram {\n    constructor(shapes, axis) {\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = [];\n        this.outputShape = backend_util.computeOutShape(shapes, axis);\n        const shape = this.outputShape;\n        const rank = shape.length;\n        const dtype = getCoordsDataType(rank);\n        const coords = getChannels('coords', rank);\n        const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][axis];\n        for (let i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][axis];\n        }\n        const channel = channels[axis];\n        const lastChannels = channels.slice(-2);\n        const allChannels = channels.join();\n        let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n        for (let i = 1; i < offsets.length; i++) {\n            const shift = offsets[i - 1];\n            // Note: the >= comparison below may seem unnecessary given the check\n            // above but is needed to workaround branch execution issues on some\n            // devices. It makes all the conditions exclusive without relying on\n            // execution order.\n            getValueSnippet += `\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n          return getChannel(\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\n        }`;\n        }\n        const lastIndex = offsets.length;\n        const shift = offsets[offsets.length - 1];\n        getValueSnippet += `\n        return getChannel(\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\n        this.userCode = `\n      float getValue(${channels.map(x => 'int ' + x)}) {\n        ${getValueSnippet}\n      }\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.g = getValue(${coords});\n        }\n\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\n          result.a = getValue(${coords});\n        }\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.b = getValue(${coords});\n        }\n        setOutput(result);\n      }\n    `;\n    }\n}\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\nfunction shiftedChannels(channels, channel, shift) {\n    const channelIdx = channels.indexOf(channel);\n    const res = channels.map((c, idx) => {\n        if (idx === channelIdx) {\n            return `${c} - ${shift}`;\n        }\n        else {\n            return c;\n        }\n    });\n    return res.join();\n}\n//# sourceMappingURL=concat_packed_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class AddNProgram {\n    constructor(outputShape, shapes) {\n        this.outputShape = [];\n        this.outputShape = outputShape;\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const snippets = [];\n        // Get target elements from every input tensor.\n        this.variableNames.forEach(variable => {\n            snippets.push(`float v${variable} = get${variable}AtOutCoords();`);\n        });\n        // Calculate the sum of all elements.\n        const operation = this.variableNames\n            .map(variable => {\n            return `v${variable}`;\n        })\n            .join(' + ');\n        this.userCode = `\n      void main() {\n        ${snippets.join('\\n        ')}\n\n        float result = ${operation};\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=addn_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class AvgPool2DBackpropProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy'];\n        this.outputShape = convInfo.inShape;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const avgMultiplier = 1 / (filterHeight * filterWidth);\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${effectiveFilterWidth};\n            wC+= ${dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class AvgPool3DBackpropProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy'];\n        this.outputShape = convInfo.inShape;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = effectiveFilterDepth - 1 - convInfo.padInfo.front;\n        const padTop = effectiveFilterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = effectiveFilterWidth - 1 - convInfo.padInfo.left;\n        const avgMultiplier = 1 / (filterDepth * filterHeight * filterWidth);\n        this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float avgMultiplier = float(${avgMultiplier});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${convInfo.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=avg_pool_backprop_gpu.js.map","import { getCoordsDataType } from './shader_compiler';\nexport class GatherNDProgram {\n    constructor(sliceDim, strides, shape) {\n        this.sliceDim = sliceDim;\n        this.strides = strides;\n        this.variableNames = ['x', 'indices'];\n        this.outputShape = shape;\n        const stridesType = getCoordsDataType(strides.length);\n        const dtype = getCoordsDataType(shape.length);\n        const strideString = this.sliceDim > 1 ? 'strides[j]' : 'strides';\n        this.userCode = `\n        ${stridesType} strides = ${stridesType}(${this.strides});\n         void main() {\n          ${dtype} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${strideString};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `;\n    }\n}\n//# sourceMappingURL=gather_nd_gpu.js.map"],"names":["contexts","WEBGL_ATTRIBUTES","alpha","antialias","premultipliedAlpha","preserveDrawingBuffer","depth","stencil","failIfMajorPerformanceCaveat","setWebGLContext","webGLVersion","gl","getWebGLContext","newCtx","Error","canvas","OffscreenCanvas","document","createElement","createCanvas","addEventListener","ev","preventDefault","getContext","getWebGLRenderingContext","isContextLost","disable","DEPTH_TEST","STENCIL_TEST","BLEND","DITHER","POLYGON_OFFSET_FILL","SAMPLE_COVERAGE","enable","SCISSOR_TEST","CULL_FACE","cullFace","BACK","DepthwiseConv2DProgram","constructor","convInfo","addBias","activation","hasPreluActivation","hasLeakyReluAlpha","this","variableNames","outputShape","outShape","xNumRows","inHeight","xNumCols","inWidth","padTop","padInfo","top","padLeft","left","strideHeight","strideWidth","dilationHeight","dilationWidth","filterHeight","filterWidth","channelMul","outChannels","inChannels","activationSnippet","applyActivationSnippet","addBiasSnippet","push","userCode","ClipPackedProgram","aShape","packedInputs","packedOutput","getCustomSetupFunc","min","max","gpgpu","webGLProgram","minLoc","getUniformLocationNoThrow","maxLoc","uniform1f","DepthwiseConvPacked2DProgram","texelsAcross","mainLoop","c","r","texelC","colIndex","nextTexelOffset","util","ConcatProgram","shapes","backend_util","map","_","i","offsets","Array","length","snippets","shift","lastIndex","lastShift","join","getGlslDifferences","version","attribute","varyingVs","varyingFs","texture2D","output","defineOutput","defineSpecialNaN","defineSpecialInf","defineRound","env","getNumber","Conv2DProgram","hasPreluActivationWeights","hasLeakyreluAlpha","inputDepthNearestVec4","Math","floor","inputDepthVec4Remainder","isChannelsLast","dataFormat","rowDim","colDim","channelDim","Conv3DProgram","padFront","front","strideDepth","dilationDepth","filterDepth","inDepth","CHECK_NAN_SNIPPET","BinaryOpProgram","op","bShape","FillProgram","shape","value","valueLoc","BatchNormProgram","xShape","meanShape","varianceShape","offsetShape","scaleShape","varianceEpsilon","offsetSnippet","scaleSnippet","AddNPackedProgram","forEach","variable","operation","DiagProgram","size","DepthToSpaceProgram","blockSize","getHeightCoordString","getWidthCoordString","getDepthCoordString","getOutputDepthSize","getInputSamplingString","ENV","registerFlag","get","getBool","device_util","threshold","DecodeMatrixProgram","outPackingScheme","DENSE","texShape","glsl","DecodeMatrixPackedProgram","EncodeFloatProgram","outTexUsage","DOWNLOAD","EncodeFloatPackedProgram","EncodeMatrixProgram","inputIsUnsignedByte","height","width","EncodeMatrixPackedProgram","row","col","channel","GPGPUContext","outputTexture","program","disposed","vertexAttrsAreBound","itemsToPoll","glVersion","COLOR_BUFFER_FLOAT","COLOR_BUFFER_HALF_FLOAT","TEXTURE_FLOAT","TEXTURE_HALF_FLOAT","textureFloatExtension","webgl_util","textureHalfFloatExtension","colorBufferFloatExtension","getExtension","colorBufferHalfFloatExtension","vertexBuffer","gpgpu_util","indexBuffer","framebuffer","textureConfig","tex_util","debug","dispose","finish","bindFramebuffer","FRAMEBUFFER","deleteFramebuffer","bindBuffer","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","deleteBuffer","createFloat32MatrixTexture","rows","columns","throwIfDisposed","createFloat16MatrixTexture","createUnsignedBytesMatrixTexture","uploadPixelDataToTexture","texture","pixels","uploadDenseMatrixToTexture","data","createFloat16PackedMatrixTexture","createPackedMatrixTexture","deleteMatrixTexture","deleteTexture","downloadByteEncodedFloatMatrixFromOutputTexture","downloadMatrixDriver","downloadPackedMatrixFromBuffer","buffer","batch","physicalRows","physicalCols","downloadFloat32MatrixFromBuffer","createBufferFromTexture","bindTextureToFrameBuffer","result","unbindTextureToFrameBuffer","createAndWaitForFence","fenceContext","createFence","pollFence","query","isFencePassed","gl2","sync","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","status","clientWaitSync","ALREADY_SIGNALED","CONDITION_SATISFIED","beginQuery","endQuery","isQueryAvailable","downloadMatrixFromPackedTexture","createProgram","fragmentShaderSource","fragmentShader","vertexShader","attachShader","setProgram","deleteProgram","useProgram","getUniformLocation","uniformName","shouldThrow","getAttributeLocation","getAttribLocation","setInputMatrixTexture","inputMatrixTexture","uniformLocation","textureUnit","throwIfNoProgram","setOutputMatrixTexture","outputMatrixTexture","setOutputMatrixTextureDriver","setOutputPackedMatrixTexture","outputPackedMatrixTexture","setOutputMatrixWriteRegion","startRow","numRows","startColumn","numColumns","setOutputMatrixWriteRegionDriver","setOutputPackedMatrixWriteRegion","debugValidate","executeProgram","drawElements","TRIANGLES","UNSIGNED_SHORT","blockUntilAllProgramsCompleted","getQueryTimerExtension","disjointQueryTimerExtension","getQueryTimerExtensionWebGL2","getQueryTimerExtensionWebGL1","ext","createQuery","TIME_ELAPSED_EXT","createQueryEXT","beginQueryEXT","endQueryEXT","waitForQueryAndGetTime","getQueryTime","queryTimerVersion","getQueryParameter","QUERY_RESULT","getQueryObjectEXT","QUERY_RESULT_EXT","available","QUERY_RESULT_AVAILABLE","disjoint","getParameter","GPU_DISJOINT_EXT","QUERY_RESULT_AVAILABLE_EXT","Promise","resolve","addItemToPoll","pollItems","index","arr","linearSearchLastTrue","x","isDoneFn","resolveFn","slice","downloadAndDecode","outputMatrixTextureMaybePacked","viewport","scissor","y","validateBinaryAndProgram","shapeInfos","inputs","s","shapeA","logicalShape","input","shapeB","isUniform","texShapeA","texShapeB","texData","whereImpl","kernel_impls","binaryCaches","MathBackendWebGL","KernelBackend","super","pendingRead","WeakMap","pendingDisposal","WeakSet","dataRefCount","numBytesInGPU","uploadWaitMs","downloadWaitMs","lastGlFlushTime","warnedAboutMemory","pendingDeletes","binaryCache","gpgpuCreatedLocally","textureManager","numMBBeforeWarning","global","screen","window","devicePixelRatio","DataStorage","engine","nextDataId","numDataIds","write","values","dtype","checkNumericalProblems","dataId","id","set","usage","UPLOAD","refCount","has","incRef","decRef","move","disposeIntermediateTensorInfo","tensorInfo","disposeData","readSync","complexTensorInfos","isPacked","res","runWebGLProgram","convertAndCacheOnCPU","shouldTimeProgram","activeTimers","start","realValues","real","imagValues","imag","getValuesFromTexture","read","subscribers","tmpDownloadTarget","vals","decode","tmpData","ps","all","dTypeVals","delete","removeDataId","bufferSync","t","decodedData","d","_a","num","tmpTarget","subarray","shouldUsePackedProgram","timerAvailable","time","f","oldActiveTimers","newActiveTimers","outerMostTime","programTimersStack","flattenedActiveTimerQueries","filter","flattenedActiveTimerNames","name","kernelMs","wallMs","ms","error","memory","unreliable","numBytesInGPUAllocated","numBytesAllocated","numBytesInGPUFree","numBytesFree","startTimer","startMs","endMs","endTimer","timerQuery","force","add","releaseGPUData","key","origDataId","computeBytes","releaseTexture","getTexture","uploadToGPU","getDataInfo","shouldExecuteOnCPU","sizeThreshold","every","getGPGPUContext","where","condition","condVals","dataSync","packedUnaryOp","outInfo","compileAndRun","makeTensorFromDataId","abs","outValues","makeOutput","makeTensorInfo","encodedValues","unpackTensor","packTensor","packedReshape","afterShape","input3DShape","input3D","afterShapeAs3D","R","shapeAs3D","outputDtype","customSetup","preventEagerUnpackingOfOutput","outData","texelShape","dataToDispose","inputsData","uniformValues","savedInput","targetShape","outputData","keyInputs","concat","hasOffset","flatOffset","keyUserCode","binary","getAndSaveBinary","inputInfos","shapeInfo","inShapeInfos","outShapeInfo","source","shader_compiler","infLoc","nanLoc","uniformLocations","varName","outTex","outTexShape","Infinity","NaN","varLoc","varOffsetLoc","Float32Array","uniform1fv","uniform1i","info","glFlushThreshold","unpacked","getBinary","getTextureManager","Object","keys","HTMLCanvasElement","remove","floatPrecision","floatPrecisionValue","tidy","debugFlag","underflowCheckValue","scalar","epsilon","isByteArray","Uint8Array","tempDenseInputHandle","PIXELS","preventEagerUnpacking","encodedOutputTarget","outputTexData","newTexture","acquireTexture","float32Values","a","Int32Array","round","float32ToTypedArray","texType","toFixed","registerBackend","CumSumProgram","exclusive","reverse","rank","val","getCoords","idxString","getFinalCoord","BinaryOpPackedProgram","checkOutOfBounds","supportsBroadcasting","checkOutOfBoundsString","channels","createVertexShader","vertexShaderSource","createVertexBuffer","vertexArray","createIndexBuffer","triangleVertexIndices","Uint16Array","createAndConfigureTexture","internalFormat","textureFormat","textureType","tex2d","TEXTURE_2D","bindTexture","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","texImage2D","getInternalFormatForFloat32MatrixTexture","internalFormatFloat","textureFormatFloat","FLOAT","getInternalFormatForFloat16MatrixTexture","internalFormatHalfFloat","textureTypeHalfFloat","getInternalFormatForUnsignedBytesMatrixTexture","downloadTextureFormat","RGBA","UNSIGNED_BYTE","getInternalFormatForPackedMatrixTexture","internalFormatPackedFloat","getInternalFormatForFloat16PackedMatrixTexture","internalFormatPackedHalfFloat","bindVertexProgramAttributeStreams","dataForUpload","texelDataType","createBufferFromOutputTexture","createBuffer","PIXEL_PACK_BUFFER","bufferSizeBytes","bytesPerFloat","bufferData","STREAM_READ","readPixels","downloadTarget","getBufferSubData","w","h","cols","downloadMatrixFromPackedOutputTexture","packedRGBA","FFTProgram","component","inputShape","inverse","innerDim","exponentMultiplierSnippet","PI","resultDenominator","opString","DepthwiseConv2DDerFilterProgram","filterShape","batchSize","outHeight","outWidth","DepthwiseConv2DDerInputProgram","inShape","FlipLeftRightProgram","imageShape","imageWidth","Im2ColPackedProgram","itemsPerBlockRow","unrolled","CropAndResizeProgram","boxShape","cropSize","method","extrapolationValue","imageHeight","numBoxes","cropHeight","cropWidth","methodId","inputHeightFloat","inputWidthFloat","heightRatio","heightScale","inY","widthRatio","widthScale","inX","ArgMinMaxProgram","reduceInfo","firstPass","windowSize","outSize","compOp","indexSnippet","GatherProgram","sourceCoords","currentCoords","getSourceCoords","ArgMinMaxPackedProgram","charAt","toUpperCase","inSize","ceil","coords","sourceLocSetup","sourceRank","sourceLocDType","inChannel","intChannels","srcRCoords","srcGCoords","srcBCoords","srcACoords","fetchCandidateIdx","fetchValue","getBestIndicesAChannelSnippet","COMPLEX_MULTIPLY","REAL","IMAG","BinaryOpComplexProgram","ComplexAbsProgram","BatchNormPackedProgram","Dilation2DProgram","ClipProgram","Conv2DDerFilterProgram","Conv2DDerInputProgram","Conv3DDerFilterProgram","outDepth","Conv3DDerInputProgram","ConcatPackedProgram","axis","lastChannels","allChannels","getValueSnippet","shiftedChannels","channelIdx","indexOf","idx","AddNProgram","AvgPool2DBackpropProgram","effectiveFilterHeight","effectiveFilterWidth","avgMultiplier","AvgPool3DBackpropProgram","effectiveFilterDepth","GatherNDProgram","sliceDim","strides","stridesType","strideString"],"sourceRoot":""}