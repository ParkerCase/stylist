{"version":3,"file":"stylist-vendors-746661ec.85c981ae2a3802b05e42.js","mappings":"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K,IAAK,KAAKM,MAAM,EAAGN,GAAMY,KAAIqI,GAAK,GAAGxB,KAAQwB,KAC7E,CACO,SAASgJ,EAAYxK,EAAMzH,GAC9B,OAAa,IAATA,EACO,CAACyH,GAELuK,EAAevK,EAAMzH,EAChC,CACO,SAASkS,EAAgBlS,EAAMkP,GAClC,GAAa,IAATlP,EACA,MAAO,KAEX,IAAIG,EAAS,GACb,IAAK,IAAIT,EAAI,EAAGA,EAAIM,EAAMN,IACtBS,GAAU+O,EAAKxP,GACXA,EAAIM,EAAO,IACXG,GAAU,KAGlB,OAAOA,CACX,C,k4DCyIA,MAAMgS,GAAgB,CAClB,KACA,KACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,MACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,KACA,KACA,GAAAC,EACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,GAAAA,EACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MAEJ,IAAK,MAAMC,MAAgBF,IACvB,IAAAG,gBAAeD,G,+EC7TZ,MAAME,EACT,WA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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/reshape_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/scatter_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/slice_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/strided_slice_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/reduce_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_backprop_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/pack_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/rotate_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_bilinear_backprop_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/segment_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/resize_nearest_neighbor_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/pad_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/reverse_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/register_all_kernels.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/pool_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/select_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as shader_util from './shader_compiler_util';\nexport class ReshapePackedProgram {\n    constructor(outputShape, inputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        let mainLoop = ``;\n        for (let i = 0; i < 4; i++) {\n            let thisRC = `thisRC = rc;`;\n            if (i % 2 === 1) {\n                thisRC += `thisRC.z += 1;`;\n            }\n            if (i > 1) {\n                thisRC += `thisRC.y += 1;`;\n            }\n            mainLoop += `\n        ${thisRC}\n        ${i > 0 ? `if(thisRC.y < rows && thisRC.z < cols){` : ''}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i > 0 ? '}' : ''}\n      `;\n        }\n        this.userCode = `\n      ${getReshapedInputCoords(inputShape)}\n      ${shader_util.getFlatIndexFrom3D(outputShape)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${outputShape[1]};\n        int cols = ${outputShape[2]};\n\n        ${mainLoop}\n\n        setOutput(result);\n      }\n    `;\n    }\n}\nfunction getReshapedInputCoords(shape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n    return `\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\n//# sourceMappingURL=reshape_packed_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class SlicePackedProgram {\n    constructor(destSize) {\n        this.variableNames = ['source'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = destSize;\n        this.rank = destSize.length;\n        const dtype = getCoordsDataType(this.rank);\n        const coords = getChannels('coords', this.rank);\n        const sourceLoc = getChannels('sourceLoc', this.rank);\n        const innerDims = this.rank === 1 ? 'sourceLoc' : `vec2(${sourceLoc.slice(-2).join()})`;\n        const getChannel = `getChannel(getSource(${sourceLoc.join()}), ${innerDims})`;\n        const upperRow = `\n      result.x = ${getChannel};\n      if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n        ++${sourceLoc[this.rank - 1]};\n        result.y = ${getChannel};\n        --${sourceLoc[this.rank - 1]};\n      }\n    `;\n        const lowerRow = this.rank === 1 ? '' : `\n      --${coords[this.rank - 1]};\n      if (++${coords[this.rank - 2]} < ${destSize[this.rank - 2]}) {\n        ++${sourceLoc[this.rank - 2]};\n        result.z = ${getChannel};\n        if (++${coords[this.rank - 1]} < ${destSize[this.rank - 1]}) {\n          ++${sourceLoc[this.rank - 1]};\n          result.w = ${getChannel};\n        }\n      }\n    `;\n        const sourceLocSetup = this.rank <= 4 ?\n            `sourceLoc = coords +\n            ${dtype}(${destSize.map((_, i) => `start[${i}]`).join()});` :\n            destSize.map((_, i) => `${sourceLoc[i]} = ${coords[i]} + start[${i}];`)\n                .join('\\n');\n        this.userCode = `\n      uniform int start[${this.rank}];\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        ${dtype} sourceLoc;\n        ${sourceLocSetup}\n        vec4 result = vec4(0.);\n        ${upperRow}\n        ${lowerRow}\n        setOutput(result);\n      }\n    `;\n    }\n    getCustomSetupFunc(start) {\n        if (start.length !== this.rank) {\n            throw Error(`The rank (${this.rank}) of the program must match the ` +\n                `length of start (${start.length})`);\n        }\n        return (gpgpu, webGLProgram) => {\n            if (this.startLoc == null) {\n                this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n                if (this.startLoc == null) {\n                    // This means the compiler has optimized and realized it doesn't need\n                    // the uniform.\n                    return;\n                }\n            }\n            gpgpu.gl.uniform1iv(this.startLoc, start);\n        };\n    }\n}\n//# sourceMappingURL=slice_packed_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeNearestNeighborProgram {\n    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {\n        this.variableNames = ['A'];\n        this.outputShape = [];\n        const [batch, oldHeight, oldWidth, depth] = inputShape;\n        this.outputShape = [batch, newHeight, newWidth, depth];\n        const effectiveInSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        // When align corners is false, we rounds the value with floor.\n        const roundBase = alignCorners ? '0.5' : '0.0';\n        let sourceFracIndexRC;\n        if (halfPixelCenters) {\n            sourceFracIndexRC =\n                `max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` +\n                    `, vec2(0.0))`;\n        }\n        else {\n            sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;\n        }\n        this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_nearest_neighbor_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class ScatterProgram {\n    constructor(updateSize, sliceDim, indicesRank, updatesRank, strides, shape, summingDupeIndex = true) {\n        this.variableNames = ['updates', 'indices', 'defaultValue'];\n        this.outputShape = shape;\n        const stridesType = getCoordsDataType(strides.length);\n        const dtype = getCoordsDataType(shape.length);\n        let indicesString = '';\n        if (indicesRank === 1) {\n            indicesString = 'i';\n        }\n        else if (indicesRank === 2) {\n            indicesString = 'i, j';\n        }\n        const indicesSnippet = `getIndices(${indicesString})`;\n        let updatesString = '';\n        if (updatesRank === 1) {\n            updatesString = 'i';\n        }\n        else if (updatesRank === 2) {\n            updatesString = 'i, coords[1]';\n        }\n        const updatesSnippet = `getUpdates(${updatesString})`;\n        const strideString = sliceDim > 1 ? 'strides[j]' : 'strides';\n        this.userCode = `\n        ${stridesType} strides = ${stridesType}(${strides});\n\n        void main() {\n          ${dtype} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${updateSize}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${sliceDim}; j++) {\n              int index = round(${indicesSnippet});\n              flattenedIndex += index * ${strideString};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${updatesSnippet};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `;\n    }\n}\n//# sourceMappingURL=scatter_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class SliceProgram {\n    constructor(destSize) {\n        this.variableNames = ['source'];\n        this.outputShape = destSize;\n        this.rank = destSize.length;\n        const dtype = getCoordsDataType(this.rank);\n        const uniformPart = `uniform int start[${this.rank}];`;\n        const sourceCoords = getCoords(this.rank);\n        let body;\n        const coordSum = destSize.map((_, i) => {\n            return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;\n        });\n        body = `\n        ${dtype} sourceLoc;\n        ${dtype} coords = getOutputCoords();\n        ${coordSum.join('\\n')}\n      `;\n        this.userCode = `\n      ${uniformPart}\n      void main() {\n        ${body}\n        setOutput(getSource(${sourceCoords}));\n      }\n    `;\n    }\n    getCustomSetupFunc(start) {\n        if (start.length !== this.rank) {\n            throw Error(`The rank (${this.rank}) of the program must match the ` +\n                `length of start (${start.length})`);\n        }\n        return (gpgpu, webGLProgram) => {\n            if (this.startLoc == null) {\n                this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');\n                if (this.startLoc == null) {\n                    // This means the compiler has optimized and realized it doesn't need\n                    // the uniform.\n                    return;\n                }\n            }\n            gpgpu.gl.uniform1iv(this.startLoc, start);\n        };\n    }\n}\nconst coords = ['x', 'y', 'z', 'w', 'u', 'v'];\nfunction getCoords(rank) {\n    if (rank === 1) {\n        return 'sourceLoc';\n    }\n    else if (rank <= 6) {\n        return coords.slice(0, rank).map(x => 'sourceLoc.' + x).join(',');\n    }\n    else {\n        throw Error(`Slicing for rank ${rank} is not yet supported`);\n    }\n}\n//# sourceMappingURL=slice_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class StridedSliceProgram {\n    constructor(begin, strides, size) {\n        this.variableNames = ['x'];\n        this.outputShape = size;\n        const rank = size.length;\n        const inputDtype = getCoordsDataType(size.length);\n        const dtype = getCoordsDataType(size.length);\n        let newCoords = '';\n        if (rank === 1) {\n            newCoords = 'coords * strides + begin';\n        }\n        else {\n            let outputAxis = 0;\n            newCoords =\n                size.map((_, i) => {\n                    outputAxis++;\n                    return size.length === 1 ?\n                        `coords * strides[${i}] + begin[${i}]` :\n                        `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;\n                })\n                    .join(',');\n        }\n        this.userCode = `\n      ${inputDtype} begin = ${inputDtype}(${begin});\n      ${inputDtype} strides = ${inputDtype}(${strides});\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        setOutput(getX(${newCoords}));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=strided_slice_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class PadPackedProgram {\n    constructor(xShape, paddings, constantValue) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const dtype = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const coords = getChannels('rc', rank);\n        const source = getChannels('source', rank);\n        const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n        const innerDims = rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n        const componentSetup = [\n            `${dtype} rc = outputLoc;`, `${coords[rank - 1]} += 1;\n       if(${cLimit}) {\n      `,\n            rank === 1 ? '' : `}\n       rc = outputLoc;\n       ${coords[rank - 2]} += 1;\n       if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {`,\n            rank === 1 ? '' : `  ${coords[rank - 1]} += 1;\n         if(${cLimit}) {`\n        ];\n        const paddingArea = rank === 1 ?\n            'rc < start || rc >= end' :\n            'any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))';\n        let mainLoop = '';\n        for (let i = 0, j = rank === 1 ? 2 : 4; i < j; i++) {\n            mainLoop += `\n        ${componentSetup[i]}\n        if (${paddingArea}) {\n          result[${i}] = float(value);\n        } else {\n          ${dtype} source = rc - start;\n          result[${i}] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n        }\n        mainLoop += (rank === 1 ? `} ` : `}}`);\n        this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n      uniform float value;\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n    }\n    getCustomSetupFunc(value) {\n        return (gpgpu, webGLProgram) => {\n            if (this.valueLoc == null) {\n                this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'value');\n            }\n            gpgpu.gl.uniform1f(this.valueLoc, value);\n        };\n    }\n}\n//# sourceMappingURL=pad_packed_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeBilinearPackedProgram {\n    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = [];\n        const [batch, oldHeight, oldWidth, depth] = inputShape;\n        this.outputShape = [batch, newHeight, newWidth, depth];\n        const effectiveInSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        let sourceFracIndexRC;\n        if (halfPixelCenters) {\n            sourceFracIndexRC = `(vec3(yRC) + vec3(0.5)) * ` +\n                `effectiveInputOverOutputRatioRC - vec3(0.5)`;\n        }\n        else {\n            sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;\n        }\n        this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,\n                                     ${oldWidth}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${depth - 1};\n        bool hasNextRow = coords.z < ${newWidth - 1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_bilinear_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ReduceProgram {\n    constructor(reduceInfo, reduceType) {\n        this.variableNames = ['x'];\n        const { windowSize, batchSize, inSize, outSize } = reduceInfo;\n        this.outputShape = [batchSize, outSize];\n        let initializationValue = '0.0';\n        let compareOp = ``;\n        if (reduceType === 'prod') {\n            initializationValue = '1.0';\n        }\n        else if (reduceType === 'min') {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '1.0 / 1e-20';\n            compareOp = `min`;\n        }\n        else if (reduceType === 'max') {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n            compareOp = `max`;\n        }\n        let returnValue = `${reduceType}(${reduceType}(${reduceType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (reduceType === 'sum') {\n            returnValue = `sumValue`;\n        }\n        else if (reduceType === 'prod') {\n            returnValue = `prodValue`;\n        }\n        else if (reduceType === 'all') {\n            returnValue = `allValue`;\n        }\n        else if (reduceType === 'any') {\n            returnValue = `anyValue`;\n        }\n        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        const windowSizeVec4Remainder = windowSize % 4;\n        let updateSnippet = `\n      if (${reduceType === 'sum'}) {\n        sumValue += dot(values, ones);\n      } else if (${reduceType === 'prod'}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n        let vecType = `vec4`;\n        if (reduceType === 'all') {\n            initializationValue = '1.0';\n            updateSnippet = `\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      `;\n            vecType = `bvec4`;\n        }\n        else if (reduceType === 'any') {\n            initializationValue = '0.0';\n            updateSnippet = `\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      `;\n            vecType = `bvec4`;\n        }\n        let checkOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n        }\n        this.userCode = `\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        vec4 minMaxValue = vec4(${initializationValue});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          ${vecType} values = ${vecType}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n    }\n}\n//# sourceMappingURL=reduce_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeBilinearProgram {\n    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {\n        this.variableNames = ['A'];\n        this.outputShape = [];\n        const [batch, oldHeight, oldWidth, depth] = inputShape;\n        this.outputShape = [batch, newHeight, newWidth, depth];\n        const effectiveInSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        let sourceFracIndexRC;\n        if (halfPixelCenters) {\n            sourceFracIndexRC =\n                `(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC` +\n                    ` - vec2(0.5)`;\n        }\n        else {\n            sourceFracIndexRC = `vec2(yRC) * effectiveInputOverOutputRatioRC`;\n        }\n        this.userCode = `\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec2 inputShapeRC = vec2(${oldHeight}.0, ${oldWidth}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_bilinear_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeNearestNeigborBackpropProgram {\n    constructor(dyShape, inputShape, alignCorners) {\n        this.variableNames = ['dy'];\n        this.outputShape = [];\n        this.outputShape = inputShape;\n        const [, xHeight, xWidth,] = inputShape;\n        const [, yHeight, yWidth] = dyShape;\n        // In the backwards pass, we want to find the pixels that were generated for\n        // each pixel in the input image the forward pass and add the corresponding\n        // coefficient from dy to the gradient (with some interpolation).\n        const effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        const effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        const heightScale = effectiveXSize[0] / effectiveYSize[0];\n        const widthScale = effectiveXSize[1] / effectiveYSize[1];\n        const invHeightScale = 1 / heightScale;\n        const invWidthScale = 1 / widthScale;\n        // This defines the size of the window of values around a particular\n        // index in dy that we want to search for contributions to dx.\n        const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n        const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${effectiveXSize[0]}) *\n                (float(dyR) / float(${effectiveYSize[0]}));\n\n            float sourceFracCol =\n                float(${effectiveXSize[1]}) *\n                  (float(dyC) / float(${effectiveYSize[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${xHeight}) - 1),\n                ${alignCorners} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${xWidth}) - 1),\n                ${alignCorners} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_nearest_neighbor_backprop_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nconst { getBroadcastDims } = backend_util;\nimport { getGlslDifferences } from './glsl_version';\nimport * as shader_util from './shader_compiler_util';\nexport function makeShader(inputsInfo, outputShape, userCode, usesPackedTextures) {\n    const prefixSnippets = [];\n    inputsInfo.forEach(x => {\n        const size = util.sizeFromShape(x.shapeInfo.logicalShape);\n        // Snippet when we decided to upload the values as uniform.\n        if (x.shapeInfo.isUniform) {\n            prefixSnippets.push(`uniform float ${x.name}${size > 1 ? `[${size}]` : ''};`);\n        }\n        else {\n            prefixSnippets.push(`uniform sampler2D ${x.name};`);\n            prefixSnippets.push(`uniform int offset${x.name};`);\n        }\n    });\n    const inputPrefixSnippet = prefixSnippets.join('\\n');\n    const inputSamplingSnippet = inputsInfo\n        .map(x => getInputSamplingSnippet(x, outputShape, usesPackedTextures))\n        .join('\\n');\n    const outTexShape = outputShape.texShape;\n    const glsl = getGlslDifferences();\n    const floatTextureSampleSnippet = getFloatTextureSampleSnippet(glsl);\n    let outputSamplingSnippet;\n    let floatTextureSetOutputSnippet;\n    let shaderPrefix = getShaderPrefix(glsl);\n    if (outputShape.isPacked) {\n        outputSamplingSnippet =\n            getPackedOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n        floatTextureSetOutputSnippet = getFloatTextureSetRGBASnippet(glsl);\n    }\n    else {\n        outputSamplingSnippet =\n            getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);\n        floatTextureSetOutputSnippet = getFloatTextureSetRSnippet(glsl);\n    }\n    if (usesPackedTextures) {\n        shaderPrefix += SHADER_PACKED_PREFIX;\n    }\n    const source = [\n        shaderPrefix, floatTextureSampleSnippet, floatTextureSetOutputSnippet,\n        inputPrefixSnippet, outputSamplingSnippet, inputSamplingSnippet, userCode\n    ].join('\\n');\n    return source;\n}\nfunction getSamplerFromInInfo(inInfo) {\n    const shape = inInfo.shapeInfo.logicalShape;\n    switch (shape.length) {\n        case 0:\n            return getSamplerScalar(inInfo);\n        case 1:\n            return getSampler1D(inInfo);\n        case 2:\n            return getSampler2D(inInfo);\n        case 3:\n            return getSampler3D(inInfo);\n        case 4:\n            return getSampler4D(inInfo);\n        case 5:\n            return getSampler5D(inInfo);\n        case 6:\n            return getSampler6D(inInfo);\n        default:\n            throw new Error(`${shape.length}-D input sampling` +\n                ` is not yet supported`);\n    }\n}\nfunction getPackedSamplerFromInInfo(inInfo) {\n    const shape = inInfo.shapeInfo.logicalShape;\n    switch (shape.length) {\n        case 0:\n            return getPackedSamplerScalar(inInfo);\n        case 1:\n            return getPackedSampler1D(inInfo);\n        case 2:\n            return getPackedSampler2D(inInfo);\n        case 3:\n            return getPackedSampler3D(inInfo);\n        default:\n            return getPackedSamplerND(inInfo);\n    }\n}\nfunction getInputSamplingSnippet(inInfo, outShapeInfo, usesPackedTextures = false) {\n    let res = '';\n    if (usesPackedTextures) {\n        res += getPackedSamplerFromInInfo(inInfo);\n    }\n    else {\n        res += getSamplerFromInInfo(inInfo);\n    }\n    const inShape = inInfo.shapeInfo.logicalShape;\n    const outShape = outShapeInfo.logicalShape;\n    if (inShape.length <= outShape.length) {\n        if (usesPackedTextures) {\n            res += getPackedSamplerAtOutputCoords(inInfo, outShapeInfo);\n        }\n        else {\n            res += getSamplerAtOutputCoords(inInfo, outShapeInfo);\n        }\n    }\n    return res;\n}\nfunction getPackedOutputSamplingSnippet(outShape, outTexShape) {\n    switch (outShape.length) {\n        case 0:\n            return getOutputScalarCoords();\n        case 1:\n            return getOutputPacked1DCoords(outShape, outTexShape);\n        case 2:\n            return getOutputPacked2DCoords(outShape, outTexShape);\n        case 3:\n            return getOutputPacked3DCoords(outShape, outTexShape);\n        default:\n            return getOutputPackedNDCoords(outShape, outTexShape);\n    }\n}\nfunction getOutputSamplingSnippet(outShape, outTexShape) {\n    switch (outShape.length) {\n        case 0:\n            return getOutputScalarCoords();\n        case 1:\n            return getOutput1DCoords(outShape, outTexShape);\n        case 2:\n            return getOutput2DCoords(outShape, outTexShape);\n        case 3:\n            return getOutput3DCoords(outShape, outTexShape);\n        case 4:\n            return getOutput4DCoords(outShape, outTexShape);\n        case 5:\n            return getOutput5DCoords(outShape, outTexShape);\n        case 6:\n            return getOutput6DCoords(outShape, outTexShape);\n        default:\n            throw new Error(`${outShape.length}-D output sampling is not yet supported`);\n    }\n}\nfunction getFloatTextureSampleSnippet(glsl) {\n    return `\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${glsl.texture2D}(textureSampler, uv).r;\n    }\n  `;\n}\nfunction getFloatTextureSetRSnippet(glsl) {\n    return `\n    void setOutput(float val) {\n      ${glsl.output} = vec4(val, 0, 0, 0);\n    }\n  `;\n}\nfunction getFloatTextureSetRGBASnippet(glsl) {\n    return `\n    void setOutput(vec4 val) {\n      ${glsl.output} = val;\n    }\n  `;\n}\nfunction getShaderPrefix(glsl) {\n    const SHADER_PREFIX = `${glsl.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${glsl.varyingFs} vec2 resultUV;\n    ${glsl.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${glsl.defineSpecialNaN}\n    ${glsl.defineSpecialInf}\n    ${glsl.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${SAMPLE_1D_SNIPPET}\n    ${SAMPLE_2D_SNIPPET}\n    ${SAMPLE_3D_SNIPPET}\n  `;\n    return SHADER_PREFIX;\n}\nconst SAMPLE_1D_SNIPPET = `\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\nconst SAMPLE_2D_SNIPPET = `\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\nconst SAMPLE_3D_SNIPPET = `\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n`;\nconst SHADER_PACKED_PREFIX = `\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n`;\nfunction getOutputScalarCoords() {\n    return `\n    int getOutputCoords() {\n      return 0;\n    }\n  `;\n}\nfunction getOutputPacked1DCoords(shape, texShape) {\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    if (packedTexShape[0] === 1) {\n        return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${packedTexShape[1]}.0);\n      }\n    `;\n    }\n    if (packedTexShape[1] === 1) {\n        return `\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${packedTexShape[0]}.0);\n      }\n    `;\n    }\n    return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      return 2 * (resTexRC.x * ${packedTexShape[1]} + resTexRC.y);\n    }\n  `;\n}\nfunction getOutput1DCoords(shape, texShape) {\n    if (texShape[0] === 1) {\n        return `\n      int getOutputCoords() {\n        return int(resultUV.x * ${texShape[1]}.0);\n      }\n    `;\n    }\n    if (texShape[1] === 1) {\n        return `\n      int getOutputCoords() {\n        return int(resultUV.y * ${texShape[0]}.0);\n      }\n    `;\n    }\n    return `\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      return resTexRC.x * ${texShape[1]} + resTexRC.y;\n    }\n  `;\n}\nfunction getOutputPacked3DCoords(shape, texShape) {\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const texelsInLogicalRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[1] / 2);\n    return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `;\n}\nfunction getOutput3DCoords(shape, texShape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd'], shape);\n    return `\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec3(r, c, d);\n    }\n  `;\n}\nfunction getOutputPackedNDCoords(shape, texShape) {\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const texelsInLogicalRow = Math.ceil(shape[shape.length - 1] / 2);\n    const texelsInBatch = texelsInLogicalRow * Math.ceil(shape[shape.length - 2] / 2);\n    let texelsInBatchN = texelsInBatch;\n    let batches = ``;\n    let coords = 'b, r, c';\n    for (let b = 2; b < shape.length - 1; b++) {\n        texelsInBatchN *= shape[shape.length - b - 1];\n        batches = `\n      int b${b} = index / ${texelsInBatchN};\n      index -= b${b} * ${texelsInBatchN};\n    ` + batches;\n        coords = `b${b}, ` + coords;\n    }\n    return `\n    ivec${shape.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n\n      ${batches}\n\n      int b = index / ${texelsInBatch};\n      index -= b * ${texelsInBatch};\n\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec${shape.length}(${coords});\n    }\n  `;\n}\nfunction getOutput4DCoords(shape, texShape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2'], shape);\n    return `\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      ${coordsFromIndexSnippet}\n      return ivec4(r, c, d, d2);\n    }\n  `;\n}\nfunction getOutput5DCoords(shape, texShape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2', 'd3'], shape);\n    return `\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${texShape[0]},\n                             ${texShape[1]}));\n\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `;\n}\nfunction getOutput6DCoords(shape, texShape) {\n    const coordsFromIndexSnippet = shader_util.getLogicalCoordinatesFromFlatIndex(['r', 'c', 'd', 'd2', 'd3', 'd4'], shape);\n    return `\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n\n      ${coordsFromIndexSnippet}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `;\n}\nfunction getOutputPacked2DCoords(shape, texShape) {\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    if (util.arraysEqual(shape, texShape)) {\n        return `\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n      }\n    `;\n    }\n    // texels needed to accommodate a logical row\n    const texelsInLogicalRow = Math.ceil(shape[1] / 2);\n    /**\n     * getOutputCoords\n     *\n     * resTexRC: The rows and columns of the texels. If you move over one\n     * texel to the right in the packed texture, you are moving over one column\n     * (not two).\n     *\n     * index: The texel index\n     */\n    return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${packedTexShape[0]}, ${packedTexShape[1]}));\n\n      int index = resTexRC.x * ${packedTexShape[1]} + resTexRC.y;\n      int r = 2 * (index / ${texelsInLogicalRow});\n      int c = imod(index, ${texelsInLogicalRow}) * 2;\n\n      return ivec2(r, c);\n    }\n  `;\n}\nfunction getOutput2DCoords(shape, texShape) {\n    if (util.arraysEqual(shape, texShape)) {\n        return `\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${texShape[0]}, ${texShape[1]}));\n      }\n    `;\n    }\n    if (shape[1] === 1) {\n        return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;\n    }\n    if (shape[0] === 1) {\n        return `\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${texShape[0]}, ${texShape[1]}));\n        int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;\n    }\n    return `\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${texShape[0]}, ${texShape[1]}));\n      int index = resTexRC.x * ${texShape[1]} + resTexRC.y;\n      int r = index / ${shape[1]};\n      int c = index - r * ${shape[1]};\n      return ivec2(r, c);\n    }\n  `;\n}\nfunction getFlatOffsetUniformName(texName) {\n    return `offset${texName}`;\n}\nfunction getPackedSamplerScalar(inputInfo) {\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const glsl = getGlslDifferences();\n    return `\n    vec4 ${funcName}() {\n      return ${glsl.texture2D}(${texName}, halfCR);\n    }\n  `;\n}\nfunction getSamplerScalar(inputInfo) {\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    if (inputInfo.shapeInfo.isUniform) {\n        return `float ${funcName}() {return ${texName};}`;\n    }\n    const [texNumR, texNumC] = inputInfo.shapeInfo.texShape;\n    if (texNumR === 1 && texNumC === 1) {\n        return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n    }\n    const [tNumR, tNumC] = inputInfo.shapeInfo.texShape;\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n    float ${funcName}() {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getPackedSampler1D(inputInfo) {\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const glsl = getGlslDifferences();\n    return `\n    vec4 ${funcName}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${packedTexShape[0]}, ${packedTexShape[1]}, index);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler1D(inputInfo) {\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int index) {\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const texShape = inputInfo.shapeInfo.texShape;\n    const tNumR = texShape[0];\n    const tNumC = texShape[1];\n    if (tNumC === 1 && tNumR === 1) {\n        return `\n      float ${funcName}(int index) {\n        return sampleTexture(${texName}, halfCR);\n      }\n    `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    if (tNumC === 1) {\n        return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${offset}) + 0.5) / ${tNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    if (tNumR === 1) {\n        return `\n      float ${funcName}(int index) {\n        vec2 uv = vec2((float(index + ${offset}) + 0.5) / ${tNumC}.0, 0.5);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    return `\n    float ${funcName}(int index) {\n      vec2 uv = uvFromFlat(${tNumR}, ${tNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getPackedSampler2D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    const glsl = getGlslDifferences();\n    if (texShape != null && util.arraysEqual(shape, texShape)) {\n        return `\n      vec4 ${funcName}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n\n        return ${glsl.texture2D}(${texName}, uv);\n      }\n    `;\n    }\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const valuesPerRow = Math.ceil(shape[1] / 2);\n    return `\n    vec4 ${funcName}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${valuesPerRow}, ${packedTexShape[0]}, ${packedTexShape[1]}, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler2D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    if (texShape != null && util.arraysEqual(shape, texShape)) {\n        const texNumR = texShape[0];\n        const texNumC = texShape[1];\n        return `\n    float ${funcName}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n    }\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        const params = ['row', 'col'];\n        return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${shape[1]}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    const offset = getFlatOffsetUniformName(texName);\n    if (texNumC === 1) {\n        // index is used directly as physical (no risk of float16 overflow).\n        return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n    }\n    if (texNumR === 1) {\n        // index is used directly as physical (no risk of float16 overflow).\n        return `\n    float ${funcName}(int row, int col) {\n      float index = dot(vec3(row, col, ${offset}), vec3(${shape[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${texNumC}.0, 0.5);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n    }\n    return `\n  float ${funcName}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${shape[1]} + col + ${offset};\n    vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n    return sampleTexture(${texName}, uv);\n  }\n`;\n}\nfunction getPackedSampler3D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    if (shape[0] === 1) {\n        const squeezedShape = shape.slice(1);\n        const keptDims = [1, 2];\n        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        const params = ['b', 'row', 'col'];\n        return `\n        ${getPackedSamplerFromInInfo(newInputInfo)}\n        vec4 ${funcName}(int b, int row, int col) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n    }\n    const texNumR = packedTexShape[0];\n    const texNumC = packedTexShape[1];\n    const valuesPerRow = Math.ceil(shape[2] / 2);\n    const texelsInBatch = valuesPerRow * Math.ceil(shape[1] / 2);\n    const glsl = getGlslDifferences();\n    return `\n    vec4 ${funcName}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${texNumR}, ${texNumC}, ${texelsInBatch}, ${valuesPerRow}, b, row, col);\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler3D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const stride0 = shape[1] * shape[2];\n    const stride1 = shape[2];\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    const squeezedShape = newShape;\n    if (squeezedShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);\n        const params = ['row', 'col', 'depth'];\n        return `\n        ${getSamplerFromInInfo(newInputInfo)}\n        float ${funcName}(int row, int col, int depth) {\n          return ${funcName}(${getSqueezedParams(params, keptDims)});\n        }\n      `;\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${stride0}, ${stride1}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    const flatOffset = inputInfo.shapeInfo.flatOffset;\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return `\n        float ${funcName}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${stride1}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${texNumC}.0, ${texNumR}.0);\n          return sampleTexture(${texName}, uv);\n        }\n      `;\n    }\n    if (texNumC === stride1 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return `\n    float ${funcName}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${shape[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}.0, ${texNumR}.0);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n      float ${funcName}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${stride0} + col * ${stride1} + depth + ${offset};\n        vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n        return sampleTexture(${texName}, uv);\n      }\n  `;\n}\nfunction getPackedSamplerND(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const rank = shape.length;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const texShape = inputInfo.shapeInfo.texShape;\n    const packedTexShape = [Math.ceil(texShape[0] / 2), Math.ceil(texShape[1] / 2)];\n    const texNumR = packedTexShape[0];\n    const texNumC = packedTexShape[1];\n    const valuesPerRow = Math.ceil(shape[rank - 1] / 2);\n    let texelsInBatch = valuesPerRow * Math.ceil(shape[rank - 2] / 2);\n    let params = `int b, int row, int col`;\n    let index = `b * ${texelsInBatch} + (row / 2) * ${valuesPerRow} + (col / 2)`;\n    for (let b = 2; b < rank - 1; b++) {\n        params = `int b${b}, ` + params;\n        texelsInBatch *= shape[rank - b - 1];\n        index = `b${b} * ${texelsInBatch} + ` + index;\n    }\n    const glsl = getGlslDifferences();\n    return `\n    vec4 ${funcName}(${params}) {\n      int index = ${index};\n      int texR = index / ${texNumC};\n      int texC = index - texR * ${texNumC};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${texNumC}, ${texNumR});\n      return ${glsl.texture2D}(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler4D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const stride2 = shape[3];\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    if (newShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        const params = ['row', 'col', 'depth', 'depth2'];\n        return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${stride0}, ${stride1}, ${stride2}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const flatOffset = inputInfo.shapeInfo.flatOffset;\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${stride1}, ${stride2}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    if (texNumC === stride2 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${shape[1] * shape[2]}, ${shape[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n    float ${funcName}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} +\n          depth * ${stride2} + depth2;\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index + ${offset});\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler5D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const stride3 = shape[4];\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    if (newShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        const params = ['row', 'col', 'depth', 'depth2', 'depth3'];\n        return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n    }\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          depth3;\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const flatOffset = inputInfo.shapeInfo.flatOffset;\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${stride1}, ${stride2}, ${stride3}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    if (texNumC === stride3 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3]},\n               ${shape[2] * shape[3]}, ${shape[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n    float ${funcName}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getSampler6D(inputInfo) {\n    const shape = inputInfo.shapeInfo.logicalShape;\n    const texName = inputInfo.name;\n    const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n    const { newShape, keptDims } = util.squeezeShape(shape);\n    if (newShape.length < shape.length) {\n        const newInputInfo = squeezeInputInfo(inputInfo, newShape);\n        const params = ['row', 'col', 'depth', 'depth2', 'depth3', 'depth4'];\n        return `\n      ${getSamplerFromInInfo(newInputInfo)}\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${funcName}(${getSqueezedParams(params, keptDims)});\n      }\n    `;\n    }\n    const stride4 = shape[5];\n    const stride3 = shape[4] * stride4;\n    const stride2 = shape[3] * stride3;\n    const stride1 = shape[2] * stride2;\n    const stride0 = shape[1] * stride1;\n    if (inputInfo.shapeInfo.isUniform) {\n        // Uniform arrays will be less than 65505 (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${stride0}, ${stride1}, ${stride2}, ${stride3})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${stride4}, 1)));\n        ${getUniformSampler(inputInfo)}\n      }\n    `;\n    }\n    const flatOffset = inputInfo.shapeInfo.flatOffset;\n    const texShape = inputInfo.shapeInfo.texShape;\n    const texNumR = texShape[0];\n    const texNumC = texShape[1];\n    if (texNumC === stride0 && flatOffset == null) {\n        // texC is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${stride1}, ${stride2}, ${stride3}, ${stride4})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    if (texNumC === stride4 && flatOffset == null) {\n        // texR is used directly as physical (no risk of float16 overflow).\n        return `\n      float ${funcName}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${shape[1] * shape[2] * shape[3] * shape[4]},\n               ${shape[2] * shape[3] * shape[4]},\n               ${shape[3] * shape[4]},\n               ${shape[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${texNumC}.0, ${texNumR}.0);\n        return sampleTexture(${texName}, uv);\n      }\n    `;\n    }\n    const offset = getFlatOffsetUniformName(texName);\n    return `\n    float ${funcName}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${stride0} + col * ${stride1} + depth * ${stride2} +\n          depth2 * ${stride3} + depth3 * ${stride4} + depth4 + ${offset};\n      vec2 uv = uvFromFlat(${texNumR}, ${texNumC}, index);\n      return sampleTexture(${texName}, uv);\n    }\n  `;\n}\nfunction getUniformSampler(inputInfo) {\n    const texName = inputInfo.name;\n    const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n    if (inSize < 2) {\n        return `return ${texName};`;\n    }\n    return `\n    for (int i = 0; i < ${inSize}; i++) {\n      if (i == index) {\n        return ${texName}[i];\n      }\n    }\n  `;\n}\nfunction getPackedSamplerAtOutputCoords(inputInfo, outShapeInfo) {\n    const texName = inputInfo.name;\n    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n    const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n    const inRank = inputInfo.shapeInfo.logicalShape.length;\n    const outRank = outShapeInfo.logicalShape.length;\n    const broadcastDims = getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n    const type = getCoordsDataType(outRank);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet;\n    const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n    if (inRank === 0) {\n        coordsSnippet = '';\n    }\n    else if (outRank < 2 && broadcastDims.length >= 1) {\n        coordsSnippet = 'coords = 0;';\n    }\n    else {\n        coordsSnippet =\n            broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n                .join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n        unpackedCoordsSnippet = 'coords';\n    }\n    else {\n        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n            .map((s, i) => `coords.${fields[i + rankDiff]}`)\n            .join(', ');\n    }\n    let output = `return outputValue;`;\n    const inSize = util.sizeFromShape(inputInfo.shapeInfo.logicalShape);\n    const isInputScalar = inSize === 1;\n    const outSize = util.sizeFromShape(outShapeInfo.logicalShape);\n    const isOutputScalar = outSize === 1;\n    if (inRank === 1 && !isInputScalar && !isOutputScalar) {\n        output = `\n      return vec4(outputValue.xy, outputValue.xy);\n    `;\n    }\n    else if (isInputScalar && !isOutputScalar) {\n        if (outRank === 1) {\n            output = `\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      `;\n        }\n        else {\n            output = `\n        return vec4(outputValue.x);\n      `;\n        }\n    }\n    else if (broadcastDims.length) {\n        const rows = inRank - 2;\n        const cols = inRank - 1;\n        if (broadcastDims.indexOf(rows) > -1 && broadcastDims.indexOf(cols) > -1) {\n            output = `return vec4(outputValue.x);`;\n        }\n        else if (broadcastDims.indexOf(rows) > -1) {\n            output = `return vec4(outputValue.x, outputValue.y, ` +\n                `outputValue.x, outputValue.y);`;\n        }\n        else if (broadcastDims.indexOf(cols) > -1) {\n            output = `return vec4(outputValue.xx, outputValue.zz);`;\n        }\n    }\n    return `\n    vec4 ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      vec4 outputValue = get${texFuncSnippet}(${unpackedCoordsSnippet});\n      ${output}\n    }\n  `;\n}\nfunction getSamplerAtOutputCoords(inputInfo, outShapeInfo) {\n    const texName = inputInfo.name;\n    const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n    const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n    const outTexShape = outShapeInfo.texShape;\n    const inTexShape = inputInfo.shapeInfo.texShape;\n    const inRank = inputInfo.shapeInfo.logicalShape.length;\n    const outRank = outShapeInfo.logicalShape.length;\n    if (!inputInfo.shapeInfo.isUniform && inRank === outRank &&\n        inputInfo.shapeInfo.flatOffset == null &&\n        util.arraysEqual(inTexShape, outTexShape)) {\n        return `\n      float ${funcName}() {\n        return sampleTexture(${texName}, resultUV);\n      }\n    `;\n    }\n    const type = getCoordsDataType(outRank);\n    const broadcastDims = getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);\n    const rankDiff = outRank - inRank;\n    let coordsSnippet;\n    const fields = ['x', 'y', 'z', 'w', 'u', 'v'];\n    if (inRank === 0) {\n        coordsSnippet = '';\n    }\n    else if (outRank < 2 && broadcastDims.length >= 1) {\n        coordsSnippet = 'coords = 0;';\n    }\n    else {\n        coordsSnippet =\n            broadcastDims.map(d => `coords.${fields[d + rankDiff]} = 0;`)\n                .join('\\n');\n    }\n    let unpackedCoordsSnippet = '';\n    if (outRank < 2 && inRank > 0) {\n        unpackedCoordsSnippet = 'coords';\n    }\n    else {\n        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape\n            .map((s, i) => `coords.${fields[i + rankDiff]}`)\n            .join(', ');\n    }\n    return `\n    float ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      return get${texFuncSnippet}(${unpackedCoordsSnippet});\n    }\n  `;\n}\nexport function getCoordsDataType(rank) {\n    if (rank <= 1) {\n        return 'int';\n    }\n    else if (rank === 2) {\n        return 'ivec2';\n    }\n    else if (rank === 3) {\n        return 'ivec3';\n    }\n    else if (rank === 4) {\n        return 'ivec4';\n    }\n    else if (rank === 5) {\n        return 'ivec5';\n    }\n    else if (rank === 6) {\n        return 'ivec6';\n    }\n    else {\n        throw Error(`GPU for rank ${rank} is not yet supported`);\n    }\n}\n/** Returns a new input info (a copy) that has a squeezed logical shape. */\nfunction squeezeInputInfo(inInfo, squeezedShape) {\n    // Deep copy.\n    const newInputInfo = JSON.parse(JSON.stringify(inInfo));\n    newInputInfo.shapeInfo.logicalShape = squeezedShape;\n    return newInputInfo;\n}\nfunction getSqueezedParams(params, keptDims) {\n    return keptDims.map(d => params[d]).join(', ');\n}\n//# sourceMappingURL=shader_compiler.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class PackProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = false;\n        this.packedOutput = true;\n        // Only input / output 3D tensors.\n        this.outputShape = outputShape;\n        const rank = outputShape.length;\n        if (rank === 0) {\n            this.userCode = `\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      `;\n        }\n        else {\n            const channels = getChannels('rc', rank);\n            const dtype = getCoordsDataType(rank);\n            const outOfBoundsCondition = getOutOfBoundsCondition(rank, outputShape, channels);\n            const setup = getSetup(rank, outputShape[outputShape.length - 1], outputShape[outputShape.length - 2], channels);\n            const output = getOutput(outputShape, channels);\n            this.userCode = `\n        void main() {\n          ${dtype} rc = getOutputCoords();\n\n          if(${outOfBoundsCondition}) {\n            setOutput(vec4(0));\n          } else {\n            ${setup}\n\n            setOutput(vec4(${output}));\n          }\n        }\n      `;\n        }\n    }\n}\nfunction getSourceCoordsArr(rank, dims) {\n    const coords = [];\n    for (let row = 0; row <= 1; row++) {\n        for (let col = 0; col <= 1; col++) {\n            let coord = `${row === 0 ? 'r' : 'rp1'}, ${col === 0 ? 'c' : 'cp1'}`;\n            for (let d = 2; d < rank; d++) {\n                coord = `${dims[dims.length - 1 - d]},` + coord;\n            }\n            coords.push(coord);\n        }\n    }\n    return coords;\n}\nfunction getOutOfBoundsCondition(rank, shape, dims) {\n    if (rank === 1) {\n        return `rc > ${shape[0]}`;\n    }\n    let cond = '';\n    for (let i = rank - 2; i < rank; i++) {\n        cond += `${dims[i]} >= ${shape[i]}`;\n        if (i < rank - 1) {\n            cond += '||';\n        }\n    }\n    return cond;\n}\nfunction getSetup(rank, cols, rows, dims) {\n    if (rank === 1) {\n        return '';\n    }\n    const innerDims = dims.slice(-2);\n    return `\n    int r = ${innerDims[0]};\n    int c = ${innerDims[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${cols};\n    bool rEdge = rp1 >= ${rows};\n  `;\n}\nfunction getOutput(shape, dims) {\n    const rank = shape.length;\n    const sourceCoords = getSourceCoordsArr(rank, dims);\n    if (rank === 1) {\n        return `getA(rc),\n            rc + 1 >= ${shape[0]} ? 0. : getA(rc + 1),\n            0, 0`;\n    }\n    return `getA(${sourceCoords[0]}),\n          cEdge ? 0. : getA(${sourceCoords[1]}),\n          rEdge ? 0. : getA(${sourceCoords[2]}),\n          rEdge || cEdge ? 0. : getA(${sourceCoords[3]})`;\n}\n//# sourceMappingURL=pack_gpu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class RotateProgram {\n    constructor(imageShape, fillValue) {\n        this.variableNames = ['Image'];\n        this.outputShape = [];\n        const imageHeight = imageShape[1];\n        const imageWidth = imageShape[2];\n        this.outputShape = imageShape;\n        let fillSnippet = '';\n        if (typeof fillValue === 'number') {\n            fillSnippet = `float outputValue = ${fillValue.toFixed(2)};`;\n        }\n        else {\n            fillSnippet = `\n        vec3 fill = vec3(${fillValue.join(',')});\n        float outputValue = fill[coords[3]];`;\n        }\n        this.userCode = `\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${fillSnippet}\n          if(coordX >= 0 && coordX < ${imageWidth} && coordY >= 0 && coordY < ${imageHeight}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `;\n    }\n    getCustomSetupFunc(centerX, centerY, sinFactor, cosFactor) {\n        return (gpgpu, webGLProgram) => {\n            if (this.paramsLoc == null) {\n                this.paramsLoc =\n                    gpgpu.getUniformLocationNoThrow(webGLProgram, 'params');\n            }\n            gpgpu.gl.uniform4f(this.paramsLoc, centerX, centerY, sinFactor, cosFactor);\n        };\n    }\n}\n//# sourceMappingURL=rotate_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeBilinearBackpropProgram {\n    constructor(dyShape, inputShape, alignCorners) {\n        this.variableNames = ['dy'];\n        this.outputShape = [];\n        this.outputShape = inputShape;\n        const [, xHeight, xWidth,] = inputShape;\n        const [, yHeight, yWidth] = dyShape;\n        // In the backwards pass, we want to find the pixels that were generated for\n        // each pixel in the input image the forward pass and add the corresponding\n        // coefficient from dy to the gradient (with some interpolation).\n        const effectiveXSize = [\n            (alignCorners && yHeight > 1) ? xHeight - 1 : xHeight,\n            (alignCorners && yWidth > 1) ? xWidth - 1 : xWidth\n        ];\n        const effectiveYSize = [\n            (alignCorners && yHeight > 1) ? yHeight - 1 : yHeight,\n            (alignCorners && yWidth > 1) ? yWidth - 1 : yWidth\n        ];\n        const heightScale = effectiveXSize[0] / effectiveYSize[0];\n        const widthScale = effectiveXSize[1] / effectiveYSize[1];\n        const invHeightScale = 1 / heightScale;\n        const invWidthScale = 1 / widthScale;\n        // This defines the size of the window of values around a particular\n        // index in dy that we want to search for contributions to dx.\n        const winHeight = (Math.ceil(invHeightScale) * 2) + 2;\n        const winWidth = (Math.ceil(invWidthScale) * 2) + 2;\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${heightScale});\n        const float widthScale = float(${widthScale});\n\n        const float invHeightScale = float(${invHeightScale});\n        const float invWidthScale = float(${invWidthScale});\n\n        const int winHeight = int(${winHeight});\n        const int winWidth = int(${winWidth});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${yHeight}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${yWidth}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${xHeight - 1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${xWidth - 1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_bilinear_backprop_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class SegmentOpProgram {\n    constructor(segOpInfo, segOpType) {\n        this.variableNames = ['x', 'segmentIds'];\n        const windowSize = segOpInfo.windowSize;\n        const batchSize = segOpInfo.batchSize;\n        const inSize = segOpInfo.inSize;\n        const numSegments = segOpInfo.numSegments;\n        const outSize = numSegments * Math.ceil(inSize / windowSize);\n        this.outputShape = [batchSize, outSize];\n        const initializationValue = '0.0';\n        const returnValue = `sumValue`;\n        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        const windowSizeVec4Remainder = windowSize % 4;\n        const updateSnippet = `\n        sumValue += dot(values, segFilter);\n    `;\n        let checkValueOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkValueOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return initializationValue;\n        }\n      `;\n        }\n        let checkSegmentIdOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkSegmentIdOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return -1.0;\n        }\n      `;\n        }\n        this.userCode = `\n      const float initializationValue = ${initializationValue};\n\n      float getValue(int batch, int inIdx) {\n        ${checkValueOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${checkSegmentIdOutOfBounds}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${numSegments})) * float(${windowSize}));\n        int currentSeg = int(mod(float(outIdx), float(${numSegments})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${updateSnippet}\n        }\n        setOutput(${returnValue});\n      }\n    `;\n    }\n}\n//# sourceMappingURL=segment_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class ResizeNearestNeighborPackedProgram {\n    constructor(inputShape, newHeight, newWidth, alignCorners, halfPixelCenters) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = [];\n        const [batch, oldHeight, oldWidth, depth] = inputShape;\n        this.outputShape = [batch, newHeight, newWidth, depth];\n        const effectiveInSize = [\n            (alignCorners && newHeight > 1) ? oldHeight - 1 : oldHeight,\n            (alignCorners && newWidth > 1) ? oldWidth - 1 : oldWidth\n        ];\n        const effectiveOutSize = [\n            (alignCorners && newHeight > 1) ? newHeight - 1 : newHeight,\n            (alignCorners && newWidth > 1) ? newWidth - 1 : newWidth\n        ];\n        // When align corners is false, we rounds the value with floor.\n        const roundBase = alignCorners ? '0.5' : '0.0';\n        let sourceFracIndexRC;\n        if (halfPixelCenters) {\n            sourceFracIndexRC = `max((vec3(yRC) + vec3(0.5)) * ` +\n                `effectiveInputOverOutputRatioRC, vec3(0.0))`;\n        }\n        else {\n            sourceFracIndexRC = `vec3(yRC) * effectiveInputOverOutputRatioRC`;\n        }\n        this.userCode = `\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${effectiveInSize[0] / effectiveOutSize[0]},\n          ${effectiveInSize[1] / effectiveOutSize[1]},\n          ${effectiveInSize[1] / effectiveOutSize[1]});\n      const vec3 inputShapeRC = vec3(${oldHeight}.0, ${oldWidth}.0,\n                                     ${oldWidth}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${sourceFracIndexRC};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${depth - 1};\n        bool hasNextRow = coords.z < ${newWidth - 1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=resize_nearest_neighbor_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class PadProgram {\n    constructor(xShape, paddings, constantValue) {\n        this.variableNames = ['x'];\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const type = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n        if (rank === 1) {\n            this.userCode = `\n        int start = ${start};\n        int end = ${end};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `;\n            return;\n        }\n        this.userCode = `\n      ${type} start = ${type}(${start});\n      ${type} end = ${type}(${end});\n      uniform float value;\n\n      void main() {\n        ${type} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${type} coords = outC - start;\n          setOutput(getX(${unpackedCoords}));\n        }\n      }\n    `;\n    }\n    getCustomSetupFunc(value) {\n        return (gpgpu, webGLProgram) => {\n            if (this.valueLoc == null) {\n                this.valueLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'value');\n            }\n            gpgpu.gl.uniform1f(this.valueLoc, value);\n        };\n    }\n}\n//# sourceMappingURL=pad_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ReversePackedProgram {\n    constructor(xShape, axis) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        const rank = xShape.length;\n        if (rank > 4) {\n            throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n        }\n        this.outputShape = xShape;\n        const channels = getChannels('rc', rank);\n        const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;\n        const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;\n        const type = getCoordsDataType(rank);\n        if (rank === 1) {\n            this.userCode = `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${xShape[0]} - rc - 1),\n            ${xShape[0]} - rc - 1);\n          if(${nextColumn}){\n              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),\n                ${xShape[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `;\n        }\n        else {\n            this.userCode = `\n        void main() {\n          ${type} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${getR(channels.slice())};\n          if(${nextColumn}){\n            result.g = ${getG(channels.slice())};\n          }\n          if(${nextRow}) {\n            result.b = ${getB(channels.slice())};\n            if(${nextColumn}) {\n              result.a = ${getA(channels.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;\n        }\n        function getR(channels) {\n            return getChannel(channels);\n        }\n        function getG(channels) {\n            channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n            return getChannel(channels);\n        }\n        function getB(channels) {\n            channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n            return getChannel(channels);\n        }\n        function getA(channels) {\n            channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n            channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n            return getChannel(channels);\n        }\n        function getChannel(channels) {\n            const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));\n            const inCoords = inCoordsArray.join(',');\n            const innerDims = inCoordsArray.slice(-2).join(',');\n            return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;\n        }\n        function getInCoord(i, channels1) {\n            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n                return `${xShape[i]} - ${channels1[i]} - 1`;\n            }\n            else {\n                return `${channels1[i]}`;\n            }\n        }\n    }\n}\n//# sourceMappingURL=reverse_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class ReverseProgram {\n    constructor(xShape, axis) {\n        this.variableNames = ['x'];\n        const rank = xShape.length;\n        if (rank > 4) {\n            throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n        }\n        this.outputShape = xShape;\n        if (rank === 1) {\n            this.userCode = `\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${xShape[0]} - coord - 1));\n        }\n      `;\n            return;\n        }\n        const getInCoord = (i) => {\n            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n                return `${xShape[i]} - coords[${i}] - 1`;\n            }\n            return `coords[${i}]`;\n        };\n        const inCoords = xShape.map((_, i) => getInCoord(i)).join(',');\n        const type = getCoordsDataType(rank);\n        this.userCode = `\n      void main() {\n        ${type} coords = getOutputCoords();\n        setOutput(getX(${inCoords}));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=reverse_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport function getVecChannels(name, rank) {\n    return ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank).map(d => `${name}.${d}`);\n}\nexport function getChannels(name, rank) {\n    if (rank === 1) {\n        return [name];\n    }\n    return getVecChannels(name, rank);\n}\nexport function getSourceCoords(rank, dims) {\n    if (rank === 1) {\n        return 'rc';\n    }\n    let coords = '';\n    for (let i = 0; i < rank; i++) {\n        coords += dims[i];\n        if (i < rank - 1) {\n            coords += ',';\n        }\n    }\n    return coords;\n}\n//# sourceMappingURL=packing_util.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { registerKernel } from '@tensorflow/tfjs-core';\nimport { _fusedMatMulConfig } from './kernels/_FusedMatMul';\nimport { absConfig } from './kernels/Abs';\nimport { acosConfig } from './kernels/Acos';\nimport { acoshConfig } from './kernels/Acosh';\nimport { addConfig } from './kernels/Add';\nimport { addNConfig } from './kernels/AddN';\nimport { allConfig } from './kernels/All';\nimport { anyConfig } from './kernels/Any';\nimport { argMaxConfig } from './kernels/ArgMax';\nimport { argMinConfig } from './kernels/ArgMin';\nimport { asinConfig } from './kernels/Asin';\nimport { asinhConfig } from './kernels/Asinh';\nimport { atanConfig } from './kernels/Atan';\nimport { atan2Config } from './kernels/Atan2';\nimport { atanhConfig } from './kernels/Atanh';\nimport { avgPoolConfig } from './kernels/AvgPool';\nimport { avgPool3DConfig } from './kernels/AvgPool3D';\nimport { avgPoolGrad3DConfig } from './kernels/AvgPool3DGrad';\nimport { avgPoolGradConfig } from './kernels/AvgPoolGrad';\nimport { batchMatMulConfig } from './kernels/BatchMatMul';\nimport { batchNormConfig } from './kernels/BatchNorm';\nimport { batchToSpaceNDConfig } from './kernels/BatchToSpaceND';\nimport { bincountConfig } from './kernels/Bincount';\nimport { castConfig } from './kernels/Cast';\nimport { ceilConfig } from './kernels/Ceil';\nimport { clipByValueConfig } from './kernels/ClipByValue';\nimport { complexConfig } from './kernels/Complex';\nimport { complexAbsConfig } from './kernels/ComplexAbs';\nimport { concatConfig } from './kernels/Concat';\nimport { conv2DConfig } from './kernels/Conv2D';\nimport { conv2DBackpropFilterConfig } from './kernels/Conv2DBackpropFilter';\nimport { conv2DBackpropInputConfig } from './kernels/Conv2DBackpropInput';\nimport { conv3DConfig } from './kernels/Conv3D';\nimport { conv3DBackpropFilterV2Config } from './kernels/Conv3DBackpropFilterV2';\nimport { conv3DBackpropInputConfig } from './kernels/Conv3DBackpropInputV2';\nimport { cosConfig } from './kernels/Cos';\nimport { coshConfig } from './kernels/Cosh';\nimport { cropAndResizeConfig } from './kernels/CropAndResize';\nimport { cumsumConfig } from './kernels/Cumsum';\nimport { denseBincountConfig } from './kernels/DenseBincount';\nimport { depthToSpaceConfig } from './kernels/DepthToSpace';\nimport { depthwiseConv2dNativeConfig } from './kernels/DepthwiseConv2dNative';\nimport { depthwiseConv2dNativeBackpropFilterConfig } from './kernels/DepthwiseConv2dNativeBackpropFilter';\nimport { depthwiseConv2dNativeBackpropInputConfig } from './kernels/DepthwiseConv2dNativeBackpropInput';\nimport { diagConfig } from './kernels/Diag';\nimport { dilation2DConfig } from './kernels/Dilation2D';\nimport { einsumConfig } from './kernels/Einsum';\nimport { eluConfig } from './kernels/Elu';\nimport { eluGradConfig } from './kernels/EluGrad';\nimport { equalConfig } from './kernels/Equal';\nimport { erfConfig } from './kernels/Erf';\nimport { expConfig } from './kernels/Exp';\nimport { expandDimsConfig } from './kernels/ExpandDims';\nimport { expm1Config } from './kernels/Expm1';\nimport { fftConfig } from './kernels/FFT';\nimport { fillConfig } from './kernels/Fill';\nimport { flipLeftRightConfig } from './kernels/FlipLeftRight';\nimport { floorConfig } from './kernels/Floor';\nimport { floorDivConfig } from './kernels/FloorDiv';\nimport { fromPixelsConfig } from './kernels/FromPixels';\nimport { fusedConv2DConfig } from './kernels/FusedConv2D';\nimport { fusedDepthwiseConv2DConfig } from './kernels/FusedDepthwiseConv2D';\nimport { gatherNdConfig } from './kernels/GatherNd';\nimport { gatherV2Config } from './kernels/GatherV2';\nimport { greaterConfig } from './kernels/Greater';\nimport { greaterEqualConfig } from './kernels/GreaterEqual';\nimport { identityConfig } from './kernels/Identity';\nimport { ifftConfig } from './kernels/IFFT';\nimport { imagConfig } from './kernels/Imag';\nimport { isFiniteConfig } from './kernels/IsFinite';\nimport { isInfConfig } from './kernels/IsInf';\nimport { isNaNConfig } from './kernels/IsNaN';\nimport { leakyReluConfig } from './kernels/LeakyRelu';\nimport { lessConfig } from './kernels/Less';\nimport { lessEqualConfig } from './kernels/LessEqual';\nimport { linSpaceConfig } from './kernels/LinSpace';\nimport { logConfig } from './kernels/Log';\nimport { log1pConfig } from './kernels/Log1p';\nimport { logicalAndConfig } from './kernels/LogicalAnd';\nimport { logicalNotConfig } from './kernels/LogicalNot';\nimport { logicalOrConfig } from './kernels/LogicalOr';\nimport { LRNConfig } from './kernels/LRN';\nimport { LRNGradConfig } from './kernels/LRNGrad';\nimport { maxConfig } from './kernels/Max';\nimport { maximumConfig } from './kernels/Maximum';\nimport { maxPoolConfig } from './kernels/MaxPool';\nimport { maxPool3DConfig } from './kernels/MaxPool3D';\nimport { maxPoolGrad3DConfig } from './kernels/MaxPool3DGrad';\nimport { maxPoolGradConfig } from './kernels/MaxPoolGrad';\nimport { maxPoolWithArgmaxConfig } from './kernels/MaxPoolWithArgmax';\nimport { meanConfig } from './kernels/Mean';\nimport { minConfig } from './kernels/Min';\nimport { minimumConfig } from './kernels/Minimum';\nimport { mirrorPadConfig } from './kernels/MirrorPad';\nimport { modConfig } from './kernels/Mod';\nimport { multinomialConfig } from './kernels/Multinomial';\nimport { multiplyConfig } from './kernels/Multiply';\nimport { negConfig } from './kernels/Neg';\nimport { nonMaxSuppressionV3Config } from './kernels/NonMaxSuppressionV3';\nimport { nonMaxSuppressionV4Config } from './kernels/NonMaxSuppressionV4';\nimport { nonMaxSuppressionV5Config } from './kernels/NonMaxSuppressionV5';\nimport { notEqualConfig } from './kernels/NotEqual';\nimport { oneHotConfig } from './kernels/OneHot';\nimport { onesLikeConfig } from './kernels/OnesLike';\nimport { packConfig } from './kernels/Pack';\nimport { padV2Config } from './kernels/PadV2';\nimport { powConfig } from './kernels/Pow';\nimport { preluConfig } from './kernels/Prelu';\nimport { prodConfig } from './kernels/Prod';\nimport { rangeConfig } from './kernels/Range';\nimport { realConfig } from './kernels/Real';\nimport { realDivConfig } from './kernels/RealDiv';\nimport { reciprocalConfig } from './kernels/Reciprocal';\nimport { reluConfig } from './kernels/Relu';\nimport { relu6Config } from './kernels/Relu6';\nimport { reshapeConfig } from './kernels/Reshape';\nimport { resizeBilinearConfig } from './kernels/ResizeBilinear';\nimport { resizeBilinearGradConfig } from './kernels/ResizeBilinearGrad';\nimport { resizeNearestNeighborConfig } from './kernels/ResizeNearestNeighbor';\nimport { resizeNearestNeighborGradConfig } from './kernels/ResizeNearestNeighborGrad';\nimport { reverseConfig } from './kernels/Reverse';\nimport { rotateWithOffsetConfig } from './kernels/RotateWithOffset';\nimport { roundConfig } from './kernels/Round';\nimport { rsqrtConfig } from './kernels/Rsqrt';\nimport { scatterNdConfig } from './kernels/ScatterNd';\nimport { selectConfig } from './kernels/Select';\nimport { seluConfig } from './kernels/Selu';\nimport { sigmoidConfig } from './kernels/Sigmoid';\nimport { signConfig } from './kernels/Sign';\nimport { sinConfig } from './kernels/Sin';\nimport { sinhConfig } from './kernels/Sinh';\nimport { sliceConfig } from './kernels/Slice';\nimport { softmaxConfig } from './kernels/Softmax';\nimport { softplusConfig } from './kernels/Softplus';\nimport { spaceToBatchNDConfig } from './kernels/SpaceToBatchND';\nimport { sparseFillEmptyRowsConfig } from './kernels/SparseFillEmptyRows';\nimport { sparseReshapeConfig } from './kernels/SparseReshape';\nimport { sparseToDenseConfig } from './kernels/SparseToDense';\nimport { splitVConfig } from './kernels/SplitV';\nimport { sqrtConfig } from './kernels/Sqrt';\nimport { squareConfig } from './kernels/Square';\nimport { squaredDifferenceConfig } from './kernels/SquaredDifference';\nimport { stepConfig } from './kernels/Step';\nimport { stridedSliceConfig } from './kernels/StridedSlice';\nimport { subConfig } from './kernels/Sub';\nimport { sumConfig } from './kernels/Sum';\nimport { tanConfig } from './kernels/Tan';\nimport { tanhConfig } from './kernels/Tanh';\nimport { tileConfig } from './kernels/Tile';\nimport { topKConfig } from './kernels/TopK';\nimport { transformConfig } from './kernels/Transform';\nimport { transposeConfig } from './kernels/Transpose';\nimport { uniqueConfig } from './kernels/Unique';\nimport { unpackConfig } from './kernels/Unpack';\nimport { unsortedSegmentSumConfig } from './kernels/UnsortedSegmentSum';\nimport { zerosLikeConfig } from './kernels/ZerosLike';\n// List all kernel configs here\nconst kernelConfigs = [\n    LRNConfig,\n    LRNGradConfig,\n    _fusedMatMulConfig,\n    absConfig,\n    acosConfig,\n    acoshConfig,\n    addConfig,\n    addNConfig,\n    allConfig,\n    anyConfig,\n    argMaxConfig,\n    argMinConfig,\n    asinConfig,\n    asinhConfig,\n    atan2Config,\n    atanConfig,\n    atanhConfig,\n    avgPool3DConfig,\n    avgPoolConfig,\n    avgPoolGrad3DConfig,\n    avgPoolGradConfig,\n    batchMatMulConfig,\n    batchNormConfig,\n    batchToSpaceNDConfig,\n    bincountConfig,\n    castConfig,\n    ceilConfig,\n    clipByValueConfig,\n    complexAbsConfig,\n    complexConfig,\n    concatConfig,\n    conv2DBackpropFilterConfig,\n    conv2DBackpropInputConfig,\n    conv2DConfig,\n    conv3DBackpropFilterV2Config,\n    conv3DBackpropInputConfig,\n    conv3DConfig,\n    cosConfig,\n    coshConfig,\n    cropAndResizeConfig,\n    cumsumConfig,\n    denseBincountConfig,\n    depthToSpaceConfig,\n    depthwiseConv2dNativeBackpropFilterConfig,\n    depthwiseConv2dNativeBackpropInputConfig,\n    depthwiseConv2dNativeConfig,\n    diagConfig,\n    dilation2DConfig,\n    einsumConfig,\n    eluConfig,\n    eluGradConfig,\n    equalConfig,\n    erfConfig,\n    expConfig,\n    expandDimsConfig,\n    expm1Config,\n    fftConfig,\n    fillConfig,\n    flipLeftRightConfig,\n    floorConfig,\n    floorDivConfig,\n    fromPixelsConfig,\n    fusedConv2DConfig,\n    fusedDepthwiseConv2DConfig,\n    gatherNdConfig,\n    gatherV2Config,\n    greaterConfig,\n    greaterEqualConfig,\n    identityConfig,\n    ifftConfig,\n    imagConfig,\n    isFiniteConfig,\n    isInfConfig,\n    isNaNConfig,\n    leakyReluConfig,\n    lessConfig,\n    lessEqualConfig,\n    linSpaceConfig,\n    log1pConfig,\n    logConfig,\n    logicalAndConfig,\n    logicalNotConfig,\n    logicalOrConfig,\n    maxConfig,\n    maxPool3DConfig,\n    maxPoolConfig,\n    maxPoolGrad3DConfig,\n    maxPoolGradConfig,\n    maxPoolWithArgmaxConfig,\n    maximumConfig,\n    meanConfig,\n    minConfig,\n    minimumConfig,\n    mirrorPadConfig,\n    modConfig,\n    multinomialConfig,\n    multiplyConfig,\n    negConfig,\n    nonMaxSuppressionV3Config,\n    nonMaxSuppressionV4Config,\n    nonMaxSuppressionV5Config,\n    notEqualConfig,\n    oneHotConfig,\n    onesLikeConfig,\n    packConfig,\n    padV2Config,\n    powConfig,\n    preluConfig,\n    prodConfig,\n    rangeConfig,\n    realConfig,\n    realDivConfig,\n    reciprocalConfig,\n    relu6Config,\n    reluConfig,\n    reshapeConfig,\n    resizeBilinearConfig,\n    resizeBilinearGradConfig,\n    resizeNearestNeighborConfig,\n    resizeNearestNeighborGradConfig,\n    reverseConfig,\n    rotateWithOffsetConfig,\n    roundConfig,\n    rsqrtConfig,\n    scatterNdConfig,\n    selectConfig,\n    seluConfig,\n    sigmoidConfig,\n    signConfig,\n    sinConfig,\n    sinhConfig,\n    sliceConfig,\n    softmaxConfig,\n    softplusConfig,\n    spaceToBatchNDConfig,\n    sparseFillEmptyRowsConfig,\n    sparseReshapeConfig,\n    sparseToDenseConfig,\n    splitVConfig,\n    sqrtConfig,\n    squareConfig,\n    squaredDifferenceConfig,\n    stepConfig,\n    stridedSliceConfig,\n    subConfig,\n    sumConfig,\n    tanConfig,\n    tanhConfig,\n    tileConfig,\n    topKConfig,\n    transformConfig,\n    transposeConfig,\n    uniqueConfig,\n    unpackConfig,\n    unsortedSegmentSumConfig,\n    zerosLikeConfig\n];\nfor (const kernelConfig of kernelConfigs) {\n    registerKernel(kernelConfig);\n}\n//# sourceMappingURL=register_all_kernels.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Pool2DProgram {\n    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        const isAvgPool = poolType === 'avg';\n        const batchFlattenPositionStr = `((batch  * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n        const flattenPositionStr = `(xR * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + d`;\n        let initializationValue = '0.0';\n        if (!isAvgPool) {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n        }\n        if (computePositions) {\n            const compareOp = '>=';\n            this.userCode = `\n        const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n        const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n              wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${effectiveFilterWidth};\n                wC += ${dilationWidth}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${compareOp} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${flattenPositions ? (includeBatchInIndex ? batchFlattenPositionStr :\n                flattenPositionStr) :\n                `wR * ${effectiveFilterWidth} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n            return;\n        }\n        const compareOp = 'max';\n        let returnValue = `${poolType}(${poolType}(${poolType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = `avgValue / count`;\n        }\n        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        const filterWidthVec4Remainder = filterWidth % 4;\n        const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n        this.userCode = `\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              getValue(batch, xR, xC + 3 * ${dilationWidth}, d)\n            );\n\n            ${updateSnippet}\n          }\n\n          int xC = xCCorner + ${filterWidthNearestVec4};\n          if (${filterWidthVec4Remainder === 1}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 2}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${updateSnippet}\n          } else if (${filterWidthVec4Remainder === 3}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${dilationWidth}, d),\n              getValue(batch, xR, xC + 2 * ${dilationWidth}, d),\n              initializationValue\n            );\n\n            ${updateSnippet}\n          }\n        }\n        setOutput(${returnValue});\n      }\n    `;\n    }\n}\nexport class Pool3DProgram {\n    constructor(convInfo, poolType, computePositions, flattenPositions = false, includeBatchInIndex = false) {\n        this.variableNames = ['x'];\n        if (poolType === 'avg' && computePositions) {\n            throw new Error('Cannot compute positions for average pool.');\n        }\n        const filterWidth = convInfo.filterWidth;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n        const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n        const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.outputShape = convInfo.outShape;\n        const isAvgPool = poolType === 'avg';\n        let initializationValue = '0.0';\n        if (!isAvgPool) {\n            // WebGL on Firefox Linux can't compile 1/0 so we do 1/eps.\n            initializationValue = '-1.0 / 1e-20';\n        }\n        if (computePositions) {\n            const compareOp = '>=';\n            this.userCode = `\n        const ivec3 strides =\n            ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n        const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${effectiveFilterDepth};\n              wD += ${dilationDepth}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${effectiveFilterHeight};\n                wR += ${dilationHeight}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${effectiveFilterWidth};\n                  wC += ${dilationWidth}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${compareOp} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${flattenPositions ?\n                (includeBatchInIndex ?\n                    `(((batch * ${convInfo.inDepth} + xD) * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch` :\n                    `((xD * ${convInfo.inHeight} + xR) * ${convInfo.inWidth} + xC) * ${convInfo.inChannels} + ch`) :\n                `wD * ${effectiveFilterHeight} * ${effectiveFilterWidth} +\n                      wR * ${effectiveFilterWidth} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `;\n            return;\n        }\n        const compareOp = 'max';\n        let returnValue = `${poolType}(${poolType}(${poolType}(` +\n            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';\n        if (poolType === 'avg') {\n            returnValue = `avgValue / count`;\n        }\n        const filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;\n        const filterWidthVec4Remainder = filterWidth % 4;\n        const updateSnippet = `\n      if (${isAvgPool}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${compareOp}(values, minMaxValue);\n      }\n    `;\n        this.userCode = `\n      const ivec3 strides =\n        ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n      const float initializationValue = ${initializationValue};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${convInfo.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${initializationValue});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${effectiveFilterDepth};\n            wD += ${dilationDepth}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${effectiveFilterHeight};\n            wR += ${dilationHeight}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidthNearestVec4}; wC += 4) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${dilationWidth}, ch)\n              );\n\n              ${updateSnippet}\n            }\n\n            int xC = xCCorner + ${filterWidthNearestVec4};\n            if (${filterWidthVec4Remainder === 1}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 2}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${updateSnippet}\n            } else if (${filterWidthVec4Remainder === 3}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${dilationWidth}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${dilationWidth}, ch),\n                initializationValue\n              );\n\n              ${updateSnippet}\n            }\n          }\n          setOutput(${returnValue});\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=pool_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class SelectProgram {\n    constructor(cRank, shape, rank) {\n        this.variableNames = ['c', 'a', 'b'];\n        this.outputShape = shape;\n        let cCoords;\n        let abCoords;\n        if (rank > 4) {\n            throw Error(`Where for rank ${rank} is not yet supported`);\n        }\n        if (rank === 1) {\n            abCoords = `resRC`;\n            cCoords = `resRC`;\n        }\n        else {\n            const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n            const cCoordVars = [];\n            const abCoordVars = [];\n            for (let i = 0; i < shape.length; i++) {\n                abCoordVars.push(`${currentCoords[i]}`);\n                if (i < cRank) {\n                    cCoordVars.push(`${currentCoords[i]}`);\n                }\n            }\n            cCoords = cCoordVars.join();\n            abCoords = abCoordVars.join();\n        }\n        const dtype = getCoordsDataType(rank);\n        this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        float cVal = getC(${cCoords});\n        if (cVal >= 1.0) {\n          setOutput(getA(${abCoords}));\n        } else {\n          setOutput(getB(${abCoords}));\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=select_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\n/**\n * Produces GLSL code that derives logical coordinates from a flat\n * index. The code performs integer division with each stride and decrements\n * the index until the index equals the final dimension coordinate.\n */\nexport function getLogicalCoordinatesFromFlatIndex(coords, shape, index = 'index') {\n    const strides = util.computeStrides(shape);\n    return strides\n        .map((stride, i) => {\n        const line1 = `int ${coords[i]} = ${index} / ${stride}`;\n        const line2 = i === strides.length - 1 ?\n            `int ${coords[i + 1]} = ${index} - ${coords[i]} * ${stride}` :\n            `index -= ${coords[i]} * ${stride}`;\n        return `${line1}; ${line2};`;\n    })\n        .join('');\n}\nfunction buildVec(x) {\n    if (x.length === 1) {\n        return `${x[0]}`;\n    }\n    return `vec${x.length}(${x.join(',')})`;\n}\n/**\n * Produces GLSL code that computes the dot product of the input x and y\n * vectors. Handles splitting inputs into increments of vec4s when necessary.\n */\nexport function dotify(x, y) {\n    if (x.length !== y.length) {\n        throw new Error(`Vectors to be dotted must be of the same length -` +\n            `got ${x.length} and ${y.length}`);\n    }\n    const slices = [];\n    const nearestVec4 = Math.floor(x.length / 4);\n    const nearestVec4Remainder = x.length % 4;\n    for (let i = 0; i < nearestVec4; i++) {\n        const xSlice = x.slice(i * 4, i * 4 + 4);\n        const ySlice = y.slice(i * 4, i * 4 + 4);\n        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n    }\n    if (nearestVec4Remainder !== 0) {\n        let xSlice = x.slice(nearestVec4 * 4);\n        let ySlice = y.slice(nearestVec4 * 4);\n        if (xSlice.length === 1) {\n            xSlice = xSlice.map(d => `float(${d})`);\n            ySlice = ySlice.map(d => `float(${d})`);\n        }\n        slices.push(`${buildVec(xSlice)}, ${buildVec(ySlice)}`);\n    }\n    return slices.map((d, i) => `dot(${d})`).join('+');\n}\n/**\n * Produces GLSL that computes the flat index from 3D coordinates.\n */\nexport function getFlatIndexFrom3D(shape) {\n    const strides = util.computeStrides(shape).map(d => d.toString());\n    return `\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${strides[0]} + coords.y * ${strides[1]} + coords.z;\n  }\n`;\n}\nexport const ENCODE_FLOAT_SNIPPET = `\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n`;\n//# sourceMappingURL=shader_compiler_util.js.map"],"names":["ReshapePackedProgram","constructor","outputShape","inputShape","this","variableNames","packedInputs","packedOutput","mainLoop","i","thisRC","shape","userCode","SlicePackedProgram","destSize","rank","length","dtype","coords","sourceLoc","innerDims","slice","join","getChannel","upperRow","lowerRow","sourceLocSetup","map","_","getCustomSetupFunc","start","Error","gpgpu","webGLProgram","startLoc","getUniformLocationNoThrow","gl","uniform1iv","ResizeNearestNeighborProgram","newHeight","newWidth","alignCorners","halfPixelCenters","batch","oldHeight","oldWidth","depth","effectiveInSize","effectiveOutSize","roundBase","sourceFracIndexRC","ScatterProgram","updateSize","sliceDim","indicesRank","updatesRank","strides","summingDupeIndex","stridesType","indicesString","indicesSnippet","updatesString","updatesSnippet","strideString","SliceProgram","uniformPart","sourceCoords","x","getCoords","body","StridedSliceProgram","begin","size","inputDtype","newCoords","outputAxis","PadPackedProgram","xShape","paddings","constantValue","p","end","source","cLimit","componentSetup","paddingArea","j","value","valueLoc","uniform1f","ResizeBilinearPackedProgram","ReduceProgram","reduceInfo","reduceType","windowSize","batchSize","inSize","outSize","initializationValue","compareOp","returnValue","windowSizeNearestVec4","Math","floor","windowSizeVec4Remainder","updateSnippet","vecType","checkOutOfBounds","ResizeBilinearProgram","ResizeNearestNeigborBackpropProgram","dyShape","xHeight","xWidth","yHeight","yWidth","effectiveXSize","effectiveYSize","heightScale","widthScale","invHeightScale","invWidthScale","winHeight","ceil","winWidth","getBroadcastDims","backend_util","makeShader","inputsInfo","usesPackedTextures","prefixSnippets","forEach","util","shapeInfo","logicalShape","isUniform","push","name","inputPrefixSnippet","inputSamplingSnippet","inInfo","outShapeInfo","res","getPackedSamplerFromInInfo","getSamplerFromInInfo","inShape","outShape","inputInfo","texName","texFuncSnippet","charAt","toUpperCase","funcName","inRank","outRank","broadcastDims","type","getCoordsDataType","rankDiff","coordsSnippet","fields","d","unpackedCoordsSnippet","s","output","isInputScalar","isOutputScalar","rows","cols","indexOf","getPackedSamplerAtOutputCoords","outTexShape","texShape","inTexShape","flatOffset","getSamplerAtOutputCoords","getInputSamplingSnippet","glsl","floatTextureSampleSnippet","texture2D","getFloatTextureSampleSnippet","outputSamplingSnippet","floatTextureSetOutputSnippet","shaderPrefix","SHADER_PREFIX","version","varyingFs","defineOutput","defineSpecialNaN","defineSpecialInf","defineRound","SAMPLE_1D_SNIPPET","SAMPLE_2D_SNIPPET","SAMPLE_3D_SNIPPET","getShaderPrefix","isPacked","getOutputScalarCoords","packedTexShape","getOutputPacked1DCoords","texelsInLogicalRow","getOutputPacked2DCoords","texelsInBatch","getOutputPacked3DCoords","texelsInBatchN","batches","b","getOutputPackedNDCoords","getPackedOutputSamplingSnippet","getFloatTextureSetRGBASnippet","getOutput1DCoords","getOutput2DCoords","coordsFromIndexSnippet","getOutput3DCoords","getOutput4DCoords","getOutput5DCoords","getOutput6DCoords","getOutputSamplingSnippet","getFloatTextureSetRSnippet","SHADER_PACKED_PREFIX","texNumR","texNumC","tNumR","tNumC","offset","getFlatOffsetUniformName","getSamplerScalar","getUniformSampler","getSampler1D","newShape","keptDims","squeezedShape","params","squeezeInputInfo","getSqueezedParams","getSampler2D","stride0","stride1","getSampler3D","stride2","getSampler4D","stride3","getSampler5D","stride4","getSampler6D","getPackedSamplerScalar","getPackedSampler1D","valuesPerRow","getPackedSampler2D","getPackedSampler3D","index","getPackedSamplerND","newInputInfo","JSON","parse","stringify","PackProgram","channels","outOfBoundsCondition","dims","cond","getOutOfBoundsCondition","setup","getSetup","row","col","coord","getSourceCoordsArr","getOutput","RotateProgram","imageShape","fillValue","imageHeight","imageWidth","fillSnippet","toFixed","centerX","centerY","sinFactor","cosFactor","paramsLoc","uniform4f","ResizeBilinearBackpropProgram","SegmentOpProgram","segOpInfo","segOpType","numSegments","checkValueOutOfBounds","checkSegmentIdOutOfBounds","ResizeNearestNeighborPackedProgram","PadProgram","unpackedCoords","ReversePackedProgram","axis","nextColumn","nextRow","inCoordsArray","channels1","getInCoord","getR","getG","getB","getA","ReverseProgram","inCoords","getVecChannels","getChannels","getSourceCoords","kernelConfigs","r","kernelConfig","registerKernel","Pool2DProgram","convInfo","poolType","computePositions","flattenPositions","includeBatchInIndex","filterWidth","strideHeight","strideWidth","dilationHeight","dilationWidth","effectiveFilterHeight","effectiveFilterWidth","padTop","padInfo","top","padLeft","left","isAvgPool","batchFlattenPositionStr","inHeight","inWidth","inChannels","flattenPositionStr","filterWidthNearestVec4","filterWidthVec4Remainder","Pool3DProgram","strideDepth","dilationDepth","effectiveFilterDepth","padFront","front","inDepth","SelectProgram","cRank","cCoords","abCoords","currentCoords","cCoordVars","abCoordVars","getLogicalCoordinatesFromFlatIndex","stride","getFlatIndexFrom3D","toString","ENCODE_FLOAT_SNIPPET"],"sourceRoot":""}