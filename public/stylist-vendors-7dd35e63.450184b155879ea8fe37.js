"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[6500],{5972:function(n,e,t){t.d(e,{z:function(){return l}});var i=t(28189),s=t(45119),r=t(70929),o=t(17986);const l=(0,r.op)({slice2d_:function(n,e,t){const r=(0,i.YT)(n,"x","slice2d");return s.vA(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),(0,o.d)(r,e,t)}})},17986:function(n,e,t){t.d(e,{d:function(){return o}});var i=t(67897),s=t(15441),r=t(28189);const o=(0,t(70929).op)({slice_:function(n,e,t){const o=(0,r.YT)(n,"x","slice","string_or_numeric");if(0===o.rank)throw new Error("Slicing scalar is not possible");const l={x:o},a={begin:e,size:t};return i.T2.runKernel(s.JiE,l,a)}})},26346:function(n,e,t){t.d(e,{V:function(){return o}});var i=t(67897),s=t(15441),r=t(28189);const o=(0,t(70929).op)({softmax_:function(n,e=-1){const t=(0,r.YT)(n,"logits","softmax","float32");if(-1===e&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const o={logits:t},l={dim:e};return i.T2.runKernel(s.rFG,o,l)}})},33726:function(n,e,t){t.d(e,{F:function(){return o}});var i=t(67897),s=t(15441),r=t(28189);const o=(0,t(70929).op)({sin_:function(n){const e={x:(0,r.YT)(n,"x","sin","float32")};return i.T2.runKernel(s.hql,e)}})},34969:function(n,e,t){t.r(e),t.d(e,{assertParamsValid:function(){return o},computeFlatOffset:function(){return A},computeOutShape:function(){return a},getNormalizedAxes:function(){return f},isSliceContinous:function(){return m},maskToAxes:function(){return l},parseSliceParams:function(){return x},sliceInfo:function(){return S},startForAxis:function(){return k},startIndicesWithElidedDims:function(){return h},stopForAxis:function(){return b},stopIndicesWithElidedDims:function(){return p},stridesForAxis:function(){return g},stridesWithElidedDims:function(){return u}});var i=t(45119);const s=-2,r=-1;function o(n,e,t){const s=n.shape.length;i.vA(s===e.length,(()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`)),i.vA(s===t.length,(()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`));for(let r=0;r<s;++r)i.vA(e[r]+t[r]<=n.shape[r],(()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`))}function l(n){const e=[];let t=0;for(;n>0;)1&n&&e.push(t),n/=2,t++;return e}function a(n,e,t){const i=[];for(let s=0;s<n.length;s++)i[s]=Math.ceil((e[s]-n[s])/t[s]);return i}function u(n,e,t,i){const s=[...n];for(let r=s.length;r<i.length;r++)s.push(1);for(let r=0;r<t;r++)0===r?s[e]=1:(s.splice(e,0,1),s.pop());return s}function c(n,e,t){return t<=n?t:t-(e-1)}function d(n,e){const t=[];for(let i=0;i<n;i++)t.push(e+i);return t}function f(n,e,t,i,s,r,o,l,a){const c=n.length;let d=new Array(c),f=new Array(c),m=new Array(c);if(e.length&&t>0){const a=e[0],c=t+1;d=h(o,a,c,i,n),f=p(l,a,c,s,n),m=u(r,a,c,n)}else for(let u=0;u<c;u++)d[u]=k(o,i,r,n,u,a),f[u]=b(l,s,r,n,u,a),m[u]=g(r,u,a);return{begin:d,end:f,strides:m}}function h(n,e,t,i,s){const r=[...s],o=d(t,e);for(let l=0;l<r.length;l++)if(o.indexOf(l)>-1)r[l]=0;else{const s=c(e,t,l);let o=i[s];n&1<<s&&(o=0),r[l]=o}return r}function p(n,e,t,s,r){const o=[...r],l=d(t,e);for(let i=0;i<o.length;i++)if(l.indexOf(i)>-1)o[i]=Number.MAX_SAFE_INTEGER;else{const r=c(e,t,i);let l=s[r];n&1<<r&&(l=Number.MAX_SAFE_INTEGER),o[i]=l}for(let a=0;a<o.length;a++){const n=r[a];o[a]<0&&(o[a]+=n),o[a]=i.qE(0,o[a],r[a])}return o}function g(n,e,t){let i=n[e];return(t&1<<e||null==i)&&(i=1),i}function k(n,e,t,s,r,o){let l=e[r];const a=t[r]||1;(n&1<<r||o&1<<r||null==l)&&(l=a>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const u=s[r];return l<0&&(l+=u),l=i.qE(0,l,u-1),l}function b(n,e,t,s,r,o){let l=e[r];const a=t[r]||1;(n&1<<r||o&1<<r||null==l)&&(l=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=s[r];return l<0&&(l+=u),l=a>0?i.qE(0,l,u):i.qE(-1,l,u-1),l}function m(n,e,t){let i=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){i=s;break}for(let s=i+1;s<t.length;s++)if(e[s]>0||t[s]!==n[s])return!1;return!0}function A(n,e){let t=n.length>0?n[n.length-1]:1;for(let i=0;i<n.length-1;i++)t+=n[i]*e[i];return t}function x(n,e,t){let s;const r=n.shape.length;let o;return s="number"===typeof e?[e,...new Array(r-1).fill(0)]:e.length<r?e.concat(new Array(r-e.length).fill(0)):e.slice(),s.forEach((n=>{i.vA(-1!==n,(()=>"slice() does not support negative begin indexing."))})),o=null==t?new Array(r).fill(-1):"number"===typeof t?[t,...new Array(r-1).fill(-1)]:t.length<r?t.concat(new Array(r-t.length).fill(-1)):t,o=o.map(((e,t)=>e>=0?e:(i.vA(-1===e,(()=>`Negative size values should be exactly -1 but got ${e} for the slice() size at index ${t}.`)),n.shape[t]-s[t]))),[s,o]}function S(n,e,t,i,o,l,a,u,c){let d;if(null==i?(d=new Array(e.length),d.fill(1)):d=i,null!=a&&0!==(a&a-1))throw new Error("Multiple ellipses in slice is not allowed.");let f=!1;const h={dims:d.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:d.slice(),beginMask:o,endMask:l,ellipsisMask:a,newAxisMask:u,shrinkAxisMask:c};for(let s=0;s<h.dims;s++)f&&0!==(1<<s&u)&&h.numAddAxisAfterEllipsis++,1<<s&a&&(f=!0);f||(h.ellipsisMask|=1<<h.dims,h.dims++);const p={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=null!=n.begin,e.endValid=null!=n.end,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let i=0;i<n.dims;i++)if(1<<i&n.ellipsisMask){const s=Math.min(e.dims-(n.dims-i)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<s;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=i}else if(1<<i&n.newAxisMask)e.finalShapeGatherIndices.push(s),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);null!=n.begin&&(e.begin[t]=n.begin[i]),null!=n.end&&(e.end[t]=n.end[i]),e.strides[t]=n.strides[i],n.beginMask&1<<i&&(e.beginMask|=1<<t),n.endMask&1<<i&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<i?(e.finalShapeGatherIndices.push(r),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(i)),e.inputShapeGatherIndicesSparse[t]=i,t++}}(h,p);let g=!0,k=!0,b=!0;const m=[],A=[];for(let s=0;s<n.length;++s){if(0===p.strides[s])throw Error(`strides[${s}] must be non-zero`);const e=!!(p.shrinkAxisMask&1<<s),t=n[s];if(-1===t){m.push(e?1:-1);continue}const i=[p.beginMask&1<<s,p.endMask&1<<s],r=[p.strides[s]>0?0:-1,p.strides[s]>0?t:t-1];if(e&&p.strides[s]<=0)throw Error("only stride 1 allowed on non-range indexing.");b=b&&1===p.strides[s];const o=!!(p.beginMask&1<<s&&p.endMask&1<<s);if(p.beginValid&&p.endValid){if(e){const n=p.begin[s]<0?t+p.begin[s]:p.begin[s];if(p.begin[s]=n,p.end[s]=p.begin[s]+1,n<0||n>=t)throw Error(`slice index ${p.begin[s]} of dimension ${s} out of bounds.`)}else p.begin[s]=E(p.begin[s],0,p.strides[s],t,i,r),p.end[s]=E(p.end[s],1,p.strides[s],t,i,r);const n=1===p.strides[s]&&0===p.begin[s]&&p.end[s]===t;g=g&&n,k=k&&(0===s&&1===p.strides[s]||n)}else g=g&&1===p.strides[s]&&o,k=k&&(0===s&&1===p.strides[s]||o);let l,a=!1;if(p.beginValid&&p.endValid?(l=p.end[s]-p.begin[s],a=!0):e?(l=1,a=!0):o&&t>=0&&(l=p.strides[s]<0?-t:t,a=!0),a){let n;n=0===l||l<0!==p.strides[s]<0?0:Math.trunc(l/p.strides[s])+(l%p.strides[s]!==0?1:0),m.push(n)}else m.push(-1)}for(let r=0;r<p.finalShapeGatherIndices.length;++r){const n=p.finalShapeGatherIndices[r];n>=0?A.push(m[n]):n===s&&A.push(1)}return{finalShapeSparse:A.filter(((n,e)=>p.finalShapeGatherIndices[e]!==s)),finalShape:A,isIdentity:g,sliceDim0:k,isSimpleSlice:b,begin:p.begin,end:p.end,strides:p.strides}}function E(n,e,t,i,s,r){if(s[e])return t>0?r[e]:r[e+1&1];{const e=n<0?i+n:n;return e<r[0]?r[0]:e>r[1]?r[1]:e}}},36241:function(n,e,t){t.d(e,{w:function(){return l}});var i=t(28189),s=t(45119),r=t(70929),o=t(17986);const l=(0,r.op)({slice3d_:function(n,e,t){const r=(0,i.YT)(n,"x","slice3d");return s.vA(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),(0,o.d)(r,e,t)}})},50963:function(n,e,t){t.d(e,{Q:function(){return l}});var i=t(28189),s=t(45119),r=t(70929),o=t(17986);const l=(0,r.op)({slice1d_:function(n,e,t){const r=(0,i.YT)(n,"x","slice1d");return s.vA(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),(0,o.d)(r,[e],[t])}})},58276:function(n,e,t){t.d(e,{L:function(){return o}});var i=t(67897),s=t(15441),r=t(28189);const o=(0,t(70929).op)({sinh_:function(n){const e={x:(0,r.YT)(n,"x","sinh")};return i.T2.runKernel(s.J3C,e)}})},62242:function(n,e,t){t.d(e,{R:function(){return l}});var i=t(28189),s=t(45119),r=t(70929),o=t(17986);const l=(0,r.op)({slice4d_:function(n,e,t){const r=(0,i.YT)(n,"x","slice4d");return s.vA(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),(0,o.d)(r,e,t)}})},66030:function(n,e,t){t.d(e,{l:function(){return o}});var i=t(67897),s=t(15441),r=t(28189);const o=(0,t(70929).op)({softplus_:function(n){const e={x:(0,r.YT)(n,"x","softplus")};return i.T2.runKernel(s.Fin,e)}})}}]);
//# sourceMappingURL=stylist-vendors-7dd35e63.450184b155879ea8fe37.js.map