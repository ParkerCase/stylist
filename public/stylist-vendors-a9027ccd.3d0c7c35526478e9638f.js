"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[3262],{4282:function(e,t,s){s.d(t,{Tb:function(){return h},lD:function(){return l},uK:function(){return a},vY:function(){return o}});var n=s(9495),r=s(31321);class i{get id(){return this.idTensor.id}constructor(e,t,s,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,null!=e&&e.forEach((e=>{if(s!==e.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${e.dtype}`);(0,r.Wq)(t,e.shape,"TensorList shape mismatch: "),(0,n.keep)(e)})),this.idTensor=(0,n.scalar)(0),this.maxNumElements=i,(0,n.keep)(this.idTensor)}copy(){return new i([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==s&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);(0,r.Wq)(e,this.elementShape,"TensorList shape mismatch: ");const i=(0,r.E8)(this.elementShape,this.tensors,e);return(0,n.tidy)((()=>{const e=this.tensors.map((e=>(0,n.reshape)(e,i)));return(0,n.stack)(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const s=(0,r.E8)(this.elementShape,this.tensors,e),i=this.tensors.pop();return i.kept=!1,(0,r.Wq)(i.shape,e,"TensorList shape mismatch: "),(0,n.reshape)(i,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if((0,r.Wq)(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,n.keep)(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new i([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);(0,r.Wq)(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=(0,r.E8)(this.elementShape,this.tensors,t);return(0,n.reshape)(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);(0,r.Wq)(this.elementShape,t.shape,"TensorList shape mismatch: "),(0,n.keep)(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);(0,r.Wq)(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=(0,r.E8)(this.elementShape,this.tensors,s);return 0===e.length?(0,n.tensor)([],[0].concat(i)):(0,n.tidy)((()=>{const t=e.map((e=>(0,n.reshape)(this.tensors[e],i)));return(0,n.stack)(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);(0,r.Wq)(this.elementShape,t,"TensorList shape mismatch: ");const s=(0,r.E8)(this.elementShape,this.tensors,t);return 0===this.size()?(0,n.tensor)([],[0].concat(s)):(0,n.tidy)((()=>{const e=this.tensors.map((e=>(0,n.reshape)(e,s)));return(0,n.concat)(e,0)}))}}function a(e,t,s){const a=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==s)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${s}`);const o=e.shape.slice(1);(0,r.Wq)(o,t,"TensorList shape mismatch: ");const h=(0,n.unstack)(e);return new i(h,t,a)}function o(e,t,s,n){return new i([],e,t,n)}function h(e,t,s,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);const o=new i([],s,e.dtype,r),h=(0,n.unstack)(e,0);return t.forEach(((e,t)=>{o.setItem(e,h[t])})),o}function l(e,t,s){let a=0;const o=t.map((e=>(a+=e,a)));if(a!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${a}, and tensor's shape is: ${e.shape}`);const h=e.shape.slice(1),l=(0,r.YI)(h,s),p=0===a?0:e.size/a,m=(0,n.tidy)((()=>{const s=[];e=(0,n.reshape)(e,[1,a,p]);for(let r=0;r<t.length;++r){const i=[0,0===r?0:o[r-1],0],a=[1,t[r],p];s[r]=(0,n.reshape)((0,n.slice)(e,i,a),l)}return e.dispose(),s})),u=new i([],s,e.dtype,t.length);for(let n=0;n<m.length;n++)u.setItem(n,m[n]);return u}},26105:function(e,t,s){s.d(t,{n:function(){return i}});var n=s(9495),r=s(31321);class i{constructor(e,t,s,r,i,a,o){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=(0,n.scalar)(0),(0,n.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),(0,r.Wq)(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,(0,n.keep)(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,s)=>this.write(e,t[s])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return(0,n.tensor)([],[0].concat(this.elementShape));const s=this.readMany(e);return(0,r.Wq)(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),(0,n.stack)(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return(0,n.tensor)([],[0].concat(this.elementShape));const t=[];for(let n=0;n<this.size();n++)t.push(n);const s=this.readMany(t);return(0,r.Wq)(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),(0,n.concat)(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,(0,n.unstack)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map((e=>(s+=e,s)));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=0===s?0:t.size/s,a=[];(0,n.tidy)((()=>{t=(0,n.reshape)(t,[1,s,i]);for(let s=0;s<e.length;++s){const o=[0,0===s?0:r[s-1],0],h=[1,e[s],i];a[s]=(0,n.reshape)((0,n.slice)(t,o,h),this.elementShape)}return a}));const o=[];for(let n=0;n<e.length;n++)o[n]=n;this.writeMany(o,a)}}},31321:function(e,t,s){s.d(t,{E8:function(){return a},Wq:function(){return r},YI:function(){return o}});var n=s(9495);function r(e,t,s=""){if("number"!==typeof e&&"number"!==typeof t){n.util.assert(e.length===t.length,(()=>s+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){const i=e[r],a=t[r];n.util.assert(i<0||a<0||i===a,(()=>s+` Shapes ${e} and ${t} must match`))}}}function i(e){return"number"!==typeof e&&!e.some((e=>e<0))}function a(e,t,s){let n=o(e,s);const r=!i(n);if(r&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(r&&t.forEach((e=>{n=o(e.shape,n)})),!i(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function o(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const s=[];for(let n=0;n<e.length;++n){const r=e[n],i=t[n];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);s[n]=r>=0?r:i}return s}},88154:function(e,t,s){s.d(t,{Q:function(){return n}});class n{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}},96454:function(e,t,s){s.d(t,{I:function(){return i},Uy:function(){return m},n8:function(){return o},r7:function(){return r}});var n=s(6439);function r(e,t,s,r){const i=new Set,a=[];let o=null,h=null;const l=new Set,p=new Set(Object.keys(e).map((e=>(0,n.Xi)(e)[0])));r=r||[];const d=new Set(r.map((e=>(0,n.Xi)(e.name)[0]))),f=[...t];for(;f.length>0;){const e=f.pop();(m(e)||u(e)||c(e))&&null==o&&(o=e,h=o.children.map((e=>e.name)).filter((e=>i.has(e)))),i.add(e.name),null==s[e.name]&&(p.has(e.name)||d.has(e.name)||(0!==e.inputs.length?e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),f.push(e))})):a.push(e.name)))}return{inputs:e,outputs:t,usedNodes:i,missingInputs:a,dynamicNode:o,syncInputs:h}}function i(e,t){const{usedNodes:s,inputs:r}=t,i=Object.keys(r).map((e=>(0,n.Xi)(e)[0])).map((t=>e.nodes[t])),o=e.initNodes||[],h=e=>s.has("string"===typeof e?e:e.name);function l(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}const p=l([...i,...e.weights,...o]).filter(h),m=l([...p,...Object.values(e.nodes)]).filter(h),u=new Map(m.map((e=>[e.name,e]))),c={};for(const n of m){c[n.name]=c[n.name]||0;for(const e of n.children)h(e)||(c[e.name]=Number.POSITIVE_INFINITY),c[e.name]=(c[e.name]||0)+1}const d=Object.entries(c).filter((([,e])=>0===e)).map((([e])=>e)),f=[...d];for(;d.length>0;){const e=d.pop(),t=u.get(e);for(const s of t.children.filter(h))0===--c[s.name]&&(f.push(s.name),d.push(s.name))}const w=function(e,t){const s=new Map(e.map((e=>[e.name,e]))),n=t.map((e=>e.name)),r=new Set(n);for(;n.length>0;){const e=n.pop(),t=s.get(e);for(const i of t.children)s.has(i.name)&&!r.has(i.name)&&(r.add(i.name),n.push(i.name))}const i=e.filter((e=>r.has(e.name)));return i}(f.map((e=>u.get(e))),p);return function(e,t){const s=new Map(e.map(((e,t)=>[e.name,t]))),n=new Set(t.map((e=>e.name))),r=e=>n.has("string"===typeof e?e:e.name),i=new Set(e.map((e=>e.name))),o=e=>i.has("string"===typeof e?e:e.name);for(const h of e){for(const e of h.children.filter(o)){if(!s.has(e.name))throw new a(`Child ${e.name} of node ${h.name} is unreachable.`);if(s.get(h.name)>s.get(e.name))throw new a(`Node ${h.name} is scheduled to run after its child ${e.name}.`)}if(!r(h))for(const e of h.inputs){if(!s.has(e.name))throw new a(`Input ${e.name} of node ${h.name} is unreachable.`);if(s.get(e.name)>s.get(h.name))throw new a(`Node ${h.name} is scheduled to run before its input ${e.name}.`)}}}(w,p),w}class a extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function o(e){const t=new Map(e.map(((e,t)=>[e.name,t]))),s=Number.MAX_SAFE_INTEGER,n=e.map(((e,t)=>m(e)?s:t)),r=e=>{const s=n[t.get(e.name)];return null==s?-1:s},i=e.map(((e,t)=>e.children.map(r).reduce(((e,t)=>Math.max(e,t)),n[t]))),a=new Map;for(let o=0;o<e.length;++o){const t=i[o];if(t===s)continue;const n=e[o],r=e[t];a.has(r.name)||a.set(r.name,[]),a.get(r.name).push(n)}return a}const h=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),l=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),p=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function m(e){return h.has(e.op)}function u(e){return l.has(e.op)}function c(e){return p.has(e.op)}}}]);
//# sourceMappingURL=stylist-vendors-a9027ccd.3d0c7c35526478e9638f.js.map