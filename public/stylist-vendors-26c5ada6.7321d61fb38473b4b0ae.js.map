{"version":3,"file":"stylist-vendors-26c5ada6.7321d61fb38473b4b0ae.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/pool_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_impl.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/fused_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/zeros_impl.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/fft_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/version.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/unary_impl.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/utils/binary_utils.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { buffer } from '@tensorflow/tfjs-core';\nexport function pool(xValues, xShape, dtype, strides, convInfo, poolType) {\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const initialValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n        Number.POSITIVE_INFINITY);\n    const output = buffer(convInfo.outShape, dtype);\n    const outputVals = output.values;\n    const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] * convInfo.outShape[3];\n    const outputRowStrides = convInfo.outShape[2] * convInfo.outShape[3];\n    const outputColStrides = convInfo.outShape[3];\n    for (let b = 0; b < convInfo.batchSize; ++b) {\n        const outputBatchOffset = b * outputBatchStrides;\n        const inputBatchOffset = b * strides[0];\n        for (let d = 0; d < convInfo.inChannels; ++d) {\n            for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                const xRCorner = yR * strideHeight - padTop;\n                const xRMin = Math.max(0, xRCorner);\n                const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n                const outputRowOffset = outputBatchOffset + yR * outputRowStrides;\n                for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                    const xCCorner = yC * strideWidth - padLeft;\n                    const xCMin = Math.max(0, xCCorner);\n                    const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n                    let minMaxValue = initialValue;\n                    let avgValue = 0;\n                    let count = 0;\n                    for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n                        const xROffset = inputBatchOffset + xR * strides[1];\n                        for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n                            const xCOffset = xROffset + xC * strides[2];\n                            const pixel = xValues[xCOffset + d];\n                            if ((poolType === 'max' && pixel > minMaxValue)) {\n                                minMaxValue = pixel;\n                            }\n                            else if (poolType === 'avg') {\n                                avgValue += pixel;\n                                count++;\n                            }\n                        }\n                        if (isNaN(minMaxValue)) {\n                            break;\n                        }\n                    }\n                    const outputOffset = outputRowOffset + yC * outputColStrides + d;\n                    outputVals[outputOffset] =\n                        poolType === 'avg' ? avgValue / count : minMaxValue;\n                }\n            }\n        }\n    }\n    return output;\n}\nexport function maxPoolPositions(xValues, xShape, dtype, convInfo, flattenPositions = false, includeBatchInIndex = false) {\n    const maxPositions = buffer(convInfo.outShape, 'int32');\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const xBuf = buffer(xShape, dtype, xValues);\n    for (let b = 0; b < convInfo.batchSize; ++b) {\n        for (let d = 0; d < convInfo.inChannels; ++d) {\n            for (let yR = 0; yR < convInfo.outHeight; ++yR) {\n                const xRCorner = yR * strideHeight - padTop;\n                let xRMin = xRCorner;\n                while (xRMin < 0) {\n                    xRMin += dilationHeight;\n                }\n                // const xRMin = Math.max(0, xRCorner);\n                const xRMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRCorner);\n                for (let yC = 0; yC < convInfo.outWidth; ++yC) {\n                    const xCCorner = yC * strideWidth - padLeft;\n                    let xCMin = xCCorner;\n                    while (xCMin < 0) {\n                        xCMin += dilationWidth;\n                    }\n                    const xCMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xCCorner);\n                    let maxValue = Number.NEGATIVE_INFINITY;\n                    let maxPosition = -1;\n                    for (let xR = xRMin; xR < xRMax; xR += dilationHeight) {\n                        const wR = xR - xRCorner;\n                        for (let xC = xCMin; xC < xCMax; xC += dilationWidth) {\n                            const wC = xC - xCCorner;\n                            const pixel = xBuf.get(b, xR, xC, d);\n                            if (pixel > maxValue) {\n                                maxValue = pixel;\n                                if (flattenPositions) {\n                                    maxPosition = includeBatchInIndex ?\n                                        ((b * convInfo.inHeight + xR) * convInfo.inWidth + xC) *\n                                            convInfo.inChannels +\n                                            d :\n                                        (xR * convInfo.inWidth + xC) * convInfo.inChannels + d;\n                                }\n                                else {\n                                    maxPosition = wR * effectiveFilterWidth + wC;\n                                }\n                            }\n                        }\n                    }\n                    maxPositions.set(maxPosition, b, yR, yC, d);\n                }\n            }\n        }\n    }\n    return maxPositions;\n}\nexport function pool3d(xValues, xShape, dtype, strides, convInfo, poolType) {\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    const initialValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :\n        Number.POSITIVE_INFINITY);\n    const output = buffer(convInfo.outShape, dtype);\n    const outputVals = output.values;\n    const outputBatchStrides = convInfo.outShape[1] * convInfo.outShape[2] *\n        convInfo.outShape[3] * convInfo.outShape[4];\n    const outputDepthStrides = convInfo.outShape[2] * convInfo.outShape[3] * convInfo.outShape[4];\n    const outputRowStrides = convInfo.outShape[3] * convInfo.outShape[4];\n    const outputColStrides = convInfo.outShape[4];\n    for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n        const outputBatchOffset = batch * outputBatchStrides;\n        const inputBatchOffset = batch * strides[0];\n        for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n            for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                const xDepthCorner = yDepth * strideDepth - padFront;\n                let xDepthMin = xDepthCorner;\n                while (xDepthMin < 0) {\n                    xDepthMin += dilationDepth;\n                }\n                const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                const outputDepthOffset = outputBatchOffset + yDepth * outputDepthStrides;\n                for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                    const xRowCorner = yRow * strideHeight - padTop;\n                    let xRowMin = xRowCorner;\n                    while (xRowMin < 0) {\n                        xRowMin += dilationHeight;\n                    }\n                    const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                    const outputRowOffset = outputDepthOffset + yRow * outputRowStrides;\n                    for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                        const xColCorner = yCol * strideWidth - padLeft;\n                        let xColMin = xColCorner;\n                        while (xColMin < 0) {\n                            xColMin += dilationWidth;\n                        }\n                        const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                        // Shader code begins\n                        const outputColOffset = outputRowOffset + yCol * outputColStrides;\n                        let minMaxValue = initialValue;\n                        let avgValue = 0;\n                        let count = 0;\n                        for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                            const xDepthOffset = inputBatchOffset + xDepth * strides[1];\n                            for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                const xRowOffset = xDepthOffset + xRow * strides[2];\n                                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                    const xColOffset = xRowOffset + xCol * strides[3];\n                                    const pixel = xValues[xColOffset + channel];\n                                    if ((poolType === 'max' && pixel > minMaxValue)) {\n                                        minMaxValue = pixel;\n                                    }\n                                    else if (poolType === 'avg') {\n                                        avgValue += pixel;\n                                        count++;\n                                    }\n                                    if (isNaN(minMaxValue)) {\n                                        break;\n                                    }\n                                }\n                                if (isNaN(minMaxValue)) {\n                                    break;\n                                }\n                            }\n                            if (isNaN(minMaxValue)) {\n                                break;\n                            }\n                        }\n                        const outputOffset = outputColOffset + channel;\n                        outputVals[outputOffset] =\n                            poolType === 'avg' ? avgValue / count : minMaxValue;\n                    }\n                }\n            }\n        }\n    }\n    return output;\n}\nexport function maxPool3dPositions(xBuf, convInfo) {\n    const maxPositions = buffer(convInfo.outShape, 'int32');\n    const strideDepth = convInfo.strideDepth;\n    const strideHeight = convInfo.strideHeight;\n    const strideWidth = convInfo.strideWidth;\n    const dilationDepth = convInfo.dilationDepth;\n    const dilationHeight = convInfo.dilationHeight;\n    const dilationWidth = convInfo.dilationWidth;\n    const effectiveFilterDepth = convInfo.effectiveFilterDepth;\n    const effectiveFilterHeight = convInfo.effectiveFilterHeight;\n    const effectiveFilterWidth = convInfo.effectiveFilterWidth;\n    const padFront = convInfo.padInfo.front;\n    const padTop = convInfo.padInfo.top;\n    const padLeft = convInfo.padInfo.left;\n    for (let batch = 0; batch < convInfo.batchSize; ++batch) {\n        for (let channel = 0; channel < convInfo.inChannels; ++channel) {\n            for (let yDepth = 0; yDepth < convInfo.outDepth; ++yDepth) {\n                const xDepthCorner = yDepth * strideDepth - padFront;\n                let xDepthMin = xDepthCorner;\n                while (xDepthMin < 0) {\n                    xDepthMin += dilationDepth;\n                }\n                const xDepthMax = Math.min(convInfo.inDepth, effectiveFilterDepth + xDepthCorner);\n                for (let yRow = 0; yRow < convInfo.outHeight; ++yRow) {\n                    const xRowCorner = yRow * strideHeight - padTop;\n                    let xRowMin = xRowCorner;\n                    while (xRowMin < 0) {\n                        xRowMin += dilationHeight;\n                    }\n                    const xRowMax = Math.min(convInfo.inHeight, effectiveFilterHeight + xRowCorner);\n                    for (let yCol = 0; yCol < convInfo.outWidth; ++yCol) {\n                        const xColCorner = yCol * strideWidth - padLeft;\n                        let xColMin = xColCorner;\n                        while (xColMin < 0) {\n                            xColMin += dilationWidth;\n                        }\n                        const xColMax = Math.min(convInfo.inWidth, effectiveFilterWidth + xColCorner);\n                        // Shader code begins\n                        let maxValue = Number.NEGATIVE_INFINITY;\n                        let maxPosition = -1;\n                        for (let xDepth = xDepthMin; xDepth < xDepthMax; xDepth += dilationDepth) {\n                            const wDepth = xDepth - xDepthCorner;\n                            for (let xRow = xRowMin; xRow < xRowMax; xRow += dilationHeight) {\n                                const wRow = xRow - xRowCorner;\n                                for (let xCol = xColMin; xCol < xColMax; xCol += dilationWidth) {\n                                    const wCol = xCol - xColCorner;\n                                    const pixel = xBuf.get(batch, xDepth, xRow, xCol, channel);\n                                    if (pixel >= maxValue) {\n                                        maxValue = pixel;\n                                        maxPosition =\n                                            wDepth * effectiveFilterHeight * effectiveFilterWidth +\n                                                wRow * effectiveFilterHeight + wCol;\n                                    }\n                                }\n                            }\n                        }\n                        maxPositions.set(maxPosition, batch, yDepth, yRow, yCol, channel);\n                    }\n                }\n            }\n        }\n    }\n    return maxPositions;\n}\n//# sourceMappingURL=pool_utils.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\n/**\n * Template that creates implementation for binary ops. Supports broadcast.\n */\nexport function createSimpleBinaryKernelImpl(op) {\n    return (aShape, bShape, aVals, bVals, dtype) => {\n        const newShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        const resultRank = newShape.length;\n        const resultStrides = util.computeStrides(newShape);\n        const resultSize = util.sizeFromShape(newShape);\n        const result = util.getTypedArrayFromDType(dtype, resultSize);\n        const aRank = aShape.length;\n        const bRank = bShape.length;\n        const aStrides = util.computeStrides(aShape);\n        const bStrides = util.computeStrides(bShape);\n        const aBroadcastDims = backend_util.getBroadcastDims(aShape, newShape);\n        const bBroadcastDims = backend_util.getBroadcastDims(bShape, newShape);\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (let i = 0; i < result.length; ++i) {\n                result[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n            }\n        }\n        else {\n            for (let i = 0; i < result.length; ++i) {\n                const loc = util.indexToLoc(i, resultRank, resultStrides);\n                const aLoc = loc.slice(-aRank);\n                aBroadcastDims.forEach(d => aLoc[d] = 0);\n                const aIndex = util.locToIndex(aLoc, aRank, aStrides);\n                const bLoc = loc.slice(-bRank);\n                bBroadcastDims.forEach(d => bLoc[d] = 0);\n                const bIndex = util.locToIndex(bLoc, bRank, bStrides);\n                result[i] = op(aVals[aIndex], bVals[bIndex]);\n            }\n        }\n        return [result, newShape];\n    };\n}\n//# sourceMappingURL=binary_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { elu } from '../kernels/Elu';\nimport { identity } from '../kernels/Identity';\nimport { leakyRelu } from '../kernels/LeakyRelu';\nimport { prelu } from '../kernels/Prelu';\nimport { relu } from '../kernels/Relu';\nimport { relu6 } from '../kernels/Relu6';\nimport { sigmoid } from '../kernels/Sigmoid';\nexport function applyActivation(backend, x, activation, preluActivationWeights, leakyreluAlpha) {\n    if (activation === 'linear') {\n        return identity({ inputs: { x }, backend });\n    }\n    else if (activation === 'relu') {\n        return relu({ inputs: { x }, backend });\n    }\n    else if (activation === 'elu') {\n        return elu({ inputs: { x }, backend });\n    }\n    else if (activation === 'relu6') {\n        return relu6({ inputs: { x }, backend });\n    }\n    else if (activation === 'prelu') {\n        return prelu({ inputs: { x, alpha: preluActivationWeights }, backend });\n    }\n    else if (activation === 'leakyrelu') {\n        return leakyRelu({ inputs: { x }, backend, attrs: { alpha: leakyreluAlpha } });\n    }\n    else if (activation === 'sigmoid') {\n        return sigmoid({ inputs: { x }, backend });\n    }\n    throw new Error(`Activation ${activation} has not been implemented for the CPU backend.`);\n}\n//# sourceMappingURL=fused_utils.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { complex } from '../kernels/Complex';\n/**\n * Generates a tensorInfo with all zeros value.\n * @param backend cpu backend.\n * @param shape Shape for the zeros tensor.\n * @param dtype Optional. If set, the result has this dtype.\n */\nexport function zeros(backend, shape, dtype = 'float32') {\n    if (dtype === 'complex64') {\n        const real = zeros(backend, shape, 'float32');\n        const imag = zeros(backend, shape, 'float32');\n        return complex({ inputs: { real, imag }, backend });\n    }\n    const values = util.makeZerosTypedArray(util.sizeFromShape(shape), dtype);\n    return backend.makeTensorInfo(shape, dtype, values);\n}\n//# sourceMappingURL=zeros_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { add } from '../kernels/Add';\nimport { complex } from '../kernels/Complex';\nimport { concat } from '../kernels/Concat';\nimport { identity } from '../kernels/Identity';\nimport { imag } from '../kernels/Imag';\nimport { multiply } from '../kernels/Multiply';\nimport { real } from '../kernels/Real';\nimport { realDivConfig } from '../kernels/RealDiv';\nimport { slice } from '../kernels/Slice';\nimport { sub } from '../kernels/Sub';\n/**\n * Calculate FFT of inner most elements of batch tensor.\n */\nexport function fftBatch(input, inverse, cpuBackend) {\n    const inputShape = input.shape;\n    const batch = inputShape[0];\n    const innerDim = inputShape[1];\n    const inputVals = cpuBackend.data.get(input.dataId);\n    const real2D = inputVals.complexTensorInfos.real;\n    const imag2D = inputVals.complexTensorInfos.imag;\n    // Collects real and imaginary values separately.\n    const resultShape = [batch, innerDim];\n    const resultSize = util.sizeFromShape(resultShape);\n    const resultReal = util.getTypedArrayFromDType('float32', resultSize);\n    const resultImag = util.getTypedArrayFromDType('float32', resultSize);\n    for (let b = 0; b < batch; b++) {\n        // TODO: Support slice ops for complex type.\n        const r = slice({\n            inputs: { x: real2D },\n            backend: cpuBackend,\n            attrs: { begin: [b, 0], size: [1, innerDim] }\n        });\n        const i = slice({\n            inputs: { x: imag2D },\n            backend: cpuBackend,\n            attrs: { begin: [b, 0], size: [1, innerDim] }\n        });\n        const input = complex({ inputs: { real: r, imag: i }, backend: cpuBackend });\n        // Run FFT by batch element.\n        const { real, imag } = fftImpl(input, inverse, cpuBackend);\n        const res = backend_util.mergeRealAndImagArrays(real, imag);\n        for (let d = 0; d < innerDim; d++) {\n            const c = backend_util.getComplexWithIndex(res, d);\n            resultReal[b * innerDim + d] = c.real;\n            resultImag[b * innerDim + d] = c.imag;\n        }\n        cpuBackend.disposeIntermediateTensorInfo(r);\n        cpuBackend.disposeIntermediateTensorInfo(i);\n        cpuBackend.disposeIntermediateTensorInfo(input);\n    }\n    const $realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultReal);\n    const $imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImag);\n    const result = complex({ inputs: { real: $realInfo, imag: $imagInfo }, backend: cpuBackend });\n    cpuBackend.disposeIntermediateTensorInfo($realInfo);\n    cpuBackend.disposeIntermediateTensorInfo($imagInfo);\n    return result;\n}\nexport function fftImpl(input, inverse, cpuBackend) {\n    const inputSize = util.sizeFromShape(input.shape);\n    const inputVals = cpuBackend.data.get(input.dataId);\n    const realVals = cpuBackend.data.get(inputVals.complexTensorInfos.real.dataId).values;\n    const imagVals = cpuBackend.data.get(inputVals.complexTensorInfos.imag.dataId).values;\n    if (isExponentOf2(inputSize)) {\n        const result = fftRadix2(realVals, imagVals, inputSize, inverse, cpuBackend);\n        const resultShape = [input.shape[0], input.shape[1]];\n        if (inverse) {\n            const realInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.real);\n            const imagInfo = cpuBackend.makeTensorInfo(resultShape, 'float32', result.imag);\n            const sizeInfo = cpuBackend.makeTensorInfo([], 'float32', util.createScalarValue(inputSize, 'float32'));\n            const sizeInfoCopy = identity({ inputs: { x: sizeInfo }, backend: cpuBackend });\n            const divRealInfo = realDivConfig.kernelFunc({ inputs: { a: realInfo, b: sizeInfo }, backend: cpuBackend });\n            const divImagInfo = realDivConfig.kernelFunc({ inputs: { a: imagInfo, b: sizeInfoCopy }, backend: cpuBackend });\n            const divRealVals = cpuBackend.data.get(divRealInfo.dataId).values;\n            const divImagVals = cpuBackend.data.get(divImagInfo.dataId).values;\n            cpuBackend.disposeIntermediateTensorInfo(realInfo);\n            cpuBackend.disposeIntermediateTensorInfo(imagInfo);\n            cpuBackend.disposeIntermediateTensorInfo(sizeInfo);\n            cpuBackend.disposeIntermediateTensorInfo(sizeInfoCopy);\n            cpuBackend.disposeIntermediateTensorInfo(divRealInfo);\n            cpuBackend.disposeIntermediateTensorInfo(divImagInfo);\n            return { real: divRealVals, imag: divImagVals };\n        }\n        return result;\n    }\n    else {\n        const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n        const rawOutput = fourierTransformByMatmul(data, inputSize, inverse);\n        return backend_util.splitRealAndImagArrays(rawOutput);\n    }\n}\nfunction isExponentOf2(size) {\n    return (size & size - 1) === 0;\n}\n// FFT using Cooley-Tukey algorithm on radix 2 dimensional input.\nfunction fftRadix2(realVals, imagVals, size, inverse, cpuBackend) {\n    if (size === 1) {\n        return { real: realVals, imag: imagVals };\n    }\n    const data = backend_util.mergeRealAndImagArrays(realVals, imagVals);\n    const half = size / 2;\n    const evenComplex = backend_util.complexWithEvenIndex(data);\n    const evenRealVals = evenComplex.real;\n    const evenImagVals = evenComplex.imag;\n    const evenShape = [evenRealVals.length];\n    const evenRealInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenRealVals);\n    const evenImagInfo = cpuBackend.makeTensorInfo(evenShape, 'float32', evenImagVals);\n    const evenTensorInfo = complex({ inputs: { real: evenRealInfo, imag: evenImagInfo }, backend: cpuBackend });\n    const oddComplex = backend_util.complexWithOddIndex(data);\n    const oddRealVals = oddComplex.real;\n    const oddImagVals = oddComplex.imag;\n    const oddShape = [oddRealVals.length];\n    const oddRealInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddRealVals);\n    const oddImagInfo = cpuBackend.makeTensorInfo(oddShape, 'float32', oddImagVals);\n    const oddTensorInfo = complex({ inputs: { real: oddRealInfo, imag: oddImagInfo }, backend: cpuBackend });\n    // Recursive call for half part of original input.\n    const $evenComplex = fftRadix2(evenRealVals, evenImagVals, half, inverse, cpuBackend);\n    const $evenRealVals = $evenComplex.real;\n    const $evenImagVals = $evenComplex.imag;\n    const $evenShape = [$evenRealVals.length];\n    const $evenRealInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenRealVals);\n    const $evenImagInfo = cpuBackend.makeTensorInfo($evenShape, 'float32', $evenImagVals);\n    const $evenTensorInfo = complex({\n        inputs: { real: $evenRealInfo, imag: $evenImagInfo },\n        backend: cpuBackend\n    });\n    const $oddComplex = fftRadix2(oddRealVals, oddImagVals, half, inverse, cpuBackend);\n    const $oddRealVals = $oddComplex.real;\n    const $oddImagVals = $oddComplex.imag;\n    const $oddShape = [$oddRealVals.length];\n    const $oddRealInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddRealVals);\n    const $oddImagInfo = cpuBackend.makeTensorInfo($oddShape, 'float32', $oddImagVals);\n    const $oddTensorInfo = complex({ inputs: { real: $oddRealInfo, imag: $oddImagInfo }, backend: cpuBackend });\n    const e = backend_util.exponents(size, inverse);\n    const eShape = [e.real.length];\n    const eRealInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.real);\n    const eImagInfo = cpuBackend.makeTensorInfo(eShape, 'float32', e.imag);\n    const complexInfo = complex({ inputs: { real: eRealInfo, imag: eImagInfo }, backend: cpuBackend });\n    const exponentInfo = multiply({ inputs: { a: complexInfo, b: $oddTensorInfo }, backend: cpuBackend });\n    const addPart = add({\n        inputs: { a: $evenTensorInfo, b: exponentInfo },\n        backend: cpuBackend\n    });\n    const subPart = sub({\n        inputs: { a: $evenTensorInfo, b: exponentInfo },\n        backend: cpuBackend\n    });\n    const addPartReal = real({ inputs: { input: addPart }, backend: cpuBackend });\n    const subPartReal = real({ inputs: { input: subPart }, backend: cpuBackend });\n    const addPartImag = imag({ inputs: { input: addPart }, backend: cpuBackend });\n    const subPartImag = imag({ inputs: { input: subPart }, backend: cpuBackend });\n    const $real = concat({\n        inputs: [addPartReal, subPartReal],\n        backend: cpuBackend,\n        attrs: { axis: 0 }\n    });\n    const $imag = concat({\n        inputs: [addPartImag, subPartImag],\n        backend: cpuBackend,\n        attrs: { axis: 0 }\n    });\n    const $realVals = cpuBackend.data.get($real.dataId).values;\n    const $imagVals = cpuBackend.data.get($imag.dataId).values;\n    cpuBackend.disposeIntermediateTensorInfo(evenRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo(evenImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo(evenTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo(oddRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo(oddImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo(oddTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo($evenRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo($evenImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo($evenTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo($oddRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo($oddImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo($oddTensorInfo);\n    cpuBackend.disposeIntermediateTensorInfo(eRealInfo);\n    cpuBackend.disposeIntermediateTensorInfo(eImagInfo);\n    cpuBackend.disposeIntermediateTensorInfo(complexInfo);\n    cpuBackend.disposeIntermediateTensorInfo(exponentInfo);\n    cpuBackend.disposeIntermediateTensorInfo(addPart);\n    cpuBackend.disposeIntermediateTensorInfo(subPart);\n    cpuBackend.disposeIntermediateTensorInfo(addPartReal);\n    cpuBackend.disposeIntermediateTensorInfo(addPartImag);\n    cpuBackend.disposeIntermediateTensorInfo(subPartReal);\n    cpuBackend.disposeIntermediateTensorInfo(subPartImag);\n    cpuBackend.disposeIntermediateTensorInfo($real);\n    cpuBackend.disposeIntermediateTensorInfo($imag);\n    return { real: $realVals, imag: $imagVals };\n}\n// Calculate fourier transform by multplying sinusoid matrix.\nfunction fourierTransformByMatmul(data, size, inverse) {\n    const ret = new Float32Array(size * 2);\n    // TODO: Use matmul instead once it supports complex64 type.\n    for (let r = 0; r < size; r++) {\n        let real = 0.0;\n        let imag = 0.0;\n        for (let c = 0; c < size; c++) {\n            const e = backend_util.exponent(r * c, size, inverse);\n            const term = backend_util.getComplexWithIndex(data, c);\n            real += term.real * e.real - term.imag * e.imag;\n            imag += term.real * e.imag + term.imag * e.real;\n        }\n        if (inverse) {\n            real /= size;\n            imag /= size;\n        }\n        backend_util.assignToTypedArray(ret, real, imag, r);\n    }\n    return ret;\n}\n//# sourceMappingURL=fft_utils.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param name Kernel name.\n * @param op A `SimpleUnaryOperation` for the kernel.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the input. This is mainly used in certain\n *     kernels that return bool type, such as isFinite, isInf, etc.\n */\nexport function unaryKernelFunc(name, op, dtype) {\n    return ({ inputs, attrs, backend }) => {\n        const { x } = inputs;\n        assertNotComplex(x, name);\n        if (x.dtype === 'string' || dtype === 'string') {\n            throw new Error('unaryKernelFunc does not support string input/output');\n        }\n        const cpuBackend = backend;\n        const values = cpuBackend.data.get(x.dataId).values;\n        const xSize = util.sizeFromShape(x.shape);\n        const $dtype = dtype || x.dtype;\n        const newValues = util.getArrayFromDType($dtype, xSize);\n        for (let i = 0; i < xSize; ++i) {\n            newValues[i] = op(values[i], attrs);\n        }\n        return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);\n    };\n}\n/**\n * Template that creates a `KernelFunc` for unary ops from the given\n * `SimpleUnaryImpl`..\n * @param name Kernel name.\n * @param unaryImpl A `SimpleUnaryImpl` that implements the op.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the input. This is mainly used in certain\n *     kernels that return bool type, such as isFinite, isInf, etc.\n */\nexport function unaryKernelFuncFromImpl(name, unaryImpl, dtype) {\n    return ({ inputs, attrs, backend }) => {\n        const { x } = inputs;\n        assertNotComplex(x, name);\n        if (x.dtype === 'string' || dtype === 'string') {\n            throw new Error('unaryKernelFunc does not support string input/output');\n        }\n        const cpuBackend = backend;\n        const values = cpuBackend.data.get(x.dataId).values;\n        const $dtype = dtype || x.dtype;\n        const newValues = unaryImpl(values, $dtype, attrs);\n        return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);\n    };\n}\n//# sourceMappingURL=unary_utils.js.map","/** @license See the LICENSE file. */\n// This code is auto-generated, do not modify this file!\nconst version = '3.6.0';\nexport { version };\n//# sourceMappingURL=version.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\n/**\n * Template that creates implementation for unary op.\n */\nexport function createSimpleUnaryImpl(op) {\n    return (values, dtype, attrs) => {\n        const newValues = util.getTypedArrayFromDType(dtype, values.length);\n        for (let i = 0; i < values.length; ++i) {\n            newValues[i] = op(values[i], attrs);\n        }\n        return newValues;\n    };\n}\n//# sourceMappingURL=unary_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nimport { assertNotComplex } from '../cpu_util';\nimport { cast } from '../kernels/Cast';\nimport { complex } from '../kernels/Complex';\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param name Kernel name.\n * @param binaryKernelImpl A `SimpleBinaryKernelImpl` for the kernel.\n * @param binaryKernelComplexImpl Optional. If exists, represents a\n *     `ComplexBinaryKernelImpl` for the kernel, will be used when input dtype\n *     is `complex64`.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc(name, simpleImpl, complexImpl, dtype) {\n    if (complexImpl == null) {\n        return ({ inputs, backend }) => {\n            const { a, b } = inputs;\n            const cpuBackend = backend;\n            assertNotComplex([a, b], name);\n            const aVals = cpuBackend.data.get(a.dataId).values;\n            const bVals = cpuBackend.data.get(b.dataId).values;\n            const $dtype = dtype || a.dtype;\n            const [resultData, resultShape] = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);\n            return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);\n        };\n    }\n    return ({ inputs, backend }) => {\n        const { a, b } = inputs;\n        const cpuBackend = backend;\n        if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n            const $aComplex = cast({ inputs: { x: a }, backend: cpuBackend, attrs: { dtype: 'complex64' } });\n            const $aComplexVals = cpuBackend.data.get($aComplex.dataId);\n            const aReal = $aComplexVals.complexTensorInfos.real;\n            const aImag = $aComplexVals.complexTensorInfos.imag;\n            const aRealVals = cpuBackend.data.get(aReal.dataId).values;\n            const aImagVals = cpuBackend.data.get(aImag.dataId).values;\n            const $bComplex = cast({ inputs: { x: b }, backend: cpuBackend, attrs: { dtype: 'complex64' } });\n            const $bComplexVals = cpuBackend.data.get($bComplex.dataId);\n            const bReal = $bComplexVals.complexTensorInfos.real;\n            const bImag = $bComplexVals.complexTensorInfos.imag;\n            const bRealVals = cpuBackend.data.get(bReal.dataId).values;\n            const bImagVals = cpuBackend.data.get(bImag.dataId).values;\n            const [resultRealData, resultImagData, resultShape] = complexImpl(a.shape, b.shape, aRealVals, aImagVals, bRealVals, bImagVals);\n            const resultReal = cpuBackend.makeTensorInfo(resultShape, 'float32', resultRealData);\n            const resultImag = cpuBackend.makeTensorInfo(resultShape, 'float32', resultImagData);\n            const result = complex({ inputs: { real: resultReal, imag: resultImag }, backend: cpuBackend });\n            cpuBackend.disposeIntermediateTensorInfo($aComplex);\n            cpuBackend.disposeIntermediateTensorInfo($bComplex);\n            cpuBackend.disposeIntermediateTensorInfo(resultReal);\n            cpuBackend.disposeIntermediateTensorInfo(resultImag);\n            return result;\n        }\n        else {\n            const aVals = cpuBackend.data.get(a.dataId).values;\n            const bVals = cpuBackend.data.get(b.dataId).values;\n            const $dtype = dtype || a.dtype;\n            const [resultData, resultShape] = simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);\n            return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);\n        }\n    };\n}\n/**\n * Template that creates the complex type implementation for binary ops.\n * Supports broadcast.\n */\nexport function createComplexBinaryKernelImpl(op) {\n    return (aShape, bShape, aRealVals, aImagVals, bRealVals, bImagVals) => {\n        const resultShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n        const resultSize = util.sizeFromShape(resultShape);\n        const resultRank = resultShape.length;\n        const resultStrides = util.computeStrides(resultShape);\n        const resultRealVals = util.getTypedArrayFromDType('float32', resultSize);\n        const resultImagVals = util.getTypedArrayFromDType('float32', resultSize);\n        const aBroadcastDims = backend_util.getBroadcastDims(aShape, resultShape);\n        const bBroadcastDims = backend_util.getBroadcastDims(bShape, resultShape);\n        const aVals = backend_util.mergeRealAndImagArrays(aRealVals, aImagVals);\n        const bVals = backend_util.mergeRealAndImagArrays(bRealVals, bImagVals);\n        const aRank = aShape.length;\n        const aStrides = util.computeStrides(aShape);\n        const bRank = bShape.length;\n        const bStrides = util.computeStrides(bShape);\n        if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n            for (let i = 0; i < resultRealVals.length; i++) {\n                const aIdx = i % aVals.length;\n                const bIdx = i % bVals.length;\n                const result = op(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2], bVals[bIdx * 2 + 1]);\n                resultRealVals[i] = result.real;\n                resultImagVals[i] = result.imag;\n            }\n        }\n        else {\n            for (let i = 0; i < resultRealVals.length; i++) {\n                const loc = util.indexToLoc(i, resultRank, resultStrides);\n                const aLoc = loc.slice(-aRank);\n                aBroadcastDims.forEach(d => aLoc[d] = 0);\n                const aIndex = util.locToIndex(aLoc, aRank, aStrides);\n                const bLoc = loc.slice(-bRank);\n                bBroadcastDims.forEach(d => bLoc[d] = 0);\n                const bIndex = util.locToIndex(bLoc, bRank, bStrides);\n                const opResult = op(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2], bVals[bIndex * 2 + 1]);\n                resultRealVals[i] = opResult.real;\n                resultImagVals[i] = opResult.imag;\n            }\n        }\n        return [resultRealVals, resultImagVals, resultShape];\n    };\n}\n//# sourceMappingURL=binary_utils.js.map"],"names":["pool","xValues","xShape","dtype","strides","convInfo","poolType","strideHeight","strideWidth","dilationHeight","dilationWidth","effectiveFilterHeight","effectiveFilterWidth","padTop","padInfo","top","padLeft","left","initialValue","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","output","buffer","outShape","outputVals","values","outputBatchStrides","outputRowStrides","outputColStrides","b","batchSize","outputBatchOffset","inputBatchOffset","d","inChannels","yR","outHeight","xRCorner","xRMin","Math","max","xRMax","min","inHeight","outputRowOffset","yC","outWidth","xCCorner","xCMin","xCMax","inWidth","minMaxValue","avgValue","count","xR","xROffset","xC","pixel","isNaN","maxPoolPositions","flattenPositions","includeBatchInIndex","maxPositions","xBuf","maxValue","maxPosition","wR","wC","get","set","pool3d","strideDepth","dilationDepth","effectiveFilterDepth","padFront","front","outputDepthStrides","batch","channel","yDepth","outDepth","xDepthCorner","xDepthMin","xDepthMax","inDepth","outputDepthOffset","yRow","xRowCorner","xRowMin","xRowMax","yCol","xColCorner","xColMin","xColMax","outputColOffset","xDepth","xDepthOffset","xRow","xRowOffset","xCol","maxPool3dPositions","wDepth","wRow","wCol","createSimpleBinaryKernelImpl","op","aShape","bShape","aVals","bVals","newShape","backend_util","resultRank","length","resultStrides","util","resultSize","result","aRank","bRank","aStrides","bStrides","aBroadcastDims","bBroadcastDims","i","loc","aLoc","slice","forEach","aIndex","bLoc","bIndex","applyActivation","backend","x","activation","preluActivationWeights","leakyreluAlpha","inputs","alpha","attrs","Error","zeros","shape","real","imag","makeTensorInfo","fftBatch","input","inverse","cpuBackend","inputShape","innerDim","inputVals","data","dataId","real2D","complexTensorInfos","imag2D","resultShape","resultReal","resultImag","r","begin","size","fftImpl","res","c","disposeIntermediateTensorInfo","$realInfo","$imagInfo","inputSize","realVals","imagVals","fftRadix2","realInfo","imagInfo","sizeInfo","sizeInfoCopy","divRealInfo","kernelFunc","a","divImagInfo","divRealVals","divImagVals","rawOutput","ret","Float32Array","e","term","fourierTransformByMatmul","half","evenComplex","evenRealVals","evenImagVals","evenShape","evenRealInfo","evenImagInfo","evenTensorInfo","oddComplex","oddRealVals","oddImagVals","oddShape","oddRealInfo","oddImagInfo","oddTensorInfo","$evenComplex","$evenRealVals","$evenImagVals","$evenShape","$evenRealInfo","$evenImagInfo","$evenTensorInfo","$oddComplex","$oddRealVals","$oddImagVals","$oddShape","$oddRealInfo","$oddImagInfo","$oddTensorInfo","eShape","eRealInfo","eImagInfo","complexInfo","exponentInfo","addPart","subPart","addPartReal","subPartReal","addPartImag","subPartImag","$real","axis","$imag","$realVals","$imagVals","unaryKernelFunc","name","xSize","$dtype","newValues","unaryKernelFuncFromImpl","unaryImpl","version","createSimpleUnaryImpl","binaryKernelFunc","simpleImpl","complexImpl","resultData","$aComplex","$aComplexVals","aReal","aImag","aRealVals","aImagVals","$bComplex","$bComplexVals","bReal","bImag","bRealVals","bImagVals","resultRealData","resultImagData","createComplexBinaryKernelImpl","resultRealVals","resultImagVals","aIdx","bIdx","opResult"],"sourceRoot":""}