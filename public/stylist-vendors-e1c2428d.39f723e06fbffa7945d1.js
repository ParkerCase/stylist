"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[9506],{456:function(e,t,n){n.d(t,{H:function(){return r},z:function(){return s}});var a=n(9495),o=n(97870);function r(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:u}=r;(0,o.C)([s],"leakyRelu");const i=a.util.sizeFromShape(s.shape),c=n.data.get(s.dataId).values,d=a.util.getTypedArrayFromDType("float32",i);for(let a=0;a<c.length;a++)d[a]=c[a]<0?u*c[a]:c[a];return n.makeTensorInfo(s.shape,"float32",d)}const s={kernelName:a.LeakyRelu,backendName:"cpu",kernelFunc:r}},998:function(e,t,n){n.d(t,{l:function(){return s}});var a=n(9495),o=n(97870),r=n(6307);const s={kernelName:a.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e,{filterSize:u,strides:i,pad:c,includeBatchInIndex:d}=t,l=n;(0,o.C)(s,"MaxPoolWithArgmax");const p=l.data.get(s.dataId).values,f=a.backend_util.computePool2DInfo(s.shape,u,i,[1,1],c),[m,k]=function(e,t,n,o,s){const u=a.util.computeStrides(t),i=(0,r.dz)(e,t,n,u,s,"max"),c=(0,r.nN)(e,t,n,s,!0,o);return[i.values,c.values]}(p,s.shape,s.dtype,d,f),h=l.write(m,f.outShape,s.dtype),b=l.write(k,f.outShape,s.dtype);return[{dataId:h,shape:f.outShape,dtype:s.dtype},{dataId:b,shape:f.outShape,dtype:"int32"}]}}},1802:function(e,t,n){n.d(t,{Fx:function(){return i},px:function(){return s}});var a=n(9495),o=n(45705),r=n(21694);const s=(0,o.o)((e=>Math.log(e))),u=(0,r.F)(a.Log,s),i={kernelName:a.Log,backendName:"cpu",kernelFunc:u}},3087:function(e,t,n){n.d(t,{Q:function(){return i},cu:function(){return s}});var a=n(9495),o=n(8195),r=n(98880);const s=(0,o.Z)(((e,t)=>e<=t?1:0)),u=(0,r.j)(a.LessEqual,s,null,"bool"),i={kernelName:a.LessEqual,backendName:"cpu",kernelFunc:u}},3759:function(e,t,n){n.d(t,{j:function(){return o}});var a=n(9495);function o(e,t,n,o){const r=a.util.getTypedArrayFromDType(o,a.util.sizeFromShape(n));for(let a=0;a<r.length;++a){const n=a*t;let o=e[n];for(let a=0;a<t;++a){const t=e[n+a];(Number.isNaN(t)||t>o)&&(o=t)}r[a]=o}return r}},4995:function(e,t,n){n.d(t,{u:function(){return s}});var a=n(9495),o=n(97870);const r=a.kernel_impls.nonMaxSuppressionV5Impl;const s={kernelName:a.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:u}=t,{maxOutputSize:i,iouThreshold:c,scoreThreshold:d,softNmsSigma:l}=a;(0,o.C)(s,"NonMaxSuppressionWithScore");const p=n.data.get(s.dataId).values,f=n.data.get(u.dataId).values,m=i,k=c,h=d,b=l,{selectedIndices:g,selectedScores:I}=r(p,f,m,k,h,b);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([I.length],"float32",new Float32Array(I))]}}},6564:function(e,t,n){n.d(t,{$:function(){return u}});var a=n(9495),o=n(97870),r=n(6307),s=n(46936);const u={kernelName:a.MaxPool,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:u}=e,{x:i}=t;(0,o.C)(i,"maxPool");const{filterSize:c,strides:d,pad:l,dimRoundingMode:p}=u;a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(d,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${d} and dilations '1'`));const f=a.backend_util.computePool2DInfo(i.shape,c,d,1,l,p);let m;if(1===f.filterWidth&&1===f.filterHeight&&a.util.arraysEqual(f.inShape,f.outShape))m=(0,s.D)({inputs:{x:i},backend:n});else{const e=n.data.get(i.dataId).values,t=a.util.computeStrides(i.shape),o=(0,r.dz)(e,i.shape,i.dtype,t,f,"max");m=n.makeTensorInfo(f.outShape,i.dtype,o.values)}return m}}},7004:function(e,t,n){n.d(t,{F:function(){return s}});var a=n(9495),o=n(97870);const r=a.kernel_impls.nonMaxSuppressionV4Impl;const s={kernelName:a.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:u}=t,{maxOutputSize:i,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:l}=a;(0,o.C)(s,"NonMaxSuppressionPadded");const p=n.data.get(s.dataId).values,f=n.data.get(u.dataId).values,{selectedIndices:m,validOutputs:k}=r(p,f,i,c,d,l);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([],"int32",new Int32Array([k]))]}}},7761:function(e,t,n){n.d(t,{_:function(){return r}});var a=n(9495),o=n(97870);const r={kernelName:a.OneHot,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:u,depth:i,onValue:c,offValue:d}=r;(0,o.C)(s,"oneHot");const l=a.util.sizeFromShape(s.shape),p=new Float32Array(l*i);p.fill(d);const f=n.data.get(s.dataId).values;for(let a=0;a<l;++a)f[a]>=0&&f[a]<i&&(p[a*i+f[a]]=c);return n.makeTensorInfo([...s.shape,i],u,p)}}},9903:function(e,t,n){n.d(t,{Z:function(){return s},q:function(){return u}});var a=n(9495),o=n(98342),r=n(36085);function s(e){const{inputs:t,backend:n,attrs:s}=e,{axis:u}=s;if(1===t.length)return(0,r.U)({inputs:{input:t[0]},backend:n,attrs:{dim:u}});const i=t[0].shape,c=t[0].dtype;t.forEach((e=>{a.util.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),a.util.assert(c===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const d=[],l=t.map((e=>{const t=(0,r.U)({inputs:{input:e},backend:n,attrs:{dim:u}});return d.push(t),t})),p=(0,o.x)({inputs:l,backend:n,attrs:{axis:u}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const u={kernelName:a.Pack,backendName:"cpu",kernelFunc:s}},14280:function(e,t,n){n.d(t,{V:function(){return r}});var a=n(9495),o=n(97870);const r={kernelName:a.MirrorPad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:u,mode:i}=r;(0,o.C)(s,"mirrorPad");const c=u.map(((e,t)=>e[0]+s.shape[t]+e[1])),d=u.map((e=>e[0])),l=u.map(((e,t)=>e[0]+s.shape[t])),p="reflect"===i?0:1,f=n.data.get(s.dataId).values,m=s.shape.length,k=a.util.computeStrides(s.shape),h=a.util.sizeFromShape(c),b=c.length,g=a.util.computeStrides(c),I=a.util.getTypedArrayFromDType(s.dtype,h);for(let o=0;o<h;o++){let e=a.util.indexToLoc(o,b,g);for(let n=0;n<b;n++)e[n]<d[n]?e[n]=2*d[n]-e[n]-p:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+p);e=e.map(((e,t)=>e-d[t]));const t=a.util.locToIndex(e,m,k);I[o]=f[t]}return{dataId:n.write(I,c,s.dtype),shape:c,dtype:s.dtype}}}},14578:function(e,t,n){n.d(t,{r:function(){return i}});var a=n(9495),o=n(8195),r=n(98880);const s=(0,o.Z)(((e,t)=>e||t)),u=(0,r.j)(a.LogicalOr,s,null,"bool"),i={kernelName:a.LogicalOr,backendName:"cpu",kernelFunc:u}},17944:function(e,t,n){n.d(t,{XR:function(){return i}});var a=n(9495),o=n(8195),r=n(98880);const s=(0,o.Z)(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),u=(0,r.j)(a.Mod,s),i={kernelName:a.Mod,backendName:"cpu",kernelFunc:u}},18439:function(e,t,n){n.d(t,{S:function(){return s}});var a=n(9495),o=n(97870),r=n(6307);const s={kernelName:a.MaxPool3DGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:u,input:i}=t,{filterSize:c,strides:d,pad:l,dimRoundingMode:p}=s;(0,o.C)([u,i],"maxPool3DGrad");const f=a.backend_util.computePool3DInfo(i.shape,c,d,1,l,p),m=n.bufferSync(i),k=(0,r.qW)(m,f),h=f.strideDepth,b=f.strideHeight,g=f.strideWidth,I=f.dilationDepth,N=f.dilationHeight,x=f.dilationWidth,y=f.effectiveFilterDepth,v=f.effectiveFilterHeight,S=f.effectiveFilterWidth,F=y-1-f.padInfo.front,T=S-1-f.padInfo.left,M=v-1-f.padInfo.top,A=(0,a.buffer)(i.shape,"float32"),D=n.bufferSync(u);for(let a=0;a<f.batchSize;++a)for(let e=0;e<f.inChannels;++e)for(let t=0;t<f.inDepth;++t)for(let n=0;n<f.inHeight;++n)for(let o=0;o<f.inWidth;++o){const r=t-F,s=n-M,u=o-T;let i=0;for(let t=0;t<y;t+=I){const n=(r+t)/h;if(!(n<0||n>=f.outDepth||Math.floor(n)!==n))for(let o=0;o<v;o+=N){const r=(s+o)/b;if(!(r<0||r>=f.outHeight||Math.floor(r)!==r))for(let s=0;s<S;s+=x){const c=(u+s)/g;if(c<0||c>=f.outWidth||Math.floor(c)!==c)continue;const d=y*v*S-1-k.get(a,n,r,c,e)===t*v*S+o*S+s?1:0;if(0===d)continue;i+=D.get(a,n,r,c,e)*d}}}A.set(i,a,t,n,o,e)}return n.makeTensorInfo(A.shape,A.dtype,A.values)}}},19697:function(e,t,n){n.d(t,{o:function(){return r}});var a=n(9495),o=n(64190);const r={kernelName:a.LinSpace,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,u=(0,o.G)(a,r,s);return t.makeTensorInfo([u.length],"float32",u)}}},37962:function(e,t,n){n.d(t,{Dk:function(){return s},hd:function(){return u}});var a=n(9495),o=n(97870),r=n(65646);function s(e,t,n){const o=a.util.createScalarValue(-1,n);return(0,r.BF)([],t,o,e,n)}const u={kernelName:a.Neg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;(0,o.C)(a,"neg");const r=n.data.get(a.dataId).values,[u,i]=s(r,a.shape,a.dtype);return n.makeTensorInfo(i,a.dtype,u)}}},45207:function(e,t,n){n.d(t,{WR:function(){return s},YW:function(){return i}});var a=n(9495),o=n(8195),r=n(98880);const s=(0,o.Z)(((e,t)=>e<t?1:0)),u=(0,r.j)(a.Less,s,null,"bool"),i={kernelName:a.Less,backendName:"cpu",kernelFunc:u}},48580:function(e,t,n){n.d(t,{Nu:function(){return i},hE:function(){return s}});var a=n(9495),o=n(8195),r=n(98880);const s=(0,o.Z)(((e,t)=>Math.min(e,t))),u=(0,r.j)(a.Minimum,s),i={kernelName:a.Minimum,backendName:"cpu",kernelFunc:u}},57384:function(e,t,n){n.d(t,{P:function(){return s}});var a=n(9495),o=n(97870),r=n(6307);const s={kernelName:a.MaxPoolGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:u,input:i,output:c}=t,d=i;(0,o.C)([i,c],"maxPoolGrad");const{filterSize:l,strides:p,pad:f,dimRoundingMode:m}=s,k=a.backend_util.computePool2DInfo(d.shape,l,p,1,f,m),h=n.data.get(d.dataId).values,b=(0,a.buffer)(k.outShape,d.dtype,(0,r.nN)(h,d.shape,d.dtype,k).values),g=k.strideHeight,I=k.strideWidth,N=k.dilationHeight,x=k.dilationWidth,y=k.effectiveFilterHeight,v=k.effectiveFilterWidth,S=v-1-k.padInfo.left,F=y-1-k.padInfo.top,T=(0,a.buffer)(d.shape,"float32"),M=n.data.get(u.dataId).values,A=(0,a.buffer)(u.shape,"float32",M);for(let a=0;a<k.batchSize;++a)for(let e=0;e<k.inChannels;++e)for(let t=0;t<k.inHeight;++t)for(let n=0;n<k.inWidth;++n){const o=t-F,r=n-S;let s=0;for(let t=0;t<y;t+=N){const n=(o+t)/g;if(!(n<0||n>=k.outHeight||Math.floor(n)!==n))for(let o=0;o<v;o+=x){const u=(r+o)/I;if(u<0||u>=k.outWidth||Math.floor(u)!==u)continue;const i=y*v-1-b.get(a,n,u,e)===t*v+o?1:0;if(0===i)continue;s+=A.get(a,n,u,e)*i}}T.set(s,a,t,n,e)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}}},63305:function(e,t,n){n.d(t,{m:function(){return s}});var a=n(9495),o=n(97870);const r=a.kernel_impls.nonMaxSuppressionV3Impl;const s={kernelName:a.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:s,scores:u}=t,{maxOutputSize:i,iouThreshold:c,scoreThreshold:d}=a;(0,o.C)(s,"NonMaxSuppression");const l=n.data.get(s.dataId).values,p=n.data.get(u.dataId).values,{selectedIndices:f}=r(l,p,i,c,d);return n.makeTensorInfo([f.length],"int32",new Int32Array(f))}}},64190:function(e,t,n){n.d(t,{G:function(){return o}});var a=n(9495);function o(e,t,n){const o=(t-e)/(n-1),r=a.util.makeZerosTypedArray(n,"float32");r[0]=e;for(let a=1;a<r.length;a++)r[a]=r[a-1]+o;return r}},65646:function(e,t,n){n.d(t,{BF:function(){return s},lw:function(){return i},tJ:function(){return c}});var a=n(9495),o=n(8195),r=n(98880);const s=(0,o.Z)(((e,t)=>e*t)),u=(0,r.B)(((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n}))),i=(0,r.j)(a.Multiply,s,u),c={kernelName:a.Multiply,backendName:"cpu",kernelFunc:i}},66114:function(e,t,n){n.d(t,{He:function(){return s},l9:function(){return i}});var a=n(9495),o=n(8195),r=n(98880);const s=(0,o.Z)(((e,t)=>Math.max(e,t))),u=(0,r.j)(a.Maximum,s),i={kernelName:a.Maximum,backendName:"cpu",kernelFunc:u}},70213:function(e,t,n){n.d(t,{a:function(){return u}});var a=n(9495),o=n(7391),r=n(97870),s=n(62282);const u={kernelName:a.Multinomial,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:u}=e,{logits:i}=t,{numSamples:c,seed:d,normalized:l}=u;(0,r.C)(i,"multinomial");const p=l?i:(0,s.V)({inputs:{logits:i},backend:n,attrs:{dim:-1}}),f=p.shape[0],m=p.shape[1],k=n.data.get(p.dataId).values,h=[f,c],b=a.util.makeZerosTypedArray(a.util.sizeFromShape(h),"int32");for(let a=0;a<f;++a){const e=a*m,t=new Float32Array(m-1);t[0]=k[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+k[e+a];const n=o.alea(d.toString()),r=a*c;for(let a=0;a<c;++a){const e=n();b[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){b[r+a]=n;break}}}return l||n.disposeIntermediateTensorInfo(p),n.makeTensorInfo(h,"int32",b)}}},74575:function(e,t,n){n.d(t,{A:function(){return s}});var a=n(9495),o=n(97870),r=n(6307);const s={kernelName:a.MaxPool3D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:u}=t,{filterSize:i,strides:c,pad:d,dimRoundingMode:l,dataFormat:p}=s;(0,o.C)(u,"maxPool3d");const f=a.backend_util.computePool3DInfo(u.shape,i,c,1,d,l,p),m=n.data.get(u.dataId).values,k=(0,r.W_)(m,u.shape,u.dtype,a.util.computeStrides(u.shape),f,"max");return n.makeTensorInfo(k.shape,"float32",k.values)}}},82486:function(e,t,n){n.d(t,{Vr:function(){return i}});var a=n(9495),o=n(8195),r=n(98880);const s=(0,o.Z)(((e,t)=>e&&t)),u=(0,r.j)(a.LogicalAnd,s,null,"bool"),i={kernelName:a.LogicalAnd,backendName:"cpu",kernelFunc:u}},94174:function(e,t,n){n.d(t,{f:function(){return r}});var a=n(9495);const o=(0,n(21694).v)(a.LogicalNot,(e=>e?0:1),"bool"),r={kernelName:a.LogicalNot,backendName:"cpu",kernelFunc:o}},94237:function(e,t,n){n.d(t,{e:function(){return r}});var a=n(9495),o=n(97870);const r={kernelName:a.PadV2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:u,constantValue:i}=r;(0,o.C)(s,"pad");const c=u.map(((e,t)=>e[0]+s.shape[t]+e[1])),d=u.map((e=>e[0])),l=n.data.get(s.dataId).values,p=a.util.sizeFromShape(s.shape),f=s.shape.length,m=a.util.computeStrides(s.shape),k=a.util.sizeFromShape(c),h=c.length,b=a.util.computeStrides(c),g=a.util.getTypedArrayFromDType(s.dtype,k);0!==i&&g.fill(i);for(let o=0;o<p;o++){const e=a.util.indexToLoc(o,f,m).map(((e,t)=>e+d[t]));g[a.util.locToIndex(e,h,b)]=l[o]}return{dataId:n.write(g,c,s.dtype),shape:c,dtype:s.dtype}}}},95439:function(e,t,n){n.d(t,{h:function(){return c}});var a=n(9495),o=n(89436),r=n(80015),s=n(18944),u=n(85806),i=n(64064);const c={kernelName:a.OnesLike,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:c}=n;if("string"===c.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===c.dtype){const t=(0,u.x)({inputs:{input:c},backend:a}),n=e({inputs:{x:t},backend:a}),r=(0,s.n)({inputs:{input:c},backend:a}),d=(0,i.P)({inputs:{x:r},backend:a}),l=(0,o.f)({inputs:{real:n,imag:d},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(d),l}return(0,r.G)({backend:a,attrs:{shape:c.shape,value:1,dtype:c.dtype}})}}},96515:function(e,t,n){n.d(t,{M:function(){return u}});var a=n(9495),o=n(13713),r=n(61879),s=n(25231);const u={kernelName:a.Mean,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:u}=e,{x:i}=t,{axis:c,keepDims:d}=u,l=a.util.parseAxisParam(c,i.shape),p=a.backend_util.computeOutAndReduceShapes(i.shape,l)[1],f=a.util.sizeFromShape(p),m=[],k=n.makeTensorInfo([],"float32",new Float32Array([f]));m.push(k);const h=(0,o.wg)({inputs:{x:i},backend:n,attrs:{dtype:"float32"}});m.push(h);const b=(0,r.y4)({inputs:{a:h,b:k},backend:n});m.push(b);const g=(0,s.c)({inputs:{x:b},backend:n,attrs:{axis:c,keepDims:d}});return m.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}}},97113:function(e,t,n){n.d(t,{AL:function(){return i},cl:function(){return s}});var a=n(9495),o=n(8195),r=n(98880);const s=(0,o.Z)(((e,t)=>e!==t?1:0)),u=(0,r.j)(a.NotEqual,s,null,"bool"),i={kernelName:a.NotEqual,backendName:"cpu",kernelFunc:u}},98287:function(e,t,n){n.d(t,{W:function(){return r}});var a=n(9495);const o=(0,n(21694).v)(a.Log1p,(e=>Math.log1p(e))),r={kernelName:a.Log1p,backendName:"cpu",kernelFunc:o}},98876:function(e,t,n){n.d(t,{j:function(){return u}});var a=n(9495),o=n(97870),r=n(14590),s=n(85655);const u={kernelName:a.Min,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:u}=e,{x:i}=t,{axis:c,keepDims:d}=u;(0,o.C)(i,"min");const l=a.util.parseAxisParam(c,i.shape);let p=l;const f=a.backend_util.getAxesPermutation(p,i.shape.length);let m=i;null!=f&&(m=(0,s.m)({inputs:{x:i},backend:n,attrs:{perm:f}}),p=a.backend_util.getInnerMostAxes(p.length,i.shape.length)),a.backend_util.assertAxesAreInnerMostDims("min",p,m.shape.length);const[k,h]=a.backend_util.computeOutAndReduceShapes(m.shape,p),b=a.util.sizeFromShape(h),g=a.util.makeZerosTypedArray(a.util.sizeFromShape(k),m.dtype),I=n.data.get(m.dataId).values;for(let a=0;a<g.length;++a){const e=a*b;let t=I[e];for(let n=0;n<b;++n){const a=I[e+n];(Number.isNaN(a)||a<t)&&(t=a)}g[a]=t}null!=f&&n.disposeIntermediateTensorInfo(m);const N=n.makeTensorInfo(k,m.dtype,g);if(d){const e=a.backend_util.expandShapeToKeepDim(k,l),t=(0,r.t)({inputs:{x:N},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(N),t}return N}}},99730:function(e,t,n){n.d(t,{T:function(){return u},l:function(){return i}});var a=n(9495),o=n(97870),r=n(3759),s=n(13396);function u(e){const{inputs:t,backend:n,attrs:u}=e,{x:i}=t,{reductionIndices:c,keepDims:d}=u,l=n;let p=i.shape;const f=p.length,m=a.util.parseAxisParam(c,p);let k=m;const h=a.backend_util.getAxesPermutation(k,f);let b=l.data.get(i.dataId).values;if(null!=h){const e=new Array(f);for(let t=0;t<e.length;t++)e[t]=p[h[t]];b=(0,s._)(b,p,i.dtype,h,e),k=a.backend_util.getInnerMostAxes(k.length,f),p=e}(0,o.C)(i,"max"),a.backend_util.assertAxesAreInnerMostDims("max",k,f);const[g,I]=a.backend_util.computeOutAndReduceShapes(p,k),N=a.util.sizeFromShape(I),x=(0,r.j)(b,N,g,i.dtype),y=l.write(x,g,i.dtype);let v=g;if(d){v=a.backend_util.expandShapeToKeepDim(g,m)}return{dataId:y,shape:v,dtype:i.dtype}}const i={kernelName:a.Max,backendName:"cpu",kernelFunc:u}}}]);
//# sourceMappingURL=stylist-vendors-e1c2428d.39f723e06fbffa7945d1.js.map