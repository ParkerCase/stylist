"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[5208],{20771:function(n,e,t){t.d(e,{$:function(){return o}});var r=t(27575);class o{constructor(n,e){this.variableNames=["A"];const t=new Array(n.length);for(let r=0;r<t.length;r++)t[r]=n[r]*e[r];this.outputShape=t,this.rank=t.length;const o=(0,r.bf)(this.rank),i=function(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let o=0;o<n.length;o++)r.push(`imod(${t[o]}, ${n[o]})`);return r.join()}(n);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}},23601:function(n,e,t){t.d(e,{R:function(){return r}});class r{constructor(n,e,t,r,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const u="nearest"===t?1:2;let a;switch(r){case"constant":default:a=1;break;case"reflect":a=2;break;case"wrap":a=3;break;case"nearest":a=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${a} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${o});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${o});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${n}));\n\n                if (${u} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}},46969:function(n,e,t){t.d(e,{z:function(){return u}});var r=t(22792),o=t(75694),i=t(27575);class u{constructor(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n,this.enableShapeUniforms=(0,r.ik)(this.outputShape.length);const e=n.length,t=(0,o.Jp)("rc",e),u=(0,i.bf)(e),a=(0,o.kp)(e,t),s=t.slice(-2),l=e<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${u} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${l}));\n      }\n    `}}},55315:function(n,e,t){t.d(e,{Y:function(){return i}});var r=t(75694),o=t(27575);class i{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const t=new Array(n.length);for(let r=0;r<t.length;r++)t[r]=n[e[r]];if(this.outputShape=t,this.rank=t.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=(0,o.bf)(this.rank),u=(0,r.Fd)("rc",this.rank),a=new Array(this.rank);for(let r=0;r<e.length;r++)a[e[r]]=u[r];const s=`vec2(${a.slice(-2).join()})`,l=`++${u[this.rank-1]} < ${t[this.rank-1]}`,c=`getChannel(getA(${a.join()}), ${s})`;this.userCode=`\n    void main() {\n      ${i} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${l}) {\n        result[1] = ${c};\n      }\n      --${u[this.rank-1]};\n      if(++${u[this.rank-2]} < ${t[this.rank-2]}) {\n        result[2] = ${c};\n        if(${l}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}},68173:function(n,e,t){t.d(e,{Hq:function(){return h},Nb:function(){return c},UC:function(){return f},X0:function(){return s},X8:function(){return l},_Q:function(){return u},dR:function(){return i},hE:function(){return o},pd:function(){return a}});var r=t(22792);class o{constructor(n,e){this.variableNames=["A"],this.outputShape=n,this.enableShapeUniforms=(0,r.ik)(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const i="if (isnan(x)) return x;",u="return x;",a="return abs(x);";const s="return (x >= 0.0) ? x : (exp(x) - 1.0);",l=i+"\n  return (x < 0.0) ? 0.0 : x;\n",c=i+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",f="return x;",h="return 1.0 / (1.0 + exp(-1.0 * x));"},74890:function(n,e,t){t.d(e,{Hq:function(){return s},Nb:function(){return a},X0:function(){return i},X8:function(){return u},_Q:function(){return o},rf:function(){return l}});var r=t(22792);const o="return x;",i="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",u="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",a="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",s="return 1.0 / (1.0 + exp(-1.0 * x));";class l{constructor(n,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=(0,r.ik)(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}},76540:function(n,e,t){t.d(e,{K:function(){return r},T:function(){return o}});class r{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=n,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class o{constructor(n){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=n,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}},77104:function(n,e,t){t.d(e,{r:function(){return r}});const r="4.22.0"},80393:function(n,e,t){t.d(e,{bP:function(){return o}});var r=t(9495);function o(){(0,r.env)().set("WEBGL_FORCE_F16_TEXTURES",!0)}},81322:function(n,e,t){t.d(e,{u:function(){return o}});var r=t(27575);class o{constructor(n,e){this.variableNames=["A"];const t=new Array(n.length);for(let r=0;r<t.length;r++)t[r]=n[e[r]];this.outputShape=t,this.rank=t.length;const o=(0,r.bf)(this.rank),i=function(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let o=0;o<n.length;o++)r[n[o]]=t[o];return r.join()}(e);this.userCode=`\n    void main() {\n      ${o} resRC = getOutputCoords();\n      setOutput(getA(${i}));\n    }\n    `}}},88380:function(n,e,t){t.d(e,{$e:function(){return T},CE:function(){return j},FP:function(){return y},HM:function(){return c},HW:function(){return b},I2:function(){return V},N0:function(){return M},N6:function(){return Y},P0:function(){return X},Ph:function(){return w},Ql:function(){return G},R7:function(){return m},Rh:function(){return A},SO:function(){return N},Se:function(){return P},Ut:function(){return q},VJ:function(){return W},Yn:function(){return C},Zj:function(){return z},bz:function(){return g},cr:function(){return E},dm:function(){return l},fA:function(){return k},jL:function(){return D},oN:function(){return R},ph:function(){return F},rC:function(){return p},rw:function(){return _},s6:function(){return I},sA:function(){return O},sZ:function(){return x},ul:function(){return u},yG:function(){return h},y_:function(){return U},yr:function(){return f}});var r=t(9495),o=t(597),i=t(28560);function u(n,e){const t=e();return(0,r.env)().getBool("DEBUG")&&function(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+function(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}(n,e))}(n),t}const a=5.96e-8,s=65504;function l(n){return!!((0,r.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||a<Math.abs(n)&&Math.abs(n)<s)}function c(n,e){return v(n,(()=>n.getExtension(e)),'Extension "'+e+'" not supported on this browser.')}function f(n,e){const t=v(n,(()=>n.createShader(n.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(u(n,(()=>n.shaderSource(t,e))),u(n,(()=>n.compileShader(t))),!1===n.getShaderParameter(t,n.COMPILE_STATUS))throw new Error("Failed to compile vertex shader.");return t}function h(n,e){const t=v(n,(()=>n.createShader(n.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(u(n,(()=>n.shaderSource(t,e))),u(n,(()=>n.compileShader(t))),(0,r.env)().get("ENGINE_COMPILE_ONLY"))return t;if(!1===n.getShaderParameter(t,n.COMPILE_STATUS))throw E(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const d=/ERROR: [0-9]+:([0-9]+):/g;function E(n,e){const t=d.exec(e);if(null==t)return;const o=+t[1],i=n.split("\n"),u=i.length.toString().length+2,a=i.map(((n,e)=>r.util.rightPad((e+1).toString(),u)+n));let s=0;for(let r=0;r<a.length;r++)s=Math.max(a[r].length,s);a.slice(0,o-1),a.slice(o-1,o),a.slice(o)}function p(n){return v(n,(()=>n.createProgram()),"Unable to create WebGLProgram.")}function m(n,e){if(u(n,(()=>n.linkProgram(e))),!(0,r.env)().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(e,n.LINK_STATUS))throw new Error("Failed to link vertex and fragment shaders.")}function g(n,e){if(u(n,(()=>n.validateProgram(e))),!1===n.getProgramParameter(e,n.VALIDATE_STATUS))throw new Error("Shader program validation failed.")}function b(n,e){const t=v(n,(()=>n.createBuffer()),"Unable to create WebGLBuffer");return u(n,(()=>n.bindBuffer(n.ARRAY_BUFFER,t))),u(n,(()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW))),t}function T(n,e){const t=v(n,(()=>n.createBuffer()),"Unable to create WebGLBuffer");return u(n,(()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t))),u(n,(()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW))),t}function x(n){return v(n,(()=>n.createTexture()),"Unable to create WebGLTexture.")}function F(n,e){const t=(0,r.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){throw new Error("Requested texture size "+`[${n}x${e}]`+" is invalid.")}if(n>t||e>t){throw new Error("Requested texture size "+`[${n}x${e}]`+" greater than WebGL maximum on this browser / GPU "+`[${t}x${t}]`+".")}}function R(n){return v(n,(()=>n.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function _(n,e,t,r,o,i,a){const s=n.getAttribLocation(e,t);return-1!==s&&(u(n,(()=>n.bindBuffer(n.ARRAY_BUFFER,r))),u(n,(()=>n.vertexAttribPointer(s,o,n.FLOAT,!1,i,a))),u(n,(()=>n.enableVertexAttribArray(s))),!0)}function A(n,e,t){return v(n,(()=>n.getUniformLocation(e,t)),'uniform "'+t+'" not present in program.')}function C(n,e,t){return n.getUniformLocation(e,t)}function U(n,e,t,r){u(n,(()=>function(n,e,t){S(n,t),u(n,(()=>n.activeTexture(n.TEXTURE0+t))),u(n,(()=>n.bindTexture(n.TEXTURE_2D,e)))}(n,e,r))),u(n,(()=>n.uniform1i(t,r)))}function N(n,e,t){u(n,(()=>n.bindFramebuffer(n.FRAMEBUFFER,t))),u(n,(()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0)))}function O(n,e){u(n,(()=>n.bindFramebuffer(n.FRAMEBUFFER,e))),u(n,(()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0)))}function I(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}(n,e))}function v(n,e,t){const r=u(n,(()=>e()));if(null==r)throw new Error(t);return r}function S(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+n.TEXTURE0;if(r<n.TEXTURE0||r>t){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${t}]`}.`)}}function M(n,e=2){return r.util.sizeFromShape(n.slice(0,n.length-e))}function w(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function y(n){let e=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(e=[M(n),...w(n)]),e}function k(n,e=!1){let t=(0,r.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),o=(0,r.env)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(o===1/0&&(0,r.env)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(o=t/2),e&&(t*=2,o*=2,1===(n=n.map(((e,t)=>t>=n.length-2?r.util.nearestLargerEven(n[t]):n[t]))).length&&(n=[2,n[0]])),2!==n.length){const e=r.util.squeezeShape(n);n=e.newShape}let i=r.util.sizeFromShape(n),u=null;n.length<=1&&i<=t?u=[1,i]:2===n.length&&n[0]<=t&&n[1]<=t?u=n:3===n.length&&n[0]*n[1]<=t&&n[2]<=t?u=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=t&&n[1]*n[2]<=t?u=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=t&&n[3]<=t?u=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(u=[n[0],n[1]*n[2]*n[3]]);const a=null!=u&&Math.max(...u)>o&&Math.min(...u)<=(e?2:1)&&Math.min(...u)>0;if(null==u||a)if(e){const e=M(n);let t=2,o=2;n.length&&([t,o]=w(n)),i=e*(t/2)*(o/2),u=r.util.sizeToSquarishShape(i).map((n=>2*n))}else u=r.util.sizeToSquarishShape(i);return u}function L(n){return n%2===0}function X(n,e){if(n=n.slice(-2),e=e.slice(-2),r.util.arraysEqual(n,e))return!0;if(!n.length||!e.length)return!0;if(0===n[0]||0===n[1]||0===e[0]||0===e[1])return!0;if(n.length!==e.length){const t=n[n.length-1],r=e[e.length-1];if(t===r)return!0;if(L(t)&&L(r)&&(1===n[0]||1===e[0]))return!0}return n[1]===e[1]&&L(n[0])&&L(e[0])}let B,$;function P(n){if(null==B){const e=(0,o.bU)(n);B=e.getParameter(e.MAX_TEXTURE_SIZE)}return B}function D(n){if(null==$){const e=(0,o.bU)(n);$=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,$)}function W(n){if(0===n)return 0;let e;const t=(0,o.bU)(n);return e=G(t,"EXT_disjoint_timer_query_webgl2")&&2===n?2:G(t,"EXT_disjoint_timer_query")?1:0,e}function G(n,e){return null!=n.getExtension(e)}function z(n){try{if(null!=(0,o.bU)(n))return!0}catch(e){return!1}return!1}function V(n){if(0===n)return!1;const e=(0,o.bU)(n);if(1===n){if(!G(e,"OES_texture_float"))return!1}else if(!G(e,"EXT_color_buffer_float"))return!1;return H(e)}function Y(n){if(0===n)return!1;const e=(0,o.bU)(n);if(1!==n){if(G(e,"EXT_color_buffer_float"))return H(e);const n="EXT_color_buffer_half_float";if(G(e,n)){const t=e.getExtension(n);return function(n,e){const t=(0,i.EZ)(n,e),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);const o=1,u=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,o,u,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const s=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(a),s}(e,t)}return!1}if(!G(e,"OES_texture_float"))return!1;if(!G(e,"WEBGL_color_buffer_float"))return!1;return H(e)}function H(n){const e=(0,i.EZ)(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,r),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(r),o}function q(n){if(2!==n)return!1;return null!=(0,o.bU)(n).fenceSync}function j(n,e){Array.isArray(n)||(n=[n]),n.forEach((n=>{null!=n&&r.util.assert("complex64"!==n.dtype,(()=>`${e} does not support complex64 tensors in the WebGL backend.`))}))}}}]);
//# sourceMappingURL=stylist-vendors-0005df24.86344ea8bff03c381a9f.js.map