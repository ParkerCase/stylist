"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[4251],{27575:function(e,n,t){t.d(n,{YE:function(){return S},bf:function(){return v},yr:function(){return a}});var r=t(9495),i=t(18765),o=t(92394);const{getBroadcastDims:c}=r.backend_util;function a(e,n,t){const a=[];if(e.forEach((e=>{const n=r.util.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push(`uniform float ${e.name}${n>1?`[${n}]`:""};`):(a.push(`uniform sampler2D ${e.name};`),a.push(`uniform int offset${e.name};`)),t.enableShapeUniforms){const{uniformShape:n}=S(t.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(n.length){case 1:a.push(`uniform int ${e.name}Shape;`);break;case 2:a.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:a.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:a.push(`uniform ivec4 ${e.name}Shape;`)}a.push(`uniform ivec2 ${e.name}TexShape;`)}})),t.enableShapeUniforms){switch(n.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach((e=>{a.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const $=a.join("\n"),f=e.map((e=>function(e,n,t=!1,i){let o="";o+=t?l(e,i):u(e,i);const a=e.shapeInfo.logicalShape,p=n.logicalShape;a.length<=p.length&&(o+=t?function(e,n){const t=e.name,i=t.charAt(0).toUpperCase()+t.slice(1),o="get"+i+"AtOutCoords",a=e.shapeInfo.logicalShape.length,u=n.logicalShape.length,l=c(e.shapeInfo.logicalShape,n.logicalShape),p=v(u),s=u-a;let x;const h=["x","y","z","w","u","v"];x=0===a?"":u<2&&l.length>=1?"coords = 0;":l.map((e=>`coords.${h[e+s]} = 0;`)).join("\n");let d="";d=u<2&&a>0?"coords":e.shapeInfo.logicalShape.map(((e,n)=>`coords.${h[n+s]}`)).join(", ");let $="return outputValue;";const f=1===r.util.sizeFromShape(e.shapeInfo.logicalShape),S=r.util.sizeFromShape(n.logicalShape),C=1===S;if(1!==a||f||C){if(f&&!C)$=1===u?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){const e=a-2,n=a-1;l.indexOf(e)>-1&&l.indexOf(n)>-1?$="return vec4(outputValue.x);":l.indexOf(e)>-1?$="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(n)>-1&&($="return vec4(outputValue.xx, outputValue.zz);")}}else $="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${o}() {\n      ${p} coords = getOutputCoords();\n      ${x}\n      vec4 outputValue = get${i}(${d});\n      ${$}\n    }\n  `}(e,n):function(e,n){const t=e.name,i=t.charAt(0).toUpperCase()+t.slice(1),o="get"+i+"AtOutCoords",a=n.texShape,u=e.shapeInfo.texShape,l=e.shapeInfo.logicalShape.length,p=n.logicalShape.length;if(!e.shapeInfo.isUniform&&l===p&&null==e.shapeInfo.flatOffset&&r.util.arraysEqual(u,a))return`\n      float ${o}() {\n        return sampleTexture(${t}, resultUV);\n      }\n    `;const s=v(p),x=c(e.shapeInfo.logicalShape,n.logicalShape),h=p-l;let d;const $=["x","y","z","w","u","v"];d=0===l?"":p<2&&x.length>=1?"coords = 0;":x.map((e=>`coords.${$[e+h]} = 0;`)).join("\n");let f="";f=p<2&&l>0?"coords":e.shapeInfo.logicalShape.map(((e,n)=>`coords.${$[n+h]}`)).join(", ");return`\n    float ${o}() {\n      ${s} coords = getOutputCoords();\n      ${d}\n      return get${i}(${f});\n    }\n  `}(e,n));return o}(e,n,t.packedInputs,t.enableShapeUniforms))).join("\n"),C=n.texShape,T=(0,i.B)(),m=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(T);let g,R,w=function(e){const n=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${p}\n    ${s}\n    ${x}\n  `;return n}(T);n.isPacked?(g=function(e,n,t){switch(e.length){case 0:return d();case 1:return function(e,n,t){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(1===r[0])return t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(t)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,n,t);case 2:return function(e,n,t){const i=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(r.util.arraysEqual(e,n))return t?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${i[0]}, ${i[1]}));\n      }\n    `;const o=Math.ceil(e[1]/2);if(t)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n\n      int index = resTexRC.x * ${i[1]} + resTexRC.y;\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,n,t);case 3:return function(e,n,t){if(t)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],i=Math.ceil(e[2]/2),o=i*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,n,t);default:return function(e,n,t){if(t)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],i=Math.ceil(e[e.length-1]/2),o=i*Math.ceil(e[e.length-2]/2);let c=o,a="",u="b, r, c";for(let l=2;l<e.length-1;l++)c*=e[e.length-l-1],a=`\n      int b${l} = index / ${c};\n      index -= b${l} * ${c};\n    `+a,u=`b${l}, `+u;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `}(e,n,t)}}(n.logicalShape,C,t.enableShapeUniforms),R=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(T)):(g=function(e,n,t){switch(e.length){case 0:return d();case 1:return function(e,n,t){if(1===n[0])return t?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `;if(1===n[1])return t?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `;if(t)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}(0,n,t);case 2:return function(e,n,t){if(r.util.arraysEqual(e,n))return t?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;if(1===e[1])return t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return t?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${n[0]}, ${n[1]}));\n        int index = resTexRC.x * ${n[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(t)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,n,t);case 3:return function(e,n,t){if(t){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${o.WA(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=o.UG(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,n,t);case 4:return function(e,n,t){if(t){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${o.WA(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=o.UG(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,n,t);case 5:return function(e,n){const t=o.UG(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,n);case 6:return function(e,n){const t=o.UG(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${t}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,n);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(n.logicalShape,C,t.enableShapeUniforms),R=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(T)),t.packedInputs&&(w+=h);return[w,m,R,$,g,f,t.userCode].join("\n")}function u(e,n=!1){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[i,o]=e.shapeInfo.texShape;if(1===i&&1===o)return`\n      float ${r}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const c=$(t);if(n)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${c});\n      return sampleTexture(${t}, uv);\n    }\n  `;const[a,u]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${a}, ${u}, ${c});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e,n);case 1:return function(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${f(e)}\n      }\n    `;const i=e.shapeInfo.texShape,o=i[0],c=i[1];if(1===c&&1===o)return`\n      float ${r}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const a=$(t);if(1===c)return n?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(1===o)return n?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${c}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(n)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${c}, index + ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e,n);case 2:return function(e,n){const t=e.shapeInfo.logicalShape,i=e.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1),c=e.shapeInfo.texShape;if(null!=c&&r.util.arraysEqual(t,c)){if(n)return`\n      float ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `;const e=c[0];return`\n    float ${o}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${c[1]}.0, ${e}.0);\n      return sampleTexture(${i}, uv);\n    }\n  `}const{newShape:a,keptDims:l}=r.util.squeezeShape(t),p=a;if(p.length<t.length){const t=["row","col"];return`\n      ${u(C(e,p),n)}\n      float ${o}(int row, int col) {\n        return ${o}(${T(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${f(e)}\n      }\n    `;const s=c[0],x=c[1],h=$(i);if(1===x)return n?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${i}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${i}TexShape[0]));\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${s}.0);\n      return sampleTexture(${i}, uv);\n    }\n  `;if(1===s)return n?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${i}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${i}TexShape[1]), 0.5);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${x}.0, 0.5);\n      return sampleTexture(${i}, uv);\n    }\n  `;if(n)return`\n      float ${o}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);\n        return sampleTexture(${i}, uv);\n      }\n    `;return`\n  float ${o}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${s}, ${x}, index);\n    return sampleTexture(${i}, uv);\n  }\n`}(e,n);case 3:return function(e,n){const t=e.shapeInfo.logicalShape,i=e.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1),c=t[1]*t[2],a=t[2],{newShape:l,keptDims:p}=r.util.squeezeShape(t),s=l;if(s.length<t.length){const t=["row","col","depth"];return`\n        ${u(C(e,s),n)}\n        float ${o}(int row, int col, int depth) {\n          return ${o}(${T(t,p)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${c}, ${a}, 1)));\n        ${f(e)}\n      }\n    `;const x=e.shapeInfo.texShape,h=x[0],d=x[1],v=e.shapeInfo.flatOffset;if(d===c&&null==v)return n?`\n      float ${o}(int row, int col, int depth) {\n        int stride1 = ${i}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n        float ${o}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${i}, uv);\n        }\n      `;if(d===a&&null==v)return n?`\n      float ${o}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${i}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n    float ${o}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${i}, uv);\n    }\n  `;const S=$(i);if(n)return`\n    float ${o}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${i}Shape[1] * ${i}Shape[2];\n      int stride1 = ${i}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${S};\n      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);\n      return sampleTexture(${i}, uv);\n    }\n    `;return`\n      float ${o}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${c} + col * ${a} + depth + ${S};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${i}, uv);\n      }\n  `}(e,n);case 4:return function(e,n){const t=e.shapeInfo.logicalShape,i=e.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1),c=t[3],a=t[2]*c,l=t[1]*a,{newShape:p,keptDims:s}=r.util.squeezeShape(t);if(p.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${u(C(e,p),n)}\n      float ${o}(int row, int col, int depth, int depth2) {\n        return ${o}(${T(t,s)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${l}, ${a}, ${c}, 1)));\n        ${f(e)}\n      }\n    `;const x=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],v=h[1],S=`int stride2 = ${i}Shape[3];`,m=`int stride1 = ${i}Shape[2] * stride2;`,g=`int stride0 = ${i}Shape[1] * stride1;`;if(v===l&&null==x)return n?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        ${S}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${c}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${v}.0, ${d}.0);\n        return sampleTexture(${i}, uv);\n      }\n    `;if(v===c&&null==x)return n?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${i}Shape[1] * ${i}Shape[2], ${i}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${v}.0, ${d}.0);\n        return sampleTexture(${i}, uv);\n      }\n    `;const R=$(i);if(n)return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${S}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index + ${R});\n      return sampleTexture(${i}, uv);\n    }\n  `;return`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${a} +\n          depth * ${c} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${v}, index + ${R});\n      return sampleTexture(${i}, uv);\n    }\n  `}(e,n);case 5:return function(e){const n=e.shapeInfo.logicalShape,t=e.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1),o=n[4],c=n[3]*o,a=n[2]*c,l=n[1]*a,{newShape:p,keptDims:s}=r.util.squeezeShape(n);if(p.length<n.length){const n=["row","col","depth","depth2","depth3"];return`\n      ${u(C(e,p))}\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        return ${i}(${T(n,s)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${l}, ${a}, ${c}, ${o})) +\n          depth3;\n        ${f(e)}\n      }\n    `;const x=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],v=h[1];if(v===l&&null==x)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${a}, ${c}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${v}.0, ${d}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(v===o&&null==x)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]},\n               ${n[2]*n[3]}, ${n[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${v}.0, ${d}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;const S=$(t);return`\n    float ${i}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${a} + depth * ${c} +\n          depth2 * ${o} + depth3 + ${S};\n      vec2 uv = uvFromFlat(${d}, ${v}, index);\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 6:return function(e){const n=e.shapeInfo.logicalShape,t=e.name,i="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:o,keptDims:c}=r.util.squeezeShape(n);if(o.length<n.length){const n=["row","col","depth","depth2","depth3","depth4"];return`\n      ${u(C(e,o))}\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${i}(${T(n,c)});\n      }\n    `}const a=n[5],l=n[4]*a,p=n[3]*l,s=n[2]*p,x=n[1]*s;if(e.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${x}, ${s}, ${p}, ${l})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${a}, 1)));\n        ${f(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,v=d[0],S=d[1];if(S===x&&null==h)return`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${s}, ${p}, ${l}, ${a})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${S}.0, ${v}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(S===a&&null==h)return`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${n[1]*n[2]*n[3]*n[4]},\n               ${n[2]*n[3]*n[4]},\n               ${n[3]*n[4]},\n               ${n[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${S}.0, ${v}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;const m=$(t);return`\n    float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${x} + col * ${s} + depth * ${p} +\n          depth2 * ${l} + depth3 * ${a} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${v}, ${S}, index);\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function l(e,n){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const n=e.name,t="get"+n.charAt(0).toUpperCase()+n.slice(1),r=(0,i.B)();return`\n    vec4 ${t}() {\n      return ${r.texture2D}(${n}, halfCR);\n    }\n  `}(e);case 1:return function(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e.shapeInfo.texShape,c=(0,i.B)();if(n)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${c.texture2D}(${t}, uv);\n    }\n  `;const a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${a[0]}, ${a[1]}, index);\n      return ${c.texture2D}(${t}, uv);\n    }\n  `}(e,n);case 2:return function(e,n){const t=e.shapeInfo.logicalShape,o=e.name,c="get"+o.charAt(0).toUpperCase()+o.slice(1),a=e.shapeInfo.texShape,u=a[0],l=a[1],p=(0,i.B)();if(null!=a&&r.util.arraysEqual(t,a))return n?`\n      vec4 ${c}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);\n\n        return ${p.texture2D}(${o}, uv);\n      }\n    `:`\n      vec4 ${c}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${u}.0);\n\n        return ${p.texture2D}(${o}, uv);\n      }\n    `;if(n)return`\n    vec4 ${c}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${o}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${p.texture2D}(${o}, uv);\n    }\n  `;const s=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],x=Math.ceil(t[1]/2);return`\n    vec4 ${c}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${x}, ${s[0]}, ${s[1]}, row, col);\n      return ${p.texture2D}(${o}, uv);\n    }\n  `}(e,n);case 3:return function(e,n){const t=e.shapeInfo.logicalShape,r=e.name,o="get"+r.charAt(0).toUpperCase()+r.slice(1),c=e.shapeInfo.texShape,a=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];if(1===t[0]){const r=[1,2],i=["b","row","col"];return`\n        ${l(C(e,t.slice(1)),n)}\n        vec4 ${o}(int b, int row, int col) {\n          return ${o}(${T(i,r)});\n        }\n      `}const u=(0,i.B)();if(n)return`\n    vec4 ${o}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `;const p=a[0],s=a[1],x=Math.ceil(t[2]/2),h=x*Math.ceil(t[1]/2);return`\n    vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${p}, ${s}, ${h}, ${x}, b, row, col);\n      return ${u.texture2D}(${r}, uv);\n    }\n  `}(e,n);default:return function(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),o=(0,i.B)();if(n)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${t}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${t}, uv);\n    }\n  `;const c=e.shapeInfo.logicalShape,a=c.length,u=e.shapeInfo.texShape,l=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)],p=l[0],s=l[1],x=Math.ceil(c[a-1]/2);let h=x*Math.ceil(c[a-2]/2),d="int b, int row, int col",$=`b * ${h} + (row / 2) * ${x} + (col / 2)`;for(let i=2;i<a-1;i++)d=`int b${i}, `+d,h*=c[a-i-1],$=`b${i} * ${h} + `+$;return`\n    vec4 ${r}(${d}) {\n      int index = ${$};\n      int texR = index / ${s};\n      int texC = index - texR * ${s};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}, ${p});\n      return ${o.texture2D}(${t}, uv);\n    }\n  `}(e,n)}}const p="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",s="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",x="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",h="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function d(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function $(e){return`offset${e}`}function f(e){const n=e.name,t=r.util.sizeFromShape(e.shapeInfo.logicalShape);return t<2?`return ${n};`:`\n    for (int i = 0; i < ${t}; i++) {\n      if (i == index) {\n        return ${n}[i];\n      }\n    }\n  `}function v(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function S(e,n,t){const{newShape:i,keptDims:o}=r.util.squeezeShape(n),c=n.length,a=e&&3===c&&1===n[0],u=a?n.slice(1):i,l=!e&&c>1&&!r.util.arraysEqual(n,t)&&i.length<c||a;return{useSqueezeShape:l,uniformShape:l?u:n,keptDims:o}}function C(e,n){const t=JSON.parse(JSON.stringify(e));return t.shapeInfo.logicalShape=n,t}function T(e,n){return n.map((n=>e[n])).join(", ")}},81847:function(e,n,t){t.d(n,{T:function(){return i}});var r=t(27575);class i{constructor(e,n,t){let i,o;if(this.variableNames=["c","a","b"],this.outputShape=n,t>4)throw Error(`Where for rank ${t} is not yet supported`);if(1===t)o="resRC",i="resRC";else{const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],c=[];for(let i=0;i<n.length;i++)c.push(`${t[i]}`),i<e&&r.push(`${t[i]}`);i=r.join(),o=c.join()}const c=(0,r.bf)(t);this.userCode=`\n      void main() {\n        ${c} resRC = getOutputCoords();\n        float cVal = getC(${i});\n        if (cVal >= 1.0) {\n          setOutput(getA(${o}));\n        } else {\n          setOutput(getB(${o}));\n        }\n      }\n    `}}},92394:function(e,n,t){t.d(n,{G2:function(){return l},Od:function(){return u},TN:function(){return c},UG:function(){return i},WA:function(){return o},fM:function(){return a}});var r=t(9495);function i(e,n,t="index"){const i=r.util.computeStrides(n);return i.map(((n,r)=>`${`int ${e[r]} = ${t} / ${n}`}; ${r===i.length-1?`int ${e[r+1]} = ${t} - ${e[r]} * ${n}`:`index -= ${e[r]} * ${n}`};`)).join("")}function o(e,n,t="index"){const i=r.util.computeStrides(n);return i.map(((n,r)=>`${`int ${e[r]} = ${t} / outShapeStrides[${r}]`}; ${r===i.length-1?`int ${e[r+1]} = ${t} - ${e[r]} * outShapeStrides[${r}]`:`index -= ${e[r]} * outShapeStrides[${r}]`};`)).join("")}function c(e,n,t="index"){const r=function(e,n){const t=e.length,r=e.map((e=>`${n}[${e}]`)),i=new Array(t-1);i[t-2]=r[t-1];for(let o=t-3;o>=0;--o)i[o]=`(${i[o+1]} * ${r[o+1]})`;return i}(e.map(((e,n)=>n)),n);return r.map(((n,i)=>`${`int ${e[i]} = ${t} / ${r[i]}`}; ${i===r.length-1?`int ${e[i+1]} = ${t} - ${e[i]} * ${r[i]}`:`index -= ${e[i]} * ${r[i]}`};`)).join("")}function a(e){const n=r.util.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${n[0]} + coords.y * ${n[1]} + coords.z;\n  }\n`}function u(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}const l="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n"}}]);
//# sourceMappingURL=stylist-vendors-5c149095.d0c373e0a852fc139347.js.map