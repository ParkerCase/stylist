"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[6689],{456:function(e,t,n){n.d(t,{H:function(){return s},z:function(){return o}});var a=n(9495),r=n(97870);function s(e){const{inputs:t,backend:n,attrs:s}=e,{x:o}=t,{alpha:u}=s;(0,r.C)([o],"leakyRelu");const i=a.util.sizeFromShape(o.shape),c=n.data.get(o.dataId).values,l=a.util.getTypedArrayFromDType("float32",i);for(let a=0;a<c.length;a++)l[a]=c[a]<0?u*c[a]:c[a];return n.makeTensorInfo(o.shape,"float32",l)}const o={kernelName:a.LeakyRelu,backendName:"cpu",kernelFunc:s}},1802:function(e,t,n){n.d(t,{Fx:function(){return i},px:function(){return o}});var a=n(9495),r=n(45705),s=n(21694);const o=(0,r.o)((e=>Math.log(e))),u=(0,s.F)(a.Log,o),i={kernelName:a.Log,backendName:"cpu",kernelFunc:u}},2750:function(e,t,n){n.d(t,{w:function(){return r}});var a=n(9495);function r(e,t,n,r){const s=a.util.parseAxisParam(t,n)[0],o=[1,n[0],1];for(let a=0;a<s;a++)o[0]*=n[a];o[1]=n[s];for(let a=s+1;a<n.length;a++)o[2]*=n[a];const u={},i=new Int32Array(n[s]),c=new a.TensorBuffer(o,r,e),l=[],d=1===o[0]&&1===o[2];for(let a=0;a<n[s];a++){let t;if(d)t=e[a].toString();else{const e=[];for(let t=0;t<o[0];t++)for(let n=0;n<o[2];n++)e.push(c.get(t,a,n));t=e.join(",")}if(void 0!==u[t])i[a]=u[t];else{const e=Object.keys(u).length;u[t]=e,i[a]=e,l.push(a)}}const p=o.slice();p[1]=Object.keys(u).length;const f=new a.TensorBuffer(p,r);l.forEach(((e,t)=>{for(let n=0;n<o[0];n++)for(let a=0;a<o[2];a++)f.set(c.get(n,e,a),n,t,a)}));const h=n.slice();return h[s]=p[1],{outputValues:f.values,outputShape:h,indices:i}}},3759:function(e,t,n){n.d(t,{j:function(){return r}});var a=n(9495);function r(e,t,n,r){const s=a.util.getTypedArrayFromDType(r,a.util.sizeFromShape(n));for(let a=0;a<s.length;++a){const n=a*t;let r=e[n];for(let a=0;a<t;++a){const t=e[n+a];t>r&&(r=t)}s[a]=r}return s}},4092:function(e,t,n){n.d(t,{Lt:function(){return i},Zy:function(){return o}});var a=n(9495),r=n(45705),s=n(21694);const o=(0,r.o)((e=>1/Math.sqrt(e))),u=(0,s.F)(a.Rsqrt,o),i={kernelName:a.Rsqrt,backendName:"cpu",kernelFunc:u}},5744:function(e,t,n){n.d(t,{y:function(){return r}});var a=n(9495);function r(e,t,n,r,s,o,u){const i=t[0],c=o[0],l=new Array(c),d=new Array(i),p=t[1];if(0===c){if(0!==i)throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${i}`);return[a.util.getArrayFromDType(n,0),[0,p],a.util.getArrayFromDType(s,0),l,d]}let f=!0,h=0;const m=new Array(c).fill(0);for(let a=0;a<i;++a){const t=e[a*p];if(t<0)throw new Error(`indices(${a}, 0) is invalid: ${t} < 0`);if(t>=c)throw new Error(`indices(${a}, 0) is invalid: ${t} >= ${c}`);++m[t],f=f&&t>=h,h=t}let k=!0;for(let a=0;a<c;++a){const e=0===m[a];l[a]=e,k=k&&!e,m[a]=Math.max(m[a],1),a>0&&(m[a]+=m[a-1])}if(k&&f){const t=e,n=r;for(let e=0;e<i;++e)d[e]=e;return[t,[i,p],n,l,d]}{const t=m[c-1],o=a.util.getArrayFromDType(n,t*p),f=a.util.getArrayFromDType(s,t),h=new Array(c).fill(0);for(let n=0;n<i;++n){const t=e[n*p],a=h[t],s=(0===t?0:m[t-1])+a;h[t]++;for(let r=0;r<p;++r)o[s*p+r]=e[n*p+r];f[s]=r[n],d[n]=s}for(let e=0;e<c;++e){if(0===h[e]){const t=0===e?0:m[e-1];o[t*p+0]=e;for(let e=1;e<p;++e)o[t*p+e]=0;f[t]=u}}return[o,[i,p],f,l,d]}}},13396:function(e,t,n){n.d(t,{_:function(){return r}});var a=n(9495);function r(e,t,n,r,s){const o=t.length,u=a.util.sizeFromShape(t),i=a.util.computeStrides(t),c=a.util.computeStrides(s),l=a.util.getTypedArrayFromDType(n,a.util.sizeFromShape(s));for(let d=0;d<u;++d){const t=a.util.indexToLoc(d,o,i),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];l[a.util.locToIndex(n,o,c)]=e[d]}return l}},14590:function(e,t,n){n.d(t,{V:function(){return s},t:function(){return r}});var a=n(9495);function r(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:o}=r,u=a.util.sizeFromShape(s.shape),i=a.util.inferFromImplicitShape(o,u),c=a.util.sizeFromShape(i);a.util.assert(u===c,(()=>`The new shape (${i}) has ${c} elements and the old shape (${s.shape}) has ${u} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(s.dataId);const l=n.data.get(s.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=i,t.shape=i}return{dataId:s.dataId,shape:i,dtype:s.dtype}}const s={kernelName:a.Reshape,backendName:"cpu",kernelFunc:r}},18566:function(e,t,n){n.d(t,{Zl:function(){return c},dl:function(){return o},jb:function(){return i}});var a=n(9495),r=n(8195),s=n(98880);const o=(0,r.Z)(((e,t)=>e-t)),u=(0,s.B)(((e,t,n,a)=>({real:e-n,imag:t-a}))),i=(0,s.j)(a.Sub,o,u),c={kernelName:a.Sub,backendName:"cpu",kernelFunc:i}},21671:function(e,t,n){n.d(t,{D:function(){return r}});var a=n(9495);function r(e,t){const n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];const r=(0,a.buffer)(n,e.dtype);for(let a=0;a<r.values.length;++a){const t=r.indexToLoc(a),n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=t[a]%e.shape[a];const s=e.locToIndex(n);r.values[a]=e.values[s]}return r}},25231:function(e,t,n){n.d(t,{c:function(){return l},q:function(){return d}});var a=n(9495),r=n(97870),s=n(11317),o=n(13713),u=n(46936),i=n(14590),c=n(85655);function l(e){const{inputs:t,backend:n,attrs:l}=e,{x:d}=t,{axis:p,keepDims:f}=l;let h;(0,r.C)(d,"sum"),h="bool"===d.dtype?(0,o.w)({inputs:{x:d},backend:n,attrs:{dtype:"int32"}}):(0,u.D)({inputs:{x:d},backend:n});const m=h.shape.length,k=a.util.parseAxisParam(p,h.shape),b=a.backend_util.getAxesPermutation(k,m);let g=k,y=h;null!=b&&(y=(0,c.m)({inputs:{x:h},backend:n,attrs:{perm:b}}),g=a.backend_util.getInnerMostAxes(g.length,m)),a.backend_util.assertAxesAreInnerMostDims("sum",g,y.shape.length);const[I,N]=a.backend_util.computeOutAndReduceShapes(y.shape,g),x=a.backend_util.upcastType(y.dtype,"int32");let S=(0,s.U)(n,I,x);const v=a.util.sizeFromShape(N),T=n.data.get(S.dataId).values,F=n.data.get(y.dataId).values;for(let a=0;a<T.length;++a){const e=a*v;let t=0;for(let n=0;n<v;++n)t+=F[e+n];T[a]=t}if(f){const e=a.backend_util.expandShapeToKeepDim(S.shape,k),t=S;S=(0,i.t)({inputs:{x:S},backend:n,attrs:{shape:e}}),n.disposeIntermediateTensorInfo(t)}return n.disposeIntermediateTensorInfo(h),null!=b&&n.disposeIntermediateTensorInfo(y),S}const d={kernelName:a.Sum,backendName:"cpu",kernelFunc:l}},37962:function(e,t,n){n.d(t,{Dk:function(){return o},hd:function(){return u}});var a=n(9495),r=n(97870),s=n(65646);function o(e,t,n){const r=a.util.createScalarValue(-1,n);return(0,s.BF)([],t,r,e,n)}const u={kernelName:a.Neg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;(0,r.C)(a,"neg");const s=n.data.get(a.dataId).values,[u,i]=o(s,a.shape,a.dtype);return n.makeTensorInfo(i,a.dtype,u)}}},45207:function(e,t,n){n.d(t,{WR:function(){return o},YW:function(){return i}});var a=n(9495),r=n(8195),s=n(98880);const o=(0,r.Z)(((e,t)=>e<t?1:0)),u=(0,s.j)(a.Less,o,null,"bool"),i={kernelName:a.Less,backendName:"cpu",kernelFunc:u}},48580:function(e,t,n){n.d(t,{Nu:function(){return i},hE:function(){return o}});var a=n(9495),r=n(8195),s=n(98880);const o=(0,r.Z)(((e,t)=>Math.min(e,t))),u=(0,s.j)(a.Minimum,o),i={kernelName:a.Minimum,backendName:"cpu",kernelFunc:u}},50666:function(e,t,n){n.d(t,{H:function(){return u},N:function(){return o}});var a=n(9495),r=n(97870);const s=(0,n(8195).Z)(((e,t)=>e<0?t*e:e));function o(e){const{inputs:t,backend:n}=e,{x:a,alpha:o}=t;(0,r.C)([a,o],"prelu");const u=n.data.get(a.dataId).values,i=n.data.get(o.dataId).values,[c,l]=s(a.shape,o.shape,u,i,a.dtype);return n.makeTensorInfo(l,a.dtype,c)}const u={kernelName:a.Prelu,backendName:"cpu",kernelFunc:o}},51675:function(e,t,n){n.d(t,{S3:function(){return u},_B:function(){return o}});var a=n(9495),r=n(97870),s=n(85655);function o(e,t,n,r){const[s,o]=a.backend_util.computeOutAndReduceShapes(e,r),u=(0,a.upcastType)(t,"int32"),i=a.util.makeZerosTypedArray(a.util.sizeFromShape(s),u),c=a.util.sizeFromShape(o);for(let a=0;a<i.length;++a){const e=a*c;let t=1;for(let a=0;a<c;++a)t*=n[e+a];i[a]=t}return{outVals:i,outShape:s,outDtype:u}}const u={kernelName:a.Prod,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:u}=e,{x:i}=t,{axis:c,keepDims:l}=u;(0,r.C)(i,"prod");const d=i.shape.length,p=a.util.parseAxisParam(c,i.shape),f=a.backend_util.getAxesPermutation(p,d);let h=p,m=i;const k=[];null!=f&&(m=(0,s.m)({inputs:{x:i},backend:n,attrs:{perm:f}}),k.push(m),h=a.backend_util.getInnerMostAxes(h.length,d));const b=n.data.get(m.dataId).values,{outVals:g,outShape:y,outDtype:I}=o(m.shape,m.dtype,b,h);let N=y;return l&&(N=a.backend_util.expandShapeToKeepDim(y,p)),k.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(N,I,g)}}},52610:function(e,t,n){n.d(t,{q:function(){return r}});var a=n(9495);function r(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return a.util.makeZerosTypedArray(0,r);const s=Math.abs(Math.ceil((t-e)/n)),o=a.util.makeZerosTypedArray(s,r);t<e&&1===n&&(n=-1),o[0]=e;for(let a=1;a<o.length;a++)o[a]=o[a-1]+n;return o}},53475:function(e,t,n){n.d(t,{x:function(){return r}});var a=n(9495);function r(e,t,n,r,s){const o=t[t.length-1],[u,i]=[e.length/o,o],c=a.util.getTypedArrayFromDType(n,u*r),l=a.util.getTypedArrayFromDType("int32",u*r);for(let a=0;a<u;a++){const t=a*i,n=e.subarray(t,t+i),s=[];for(let e=0;e<n.length;e++)s.push({value:n[e],index:e});s.sort(((e,t)=>t.value-e.value));const o=a*r,u=c.subarray(o,o+r),d=l.subarray(o,o+r);for(let e=0;e<r;e++)u[e]=s[e].value,d[e]=s[e].index}const d=t.slice();return d[d.length-1]=r,[(0,a.buffer)(d,n,c),(0,a.buffer)(d,"int32",l)]}},53652:function(e,t,n){n.d(t,{X:function(){return s},j:function(){return r}});var a=n(9495);const r=(0,n(21694).v)(a.Relu6,(e=>Math.min(Math.max(0,e),6))),s={kernelName:a.Relu6,backendName:"cpu",kernelFunc:r}},61879:function(e,t,n){n.d(t,{GN:function(){return i},y4:function(){return u}});var a=n(9495),r=n(8195),s=n(98880);const o=(0,r.Z)(((e,t)=>e/t)),u=(0,s.j)(a.RealDiv,o),i={kernelName:a.RealDiv,backendName:"cpu",kernelFunc:u}},64190:function(e,t,n){n.d(t,{G:function(){return r}});var a=n(9495);function r(e,t,n){const r=(t-e)/(n-1),s=a.util.makeZerosTypedArray(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}},64904:function(e,t,n){n.d(t,{X:function(){return s},r:function(){return r}});var a=n(9495);const r=(0,n(21694).v)(a.Sigmoid,(e=>1/(1+Math.exp(-e)))),s={kernelName:a.Sigmoid,backendName:"cpu",kernelFunc:r}},65646:function(e,t,n){n.d(t,{BF:function(){return o},lw:function(){return i},tJ:function(){return c}});var a=n(9495),r=n(8195),s=n(98880);const o=(0,r.Z)(((e,t)=>e*t)),u=(0,s.B)(((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n}))),i=(0,s.j)(a.Multiply,o,u),c={kernelName:a.Multiply,backendName:"cpu",kernelFunc:i}},66114:function(e,t,n){n.d(t,{He:function(){return o},l9:function(){return i}});var a=n(9495),r=n(8195),s=n(98880);const o=(0,r.Z)(((e,t)=>Math.max(e,t))),u=(0,s.j)(a.Maximum,o),i={kernelName:a.Maximum,backendName:"cpu",kernelFunc:u}},67686:function(e,t,n){n.d(t,{e:function(){return r}});var a=n(9495);function r(e,t,n,r){const s=(0,a.buffer)(e,t.dtype);for(let a=0;a<s.size;a++){const e=s.indexToLoc(a),o=new Array(e.length);for(let t=0;t<o.length;t++)o[t]=e[t]*n[t]+r[t];s.set(t.get(...o),...e)}return s}},74016:function(e,t,n){n.d(t,{V:function(){return r},z:function(){return s}});var a=n(9495);const r=(0,n(21694).v)(a.Relu,(e=>Math.max(0,e))),s={kernelName:a.Relu,backendName:"cpu",kernelFunc:r}},85655:function(e,t,n){n.d(t,{W:function(){return u},m:function(){return o}});var a=n(9495),r=n(97870),s=n(13396);function o(e){const{inputs:t,attrs:n,backend:a}=e,{x:o}=t,{perm:u}=n;(0,r.C)(o,"transpose");const i=o.shape.length,c=new Array(i);for(let r=0;r<c.length;r++)c[r]=o.shape[u[r]];const l=a.data.get(o.dataId).values,d=(0,s._)(l,o.shape,o.dtype,u,c);return{dataId:a.write(d,c,o.dtype),shape:c,dtype:o.dtype}}const u={kernelName:a.Transpose,backendName:"cpu",kernelFunc:o}},85806:function(e,t,n){function a(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}n.d(t,{r:function(){return r},x:function(){return a}});const r={kernelName:n(9495).Real,backendName:"cpu",kernelFunc:a}},87906:function(e,t,n){n.d(t,{HS:function(){return s},di:function(){return o},lv:function(){return u}});var a=n(9495),r=n(97870);function s(e,t,n,r,s){const o=a.slice_util.isSliceContinous(r,t,n),u=a.util.sizeFromShape(n),i=a.util.computeStrides(r);if(o){const n=a.slice_util.computeFlatOffset(t,i);return"string"===s?e.slice(n,n+u):e.subarray(n,n+u)}const c="string"===s?a.backend_util.fromUint8ToStringArray(e):e,l=(0,a.buffer)(r,s,c),d=(0,a.buffer)(n,s);for(let a=0;a<d.size;++a){const e=d.indexToLoc(a),n=e.map(((e,n)=>e+t[n]));d.set(l.get(...n),...e)}return"string"===s?a.backend_util.fromStringArrayToUint8(d.values):d.values}function o(e){const{inputs:t,backend:n,attrs:o}=e,{x:u}=t,{begin:i,size:c}=o;(0,r.C)(u,"slice");const[l,d]=a.slice_util.parseSliceParams(u,i,c);a.slice_util.assertParamsValid(u,l,d);const p=s(n.data.get(u.dataId).values,l,d,u.shape,u.dtype);return n.makeTensorInfo(d,u.dtype,p)}const u={kernelName:a.Slice,backendName:"cpu",kernelFunc:o}},92163:function(e,t,n){var a=n(9495),r=n(9949),s=n(95315),o=n(78140);const u={kernelName:a._FusedMatMul,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:u,b:i,bias:c,preluActivationWeights:l}=t,{transposeA:d,transposeB:p,activation:f,leakyreluAlpha:h}=a;let m,k,b;const g=[];m=(0,o.N)({inputs:{a:u,b:i},attrs:{transposeA:d,transposeB:p},backend:n}),c&&(k=(0,s.WQ)({inputs:{a:m,b:c},backend:n}),g.push(m),m=k),f&&(b=(0,r.f)(n,m,f,l,h),g.push(m),m=b);for(const r of g)n.disposeIntermediateTensorInfo(r);return m}};var i=n(62680),c=n(96708),l=n(7478),d=n(91601),p=n(53747),f=n(30766),h=n(98828),m=n(25954),k=n(50745),b=n(36541),g=n(13484),y=n(7676),I=n(50046),N=n(1090),x=n(58449),S=n(87105),v=n(3822),T=n(58306),F=n(237),M=n(46838),w=n(13713),A=n(14759),z=n(75304),D=n(89436),_=n(63330),C=n(98342),P=n(43898),R=n(23530),E=n(33910),$=n(70583),L=n(45655),V=n(6941),q=n(41347),W=n(11355),O=n(55671),Z=n(50120),j=n(1903),H=n(57152),B=n(87994),U=n(14666),G=n(85046),K=n(94505),X=n(69034),Y=n(25242),J=n(19910),Q=n(36813),ee=n(24856),te=n(4652),ne=n(99292),ae=n(52999),re=n(66423),se=n(36085),oe=n(26789),ue=n(89792),ie=n(80015),ce=n(62684),le=n(85526),de=n(95071),pe=n(30307),fe=n(99150),he=n(50591),me=n(11717),ke=n(14346),be=n(86768),ge=n(46936),ye=n(60251),Ie=n(18944),Ne=n(71969),xe=n(79727),Se=n(27445),ve=n(456),Te=n(45207),Fe=n(8195),Me=n(98880);const we=(0,Fe.Z)(((e,t)=>e<=t?1:0)),Ae=(0,Me.j)(a.LessEqual,we,null,"bool"),ze={kernelName:a.LessEqual,backendName:"cpu",kernelFunc:Ae};var De=n(64190);const _e={kernelName:a.LinSpace,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,o=(0,De.G)(a,r,s);return t.makeTensorInfo([o.length],"float32",o)}};var Ce=n(1802),Pe=n(21694);const Re=(0,Pe.v)(a.Log1p,(e=>Math.log1p(e))),Ee={kernelName:a.Log1p,backendName:"cpu",kernelFunc:Re},$e=(0,Fe.Z)(((e,t)=>e&&t)),Le=(0,Me.j)(a.LogicalAnd,$e,null,"bool"),Ve={kernelName:a.LogicalAnd,backendName:"cpu",kernelFunc:Le},qe=(0,Pe.v)(a.LogicalNot,(e=>e?0:1),"bool"),We={kernelName:a.LogicalNot,backendName:"cpu",kernelFunc:qe},Oe=(0,Fe.Z)(((e,t)=>e||t)),Ze=(0,Me.j)(a.LogicalOr,Oe,null,"bool"),je={kernelName:a.LogicalOr,backendName:"cpu",kernelFunc:Ze};var He=n(34820),Be=n(49608),Ue=n(97870),Ge=n(3759),Ke=n(13396);function Xe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:o,keepDims:u}=r,i=n;let c=s.shape;const l=c.length,d=a.util.parseAxisParam(o,c);let p=d;const f=a.backend_util.getAxesPermutation(p,l);let h=i.data.get(s.dataId).values;if(null!=f){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=c[f[t]];h=(0,Ke._)(h,c,s.dtype,f,e),p=a.backend_util.getInnerMostAxes(p.length,l),c=e}(0,Ue.C)(s,"max"),a.backend_util.assertAxesAreInnerMostDims("max",p,l);const[m,k]=a.backend_util.computeOutAndReduceShapes(c,p),b=a.util.sizeFromShape(k),g=(0,Ge.j)(h,b,m,s.dtype),y=i.write(g,m,s.dtype);let I=m;if(u){I=a.backend_util.expandShapeToKeepDim(m,d)}return{dataId:y,shape:I,dtype:s.dtype}}const Ye={kernelName:a.Max,backendName:"cpu",kernelFunc:Xe};var Je=n(66114),Qe=n(6307);const et={kernelName:a.MaxPool,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;(0,Ue.C)(s,"maxPool");const{filterSize:o,strides:u,pad:i,dimRoundingMode:c}=r;a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(u,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${u} and dilations '1'`));const l=a.backend_util.computePool2DInfo(s.shape,o,u,1,i,c);let d;if(1===l.filterWidth&&1===l.filterHeight&&a.util.arraysEqual(l.inShape,l.outShape))d=(0,ge.D)({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=a.util.computeStrides(s.shape),r=(0,Qe.dz)(e,s.shape,s.dtype,t,l,"max");d=n.makeTensorInfo(l.outShape,s.dtype,r.values)}return d}};const tt={kernelName:a.MaxPool3D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:o,strides:u,pad:i,dimRoundingMode:c,dataFormat:l}=r;(0,Ue.C)(s,"maxPool3d");const d=a.backend_util.computePool3DInfo(s.shape,o,u,1,i,c,l),p=n.data.get(s.dataId).values,f=(0,Qe.W_)(p,s.shape,s.dtype,a.util.computeStrides(s.shape),d,"max");return n.makeTensorInfo(f.shape,"float32",f.values)}};const nt={kernelName:a.MaxPool3DGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,{filterSize:u,strides:i,pad:c,dimRoundingMode:l}=r;(0,Ue.C)([s,o],"maxPool3DGrad");const d=a.backend_util.computePool3DInfo(o.shape,u,i,1,c,l),p=n.bufferSync(o),f=(0,Qe.qW)(p,d),h=d.strideDepth,m=d.strideHeight,k=d.strideWidth,b=d.dilationDepth,g=d.dilationHeight,y=d.dilationWidth,I=d.effectiveFilterDepth,N=d.effectiveFilterHeight,x=d.effectiveFilterWidth,S=I-1-d.padInfo.front,v=x-1-d.padInfo.left,T=N-1-d.padInfo.top,F=(0,a.buffer)(o.shape,"float32"),M=n.bufferSync(s);for(let a=0;a<d.batchSize;++a)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inDepth;++t)for(let n=0;n<d.inHeight;++n)for(let r=0;r<d.inWidth;++r){const s=t-S,o=n-T,u=r-v;let i=0;for(let t=0;t<I;t+=b){const n=(s+t)/h;if(!(n<0||n>=d.outDepth||Math.floor(n)!==n))for(let r=0;r<N;r+=g){const s=(o+r)/m;if(!(s<0||s>=d.outHeight||Math.floor(s)!==s))for(let o=0;o<x;o+=y){const c=(u+o)/k;if(c<0||c>=d.outWidth||Math.floor(c)!==c)continue;const l=I*N*x-1-f.get(a,n,s,c,e)===t*N*x+r*x+o?1:0;if(0===l)continue;i+=M.get(a,n,s,c,e)*l}}}F.set(i,a,t,n,r,e)}return n.makeTensorInfo(F.shape,F.dtype,F.values)}};const at={kernelName:a.MaxPoolGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o,output:u}=t,i=o;(0,Ue.C)([o,u],"maxPoolGrad");const{filterSize:c,strides:l,pad:d,dimRoundingMode:p}=r,f=a.backend_util.computePool2DInfo(i.shape,c,l,1,d,p),h=n.data.get(i.dataId).values,m=(0,a.buffer)(f.outShape,i.dtype,(0,Qe.nN)(h,i.shape,i.dtype,f).values),k=f.strideHeight,b=f.strideWidth,g=f.dilationHeight,y=f.dilationWidth,I=f.effectiveFilterHeight,N=f.effectiveFilterWidth,x=N-1-f.padInfo.left,S=I-1-f.padInfo.top,v=(0,a.buffer)(i.shape,"float32"),T=n.data.get(s.dataId).values,F=(0,a.buffer)(s.shape,"float32",T);for(let a=0;a<f.batchSize;++a)for(let e=0;e<f.inChannels;++e)for(let t=0;t<f.inHeight;++t)for(let n=0;n<f.inWidth;++n){const r=t-S,s=n-x;let o=0;for(let t=0;t<I;t+=g){const n=(r+t)/k;if(!(n<0||n>=f.outHeight||Math.floor(n)!==n))for(let r=0;r<N;r+=y){const u=(s+r)/b;if(u<0||u>=f.outWidth||Math.floor(u)!==u)continue;const i=I*N-1-m.get(a,n,u,e)===t*N+r?1:0;if(0===i)continue;o+=F.get(a,n,u,e)*i}}v.set(o,a,t,n,e)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};const rt={kernelName:a.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:o,pad:u,includeBatchInIndex:i}=t,c=n;(0,Ue.C)(r,"MaxPoolWithArgmax");const l=c.data.get(r.dataId).values,d=a.backend_util.computePool2DInfo(r.shape,s,o,[1,1],u),[p,f]=function(e,t,n,r,s){const o=a.util.computeStrides(t),u=(0,Qe.dz)(e,t,n,o,s,"max"),i=(0,Qe.nN)(e,t,n,s,!0,r);return[u.values,i.values]}(l,r.shape,r.dtype,i,d),h=c.write(p,d.outShape,r.dtype),m=c.write(f,d.outShape,r.dtype);return[{dataId:h,shape:d.outShape,dtype:r.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};var st=n(61879),ot=n(25231);const ut={kernelName:a.Mean,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:u}=r,i=a.util.parseAxisParam(o,s.shape),c=a.backend_util.computeOutAndReduceShapes(s.shape,i)[1],l=a.util.sizeFromShape(c),d=[],p=n.makeTensorInfo([],"float32",new Float32Array([l]));d.push(p);const f=(0,w.w)({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});d.push(f);const h=(0,st.y4)({inputs:{a:f,b:p},backend:n});d.push(h);const m=(0,ot.c)({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:u}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}};var it=n(14590),ct=n(85655);const lt={kernelName:a.Min,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:u}=r;(0,Ue.C)(s,"min");const i=a.util.parseAxisParam(o,s.shape);let c=i;const l=a.backend_util.getAxesPermutation(c,s.shape.length);let d=s;null!=l&&(d=(0,ct.m)({inputs:{x:s},backend:n,attrs:{perm:l}}),c=a.backend_util.getInnerMostAxes(c.length,s.shape.length)),a.backend_util.assertAxesAreInnerMostDims("min",c,d.shape.length);const[p,f]=a.backend_util.computeOutAndReduceShapes(d.shape,c),h=a.util.sizeFromShape(f),m=a.util.makeZerosTypedArray(a.util.sizeFromShape(p),d.dtype),k=n.data.get(d.dataId).values;for(let a=0;a<m.length;++a){const e=a*h;let t=k[e];for(let n=0;n<h;++n){const a=k[e+n];a<t&&(t=a)}m[a]=t}null!=l&&n.disposeIntermediateTensorInfo(d);const b=n.makeTensorInfo(p,d.dtype,m);if(u){const e=a.backend_util.expandShapeToKeepDim(p,i),t=(0,it.t)({inputs:{x:b},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(b),t}return b}};var dt=n(48580);const pt={kernelName:a.MirrorPad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:o,mode:u}=r;(0,Ue.C)(s,"mirrorPad");const i=o.map(((e,t)=>e[0]+s.shape[t]+e[1])),c=o.map((e=>e[0])),l=o.map(((e,t)=>e[0]+s.shape[t])),d="reflect"===u?0:1,p=n.data.get(s.dataId).values,f=s.shape.length,h=a.util.computeStrides(s.shape),m=a.util.sizeFromShape(i),k=i.length,b=a.util.computeStrides(i),g=a.util.getTypedArrayFromDType(s.dtype,m);for(let y=0;y<m;y++){let e=a.util.indexToLoc(y,k,b);for(let n=0;n<k;n++)e[n]<c[n]?e[n]=2*c[n]-e[n]-d:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+d);e=e.map(((e,t)=>e-c[t]));const t=a.util.locToIndex(e,f,h);g[y]=p[t]}return{dataId:n.write(g,i,s.dtype),shape:i,dtype:s.dtype}}},ft=(0,Fe.Z)(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),ht=(0,Me.j)(a.Mod,ft),mt={kernelName:a.Mod,backendName:"cpu",kernelFunc:ht};var kt=n(7391),bt=n(18566);function gt(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:o}=r,u=s.shape.length;let i=o;if(-1===i&&(i=u-1),i!==u-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${u} and dim was ${i}`);const c=a.util.parseAxisParam([i],s.shape),l=Xe({inputs:{x:s},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),d=a.backend_util.expandShapeToKeepDim(l.shape,c),p=(0,it.t)({inputs:{x:l},backend:n,attrs:{shape:d}}),f=(0,bt.jb)({inputs:{a:s,b:p},backend:n}),h=(0,re.oN)({inputs:{x:f},backend:n}),m=(0,ot.c)({inputs:{x:h},backend:n,attrs:{axis:c,keepDims:!1}}),k=(0,it.t)({inputs:{x:m},backend:n,attrs:{shape:d}}),b=(0,st.y4)({inputs:{a:h,b:k},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(k),b}const yt={kernelName:a.Softmax,backendName:"cpu",kernelFunc:gt};const It={kernelName:a.Multinomial,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:o,seed:u,normalized:i}=r;(0,Ue.C)(s,"multinomial");const c=i?s:gt({inputs:{logits:s},backend:n,attrs:{dim:-1}}),l=c.shape[0],d=c.shape[1],p=n.data.get(c.dataId).values,f=[l,o],h=a.util.makeZerosTypedArray(a.util.sizeFromShape(f),"int32");for(let a=0;a<l;++a){const e=a*d,t=new Float32Array(d-1);t[0]=p[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+p[e+a];const n=kt.alea(u.toString()),r=a*o;for(let a=0;a<o;++a){const e=n();h[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){h[r+a]=n;break}}}return i||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(f,"int32",h)}};var Nt=n(65646),xt=n(37962);const St=a.kernel_impls.nonMaxSuppressionV3Impl;const vt={kernelName:a.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:i}=a;(0,Ue.C)(r,"NonMaxSuppression");const c=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,{selectedIndices:d}=St(c,l,o,u,i);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Tt=a.kernel_impls.nonMaxSuppressionV4Impl;const Ft={kernelName:a.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:i,padToMaxOutputSize:c}=a;(0,Ue.C)(r,"NonMaxSuppressionPadded");const l=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:p,validOutputs:f}=Tt(l,d,o,u,i,c);return[n.makeTensorInfo([p.length],"int32",new Int32Array(p)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}},Mt=a.kernel_impls.nonMaxSuppressionV5Impl;const wt={kernelName:a.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:u,scoreThreshold:i,softNmsSigma:c}=a;(0,Ue.C)(r,"NonMaxSuppressionWithScore");const l=n.data.get(r.dataId).values,d=n.data.get(s.dataId).values,p=o,f=u,h=i,m=c,{selectedIndices:k,selectedScores:b}=Mt(l,d,p,f,h,m);return[n.makeTensorInfo([k.length],"int32",new Int32Array(k)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},At=(0,Fe.Z)(((e,t)=>e!==t?1:0)),zt=(0,Me.j)(a.NotEqual,At,null,"bool"),Dt={kernelName:a.NotEqual,backendName:"cpu",kernelFunc:zt};const _t={kernelName:a.OneHot,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:o,onValue:u,offValue:i}=r;(0,Ue.C)(s,"oneHot");const c=a.util.sizeFromShape(s.shape),l=new Float32Array(c*o);l.fill(i);const d=n.data.get(s.dataId).values;for(let a=0;a<c;++a)d[a]>=0&&d[a]<o&&(l[a*o+d[a]]=u);return n.makeTensorInfo([...s.shape,o],"int32",l)}};var Ct=n(85806);function Pt(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=(0,Ct.x)({inputs:{input:a},backend:n}),t=Pt({inputs:{x:e},backend:n}),r=(0,Ie.n)({inputs:{input:a},backend:n}),s=Pt({inputs:{x:r},backend:n}),o=(0,D.f)({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return(0,ie.G)({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const Rt={kernelName:a.ZerosLike,backendName:"cpu",kernelFunc:Pt};const Et={kernelName:a.OnesLike,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const t=(0,Ct.x)({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),s=(0,Ie.n)({inputs:{input:r},backend:a}),o=Pt({inputs:{x:s},backend:a}),u=(0,D.f)({inputs:{real:n,imag:o},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),u}return(0,ie.G)({backend:a,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function $t(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return(0,se.U)({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const o=t[0].shape,u=t[0].dtype;t.forEach((e=>{a.util.assertShapesMatch(o,e.shape,"All tensors passed to stack must have matching shapes"),a.util.assert(u===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],c=t.map((e=>{const t=(0,se.U)({inputs:{input:e},backend:n,attrs:{dim:s}});return i.push(t),t})),l=(0,C.x)({inputs:c,backend:n,attrs:{axis:s}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const Lt={kernelName:a.Pack,backendName:"cpu",kernelFunc:$t};const Vt={kernelName:a.PadV2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:o,constantValue:u}=r;(0,Ue.C)(s,"pad");const i=o.map(((e,t)=>e[0]+s.shape[t]+e[1])),c=o.map((e=>e[0])),l=n.data.get(s.dataId).values,d=a.util.sizeFromShape(s.shape),p=s.shape.length,f=a.util.computeStrides(s.shape),h=a.util.sizeFromShape(i),m=i.length,k=a.util.computeStrides(i),b=a.util.getTypedArrayFromDType(s.dtype,h);0!==u&&b.fill(u);for(let g=0;g<d;g++){const e=a.util.indexToLoc(g,p,f).map(((e,t)=>e+c[t]));b[a.util.locToIndex(e,m,k)]=l[g]}return{dataId:n.write(b,i,s.dtype),shape:i,dtype:s.dtype}}},qt=(0,Fe.Z)(((e,t)=>Math.pow(e,t))),Wt=(0,Me.j)(a.Pow,qt),Ot={kernelName:a.Pow,backendName:"cpu",kernelFunc:Wt};var Zt=n(50666),jt=n(51675),Ht=n(52610);const Bt={kernelName:a.Range,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,dtype:s,step:o}=n,u=(0,Ht.q)(a,r,o,s);return t.makeTensorInfo([u.length],s,u)}},Ut=(0,Pe.v)(a.Reciprocal,(e=>1/e)),Gt={kernelName:a.Reciprocal,backendName:"cpu",kernelFunc:Ut};var Kt=n(74016),Xt=n(53652);const Yt={kernelName:a.ResizeBilinear,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:u,size:i}=r;(0,Ue.C)(s,"resizeBilinear");const c=a.util.computeStrides(s.shape),[l,d]=i,[p,f,h,m]=s.shape,k=n.data.get(s.dataId).values,b=new Float32Array(a.util.sizeFromShape([p,l,d,m])),g=[o&&l>1?f-1:f,o&&d>1?h-1:h],y=[o&&l>1?l-1:l,o&&d>1?d-1:d];let I=0;const N=g[0]/y[0],x=g[1]/y[1];for(let a=0;a<p;a++)for(let e=0;e<l;e++){let t;t=u?N*(e+.5)-.5:N*e;const n=Math.max(0,Math.floor(t)),r=t-n,s=Math.min(f-1,Math.ceil(t)),o=a*c[0]+n*c[1],i=a*c[0]+s*c[1];for(let e=0;e<d;e++){let t;t=u?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),a=t-n,s=Math.min(h-1,Math.ceil(t)),l=o+n*c[2],d=i+n*c[2],p=o+s*c[2],f=i+s*c[2];for(let e=0;e<m;e++){const t=k[l+e],n=k[d+e],s=t+(k[p+e]-t)*a,o=s+(n+(k[f+e]-n)*a-s)*r;b[I++]=o}}}return n.makeTensorInfo([p,l,d,m],"float32",b)}};const Jt={kernelName:a.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:u}=r;(0,Ue.C)([o,s],"resizeBilinearGrad");const i=a.util.computeStrides(s.shape),[c,l,d,p]=s.shape,[,f,h]=o.shape,m=new Float32Array(c*l*d*p),k=[u&&f>1?l-1:l,u&&h>1?d-1:d],b=[u&&f>1?f-1:f,u&&h>1?h-1:h],g=k[0]/b[0],y=k[1]/b[1],I=n.data.get(o.dataId).values;let N=0;for(let a=0;a<c;a++){const e=a*i[0];for(let t=0;t<f;t++){const n=t*g,a=Math.floor(n),r=Math.min(Math.ceil(n),l-1),s=e+a*i[1],o=e+r*i[1],u=n-a,c=1-u;for(let e=0;e<h;e++){const t=e*y,n=Math.floor(t),a=Math.min(Math.ceil(t),d-1),r=t-n,l=1-r,f=s+n*i[2],h=s+a*i[2],k=o+n*i[2],b=o+a*i[2],g=c*l,x=c*r,S=u*l,v=u*r;for(let e=0;e<p;e++){const t=I[N++];m[f+e]+=t*g,m[h+e]+=t*x,m[k+e]+=t*S,m[b+e]+=t*v}}}}return n.makeTensorInfo([c,d,l,p],"float32",m)}};const Qt={kernelName:a.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:u,size:i}=r;(0,Ue.C)(s,"resizeNearestNeighbor");const c=a.util.computeStrides(s.shape),[l,d]=i,[p,f,h,m]=s.shape,k=n.data.get(s.dataId).values,b=new Float32Array(p*l*d*m),g=[o&&l>1?f-1:f,o&&d>1?h-1:h],y=[o&&l>1?l-1:l,o&&d>1?d-1:d],I=g[0]/y[0],N=g[1]/y[1];let x=0;for(let a=0;a<p;a++){const e=a*c[0];for(let t=0;t<l;t++){const n=u?I*(t+.5):I*t;let a=Math.min(f-1,o?Math.round(n):Math.floor(n));u&&(a=Math.max(0,a));const r=e+a*c[1];for(let e=0;e<d;e++){const t=u?N*(e+.5):N*e;let n=Math.min(h-1,o?Math.round(t):Math.floor(t));u&&(n=Math.max(0,n));const a=r+n*c[2];for(let e=0;e<m;e++){const t=k[a+e];b[x++]=t}}}}return n.makeTensorInfo([p,l,d,m],s.dtype,b)}};const en={kernelName:a.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:u}=r;(0,Ue.C)([o,s],"resizeNearestNeighborGrad");const i=a.util.computeStrides(s.shape),c=a.util.computeStrides(o.shape),[l,d,p,f]=s.shape,[,h,m]=o.shape,k=new Float32Array(l*d*p*f),b=n.data.get(o.dataId).values,g=[u&&h>1?d-1:d,u&&m>1?p-1:p],y=[u&&h>1?h-1:h,u&&m>1?m-1:m],I=g[0]/y[0],N=g[1]/y[1],x=1/I,S=1/N,v=2*Math.ceil(x)+2,T=2*Math.ceil(S)+2;for(let a=0;a<l;a++){const e=a*i[0];for(let t=0;t<d;t++){const n=e+t*i[1],a=Math.floor(t*x),r=Math.floor(a-v/2);for(let s=0;s<p;s++){const a=n+s*i[2],o=Math.floor(s*S),l=Math.floor(o-T/2);for(let n=0;n<f;n++){let o=0;for(let a=0;a<v;a++){const i=a+r;if(i<0||i>=h)continue;const f=e+i*c[1],k=i*I;if(t===Math.min(d-1,u?Math.round(k):Math.floor(k)))for(let e=0;e<T;e++){const t=e+l;if(t<0||t>=m)continue;const a=f+t*c[2],r=t*N;s===Math.min(p-1,u?Math.round(r):Math.floor(r))&&(o+=b[a+n])}}k[a+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,k)}};const tn={kernelName:a.Reverse,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:o}=r;(0,Ue.C)(s,"reverse");const u=s.shape.length,i=a.util.parseAxisParam(o,s.shape);if(0===u)return(0,ge.D)({inputs:{x:s},backend:n});const c=new a.TensorBuffer(s.shape,s.dtype),l=n.bufferSync(s);for(let a=0;a<c.size;a++){const e=c.indexToLoc(a),t=e.slice();i.forEach((e=>t[e]=s.shape[e]-1-t[e])),c.set(l.get(...t),...e)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}},nn={kernelName:a.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:o,center:u}=t,i=n,c=a.util.getTypedArrayFromDType(r.dtype,a.util.sizeFromShape(r.shape)),[l,d,p,f]=r.shape,[h,m]=a.backend_util.getImageCenter(u,d,p),k=Math.sin(s),b=Math.cos(s),g=i.data.get(r.dataId).values;for(let a=0;a<l;a++){const e=a*p*d*f;for(let t=0;t<d;t++){const n=t*(p*f);for(let a=0;a<p;a++){const r=a*f;for(let s=0;s<f;s++){const u=[l,t,a,s],i=u[2],y=u[1];let I=(i-h)*b-(y-m)*k,N=(i-h)*k+(y-m)*b;I=Math.round(I+h),N=Math.round(N+m);let x=o;if("number"!==typeof o&&(x=3===s?255:o[s]),I>=0&&I<p&&N>=0&&N<d){x=g[e+N*(p*f)+I*f+s]}c[e+n+r+s]=x}}}}return{dataId:i.write(c,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},an=(0,Pe.v)(a.Round,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),rn={kernelName:a.Round,backendName:"cpu",kernelFunc:an};var sn=n(4092);function on(e,t,n,r,s,o,u,i,c,l){const d=[r/s,s],p=e.values,f=t.values;if(0===r)return(0,a.buffer)(n,t.dtype);const h=(0,a.buffer)(d,t.dtype);h.values.fill(c);for(let a=0;a<o;a++){const e=[];let o=0;for(let t=0;t<u;t++){const n=p[a*u+t];e.push(n),o+=n*i[t]}if(o<0||o>=r/s)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<s;n++)l?h.values[o*s+n]+=f[a*s+n]:h.values[o*s+n]=0===t.rank?f[0]:f[a*s+n]}return h}const un={kernelName:a.ScatterNd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:o}=t,{shape:u}=r,{sliceRank:i,numUpdates:c,sliceSize:l,strides:d,outputSize:p}=a.backend_util.calculateShapes(o,s,u),f=on(n.bufferSync(s),n.bufferSync(o),u,p,l,c,i,d,0,!0);return n.makeTensorInfo(u,f.dtype,f.values)}};const cn={kernelName:a.Select,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:o}=t;(0,Ue.C)([r,s,o],"select");const u=r.shape.length,i=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values,d=(0,a.upcastType)(s.dtype,o.dtype),p=a.util.makeZerosTypedArray(a.util.sizeFromShape(s.shape),d);let f=0;const h=0===u||u>1||1===s.shape.length?1:a.util.sizeFromShape(s.shape.slice(1));for(let a=0;a<i.length;a++)for(let e=0;e<h;e++)1===i[a]?p[f++]=c[a]:p[f++]=l[a];return n.makeTensorInfo(s.shape,d,p)}},ln=a.backend_util.SELU_SCALEALPHA,dn=a.backend_util.SELU_SCALE,pn=(0,Pe.v)(a.Selu,(e=>e>=0?dn*e:ln*(Math.exp(e)-1))),fn={kernelName:a.Selu,backendName:"cpu",kernelFunc:pn};var hn=n(64904);const mn=(0,Pe.v)(a.Sign,(e=>e<0?-1:e>0?1:0)),kn={kernelName:a.Sign,backendName:"cpu",kernelFunc:mn},bn=(0,Pe.v)(a.Sin,(e=>Math.sin(e))),gn={kernelName:a.Sin,backendName:"cpu",kernelFunc:bn},yn=(0,Pe.v)(a.Sinh,(e=>Math.sinh(e))),In={kernelName:a.Sinh,backendName:"cpu",kernelFunc:yn};var Nn=n(87906);const xn=Math.log(1.1920928955078125e-7)+2,Sn=(0,Pe.v)(a.Softplus,(e=>{const t=e>-xn,n=e<xn,a=Math.exp(e);let r;return r=n?a:t?e:Math.log(1+a),r})),vn={kernelName:a.Softplus,backendName:"cpu",kernelFunc:Sn};const Tn={kernelName:a.SpaceToBatchND,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,paddings:u}=r;(0,Ue.C)([s],"spaceToBatchND");const i=a.util.sizeFromShape(o),c=[[0,0]];c.push(...u);for(let a=1+o.length;a<s.shape.length;++a)c.push([0,0]);const l=Vt.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:c,constantValue:0}}),d=a.backend_util.getReshaped(l.shape,o,i,!1),p=a.backend_util.getPermuted(d.length,o.length,!1),f=a.backend_util.getReshapedPermuted(l.shape,o,i,!1),h={x:l},m={shape:d},k=(0,it.t)({inputs:h,backend:n,attrs:m}),b={x:k},g={perm:p},y=(0,ct.m)({inputs:b,backend:n,attrs:g}),I={x:y},N={shape:f},x=(0,it.t)({inputs:I,backend:n,attrs:N});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(y),x}};var Fn=n(5744);const Mn={kernelName:a.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:o}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==a.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${a.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const u=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,l=n.data.get(o.dataId).values[0],[d,p,f,h,m]=(0,Fn.y)(u,a.shape,a.dtype,i,r.dtype,c,l);return[n.makeTensorInfo(p,a.dtype,d),n.makeTensorInfo([p[0]],r.dtype,f),n.makeTensorInfo([h.length],"bool",new Uint8Array(h.map((e=>Number(e))))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};var wn=n(95587);const An={kernelName:a.SparseReshape,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(2!==a.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${a.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(n.data.get(r.dataId).values),u=n.data.get(a.dataId).values,i=Array.from(n.data.get(s.dataId).values),[c,l,d]=(0,wn.l)(u,a.shape,a.dtype,o,i);return[n.makeTensorInfo(l,a.dtype,c),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}};const zn={kernelName:a.SparseToDense,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:o,defaultValue:u}=t,{outputShape:i}=r,{sliceRank:c,numUpdates:l,sliceSize:d,strides:p,outputSize:f}=a.backend_util.calculateShapes(o,s,i),h=on(n.bufferSync(s),n.bufferSync(o),i,f,d,l,c,p,n.data.get(u.dataId).values[0],!1);return n.makeTensorInfo(i,h.dtype,h.values)}};const Dn={kernelName:a.SplitV,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:o,axis:u}=r,i=a.util.parseAxisParam(u,s.shape)[0],c=a.backend_util.prepareSplitSize(s,o,i),l=new Array(s.shape.length).fill(0),d=s.shape.slice();return c.map((e=>{const t=[...d];t[i]=e;const a=(0,Nn.di)({inputs:{x:s},backend:n,attrs:{begin:l,size:t}});return l[i]+=e,a}))}},_n=(0,Pe.v)(a.Sqrt,(e=>Math.sqrt(e))),Cn={kernelName:a.Sqrt,backendName:"cpu",kernelFunc:_n},Pn={kernelName:a.Square,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,a=t;(0,Ue.C)(n,"square");const r=a.data.get(n.dataId).values,s=new Float32Array(r.length);for(let o=0;o<r.length;++o){const e=r[o];s[o]=e*e}return{dataId:a.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},Rn=(0,Fe.Z)(((e,t)=>{const n=e-t;return n*n})),En=(0,Me.j)(a.SquaredDifference,Rn),$n={kernelName:a.SquaredDifference,backendName:"cpu",kernelFunc:En},Ln=(0,Pe.v)(a.Step,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),Vn={kernelName:a.Step,backendName:"cpu",kernelFunc:Ln};var qn=n(67686);const Wn={kernelName:a.StridedSlice,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:o,end:u,strides:i,beginMask:c,endMask:l,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:f}=r;(0,Ue.C)(s,"stridedSlice");const{nonStrided:h,$begin:m,$strides:k,size:b,newShape:g,outShape:y}=a.slice_util.sliceInfo(s.shape,o,u,i,c,l,d,p,f),I=(0,it.t)({inputs:{x:s},backend:n,attrs:{shape:g}});let N;if(h){const e=(0,Nn.di)({inputs:{x:I},backend:n,attrs:{begin:m,size:b}});N=(0,it.t)({inputs:{x:e},backend:n,attrs:{shape:y}}),n.disposeIntermediateTensorInfo(e)}else if(y.some((e=>0===e)))N=n.makeTensorInfo(y,s.dtype,[]);else{const e=n.bufferSync(I),t=(0,qn.e)(y,e,k,m);N=n.makeTensorInfo(t.shape,t.dtype,t.values)}const x=(0,it.t)({inputs:{x:N},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(N),x}},On=(0,Pe.v)(a.Tan,(e=>Math.tan(e))),Zn={kernelName:a.Tan,backendName:"cpu",kernelFunc:On},jn=(0,Pe.v)(a.Tanh,(e=>Math.tanh(e))),Hn={kernelName:a.Tanh,backendName:"cpu",kernelFunc:jn};var Bn=n(21671);const Un={kernelName:a.Tile,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;(0,Ue.C)(r,"tile");const o=(0,Bn.D)(n.bufferSync(r),s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}};var Gn=n(53475);const Kn={kernelName:a.TopK,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:o}=a;(0,Ue.C)(r,"topk");const u=n.data.get(r.dataId).values,[i,c]=(0,Gn.x)(u,r.shape,r.dtype,s,o);return[n.makeTensorInfo(i.shape,i.dtype,i.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}};const Xn={kernelName:a.Transform,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:o}=t,{interpolation:u,fillMode:i,fillValue:c,outputShape:l}=n,[d,p,f,h]=s.shape,[m,k]=null!=l?l:[p,f],b=[d,m,k,h],g=a.util.computeStrides(s.shape),y=g[0],I=g[1],N=g[2],x=a.util.getTypedArrayFromDType(s.dtype,a.util.sizeFromShape(b));x.fill(c);const S=r.data.get(s.dataId).values,v=r.data.get(o.dataId).values;for(let a=0;a<d;++a){const e=1===o.shape[0]?v:v.subarray(8*a,8*a+8);for(let t=0;t<m;++t)for(let n=0;n<k;++n)for(let r=0;r<h;++r){let s;const o=e[6]*n+e[7]*t+1;if(0===o)continue;const l=(e[0]*n+e[1]*t+e[2])/o,d=(e[3]*n+e[4]*t+e[5])/o,h=Yn(l,f,i),m=Yn(d,p,i);switch(u){case"nearest":s=Qn(S,p,f,y,I,N,a,m,h,r,c);break;case"bilinear":s=ea(S,p,f,y,I,N,a,m,h,r,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${u}`)}x[a*y+t*I+n*N+r]=s}return r.makeTensorInfo(b,s.dtype,x)}return{dataId:r.write(x,b,s.dtype),shape:s.shape,dtype:s.dtype}}};function Yn(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return a.util.clamp(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return a.util.clamp(0,n,t-1)}(e,t);case"nearest":return function(e,t){return a.util.clamp(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function Jn(e,t,n,a,r,s,o,u,i,c,l){return 0<=u&&u<t&&0<=i&&i<n?e[o*a+u*r+i*s+c]:l}function Qn(e,t,n,a,r,s,o,u,i,c,l){return Jn(e,t,n,a,r,s,o,Math.round(u),Math.round(i),c,l)}function ea(e,t,n,a,r,s,o,u,i,c,l){const d=Math.floor(u),p=Math.floor(i),f=d+1,h=p+1;return(f-u)*((h-i)*Jn(e,t,n,a,r,s,o,d,p,c,l)+(i-p)*Jn(e,t,n,a,r,s,o,d,h,c,l))+(u-d)*((h-i)*Jn(e,t,n,a,r,s,o,f,p,c,l)+(i-p)*Jn(e,t,n,a,r,s,o,f,h,c,l))}var ta=n(2750);const na={kernelName:a.Unique,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;(0,Ue.C)(s,"unique");const o=a.data.get(s.dataId).values,{outputValues:u,outputShape:i,indices:c}=(0,ta.w)(o,r,s.shape,s.dtype);return[a.makeTensorInfo(i,s.dtype,u),a.makeTensorInfo([c.length],"int32",c)]}};const aa={kernelName:a.Unpack,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const o=r.shape.length,u=r.shape[s],i=new Array(o-1);let c=0;for(let f=0;f<o;f++)f!==s&&(i[c++]=r.shape[f]);const l=new Array(o).fill(0),d=r.shape.slice();d[s]=1;const p=new Array(u);for(let f=0;f<p.length;f++){l[s]=f;const e=(0,Nn.di)({inputs:{x:r},backend:n,attrs:{begin:l,size:d}});p[f]=(0,it.t)({inputs:{x:e},backend:n,attrs:{shape:i}}),n.disposeIntermediateTensorInfo(e)}return p}};const ra={kernelName:a.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:o}=t,{numSegments:u}=r;(0,Ue.C)(s,"unsortedSegmentSum");const i=[],c=[],l=s.shape.length-o.shape.length;let d=o;for(let a=0;a<l;++a){const e=(0,se.U)({inputs:{input:d},backend:n,attrs:{dim:a+1}});d=e,c.push(e)}for(let f=0;f<u;++f){const e=a.util.createScalarValue(f,"int32"),t=n.makeTensorInfo([],"int32",e),r=(0,ne.LC)({inputs:{a:t,b:d},backend:n}),o=(0,w.w)({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),u=(0,Nt.lw)({inputs:{a:o,b:s},backend:n}),l=(0,ot.c)({inputs:{x:u},backend:n,attrs:{axis:0,keepDims:!1}});i.push(l),c.push(t),c.push(r),c.push(o),c.push(u),c.push(l)}const p=$t({inputs:i,backend:n,attrs:{axis:0}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}},sa=[u,i.lO,c.t,l.D,s.UK,d.y,p.k,f.l,h.n,m.l,k.S,b.M,g.L,y.rL,I.l,N.R,x.O,S.m,v.$,o.X,T.V,F.e,M.l,w.M,A.uf,z.z,D.v,_.t,C.V,R.r,E.f,P.x,L.i,V.e,$.i,q.o,W.k,O.O,Z.$,j.Y,H.R,B.v,U.n,G.V,K.O,X.D,J.B,Y.p,st.GN,Q._,ee.J,te.x,ne.RY,ae._,re.AC,se.a,oe.Yp,ue.N,ie.u,ce.D,le.Hc,de.Uc,pe.q,fe.l,he.K,me.a,ke.xp,be.VM,ge.F,ye.c,Ie.l,Ne.K,xe.I,Se.I,ve.z,Te.YW,ze,_e,Ce.Fx,Ee,Ve,We,je,He.t,Be.z,Je.l9,et,tt,nt,at,rt,Ye,ut,lt,dt.Nu,pt,mt,It,Nt.tJ,xt.hd,vt,Ft,wt,Dt,_t,Et,Lt,Vt,Ot,Zt.H,jt.S3,Bt,Ct.r,Gt,Kt.z,Xt.X,it.V,Yt,Jt,Qt,en,tn,nn,rn,sn.Lt,un,cn,fn,hn.X,kn,gn,In,Nn.lv,yt,vn,Tn,Mn,An,zn,Dn,Cn,Pn,$n,Vn,Wn,bt.Zl,ot.q,Zn,Hn,Un,Kn,ct.W,Xn,na,aa,ra,Rt];for(const oa of sa)(0,a.registerKernel)(oa)},95587:function(e,t,n){n.d(t,{l:function(){return r}});var a=n(9495);function r(e,t,n,r,s){const o=a.util.sizeFromShape(r),u=t[0],i=s.length,c=[];let l=1,d=-1;for(let a=0;a<i;++a){const e=s[a];if(-1===e){if(-1!==d)throw new Error(`only one output dimension may be -1, not both ${d} and ${a}`);d=a,c.push(1)}else{if(e<0)throw new Error(`size ${a} must be non-negative, not ${e}`);l*=e,c.push(e)}}if(-1!==d){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(o/l);if(l*e!==o)throw new Error(`Input to reshape is a SparseTensor with ${o}\n          dense values, but the requested shape requires a multiple of ${l}. inputShape=${r} outputShape= ${c}`);c[d]=e}const p=a.util.sizeFromShape(c);if(p!==o)throw new Error(`Input to reshape is a tensor with ${o} dense values, but the requested shape has ${p}. inputShape=${r} outputShape=${c}`);const f=r.length,h=[];if(f>0){h[f-1]=1;for(let e=f-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}const m=[];if(i>0){m[i-1]=1;for(let e=i-2;e>=0;--e)m[e]=m[e+1]*c[e+1]}const k=a.util.getArrayFromDType(n,u*i);for(let a=0;a<u;++a){let t=0;for(let n=0;n<f;++n)t+=e[a*f+n]*h[n];for(let e=0;e<i;++e)k[a*i+e]=Math.trunc(t/m[e]),t%=m[e]}return[k,[u,i],c]}}}]);
//# sourceMappingURL=stylist-vendors-8cb190b9.ffcbe7ad849e09b96587.js.map