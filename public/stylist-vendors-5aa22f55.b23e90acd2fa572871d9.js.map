{"version":3,"file":"stylist-vendors-5aa22f55.b23e90acd2fa572871d9.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/metrics.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/losses.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/logs.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Built-in metrics.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { tidy } from '@tensorflow/tfjs-core';\nimport * as K from './backend/tfjs_backend';\nimport { NotImplementedError, ValueError } from './errors';\nimport { binaryCrossentropy as lossBinaryCrossentropy, categoricalCrossentropy as categoricalCrossentropyLoss, cosineProximity, lossesMap, meanAbsoluteError, meanAbsolutePercentageError, meanSquaredError, sparseCategoricalCrossentropy as sparseCategoricalCrossentropyLoss } from './losses';\nimport * as util from './utils/generic_utils';\nexport function binaryAccuracy(yTrue, yPred) {\n    return tidy(() => {\n        const threshold = tfc.mul(.5, tfc.onesLike(yPred));\n        const yPredThresholded = K.cast(tfc.greater(yPred, threshold), yTrue.dtype);\n        return tfc.mean(tfc.equal(yTrue, yPredThresholded), -1);\n    });\n}\nexport function categoricalAccuracy(yTrue, yPred) {\n    return tidy(() => K.cast(tfc.equal(tfc.argMax(yTrue, -1), tfc.argMax(yPred, -1)), 'float32'));\n}\nfunction truePositives(yTrue, yPred) {\n    return tidy(() => {\n        return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 1), tfc.equal(yPred, 1))), 'float32');\n    });\n}\nfunction falseNegatives(yTrue, yPred) {\n    return tidy(() => {\n        return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 1), tfc.equal(yPred, 0))), 'float32');\n    });\n}\nfunction falsePositives(yTrue, yPred) {\n    return tidy(() => {\n        return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 0), tfc.equal(yPred, 1))), 'float32');\n    });\n}\nexport function precision(yTrue, yPred) {\n    return tidy(() => {\n        const tp = truePositives(yTrue, yPred);\n        const fp = falsePositives(yTrue, yPred);\n        const denominator = tfc.add(tp, fp);\n        return tfc.cast(tfc.where(tfc.greater(denominator, 0), tfc.div(tp, denominator), 0), 'float32');\n    });\n}\nexport function recall(yTrue, yPred) {\n    return tidy(() => {\n        const tp = truePositives(yTrue, yPred);\n        const fn = falseNegatives(yTrue, yPred);\n        const denominator = tfc.add(tp, fn);\n        return tfc.cast(tfc.where(tfc.greater(denominator, 0), tfc.div(tp, denominator), 0), 'float32');\n    });\n}\nexport function binaryCrossentropy(yTrue, yPred) {\n    return lossBinaryCrossentropy(yTrue, yPred);\n}\nexport function sparseCategoricalAccuracy(yTrue, yPred) {\n    if (yTrue.rank === yPred.rank) {\n        yTrue = tfc.squeeze(yTrue, [yTrue.rank - 1]);\n    }\n    yPred = tfc.argMax(yPred, -1);\n    if (yPred.dtype !== yTrue.dtype) {\n        yPred = tfc.cast(yPred, yTrue.dtype);\n    }\n    return tfc.cast(tfc.equal(yTrue, yPred), 'float32');\n}\nexport function topKCategoricalAccuracy(yTrue, yPred) {\n    throw new NotImplementedError();\n}\nexport function sparseTopKCategoricalAccuracy(yTrue, yPred) {\n    throw new NotImplementedError();\n}\nexport function r2Score(yTrue, yPred) {\n    return tidy(() => {\n        const sumSquaresResiduals = yTrue.sub(yPred).square().sum();\n        const sumSquares = yTrue.sub(yTrue.mean()).square().sum();\n        return tfc.scalar(1).sub(sumSquaresResiduals.div(sumSquares));\n    });\n}\n// Aliases.\nexport const mse = meanSquaredError;\nexport const MSE = meanSquaredError;\nexport const mae = meanAbsoluteError;\nexport const MAE = meanAbsoluteError;\nexport const mape = meanAbsolutePercentageError;\nexport const MAPE = meanAbsolutePercentageError;\nexport const categoricalCrossentropy = categoricalCrossentropyLoss;\nexport const cosine = cosineProximity;\nexport const sparseCategoricalCrossentropy = sparseCategoricalCrossentropyLoss;\n// TODO(cais, nielsene): Add serialize().\nexport const metricsMap = {\n    binaryAccuracy,\n    categoricalAccuracy,\n    precision,\n    categoricalCrossentropy,\n    sparseCategoricalCrossentropy,\n    mse,\n    MSE,\n    mae,\n    MAE,\n    mape,\n    MAPE,\n    cosine\n};\nexport function get(identifier) {\n    if (typeof identifier === 'string' && identifier in metricsMap) {\n        return metricsMap[identifier];\n    }\n    else if (typeof identifier !== 'string' && identifier != null) {\n        return identifier;\n    }\n    else {\n        throw new ValueError(`Unknown metric ${identifier}`);\n    }\n}\n/**\n * Get the shortcut function name.\n *\n * If the fn name is a string,\n *   directly return the string name.\n * If the function is included in metricsMap or lossesMap,\n *   return key of the map.\n *   - If the function relative to multiple keys,\n *     return the first found key as the function name.\n *   - If the function exists in both lossesMap and metricsMap,\n *     search lossesMap first.\n * If the function is not included in metricsMap or lossesMap,\n *   return the function name.\n *\n * @param fn loss function, metric function, or short cut name.\n * @returns Loss or Metric name in string.\n */\nexport function getLossOrMetricName(fn) {\n    util.assert(fn !== null, `Unknown LossOrMetricFn ${fn}`);\n    if (typeof fn === 'string') {\n        return fn;\n    }\n    else {\n        let fnName;\n        for (const key of Object.keys(lossesMap)) {\n            if (lossesMap[key] === fn) {\n                fnName = key;\n                break;\n            }\n        }\n        if (fnName !== undefined) {\n            return fnName;\n        }\n        for (const key of Object.keys(metricsMap)) {\n            if (metricsMap[key] === fn) {\n                fnName = key;\n                break;\n            }\n        }\n        if (fnName !== undefined) {\n            return fnName;\n        }\n        return fn.name;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0cmljcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9tZXRyaWNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUg7O0dBRUc7QUFFSCxPQUFPLEtBQUssR0FBRyxNQUFNLHVCQUF1QixDQUFDO0FBQzdDLE9BQU8sRUFBUyxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUVuRCxPQUFPLEtBQUssQ0FBQyxNQUFNLHdCQUF3QixDQUFDO0FBQzVDLE9BQU8sRUFBQyxtQkFBbUIsRUFBRSxVQUFVLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFDekQsT0FBTyxFQUFDLGtCQUFrQixJQUFJLHNCQUFzQixFQUFFLHVCQUF1QixJQUFJLDJCQUEyQixFQUFFLGVBQWUsRUFBRSxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsMkJBQTJCLEVBQUUsZ0JBQWdCLEVBQUUsNkJBQTZCLElBQUksaUNBQWlDLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFFaFMsT0FBTyxLQUFLLElBQUksTUFBTSx1QkFBdUIsQ0FBQztBQUU5QyxNQUFNLFVBQVUsY0FBYyxDQUFDLEtBQWEsRUFBRSxLQUFhO0lBQ3pELE9BQU8sSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNmLE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNuRCxNQUFNLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVFLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFD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LE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDekMsSUFBSSxVQUFVLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxFQUFFO2dCQUMxQixNQUFNLEdBQUcsR0FBRyxDQUFDO2dCQUNiLE1BQU07YUFDUDtTQUNGO1FBQ0QsSUFBSSxNQUFNLEtBQUssU0FBUyxFQUFFO1lBQ3hCLE9BQU8sTUFBTSxDQUFDO1NBQ2Y7UUFDRCxPQUFRLEVBQWUsQ0FBQyxJQUFJLENBQUM7S0FDOUI7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyoqXG4gKiBCdWlsdC1pbiBtZXRyaWNzLlxuICovXG5cbmltcG9ydCAqIGFzIHRmYyBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtUZW5zb3IsIHRpZHl9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCAqIGFzIEsgZnJvbSAnLi9iYWNrZW5kL3RmanNfYmFja2VuZCc7XG5pbXBvcnQge05vdEltcGxlbWVudGVkRXJyb3IsIFZhbHVlRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7YmluYXJ5Q3Jvc3NlbnRyb3B5IGFzIGxvc3NCaW5hcnlDcm9zc2VudHJvcHksIGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5IGFzIGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5TG9zcywgY29zaW5lUHJveGltaXR5LCBsb3NzZXNNYXAsIG1lYW5BYnNvbHV0ZUVycm9yLCBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3IsIG1lYW5TcXVhcmVkRXJyb3IsIHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5IGFzIHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5TG9zc30gZnJvbSAnLi9sb3NzZXMnO1xuaW1wb3J0IHtMb3NzT3JNZXRyaWNGbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlBY2N1cmFjeSh5VHJ1ZTogVGVuc29yLCB5UHJlZDogVGVuc29yKTogVGVuc29yIHtcbiAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRmYy5tdWwoLjUsIHRmYy5vbmVzTGlrZSh5UHJlZCkpO1xuICAgIGNvbnN0IHlQcmVkVGhyZXNob2xkZWQgPSBLLmNhc3QodGZjLmdyZWF0ZXIoeVByZWQsIHRocmVzaG9sZCksIHlUcnVlLmR0eXBlKTtcbiAgICByZXR1cm4gdGZjLm1lYW4odGZjLmVxdWFsKHlUcnVlLCB5UHJlZFRocmVzaG9sZGVkKSwgLTEpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhdGVnb3JpY2FsQWNjdXJhY3koeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KFxuICAgICAgKCkgPT4gSy5jYXN0KFxuICAgICAgICAgIHRmYy5lcXVhbCh0ZmMuYXJnTWF4KHlUcnVlLCAtMSksIHRmYy5hcmdNYXgoeVByZWQsIC0xKSksICdmbG9hdDMyJykpO1xufVxuXG5mdW5jdGlvbiB0cnVlUG9zaXRpdmVzKHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgcmV0dXJuIHRmYy5jYXN0KFxuICAgICAgICB0ZmMuc3VtKHRmYy5sb2dpY2FsQW5kKHRmYy5lcXVhbCh5VHJ1ZSwgMSksIHRmYy5lcXVhbCh5UHJlZCwgMSkpKSxcbiAgICAgICAgJ2Zsb2F0MzInKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZhbHNlTmVnYXRpdmVzKHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgcmV0dXJuIHRmYy5jYXN0KFxuICAgICAgICB0ZmMuc3VtKHRmYy5sb2dpY2FsQW5kKHRmYy5lcXVhbCh5VHJ1ZSwgMSksIHRmYy5lcXVhbCh5UHJlZCwgMCkpKSxcbiAgICAgICAgJ2Zsb2F0MzInKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZhbHNlUG9zaXRpdmVzKHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgcmV0dXJuIHRmYy5jYXN0KFxuICAgICAgICB0ZmMuc3VtKHRmYy5sb2dpY2FsQW5kKHRmYy5lcXVhbCh5VHJ1ZSwgMCksIHRmYy5lcXVhbCh5UHJlZCwgMSkpKSxcbiAgICAgICAgJ2Zsb2F0MzInKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVjaXNpb24oeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCB0cCA9IHRydWVQb3NpdGl2ZXMoeVRydWUsIHlQcmVkKTtcbiAgICBjb25zdCBmcCA9IGZhbHNlUG9zaXRpdmVzKHlUcnVlLCB5UHJlZCk7XG5cbiAgICBjb25zdCBkZW5vbWluYXRvciA9IHRmYy5hZGQodHAsIGZwKTtcblxuICAgIHJldHVybiB0ZmMuY2FzdChcbiAgICAgICAgdGZjLndoZXJlKHRmYy5ncmVhdGVyKGRlbm9taW5hdG9yLCAwKSwgdGZjLmRpdih0cCwgZGVub21pbmF0b3IpLCAwKSxcbiAgICAgICAgJ2Zsb2F0MzInKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWNhbGwoeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCB0cCA9IHRydWVQb3NpdGl2ZXMoeVRydWUsIHlQcmVkKTtcbiAgICBjb25zdCBmbiA9IGZhbHNlTmVnYXRpdmVzKHlUcnVlLCB5UHJlZCk7XG5cbiAgICBjb25zdCBkZW5vbWluYXRvciA9IHRmYy5hZGQodHAsIGZuKTtcblxuICAgIHJldHVybiB0ZmMuY2FzdChcbiAgICAgICAgdGZjLndoZXJlKHRmYy5ncmVhdGVyKGRlbm9taW5hdG9yLCAwKSwgdGZjLmRpdih0cCwgZGVub21pbmF0b3IpLCAwKSxcbiAgICAgICAgJ2Zsb2F0MzInKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlDcm9zc2VudHJvcHkoeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiBsb3NzQmluYXJ5Q3Jvc3NlbnRyb3B5KHlUcnVlLCB5UHJlZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGFyc2VDYXRlZ29yaWNhbEFjY3VyYWN5KFxuICAgIHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICBpZiAoeVRydWUucmFuayA9PT0geVByZWQucmFuaykge1xuICAgIHlUcnVlID0gdGZjLnNxdWVlemUoeVRydWUsIFt5VHJ1ZS5yYW5rIC0gMV0pO1xuICB9XG4gIHlQcmVkID0gdGZjLmFyZ01heCh5UHJlZCwgLTEpO1xuICBpZiAoeVByZWQuZHR5cGUgIT09IHlUcnVlLmR0eXBlKSB7XG4gICAgeVByZWQgPSB0ZmMuY2FzdCh5UHJlZCwgeVRydWUuZHR5cGUpO1xuICB9XG4gIHJldHVybiB0ZmMuY2FzdCh0ZmMuZXF1YWwoeVRydWUsIHlQcmVkKSwgJ2Zsb2F0MzInKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvcEtDYXRlZ29yaWNhbEFjY3VyYWN5KHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3BhcnNlVG9wS0NhdGVnb3JpY2FsQWNjdXJhY3koXG4gICAgeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByMlNjb3JlKHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgY29uc3Qgc3VtU3F1YXJlc1Jlc2lkdWFscyA9IHlUcnVlLnN1Yih5UHJlZCkuc3F1YXJlKCkuc3VtKCk7XG4gICAgY29uc3Qgc3VtU3F1YXJlcyA9IHlUcnVlLnN1Yih5VHJ1ZS5tZWFuKCkpLnNxdWFyZSgpLnN1bSgpO1xuICAgIHJldHVybiB0ZmMuc2NhbGFyKDEpLnN1YihzdW1TcXVhcmVzUmVzaWR1YWxzLmRpdihzdW1TcXVhcmVzKSk7XG4gIH0pO1xufVxuXG4vLyBBbGlhc2VzLlxuZXhwb3J0IGNvbnN0IG1zZSA9IG1lYW5TcXVhcmVkRXJyb3I7XG5leHBvcnQgY29uc3QgTVNFID0gbWVhblNxdWFyZWRFcnJvcjtcbmV4cG9ydCBjb25zdCBtYWUgPSBtZWFuQWJzb2x1dGVFcnJvcjtcbmV4cG9ydCBjb25zdCBNQUUgPSBtZWFuQWJzb2x1dGVFcnJvcjtcbmV4cG9ydCBjb25zdCBtYXBlID0gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yO1xuZXhwb3J0IGNvbnN0IE1BUEUgPSBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3I7XG5leHBvcnQgY29uc3QgY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkgPSBjYXRlZ29yaWNhbENyb3NzZW50cm9weUxvc3M7XG5leHBvcnQgY29uc3QgY29zaW5lID0gY29zaW5lUHJveGltaXR5O1xuZXhwb3J0IGNvbnN0IHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5ID0gc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHlMb3NzO1xuXG4vLyBUT0RPKGNhaXMsIG5pZWxzZW5lKTogQWRkIHNlcmlhbGl6ZSgpLlxuXG5leHBvcnQgY29uc3QgbWV0cmljc01hcDoge1tmdW5jdGlvbk5hbWU6IHN0cmluZ106IExvc3NPck1ldHJpY0ZufSA9IHtcbiAgYmluYXJ5QWNjdXJhY3ksXG4gIGNhdGVnb3JpY2FsQWNjdXJhY3ksXG4gIHByZWNpc2lvbixcbiAgY2F0ZWdvcmljYWxDcm9zc2VudHJvcHksXG4gIHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5LFxuICBtc2UsXG4gIE1TRSxcbiAgbWFlLFxuICBNQUUsXG4gIG1hcGUsXG4gIE1BUEUsXG4gIGNvc2luZVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldChpZGVudGlmaWVyOiBzdHJpbmd8TG9zc09yTWV0cmljRm4pOiBMb3NzT3JNZXRyaWNGbiB7XG4gIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ3N0cmluZycgJiYgaWRlbnRpZmllciBpbiBtZXRyaWNzTWFwKSB7XG4gICAgcmV0dXJuIG1ldHJpY3NNYXBbaWRlbnRpZmllcl07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGlkZW50aWZpZXIgIT09ICdzdHJpbmcnICYmIGlkZW50aWZpZXIgIT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGlmaWVyO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBVbmtub3duIG1ldHJpYyAke2lkZW50aWZpZXJ9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNob3J0Y3V0IGZ1bmN0aW9uIG5hbWUuXG4gKlxuICogSWYgdGhlIGZuIG5hbWUgaXMgYSBzdHJpbmcsXG4gKiAgIGRpcmVjdGx5IHJldHVybiB0aGUgc3RyaW5nIG5hbWUuXG4gKiBJZiB0aGUgZnVuY3Rpb24gaXMgaW5jbHVkZWQgaW4gbWV0cmljc01hcCBvciBsb3NzZXNNYXAsXG4gKiAgIHJldHVybiBrZXkgb2YgdGhlIG1hcC5cbiAqICAgLSBJZiB0aGUgZnVuY3Rpb24gcmVsYXRpdmUgdG8gbXVsdGlwbGUga2V5cyxcbiAqICAgICByZXR1cm4gdGhlIGZpcnN0IGZvdW5kIGtleSBhcyB0aGUgZnVuY3Rpb24gbmFtZS5cbiAqICAgLSBJZiB0aGUgZnVuY3Rpb24gZXhpc3RzIGluIGJvdGggbG9zc2VzTWFwIGFuZCBtZXRyaWNzTWFwLFxuICogICAgIHNlYXJjaCBsb3NzZXNNYXAgZmlyc3QuXG4gKiBJZiB0aGUgZnVuY3Rpb24gaXMgbm90IGluY2x1ZGVkIGluIG1ldHJpY3NNYXAgb3IgbG9zc2VzTWFwLFxuICogICByZXR1cm4gdGhlIGZ1bmN0aW9uIG5hbWUuXG4gKlxuICogQHBhcmFtIGZuIGxvc3MgZnVuY3Rpb24sIG1ldHJpYyBmdW5jdGlvbiwgb3Igc2hvcnQgY3V0IG5hbWUuXG4gKiBAcmV0dXJucyBMb3NzIG9yIE1ldHJpYyBuYW1lIGluIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExvc3NPck1ldHJpY05hbWUoZm46IHN0cmluZ3xMb3NzT3JNZXRyaWNGbik6IHN0cmluZyB7XG4gIHV0aWwuYXNzZXJ0KGZuICE9PSBudWxsLCBgVW5rbm93biBMb3NzT3JNZXRyaWNGbiAke2ZufWApO1xuICBpZiAodHlwZW9mIGZuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmbjtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZm5OYW1lO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGxvc3Nlc01hcCkpIHtcbiAgICAgIGlmIChsb3NzZXNNYXBba2V5XSA9PT0gZm4pIHtcbiAgICAgICAgZm5OYW1lID0ga2V5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZuTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZm5OYW1lO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtZXRyaWNzTWFwKSkge1xuICAgICAgaWYgKG1ldHJpY3NNYXBba2V5XSA9PT0gZm4pIHtcbiAgICAgICAgZm5OYW1lID0ga2V5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZuTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZm5OYW1lO1xuICAgIH1cbiAgICByZXR1cm4gKGZuIGFzIEZ1bmN0aW9uKS5uYW1lO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original Source: losses.py */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { tidy, util } from '@tensorflow/tfjs-core';\nimport { epsilon } from './backend/common';\nimport * as K from './backend/tfjs_backend';\nimport { ValueError } from './errors';\n/**\n * Normalizes a tensor wrt the L2 norm alongside the specified axis.\n * @param x\n * @param axis Axis along which to perform normalization.\n */\nexport function l2Normalize(x, axis) {\n    return tidy(() => {\n        if (x.dtype !== 'float32') {\n            x = tfc.cast(x, 'float32');\n        }\n        const squareSum = tfc.sum(K.square(x), axis, true);\n        const epsilonTensor = tfc.fill(squareSum.shape, epsilon());\n        const norm = tfc.sqrt(tfc.maximum(squareSum, epsilonTensor));\n        return tfc.div(x, norm);\n    });\n}\nexport function meanSquaredError(yTrue, yPred) {\n    return tidy(() => tfc.mean(K.square(tfc.sub(yPred, yTrue)), -1));\n}\nexport function meanAbsoluteError(yTrue, yPred) {\n    return tidy(() => tfc.mean(tfc.abs(tfc.sub(yPred, yTrue)), -1));\n}\nexport function meanAbsolutePercentageError(yTrue, yPred) {\n    return tidy(() => {\n        const diff = tfc.sub(yTrue, yPred);\n        const clippedTrue = tfc.clipByValue(tfc.abs(yTrue), epsilon(), Number.MAX_VALUE);\n        const absResult = tfc.abs(tfc.div(diff, clippedTrue));\n        return tfc.mul(100, tfc.mean(absResult, -1));\n    });\n}\nexport function meanSquaredLogarithmicError(yTrue, yPred) {\n    return tidy(() => {\n        const clippedPred = tfc.clipByValue(yPred, epsilon(), Number.MAX_VALUE);\n        const firstLog = tfc.log(tfc.add(1, clippedPred));\n        const clippedTrue = tfc.clipByValue(yTrue, epsilon(), Number.MAX_VALUE);\n        const secondLog = tfc.log(tfc.add(1, clippedTrue));\n        return tfc.mean(K.square(tfc.sub(firstLog, secondLog)), -1);\n    });\n}\nexport function squaredHinge(yTrue, yPred) {\n    return tidy(() => {\n        const maxResult = tfc.maximum(0, tfc.sub(1, tfc.mul(yTrue, yPred)));\n        return tfc.mean(K.square(maxResult), -1);\n    });\n}\nexport function hinge(yTrue, yPred) {\n    return tidy(() => {\n        const maxResult = tfc.maximum(0, tfc.sub(1, tfc.mul(yTrue, yPred)));\n        return tfc.mean(maxResult, -1);\n    });\n}\nexport function categoricalHinge(yTrue, yPred) {\n    return tidy(() => {\n        const pos = tfc.sum(tfc.mul(yTrue, yPred), -1);\n        const neg = tfc.max(tfc.mul(tfc.sub(1, yTrue), yPred), -1);\n        return tfc.maximum(0, tfc.add(1, tfc.sub(neg, pos)));\n    });\n}\n/**\n * Logarithm of the hyperbolic cosine of the prediction error.\n *\n * `log(cosh(x))` is approximately equal to `(x ** 2) / 2` for small `x` and\n * to `abs(x) - log(2)` for large `x`. This means that 'logcosh' works mostly\n * like the mean squared error, but will not be so strongly affected by the\n * occasional wildly incorrect prediction.\n */\nexport function logcosh(yTrue, yPred) {\n    return tidy(() => {\n        const log2 = Math.log(2);\n        const predictionDiff = tfc.sub(yPred, yTrue);\n        const logcoshResult = tfc.sub(tfc.add(predictionDiff, tfc.softplus(tfc.mul(-2, predictionDiff))), log2);\n        return tfc.mean(logcoshResult, -1);\n    });\n}\nexport function categoricalCrossentropy(target, output, fromLogits = false) {\n    return tidy(() => {\n        if (fromLogits) {\n            output = tfc.softmax(output);\n        }\n        else {\n            // scale preds so that the class probabilities of each sample sum to 1.\n            const outputSum = tfc.sum(output, output.shape.length - 1, true);\n            output = tfc.div(output, outputSum);\n        }\n        output = tfc.clipByValue(output, epsilon(), 1 - epsilon());\n        return tfc.neg(tfc.sum(tfc.mul(tfc.cast(target, 'float32'), tfc.log(output)), output.shape.length - 1));\n    });\n}\n/**\n * Categorical crossentropy with integer targets.\n *\n * @param target An integer tensor.\n * @param output A tensor resulting from a softmax (unless `fromLogits` is\n *  `true`, in which case `output` is expected to be the logits).\n * @param fromLogits Boolean, whether `output` is the result of a softmax, or is\n *   a tensor of logits.\n */\nexport function sparseCategoricalCrossentropy(target, output, fromLogits = false) {\n    return tidy(() => {\n        const flatTarget = tfc.cast(tfc.floor(K.flatten(target)), 'int32');\n        output = tfc.clipByValue(output, epsilon(), 1 - epsilon());\n        const outputShape = output.shape;\n        const oneHotTarget = tfc.reshape(tfc.oneHot(flatTarget, outputShape[outputShape.length - 1]), outputShape);\n        return categoricalCrossentropy(oneHotTarget, output, fromLogits);\n    });\n}\n/**\n * From TensorFlow's implementation in nn_impl.py:\n *\n * For brevity, let `x = logits`, `z = labels`.  The logistic loss is\n *      z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))\n *    = z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))\n *    = z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))\n *    = z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))\n *    = (1 - z) * x + log(1 + exp(-x))\n *    = x - x * z + log(1 + exp(-x))\n * For x < 0, to avoid overflow in exp(-x), we reformulate the above\n *      x - x * z + log(1 + exp(-x))\n *    = log(exp(x)) - x * z + log(1 + exp(-x))\n *    = - x * z + log(1 + exp(x))\n * Hence, to ensure stability and avoid overflow, the implementation uses this\n * equivalent formulation\n *    max(x, 0) - x * z + log(1 + exp(-abs(x)))\n *\n * @param labels The labels.\n * @param logits The logits.\n */\nexport function sigmoidCrossEntropyWithLogits(labels, logits) {\n    if (!util.arraysEqual(labels.shape, logits.shape)) {\n        throw new ValueError(`logits and labels must have the same shape, but got shapes ` +\n            `${JSON.stringify(labels.shape)} and ${JSON.stringify(logits.shape)}`);\n    }\n    return tidy(() => {\n        // The logistic loss formula from above is\n        //   x - x * z + log(1 + exp(-x))\n        // For x < 0, a more numerically stable formula is\n        //   -x * z + log(1 + exp(x))\n        // Note that these two expressions can be combined into the following:\n        //   max(x, 0) - x * z + log(1 + exp(-abs(x)))\n        const reluLogits = tfc.relu(logits);\n        const negAbsLogits = tfc.neg(tfc.abs(logits));\n        return tfc.add(tfc.sub(reluLogits, tfc.mul(logits, labels)), tfc.log1p(tfc.exp(negAbsLogits)));\n    });\n}\nexport function binaryCrossentropy(yTrue, yPred) {\n    return tidy(() => {\n        let y;\n        y = tfc.clipByValue(yPred, epsilon(), 1 - epsilon());\n        y = tfc.log(tfc.div(y, tfc.sub(1, y)));\n        return tfc.mean(sigmoidCrossEntropyWithLogits(yTrue, y), -1);\n    });\n}\nexport function kullbackLeiblerDivergence(yTrue, yPred) {\n    return tidy(() => {\n        const clippedTrue = tfc.clipByValue(yTrue, epsilon(), 1);\n        const clippedPred = tfc.clipByValue(yPred, epsilon(), 1);\n        return tfc.sum(tfc.mul(yTrue, tfc.log(tfc.div(clippedTrue, clippedPred))), -1);\n    });\n}\nexport function poisson(yTrue, yPred) {\n    return tidy(() => {\n        const logPred = tfc.log(tfc.add(epsilon(), yPred));\n        return tfc.mean(tfc.sub(yPred, tfc.mul(yTrue, logPred)), -1);\n    });\n}\nexport function cosineProximity(yTrue, yPred) {\n    return tidy(() => {\n        const trueNormalized = l2Normalize(yTrue, -1);\n        const predNormalized = l2Normalize(yPred, -1);\n        const trueXPred = tfc.mul(trueNormalized, predNormalized);\n        return tfc.neg(tfc.sum(trueXPred, -1));\n    });\n}\nexport const mse = meanSquaredError;\nexport const MSE = meanSquaredError;\nexport const mae = meanAbsoluteError;\nexport const MAE = meanAbsoluteError;\nexport const mape = meanAbsolutePercentageError;\nexport const MAPE = meanAbsolutePercentageError;\nexport const msle = meanSquaredLogarithmicError;\nexport const MSLE = meanSquaredLogarithmicError;\nexport const kld = kullbackLeiblerDivergence;\nexport const KLD = kullbackLeiblerDivergence;\nexport const cosine = cosineProximity;\n// TODO(michaelterry): Add deserialize() function.\nexport const lossesMap = {\n    meanSquaredError,\n    meanAbsoluteError,\n    meanAbsolutePercentageError,\n    meanSquaredLogarithmicError,\n    squaredHinge,\n    hinge,\n    categoricalHinge,\n    logcosh,\n    categoricalCrossentropy,\n    sparseCategoricalCrossentropy,\n    binaryCrossentropy,\n    kullbackLeiblerDivergence,\n    poisson,\n    cosineProximity\n};\n// Porting note: This diverges from the PyKeras implementation and may need to\n// change based on (de)serialization requirements.\nexport function get(identifierOrFn) {\n    if (typeof identifierOrFn === 'string') {\n        if (identifierOrFn in lossesMap) {\n            return lossesMap[identifierOrFn];\n        }\n        let errMsg = `Unknown loss ${identifierOrFn}`;\n        if (identifierOrFn.toLowerCase().includes('softmaxcrossentropy')) {\n            errMsg = `Unknown loss ${identifierOrFn}. ` +\n                'Use \"categoricalCrossentropy\" as the string name for ' +\n                'tf.losses.softmaxCrossEntropy';\n        }\n        throw new ValueError(errMsg);\n    }\n    else {\n        return identifierOrFn;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9zc2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2xvc3Nlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVILGdDQUFnQztBQUNoQyxPQUFPLEtBQUssR0FBRyxNQUFNLHVCQUF1QixDQUFDO0FBQzdDLE9BQU8sRUFBbUIsSUFBSSxFQUFFLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRW5FLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUN6QyxPQUFPLEtBQUssQ0FBQyxNQUFNLHdCQUF3QixDQUFDO0FBQzVDLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFHcEM7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQUMsQ0FBUyxFQUFFLElBQWE7SUFDbEQsT0FBTyxJQUFJLENBQUMsR0FBRyxFQUFFO1FBQ2YsSUFBSSxDQUFDLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBRTtZQUN6QixDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDNUI7UUFDRCxNQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ25ELE1BQU0sYUFBYSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQzNELE1BQU0sSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQztRQUM3RCxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzFCLENBQUMs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SUFDM0IsWUFBWTtJQUNaLEtBQUs7SUFDTCxnQkFBZ0I7SUFDaEIsT0FBTztJQUNQLHVCQUF1QjtJQUN2Qiw2QkFBNkI7SUFDN0Isa0JBQWtCO0lBQ2xCLHlCQUF5QjtJQUN6QixPQUFPO0lBQ1AsZUFBZTtDQUNoQixDQUFDO0FBRUYsOEVBQThFO0FBQzlFLGtEQUFrRDtBQUNsRCxNQUFNLFVBQVUsR0FBRyxDQUFDLGNBQXFDO0lBQ3ZELElBQUksT0FBTyxjQUFjLEtBQUssUUFBUSxFQUFFO1FBQ3RDLElBQUksY0FBYyxJQUFJLFNBQVMsRUFBRTtZQUMvQixPQUFPLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUNsQztRQUNELElBQUksTUFBTSxHQUFHLGdCQUFnQixjQUFjLEVBQUUsQ0FBQztRQUM5QyxJQUFJLGNBQWMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMscUJBQXFCLENBQUMsRUFBRTtZQUNoRSxNQUFNLEdBQUcsZ0JBQWdCLGNBQWMsSUFBSTtnQkFDdkMsdURBQXVEO2dCQUN2RCwrQkFBK0IsQ0FBQztTQUNyQztRQUNELE1BQU0sSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDOUI7U0FBTTtRQUNMLE9BQU8sY0FBYyxDQUFDO0tBQ3ZCO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qIE9yaWdpbmFsIFNvdXJjZTogbG9zc2VzLnB5ICovXG5pbXBvcnQgKiBhcyB0ZmMgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7VGVuc29yLCBUZW5zb3IxRCwgdGlkeSwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtlcHNpbG9ufSBmcm9tICcuL2JhY2tlbmQvY29tbW9uJztcbmltcG9ydCAqIGFzIEsgZnJvbSAnLi9iYWNrZW5kL3RmanNfYmFja2VuZCc7XG5pbXBvcnQge1ZhbHVlRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7TG9zc09yTWV0cmljRm59IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSB0ZW5zb3Igd3J0IHRoZSBMMiBub3JtIGFsb25nc2lkZSB0aGUgc3BlY2lmaWVkIGF4aXMuXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIGF4aXMgQXhpcyBhbG9uZyB3aGljaCB0byBwZXJmb3JtIG5vcm1hbGl6YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsMk5vcm1hbGl6ZSh4OiBUZW5zb3IsIGF4aXM/OiBudW1iZXIpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgaWYgKHguZHR5cGUgIT09ICdmbG9hdDMyJykge1xuICAgICAgeCA9IHRmYy5jYXN0KHgsICdmbG9hdDMyJyk7XG4gICAgfVxuICAgIGNvbnN0IHNxdWFyZVN1bSA9IHRmYy5zdW0oSy5zcXVhcmUoeCksIGF4aXMsIHRydWUpO1xuICAgIGNvbnN0IGVwc2lsb25UZW5zb3IgPSB0ZmMuZmlsbChzcXVhcmVTdW0uc2hhcGUsIGVwc2lsb24oKSk7XG4gICAgY29uc3Qgbm9ybSA9IHRmYy5zcXJ0KHRmYy5tYXhpbXVtKHNxdWFyZVN1bSwgZXBzaWxvblRlbnNvcikpO1xuICAgIHJldHVybiB0ZmMuZGl2KHgsIG5vcm0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lYW5TcXVhcmVkRXJyb3IoeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHRmYy5tZWFuKEsuc3F1YXJlKHRmYy5zdWIoeVByZWQsIHlUcnVlKSksIC0xKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZWFuQWJzb2x1dGVFcnJvcih5VHJ1ZTogVGVuc29yLCB5UHJlZDogVGVuc29yKTogVGVuc29yIHtcbiAgcmV0dXJuIHRpZHkoKCkgPT4gdGZjLm1lYW4odGZjLmFicyh0ZmMuc3ViKHlQcmVkLCB5VHJ1ZSkpLCAtMSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yKFxuICAgIHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgY29uc3QgZGlmZiA9IHRmYy5zdWIoeVRydWUsIHlQcmVkKTtcbiAgICBjb25zdCBjbGlwcGVkVHJ1ZSA9XG4gICAgICAgIHRmYy5jbGlwQnlWYWx1ZSh0ZmMuYWJzKHlUcnVlKSwgZXBzaWxvbigpLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICBjb25zdCBhYnNSZXN1bHQgPSB0ZmMuYWJzKHRmYy5kaXYoZGlmZiwgY2xpcHBlZFRydWUpKTtcbiAgICByZXR1cm4gdGZjLm11bCgxMDAsIHRmYy5tZWFuKGFic1Jlc3VsdCwgLTEpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3IoXG4gICAgeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCBjbGlwcGVkUHJlZCA9IHRmYy5jbGlwQnlWYWx1ZSh5UHJlZCwgZXBzaWxvbigpLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICBjb25zdCBmaXJzdExvZyA9IHRmYy5sb2codGZjLmFkZCgxLCBjbGlwcGVkUHJlZCkpO1xuXG4gICAgY29uc3QgY2xpcHBlZFRydWUgPSB0ZmMuY2xpcEJ5VmFsdWUoeVRydWUsIGVwc2lsb24oKSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgY29uc3Qgc2Vjb25kTG9nID0gdGZjLmxvZyh0ZmMuYWRkKDEsIGNsaXBwZWRUcnVlKSk7XG5cbiAgICByZXR1cm4gdGZjLm1lYW4oSy5zcXVhcmUodGZjLnN1YihmaXJzdExvZywgc2Vjb25kTG9nKSksIC0xKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkSGluZ2UoeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCBtYXhSZXN1bHQgPSB0ZmMubWF4aW11bSgwLCB0ZmMuc3ViKDEsIHRmYy5tdWwoeVRydWUsIHlQcmVkKSkpO1xuICAgIHJldHVybiB0ZmMubWVhbihLLnNxdWFyZShtYXhSZXN1bHQpLCAtMSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGluZ2UoeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCBtYXhSZXN1bHQgPSB0ZmMubWF4aW11bSgwLCB0ZmMuc3ViKDEsIHRmYy5tdWwoeVRydWUsIHlQcmVkKSkpO1xuICAgIHJldHVybiB0ZmMubWVhbihtYXhSZXN1bHQsIC0xKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXRlZ29yaWNhbEhpbmdlKHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgY29uc3QgcG9zID0gdGZjLnN1bSh0ZmMubXVsKHlUcnVlLCB5UHJlZCksIC0xKTtcbiAgICBjb25zdCBuZWcgPSB0ZmMubWF4KHRmYy5tdWwodGZjLnN1YigxLCB5VHJ1ZSksIHlQcmVkKSwgLTEpO1xuICAgIHJldHVybiB0ZmMubWF4aW11bSgwLCB0ZmMuYWRkKDEsIHRmYy5zdWIobmVnLCBwb3MpKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIExvZ2FyaXRobSBvZiB0aGUgaHlwZXJib2xpYyBjb3NpbmUgb2YgdGhlIHByZWRpY3Rpb24gZXJyb3IuXG4gKlxuICogYGxvZyhjb3NoKHgpKWAgaXMgYXBwcm94aW1hdGVseSBlcXVhbCB0byBgKHggKiogMikgLyAyYCBmb3Igc21hbGwgYHhgIGFuZFxuICogdG8gYGFicyh4KSAtIGxvZygyKWAgZm9yIGxhcmdlIGB4YC4gVGhpcyBtZWFucyB0aGF0ICdsb2djb3NoJyB3b3JrcyBtb3N0bHlcbiAqIGxpa2UgdGhlIG1lYW4gc3F1YXJlZCBlcnJvciwgYnV0IHdpbGwgbm90IGJlIHNvIHN0cm9uZ2x5IGFmZmVjdGVkIGJ5IHRoZVxuICogb2NjYXNpb25hbCB3aWxkbHkgaW5jb3JyZWN0IHByZWRpY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2djb3NoKHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgY29uc3QgbG9nMiA9IE1hdGgubG9nKDIpO1xuICAgIGNvbnN0IHByZWRpY3Rpb25EaWZmID0gdGZjLnN1Yih5UHJlZCwgeVRydWUpO1xuICAgIGNvbnN0IGxvZ2Nvc2hSZXN1bHQgPSB0ZmMuc3ViKFxuICAgICAgICB0ZmMuYWRkKHByZWRpY3Rpb25EaWZmLCB0ZmMuc29mdHBsdXModGZjLm11bCgtMiwgcHJlZGljdGlvbkRpZmYpKSksXG4gICAgICAgIGxvZzIpO1xuICAgIHJldHVybiB0ZmMubWVhbihsb2djb3NoUmVzdWx0LCAtMSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkoXG4gICAgdGFyZ2V0OiBUZW5zb3IsIG91dHB1dDogVGVuc29yLCBmcm9tTG9naXRzID0gZmFsc2UpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgaWYgKGZyb21Mb2dpdHMpIHtcbiAgICAgIG91dHB1dCA9IHRmYy5zb2Z0bWF4KG91dHB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNjYWxlIHByZWRzIHNvIHRoYXQgdGhlIGNsYXNzIHByb2JhYmlsaXRpZXMgb2YgZWFjaCBzYW1wbGUgc3VtIHRvIDEuXG4gICAgICBjb25zdCBvdXRwdXRTdW0gPSB0ZmMuc3VtKG91dHB1dCwgb3V0cHV0LnNoYXBlLmxlbmd0aCAtIDEsIHRydWUpO1xuICAgICAgb3V0cHV0ID0gdGZjLmRpdihvdXRwdXQsIG91dHB1dFN1bSk7XG4gICAgfVxuICAgIG91dHB1dCA9IHRmYy5jbGlwQnlWYWx1ZShvdXRwdXQsIGVwc2lsb24oKSwgMSAtIGVwc2lsb24oKSk7XG4gICAgcmV0dXJuIHRmYy5uZWcodGZjLnN1bShcbiAgICAgICAgdGZjLm11bCh0ZmMuY2FzdCh0YXJnZXQsICdmbG9hdDMyJyksIHRmYy5sb2cob3V0cHV0KSksXG4gICAgICAgIG91dHB1dC5zaGFwZS5sZW5ndGggLSAxKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENhdGVnb3JpY2FsIGNyb3NzZW50cm9weSB3aXRoIGludGVnZXIgdGFyZ2V0cy5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IEFuIGludGVnZXIgdGVuc29yLlxuICogQHBhcmFtIG91dHB1dCBBIHRlbnNvciByZXN1bHRpbmcgZnJvbSBhIHNvZnRtYXggKHVubGVzcyBgZnJvbUxvZ2l0c2AgaXNcbiAqICBgdHJ1ZWAsIGluIHdoaWNoIGNhc2UgYG91dHB1dGAgaXMgZXhwZWN0ZWQgdG8gYmUgdGhlIGxvZ2l0cykuXG4gKiBAcGFyYW0gZnJvbUxvZ2l0cyBCb29sZWFuLCB3aGV0aGVyIGBvdXRwdXRgIGlzIHRoZSByZXN1bHQgb2YgYSBzb2Z0bWF4LCBvciBpc1xuICogICBhIHRlbnNvciBvZiBsb2dpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weShcbiAgICB0YXJnZXQ6IFRlbnNvciwgb3V0cHV0OiBUZW5zb3IsIGZyb21Mb2dpdHMgPSBmYWxzZSk6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCBmbGF0VGFyZ2V0ID1cbiAgICAgICAgdGZjLmNhc3QodGZjLmZsb29yKEsuZmxhdHRlbih0YXJnZXQpKSwgJ2ludDMyJykgYXMgVGVuc29yMUQ7XG4gICAgb3V0cHV0ID0gdGZjLmNsaXBCeVZhbHVlKG91dHB1dCwgZXBzaWxvbigpLCAxIC0gZXBzaWxvbigpKTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IG91dHB1dC5zaGFwZTtcbiAgICBjb25zdCBvbmVIb3RUYXJnZXQgPSB0ZmMucmVzaGFwZShcbiAgICAgICAgdGZjLm9uZUhvdChmbGF0VGFyZ2V0LCBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxXSksXG4gICAgICAgIG91dHB1dFNoYXBlKTtcbiAgICByZXR1cm4gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkob25lSG90VGFyZ2V0LCBvdXRwdXQsIGZyb21Mb2dpdHMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBGcm9tIFRlbnNvckZsb3cncyBpbXBsZW1lbnRhdGlvbiBpbiBubl9pbXBsLnB5OlxuICpcbiAqIEZvciBicmV2aXR5LCBsZXQgYHggPSBsb2dpdHNgLCBgeiA9IGxhYmVsc2AuICBUaGUgbG9naXN0aWMgbG9zcyBpc1xuICogICAgICB6ICogLWxvZyhzaWdtb2lkKHgpKSArICgxIC0geikgKiAtbG9nKDEgLSBzaWdtb2lkKHgpKVxuICogICAgPSB6ICogLWxvZygxIC8gKDEgKyBleHAoLXgpKSkgKyAoMSAtIHopICogLWxvZyhleHAoLXgpIC8gKDEgKyBleHAoLXgpKSlcbiAqICAgID0geiAqIGxvZygxICsgZXhwKC14KSkgKyAoMSAtIHopICogKC1sb2coZXhwKC14KSkgKyBsb2coMSArIGV4cCgteCkpKVxuICogICAgPSB6ICogbG9nKDEgKyBleHAoLXgpKSArICgxIC0geikgKiAoeCArIGxvZygxICsgZXhwKC14KSlcbiAqICAgID0gKDEgLSB6KSAqIHggKyBsb2coMSArIGV4cCgteCkpXG4gKiAgICA9IHggLSB4ICogeiArIGxvZygxICsgZXhwKC14KSlcbiAqIEZvciB4IDwgMCwgdG8gYXZvaWQgb3ZlcmZsb3cgaW4gZXhwKC14KSwgd2UgcmVmb3JtdWxhdGUgdGhlIGFib3ZlXG4gKiAgICAgIHggLSB4ICogeiArIGxvZygxICsgZXhwKC14KSlcbiAqICAgID0gbG9nKGV4cCh4KSkgLSB4ICogeiArIGxvZygxICsgZXhwKC14KSlcbiAqICAgID0gLSB4ICogeiArIGxvZygxICsgZXhwKHgpKVxuICogSGVuY2UsIHRvIGVuc3VyZSBzdGFiaWxpdHkgYW5kIGF2b2lkIG92ZXJmbG93LCB0aGUgaW1wbGVtZW50YXRpb24gdXNlcyB0aGlzXG4gKiBlcXVpdmFsZW50IGZvcm11bGF0aW9uXG4gKiAgICBtYXgoeCwgMCkgLSB4ICogeiArIGxvZygxICsgZXhwKC1hYnMoeCkpKVxuICpcbiAqIEBwYXJhbSBsYWJlbHMgVGhlIGxhYmVscy5cbiAqIEBwYXJhbSBsb2dpdHMgVGhlIGxvZ2l0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzKFxuICAgIGxhYmVsczogVGVuc29yLCBsb2dpdHM6IFRlbnNvcik6IFRlbnNvciB7XG4gIGlmICghdXRpbC5hcnJheXNFcXVhbChsYWJlbHMuc2hhcGUsIGxvZ2l0cy5zaGFwZSkpIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgYGxvZ2l0cyBhbmQgbGFiZWxzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZSwgYnV0IGdvdCBzaGFwZXMgYCArXG4gICAgICAgIGAke0pTT04uc3RyaW5naWZ5KGxhYmVscy5zaGFwZSl9IGFuZCAke0pTT04uc3RyaW5naWZ5KGxvZ2l0cy5zaGFwZSl9YCk7XG4gIH1cbiAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgIC8vIFRoZSBsb2dpc3RpYyBsb3NzIGZvcm11bGEgZnJvbSBhYm92ZSBpc1xuICAgIC8vICAgeCAtIHggKiB6ICsgbG9nKDEgKyBleHAoLXgpKVxuICAgIC8vIEZvciB4IDwgMCwgYSBtb3JlIG51bWVyaWNhbGx5IHN0YWJsZSBmb3JtdWxhIGlzXG4gICAgLy8gICAteCAqIHogKyBsb2coMSArIGV4cCh4KSlcbiAgICAvLyBOb3RlIHRoYXQgdGhlc2UgdHdvIGV4cHJlc3Npb25zIGNhbiBiZSBjb21iaW5lZCBpbnRvIHRoZSBmb2xsb3dpbmc6XG4gICAgLy8gICBtYXgoeCwgMCkgLSB4ICogeiArIGxvZygxICsgZXhwKC1hYnMoeCkpKVxuICAgIGNvbnN0IHJlbHVMb2dpdHMgPSB0ZmMucmVsdShsb2dpdHMpO1xuICAgIGNvbnN0IG5lZ0Fic0xvZ2l0cyA9IHRmYy5uZWcodGZjLmFicyhsb2dpdHMpKTtcbiAgICByZXR1cm4gdGZjLmFkZChcbiAgICAgICAgdGZjLnN1YihyZWx1TG9naXRzLCB0ZmMubXVsKGxvZ2l0cywgbGFiZWxzKSksXG4gICAgICAgIHRmYy5sb2cxcCh0ZmMuZXhwKG5lZ0Fic0xvZ2l0cykpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlDcm9zc2VudHJvcHkoeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBsZXQgeTogVGVuc29yO1xuICAgIHkgPSB0ZmMuY2xpcEJ5VmFsdWUoeVByZWQsIGVwc2lsb24oKSwgMSAtIGVwc2lsb24oKSk7XG4gICAgeSA9IHRmYy5sb2codGZjLmRpdih5LCB0ZmMuc3ViKDEsIHkpKSk7XG4gICAgcmV0dXJuIHRmYy5tZWFuKHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzKHlUcnVlLCB5KSwgLTEpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGt1bGxiYWNrTGVpYmxlckRpdmVyZ2VuY2UoXG4gICAgeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCBjbGlwcGVkVHJ1ZSA9IHRmYy5jbGlwQnlWYWx1ZSh5VHJ1ZSwgZXBzaWxvbigpLCAxKTtcbiAgICBjb25zdCBjbGlwcGVkUHJlZCA9IHRmYy5jbGlwQnlWYWx1ZSh5UHJlZCwgZXBzaWxvbigpLCAxKTtcbiAgICByZXR1cm4gdGZjLnN1bShcbiAgICAgICAgdGZjLm11bCh5VHJ1ZSwgdGZjLmxvZyh0ZmMuZGl2KGNsaXBwZWRUcnVlLCBjbGlwcGVkUHJlZCkpKSwgLTEpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaXNzb24oeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCBsb2dQcmVkID0gdGZjLmxvZyh0ZmMuYWRkKGVwc2lsb24oKSwgeVByZWQpKTtcbiAgICByZXR1cm4gdGZjLm1lYW4odGZjLnN1Yih5UHJlZCwgdGZjLm11bCh5VHJ1ZSwgbG9nUHJlZCkpLCAtMSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29zaW5lUHJveGltaXR5KHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgY29uc3QgdHJ1ZU5vcm1hbGl6ZWQgPSBsMk5vcm1hbGl6ZSh5VHJ1ZSwgLTEpO1xuICAgIGNvbnN0IHByZWROb3JtYWxpemVkID0gbDJOb3JtYWxpemUoeVByZWQsIC0xKTtcbiAgICBjb25zdCB0cnVlWFByZWQgPSB0ZmMubXVsKHRydWVOb3JtYWxpemVkLCBwcmVkTm9ybWFsaXplZCk7XG4gICAgcmV0dXJuIHRmYy5uZWcodGZjLnN1bSh0cnVlWFByZWQsIC0xKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgbXNlID0gbWVhblNxdWFyZWRFcnJvcjtcbmV4cG9ydCBjb25zdCBNU0UgPSBtZWFuU3F1YXJlZEVycm9yO1xuZXhwb3J0IGNvbnN0IG1hZSA9IG1lYW5BYnNvbHV0ZUVycm9yO1xuZXhwb3J0IGNvbnN0IE1BRSA9IG1lYW5BYnNvbHV0ZUVycm9yO1xuZXhwb3J0IGNvbnN0IG1hcGUgPSBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3I7XG5leHBvcnQgY29uc3QgTUFQRSA9IG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcjtcbmV4cG9ydCBjb25zdCBtc2xlID0gbWVhblNxdWFyZWRMb2dhcml0aG1pY0Vycm9yO1xuZXhwb3J0IGNvbnN0IE1TTEUgPSBtZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3I7XG5leHBvcnQgY29uc3Qga2xkID0ga3VsbGJhY2tMZWlibGVyRGl2ZXJnZW5jZTtcbmV4cG9ydCBjb25zdCBLTEQgPSBrdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlO1xuZXhwb3J0IGNvbnN0IGNvc2luZSA9IGNvc2luZVByb3hpbWl0eTtcblxuLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBBZGQgZGVzZXJpYWxpemUoKSBmdW5jdGlvbi5cblxuZXhwb3J0IGNvbnN0IGxvc3Nlc01hcDoge1tmdW5jdGlvbk5hbWU6IHN0cmluZ106IExvc3NPck1ldHJpY0ZufSA9IHtcbiAgbWVhblNxdWFyZWRFcnJvcixcbiAgbWVhbkFic29sdXRlRXJyb3IsXG4gIG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcixcbiAgbWVhblNxdWFyZWRMb2dhcml0aG1pY0Vycm9yLFxuICBzcXVhcmVkSGluZ2UsXG4gIGhpbmdlLFxuICBjYXRlZ29yaWNhbEhpbmdlLFxuICBsb2djb3NoLFxuICBjYXRlZ29yaWNhbENyb3NzZW50cm9weSxcbiAgc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHksXG4gIGJpbmFyeUNyb3NzZW50cm9weSxcbiAga3VsbGJhY2tMZWlibGVyRGl2ZXJnZW5jZSxcbiAgcG9pc3NvbixcbiAgY29zaW5lUHJveGltaXR5XG59O1xuXG4vLyBQb3J0aW5nIG5vdGU6IFRoaXMgZGl2ZXJnZXMgZnJvbSB0aGUgUHlLZXJhcyBpbXBsZW1lbnRhdGlvbiBhbmQgbWF5IG5lZWQgdG9cbi8vIGNoYW5nZSBiYXNlZCBvbiAoZGUpc2VyaWFsaXphdGlvbiByZXF1aXJlbWVudHMuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGlkZW50aWZpZXJPckZuOiBzdHJpbmd8TG9zc09yTWV0cmljRm4pOiBMb3NzT3JNZXRyaWNGbiB7XG4gIGlmICh0eXBlb2YgaWRlbnRpZmllck9yRm4gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGlkZW50aWZpZXJPckZuIGluIGxvc3Nlc01hcCkge1xuICAgICAgcmV0dXJuIGxvc3Nlc01hcFtpZGVudGlmaWVyT3JGbl07XG4gICAgfVxuICAgIGxldCBlcnJNc2cgPSBgVW5rbm93biBsb3NzICR7aWRlbnRpZmllck9yRm59YDtcbiAgICBpZiAoaWRlbnRpZmllck9yRm4udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnc29mdG1heGNyb3NzZW50cm9weScpKSB7XG4gICAgICBlcnJNc2cgPSBgVW5rbm93biBsb3NzICR7aWRlbnRpZmllck9yRm59LiBgICtcbiAgICAgICAgICAnVXNlIFwiY2F0ZWdvcmljYWxDcm9zc2VudHJvcHlcIiBhcyB0aGUgc3RyaW5nIG5hbWUgZm9yICcgK1xuICAgICAgICAgICd0Zi5sb3NzZXMuc29mdG1heENyb3NzRW50cm9weSc7XG4gICAgfVxuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGVyck1zZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXJPckZuO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { dispose } from '@tensorflow/tfjs-core';\n/**\n * Turn any Scalar values in a Logs object into actual number values.\n *\n * @param logs The `Logs` object to be resolved in place.\n */\nexport async function resolveScalarsInLogs(logs) {\n    if (logs == null) {\n        return;\n    }\n    const promises = [];\n    const keys = [];\n    const scalarsToDispose = [];\n    for (const key in logs) {\n        const value = logs[key];\n        if (typeof value !== 'number') {\n            const valueScalar = value;\n            promises.push(valueScalar.data());\n            keys.push(key);\n            scalarsToDispose.push(valueScalar);\n        }\n    }\n    if (promises.length > 0) {\n        const values = await Promise.all(promises);\n        for (let i = 0; i < values.length; ++i) {\n            logs[keys[i]] = values[i][0];\n        }\n        // Dispose the original scalar tensors.\n        dispose(scalarsToDispose);\n    }\n}\n/**\n * Dispose all Tensors in an UnresolvedLogs object.\n *\n * @param logs An `UnresolvedLogs` object potentially containing `tf.Tensor`s in\n *   places where the values can be `tf.Tensor` or `number`.\n */\nexport function disposeTensorsInLogs(logs) {\n    if (logs == null) {\n        return;\n    }\n    for (const key in logs) {\n        const value = logs[key];\n        if (typeof value !== 'number') {\n            value.dispose();\n        }\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9ncy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9sb2dzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsT0FBTyxFQUFDLE9BQU8sRUFBUyxNQUFNLHVCQUF1QixDQUFDO0FBV3REOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsS0FBSyxVQUFVLG9CQUFvQixDQUFDLElBQW9CO0lBQzdELElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtRQUNoQixPQUFPO0tBQ1I7SUFDRCxNQUFNLFFBQVEsR0FBdUQsRUFBRSxDQUFDO0lBQ3hFLE1BQU0sSUFBSSxHQUFhLEVBQUUsQ0FBQztJQUMxQixNQUFNLGdCQUFnQixHQUFhLEVBQUUsQ0FBQztJQUN0QyxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTtRQUN0QixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7WUFDN0IsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDO1lBQzFCLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7WUFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNmLGdCQUFnQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUNwQztLQUNGO0lBQ0QsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUN2QixNQUFNLE1BQU0sR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDM0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUU7WUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUM5QjtRQUNELHVDQUF1QztRQUN2QyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztLQUMzQjtBQUNILENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxvQkFBb0IsQ0FBQyxJQUFvQjtJQUN2RCxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7UUFDaEIsT0FBTztLQUNSO0lBQ0QsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUU7UUFDdEIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hCLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO1lBQzdCLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUNqQjtLQUNGO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7ZGlzcG9zZSwgU2NhbGFyfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG4vKipcbiAqIExvZ3MgaW4gd2hpY2ggdmFsdWVzIGNhbiBiZSBlaXRoZXIgbnVtYmVycyBvciBUZW5zb3JzIChTY2FsYXJzKS5cbiAqXG4gKiBVc2VkIGludGVybmFsbHkuXG4gKi9cbmV4cG9ydCB0eXBlIFVucmVzb2x2ZWRMb2dzID0ge1xuICBba2V5OiBzdHJpbmddOiBudW1iZXJ8U2NhbGFyO1xufTtcblxuLyoqXG4gKiBUdXJuIGFueSBTY2FsYXIgdmFsdWVzIGluIGEgTG9ncyBvYmplY3QgaW50byBhY3R1YWwgbnVtYmVyIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gbG9ncyBUaGUgYExvZ3NgIG9iamVjdCB0byBiZSByZXNvbHZlZCBpbiBwbGFjZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVTY2FsYXJzSW5Mb2dzKGxvZ3M6IFVucmVzb2x2ZWRMb2dzKSB7XG4gIGlmIChsb2dzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8RmxvYXQzMkFycmF5fEludDMyQXJyYXl8VWludDhBcnJheT4+ID0gW107XG4gIGNvbnN0IGtleXM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IHNjYWxhcnNUb0Rpc3Bvc2U6IFNjYWxhcltdID0gW107XG4gIGZvciAoY29uc3Qga2V5IGluIGxvZ3MpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGxvZ3Nba2V5XTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgdmFsdWVTY2FsYXIgPSB2YWx1ZTtcbiAgICAgIHByb21pc2VzLnB1c2godmFsdWVTY2FsYXIuZGF0YSgpKTtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgc2NhbGFyc1RvRGlzcG9zZS5wdXNoKHZhbHVlU2NhbGFyKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb21pc2VzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxvZ3Nba2V5c1tpXV0gPSB2YWx1ZXNbaV1bMF07XG4gICAgfVxuICAgIC8vIERpc3Bvc2UgdGhlIG9yaWdpbmFsIHNjYWxhciB0ZW5zb3JzLlxuICAgIGRpc3Bvc2Uoc2NhbGFyc1RvRGlzcG9zZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwb3NlIGFsbCBUZW5zb3JzIGluIGFuIFVucmVzb2x2ZWRMb2dzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbG9ncyBBbiBgVW5yZXNvbHZlZExvZ3NgIG9iamVjdCBwb3RlbnRpYWxseSBjb250YWluaW5nIGB0Zi5UZW5zb3JgcyBpblxuICogICBwbGFjZXMgd2hlcmUgdGhlIHZhbHVlcyBjYW4gYmUgYHRmLlRlbnNvcmAgb3IgYG51bWJlcmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlVGVuc29yc0luTG9ncyhsb2dzOiBVbnJlc29sdmVkTG9ncykge1xuICBpZiAobG9ncyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGxvZ3MpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGxvZ3Nba2V5XTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIExvZ3MgaW4gd2hpY2ggdmFsdWVzIGNhbiBvbmx5IGJlIG51bWJlcnMuXG4gKlxuICogVXNlZCB3aGVuIGNhbGxpbmcgY2xpZW50LXByb3ZpZGVkIGN1c3RvbSBjYWxsYmFja3MuXG4gKi9cbmV4cG9ydCB0eXBlIExvZ3MgPSB7XG4gIFtrZXk6IHN0cmluZ106IG51bWJlcjtcbn07XG4iXX0="],"names":["binaryAccuracy","yTrue","yPred","tidy","threshold","yPredThresholded","dtype","categoricalAccuracy","truePositives","binaryCrossentropy","sparseCategoricalAccuracy","rank","mse","MSE","mae","MAE","mape","MAPE","categoricalCrossentropy","cosine","sparseCategoricalCrossentropy","metricsMap","precision","tp","fp","falsePositives","denominator","get","identifier","getLossOrMetricName","fn","fnName","key","Object","keys","undefined","name","l2Normalize","x","axis","squareSum","epsilonTensor","shape","norm","meanSquaredError","meanAbsoluteError","meanAbsolutePercentageError","diff","clippedTrue","Number","MAX_VALUE","absResult","meanSquaredLogarithmicError","clippedPred","firstLog","secondLog","target","output","fromLogits","outputSum","length","flatTarget","outputShape","y","labels","logits","util","JSON","stringify","reluLogits","negAbsLogits","sigmoidCrossEntropyWithLogits","kullbackLeiblerDivergence","cosineProximity","trueNormalized","predNormalized","trueXPred","lossesMap","squaredHinge","maxResult","hinge","categoricalHinge","pos","neg","logcosh","log2","Math","log","predictionDiff","logcoshResult","poisson","logPred","identifierOrFn","errMsg","toLowerCase","includes","async","resolveScalarsInLogs","logs","promises","scalarsToDispose","value","valueScalar","push","data","values","Promise","all","i","dispose","disposeTensorsInLogs"],"sourceRoot":""}