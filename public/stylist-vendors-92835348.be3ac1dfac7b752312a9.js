"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[3811],{15685:function(e,t,n){n.d(t,{i:function(){return o}});const o={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8}},16121:function(e,t,n){n.d(t,{U:function(){return r}});var o=n(45119);function r(e,t,n,r){!function(e){(0,o.vA)(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){(0,o.vA)(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),(0,o.vA)(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),(0,o.vA)(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map((o=>(o.then((o=>{const i=n+ ++s/e.length*(r-n);return t(i),o})),o))))}},24278:function(e,t,n){n.r(t),n.d(t,{browserFiles:function(){return c},browserHTTPRequest:function(){return p},concatenateArrayBuffers:function(){return r.AQ},copyModel:function(){return b.xk},decodeWeights:function(){return r.CY},encodeWeights:function(){return r.aG},fromMemory:function(){return S},getLoadHandlers:function(){return s.C9},getModelArtifactsInfoForJSON:function(){return r.oR},getSaveHandlers:function(){return s.x3},http:function(){return m},isHTTPScheme:function(){return f},listModels:function(){return b.D},loadWeights:function(){return d.Ic},moveModel:function(){return b.Vo},registerLoadRouter:function(){return s.R4},registerSaveRouter:function(){return s.Yd},removeModel:function(){return b.az},weightsLoaderFactory:function(){return d.j$},withSaveHandler:function(){return v}});n(30522),n(76745),n(66652);var o=n(46574),r=n(77084),s=n(46669);function i(e){return new Promise((e=>setTimeout(e))).then(e)}class a{constructor(e){if(!(0,o._K)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(a.URL_SCHEME)&&(e=e.slice(a.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelTopologyFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:n};null!=e.signature&&(o.signature=e.signature),null!=e.userDefinedMetadata&&(o.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(o.modelInitializer=e.modelInitializer);const s=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=null==this.jsonAnchor?document.createElement("a"):this.jsonAnchor;if(a.download=this.modelTopologyFileName,a.href=s,await i((()=>a.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await i((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:(0,r.oR)(e)}}}}a.URL_SCHEME="downloads://";class l{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.files=e}async load(){const e=this.files[0],t=this.files.slice(1);return new Promise(((n,o)=>{const s=new FileReader;s.onload=s=>{const i=JSON.parse(s.target.result),a=i.modelTopology;if(null==a)return void o(new Error(`modelTopology field is missing from file ${e.name}`));0===t.length&&n({modelTopology:a});const l=i.weightsManifest;if(null==l)return void o(new Error(`weightManifest field is missing from file ${e.name}`));let c;try{c=this.checkManifestAndWeightFiles(l,t)}catch(f){return void o(f)}const u=[],d=[],h=[];l.forEach((e=>{e.paths.forEach((e=>{d.push(e),h.push(null)})),u.push(...e.weights)})),l.forEach((e=>{e.paths.forEach((e=>{const t=new FileReader;t.onload=t=>{const o=t.target.result,s=d.indexOf(e);if(h[s]=o,-1===h.indexOf(null)){const e={modelTopology:a,weightSpecs:u,weightData:(0,r.AQ)(h),format:i.format,generatedBy:i.generatedBy,convertedBy:i.convertedBy};null!=i.signature&&(e.signature=i.signature),null!=i.userDefinedMetadata&&(e.userDefinedMetadata=i.userDefinedMetadata),null!=i.modelInitializer&&(e.modelInitializer=i.modelInitializer),n(e)}},t.onerror=t=>o(`Failed to weights data from file of path '${e}'.`),t.readAsArrayBuffer(c[e])}))}))},s.onerror=t=>o(`Failed to read model topology and weights manifest JSON from file '${e.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(e)}))}checkManifestAndWeightFiles(e,t){const n=[],o=t.map((e=>(0,r.P8)(e.name))),s={};for(const i of e)i.paths.forEach((e=>{const i=(0,r.P8)(e);if(-1!==n.indexOf(i))throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(n.push(i),-1===o.indexOf(i))throw new Error(`Weight file with basename '${i}' is not provided.`);s[e]=t[o.indexOf(i)]}));if(n.length!==t.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${t.length}).`);return s}}function c(e){return new l(e)}s.bM.registerSaveRouter((e=>(0,o._K)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(a.URL_SCHEME)?function(e="model"){return new a(e)}(e.slice(a.URL_SCHEME.length)):null));var u=n(45119),d=n(66519);class h{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?((0,u.vA)("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=(0,o._K)().platform.fetch,(0,u.vA)(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&(0,u.vA)(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],o={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:n};null!=e.signature&&(o.signature=e.signature),null!=e.userDefinedMetadata&&(o.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(o.modelInitializer=e.modelInitializer),t.body.append("model.json",new Blob([JSON.stringify(o)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:(0,r.oR)(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(f){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=t.modelTopology,o=t.weightsManifest,r=t.generatedBy,s=t.convertedBy,i=t.format,a=t.signature,l=t.userDefinedMetadata;if(null==n&&null==o)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let c,u;if(null!=o){const e=await this.loadWeights(o);[c,u]=e}const d={modelTopology:n,weightSpecs:c,weightData:u,generatedBy:r,convertedBy:s,format:i};null!=a&&(d.signature=a),null!=l&&(d.userDefinedMetadata=l);const h=t.modelInitializer;return h&&(d.modelInitializer=h),d}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),o=e.substring(0,t),r=n>t?e.substring(n):"";return[o+"/",r]}(t),s=this.weightPathPrefix||n,i=[];for(const r of e)i.push(...r.weights);const a=[],l=[];for(const r of e)for(const e of r.paths)null!=this.weightUrlConverter?l.push(this.weightUrlConverter(e)):a.push(s+e+o);this.weightUrlConverter&&a.push(...await Promise.all(l));const c=await(0,d.jP)(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[i,(0,r.AQ)(c)]}}function f(e){return null!=e.match(h.URL_SCHEME_REGEX)}h.URL_SCHEME_REGEX=/^https?:\/\//;const g=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>f(e))):f(e),n)return m(e,t)}return null};function m(e,t){return new h(e,t)}function p(e,t){return m(e,t)}s.bM.registerSaveRouter(g),s.bM.registerLoadRouter(g);class w{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}}class y{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}}function S(e,t,n,o){if(1===arguments.length){const t=null!=e.modelTopology||null!=e.weightSpecs;return new w(t?e:{modelTopology:e})}return new w({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:o})}function v(e){return new y(e)}var b=n(66235)},30522:function(e,t,n){n.d(t,{lQ:function(){return f},mn:function(){return d}});n(66652);var o=n(46574),r=n(77084),s=n(46669);const i="tensorflowjs",a="models_store",l="model_info_store";function c(){if(!(0,o._K)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function u(e){const t=e.result;t.createObjectStore(a,{keyPath:"modelPath"}),t.createObjectStore(l,{keyPath:"modelPath"})}class d{constructor(e){if(this.indexedDB=c(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const o=this.indexedDB.open(i,1);o.onupgradeneeded=()=>u(o),o.onsuccess=()=>{const s=o.result;if(null==t){const t=s.transaction(a,"readonly"),o=t.objectStore(a).get(this.modelPath);o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(o.result.modelArtifacts)},o.onerror=e=>(s.close(),n(o.error)),t.oncomplete=()=>s.close()}else{const o=(0,r.oR)(t),i=s.transaction(l,"readwrite");let c=i.objectStore(l);const u=c.put({modelPath:this.modelPath,modelArtifactsInfo:o});let d;u.onsuccess=()=>{d=s.transaction(a,"readwrite");const r=d.objectStore(a).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o});r.onsuccess=()=>e({modelArtifactsInfo:o}),r.onerror=e=>{c=i.objectStore(l);const t=c.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(r.error)),t.onerror=e=>(s.close(),n(r.error))}},u.onerror=e=>(s.close(),n(u.error)),i.oncomplete=()=>{null==d?s.close():d.oncomplete=()=>s.close()}}},o.onerror=e=>n(o.error)}))}}d.URL_SCHEME="indexeddb://";const h=e=>{return(0,o._K)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(d.URL_SCHEME)?(t=e.slice(d.URL_SCHEME.length),new d(t)):null;var t};s.bM.registerSaveRouter(h),s.bM.registerLoadRouter(h);class f{constructor(){this.indexedDB=c()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(i,1);n.onupgradeneeded=()=>u(n),n.onsuccess=()=>{const o=n.result,r=o.transaction(l,"readonly"),s=r.objectStore(l).getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(o.close(),t(s.error)),r.oncomplete=()=>o.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(d.URL_SCHEME)?t.slice(d.URL_SCHEME.length):t,new Promise(((t,n)=>{const o=this.indexedDB.open(i,1);o.onupgradeneeded=()=>u(o),o.onsuccess=()=>{const r=o.result,s=r.transaction(l,"readwrite"),i=s.objectStore(l),c=i.get(e);let u;c.onsuccess=()=>{if(null==c.result)return r.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const o=i.delete(e),s=()=>{u=r.transaction(a,"readwrite");const o=u.objectStore(a).delete(e);o.onsuccess=()=>t(c.result.modelArtifactsInfo),o.onerror=e=>n(c.error)};o.onsuccess=s,o.onerror=e=>(s(),r.close(),n(c.error))}},c.onerror=e=>(r.close(),n(c.error)),s.oncomplete=()=>{null==u?r.close():u.oncomplete=()=>r.close()}},o.onerror=e=>n(o.error)}))}}},46669:function(e,t,n){n.d(t,{C9:function(){return a},R4:function(){return s},Yd:function(){return r},bM:function(){return o},x3:function(){return i}});class o{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==o.instance&&(o.instance=new o),o.instance}static registerSaveRouter(e){o.getInstance().saveRouters.push(e)}static registerLoadRouter(e){o.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return o.getHandlers(e,"save")}static getLoadHandlers(e,t){return o.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?o.getInstance().loadRouters:o.getInstance().saveRouters).forEach((t=>{const o=t(e,n);null!==o&&r.push(o)})),r}}const r=e=>o.registerSaveRouter(e),s=e=>o.registerLoadRouter(e),i=e=>o.getSaveHandlers(e),a=(e,t)=>o.getLoadHandlers(e,t)},66235:function(e,t,n){n.d(t,{D:function(){return c},Vo:function(){return h},az:function(){return u},dy:function(){return i},xk:function(){return d}});var o=n(45119),r=n(46669);const s="://";class i{constructor(){this.managers={}}static getInstance(){return null==i.instance&&(i.instance=new i),i.instance}static registerManager(e,t){(0,o.vA)(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(s)&&(e=e.slice(0,e.indexOf(s))),(0,o.vA)(e.length>0,(()=>"scheme must not be an empty string."));const n=i.getInstance();(0,o.vA)(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}function a(e){if(-1===e.indexOf(s))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${i.getSchemes().join(",")}`);return{scheme:e.split(s)[0],path:e.split(s)[1]}}async function l(e,t,n=!1){(0,o.vA)(e!==t,(()=>`Old path and new path are the same: '${e}'`));const s=r.bM.getLoadHandlers(e);(0,o.vA)(s.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),(0,o.vA)(s.length<2,(()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${e}.`));const l=s[0],c=r.bM.getSaveHandlers(t);(0,o.vA)(c.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),(0,o.vA)(c.length<2,(()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${t}.`));const u=c[0],d=a(e).scheme,h=a(e).path,f=d===a(e).scheme,g=await l.load();n&&f&&await i.getManager(d).removeModel(h);const m=await u.save(g);return n&&!f&&await i.getManager(d).removeModel(h),m.modelArtifactsInfo}async function c(){const e=i.getSchemes(),t={};for(const n of e){const e=await i.getManager(n).listModels();for(const o in e){t[n+s+o]=e[o]}}return t}async function u(e){const t=a(e);return i.getManager(t.scheme).removeModel(t.path)}async function d(e,t){return l(e,t,!1)}async function h(e,t){return l(e,t,!0)}},76745:function(e,t,n){n.d(t,{Cd:function(){return y},ZT:function(){return p}});n(66652);var o=n(46574),r=n(45119),s=n(77084),i=n(46669);const a="/",l="tensorflowjs_models",c="info",u="model_topology",d="weight_specs",h="weight_data",f="model_metadata";function g(e){return{info:[l,e,c].join(a),topology:[l,e,u].join(a),weightSpecs:[l,e,d].join(a),weightData:[l,e,h].join(a),modelMetadata:[l,e,f].join(a)}}function m(e){const t=e.split(a);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(a)}class p{constructor(e){if(!(0,o._K)().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=g(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),o=JSON.stringify(e.weightSpecs),r=(0,s.oR)(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,o),this.LS.setItem(this.keys.weightData,(0,s.l3)(e.weightData));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};return null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:r}}catch(t){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==o)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=o;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer)}const i=this.LS.getItem(this.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=(0,s.jf)(i),t}}p.URL_SCHEME="localstorage://";const w=e=>{return(0,o._K)().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(p.URL_SCHEME)?(t=e.slice(p.URL_SCHEME.length),new p(t)):null;var t};i.bM.registerSaveRouter(w),i.bM.registerLoadRouter(w);class y{constructor(){(0,r.vA)((0,o._K)().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),(0,r.vA)("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=l+a,n=a+c;for(let o=0;o<this.LS.length;++o){const r=this.LS.key(o);if(r.startsWith(t)&&r.endsWith(n)){e[m(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){var t;const n=g(e=(t=e).startsWith(p.URL_SCHEME)?t.slice(p.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const o=JSON.parse(this.LS.getItem(n.info));return this.LS.removeItem(n.info),this.LS.removeItem(n.topology),this.LS.removeItem(n.weightSpecs),this.LS.removeItem(n.weightData),o}}},77084:function(e,t,n){n.d(t,{AQ:function(){return p},CY:function(){return u},P8:function(){return w},aG:function(){return c},jf:function(){return m},l3:function(){return g},oR:function(){return y}});var o=n(37148),r=n(74027),s=n(45119),i=n(15685),a=n(48287).hp;const l=4;async function c(e,t){const n=[],o=[],r=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<r.length;++s){const i=r[s],a=Array.isArray(e)?e[s].tensor:e[i];if("float32"!==a.dtype&&"int32"!==a.dtype&&"bool"!==a.dtype&&"string"!==a.dtype&&"complex64"!==a.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${a.dtype}`);const c={name:i,shape:a.shape,dtype:a.dtype};if("string"===a.dtype){const e=new Promise((async e=>{const t=await a.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+l*t.length,o=new Uint8Array(n);let r=0;for(let s=0;s<t.length;s++){const e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);o.set(n,r),r+=l,o.set(e,r),r+=e.length}e(o)}));o.push(e)}else o.push(a.data());null!=t&&(c.group=t),n.push(c)}return{data:d(await Promise.all(o)),specs:n}}function u(e,t){const n={};let a,c=0;for(const u of t){const t=u.name,d=u.dtype,h=u.shape,f=(0,s.Ze)(h);let g;if("quantization"in u){const n=u.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${u.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${u.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==d)throw new Error(`Weight ${u.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${d}.`)}const o=i.i[n.dtype],r=e.slice(c,c+f*o),s="uint8"===n.dtype?new Uint8Array(r):new Uint16Array(r);if("float32"===d)if("uint8"===n.dtype||"uint16"===n.dtype){g=new Float32Array(s.length);for(let e=0;e<s.length;e++){const t=s[e];g[e]=t*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===a&&(a=S()),g=a(s)}else{if("int32"!==d)throw new Error(`Unsupported dtype in weight '${t}': ${d}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);g=new Int32Array(s.length);for(let e=0;e<s.length;e++){const t=s[e];g[e]=Math.round(t*n.scale+n.min)}}c+=f*o}else if("string"===d){const t=(0,s.Ze)(u.shape);g=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(c,c+l))[0];c+=l;const n=new Uint8Array(e.slice(c,c+t));g.push(n),c+=t}}else{const s=i.i[d],a=e.slice(c,c+f*s);if("float32"===d)g=new Float32Array(a);else if("int32"===d)g=new Int32Array(a);else if("bool"===d)g=new Uint8Array(a);else{if("complex64"!==d)throw new Error(`Unsupported dtype in weight '${t}': ${d}`);{g=new Float32Array(a);const e=new Float32Array(g.length/2),s=new Float32Array(g.length/2);for(let t=0;t<e.length;t++)e[t]=g[2*t],s[t]=g[2*t+1];const i=(0,r.O)(e,h,"float32"),l=(0,r.O)(s,h,"float32");n[t]=(0,o.f)(i,l),i.dispose(),l.dispose()}}c+=f*s}"complex64"!==d&&(n[t]=(0,r.O)(g,h,d))}return n}function d(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const o=new Uint8Array(t);let r=0;return n.forEach((e=>{o.set(new Uint8Array(e.buffer),r),r+=e.byteLength})),o.buffer}const h="undefined"!==typeof a&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function f(e){return h?a.byteLength(e):new Blob([e]).size}function g(e){if(h)return a.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let o=0,r=t.length;o<r;o++)n+=String.fromCharCode(t[o]);return btoa(n)}function m(e){if(h){const t=a.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let o=0;o<t.length;++o)n.set([t.charCodeAt(o)],o);return n.buffer}function p(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));const n=new Uint8Array(t);let o=0;return e.forEach((e=>{n.set(new Uint8Array(e),o),o+=e.byteLength})),n.buffer}function w(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function y(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:f(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:f(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function S(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return o=>{const r=new ArrayBuffer(4*o.length),s=new Uint32Array(r);for(let i=0;i<o.length;i++){const r=o[i],a=e[n[r>>10]+(1023&r)]+t[r>>10];s[i]=a}return new Float32Array(r)}}}}]);
//# sourceMappingURL=stylist-vendors-92835348.be3ac1dfac7b752312a9.js.map