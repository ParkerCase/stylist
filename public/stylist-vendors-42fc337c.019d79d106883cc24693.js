"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[1110],{10776:function(e,n,t){t.d(n,{e:function(){return u}});var s=t(67897),r=t(15441),a=t(28189),o=t(45119);const u=(0,t(70929).op)({spaceToBatchND_:function(e,n,t){const u=(0,a.YT)(e,"x","spaceToBatchND");o.vA(u.rank>=1+n.length,(()=>`input rank ${u.rank} should be > than [blockShape] ${n.length}`)),o.vA(t.length===n.length,(()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${n.length}`)),o.vA(u.shape.reduce(((e,s,r)=>r>0&&r<=n.length?e&&(s+t[r-1][0]+t[r-1][1])%n[r-1]===0:e),!0),(()=>`input spatial dimensions ${u.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${n.toString()}`));const i={x:u},p={blockShape:n,paddings:t};return s.T2.runKernel(r.A8B,i,p)}})},16112:function(e,n,t){t.d(n,{Z:function(){return o}});var s=t(67897),r=t(15441),a=t(28189);const o=(0,t(70929).op)({sparseReshape_:function(e,n,t){const o=(0,a.YT)(e,"inputIndices","sparseReshape","int32"),u=(0,a.YT)(n,"inputShape","sparseReshape","int32"),i=(0,a.YT)(t,"newShape","sparseReshape","int32");if(2!==o.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${o.shape}`);if(1!==u.rank)throw new Error(`Input shape should be Tensor1D but received shape ${u.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const p={inputIndices:o,inputShape:u,newShape:i},c=s.T2.runKernel(r.BoJ,p);return{outputIndices:c[0],outputShape:c[1]}}})},34899:function(e,n,t){t.d(n,{t:function(){return o}});var s=t(67897),r=t(15441),a=t(28189);const o=(0,t(70929).op)({sparseSegmentMean_:function(e,n,t){const o=(0,a.YT)(e,"data","sparseSegmentMean"),u=(0,a.YT)(n,"indices","sparseSegmentMean","int32"),i=(0,a.YT)(t,"segmentIds","sparseSegmentMean","int32");if(o.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==u.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${u.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${i.shape}`);const p={data:o,indices:u,segmentIds:i};return s.T2.runKernel(r.L6G,p)}})},49119:function(e,n,t){t.d(n,{F:function(){return o}});var s=t(67897),r=t(15441),a=t(28189);const o=(0,t(70929).op)({sparseSegmentSum_:function(e,n,t){const o=(0,a.YT)(e,"data","sparseSegmentSum"),u=(0,a.YT)(n,"indices","sparseSegmentSum","int32"),i=(0,a.YT)(t,"segmentIds","sparseSegmentSum","int32");if(o.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==u.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${u.shape}`);if(1!==i.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${i.shape}`);const p={data:o,indices:u,segmentIds:i};return s.T2.runKernel(r.DvZ,p)}})},55880:function(e,n,t){function s(){return"segment ids must be >= 0"}function r(){return"segment ids are not increasing"}function a(e,n){return`Segment id ${e} out of range [0, ${n}), possibly because segmentIds input is not sorted.`}function o(e,n,t){return`Bad: indices[${e}] == ${n} out of range [0, ${t})`}t.d(n,{AP:function(){return a},dS:function(){return o},tb:function(){return r},u1:function(){return s}})},63551:function(e,n,t){t.d(n,{o:function(){return o}});var s=t(67897),r=t(15441),a=t(28189);const o=(0,t(70929).op)({sparseFillEmptyRows_:function(e,n,t,o){const u=(0,a.YT)(e,"indices","sparseFillEmptyRows","int32"),i=(0,a.YT)(n,"values","sparseFillEmptyRows"),p=(0,a.YT)(t,"denseShape","sparseFillEmptyRows","int32"),c=(0,a.YT)(o,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==u.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${u.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==p.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${p.shape}`);if(0!==c.rank)throw new Error(`Default value should be a scalar but received shape ${c.shape}`);const h={indices:u,values:i,denseShape:p,defaultValue:c},d=s.T2.runKernel(r.C8s,h);return{outputIndices:d[0],outputValues:d[1],emptyRowIndicator:d[2],reverseIndexMap:d[3]}}})},77618:function(e,n,t){function s(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function r(e,n){return`indices(${e}, 0) is invalid: ${n} < 0`}function a(e,n,t){return`indices(${e}, 0) is invalid: ${n} >= ${t}`}t.d(n,{P_:function(){return s},U8:function(){return r},zP:function(){return a}})},83255:function(e,n,t){t.d(n,{M5:function(){return a},Ni:function(){return u},Pz:function(){return o},pC:function(){return i},yM:function(){return r}});var s=t(45119);function r(e,n){return`only one output dimension may be -1, not both ${e} and ${n}`}function a(e,n){return`size ${e} must be non-negative, not ${n}`}function o(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function u(e,n){return`Input to reshape is a SparseTensor with ${(0,s.Ze)(e)}\n  dense values, but the requested shape requires a multiple of ${(0,s.Ze)(n)}. inputShape=${e} outputShape= ${n}`}function i(e,n){return`Input to reshape is a tensor with ${(0,s.Ze)(e)} dense values, but the requested shape has ${(0,s.Ze)(n)}. inputShape=${e} outputShape=${n}`}},96654:function(e,n,t){t.d(n,{Z:function(){return u}});var s=t(67897),r=t(15441);var a=t(28189),o=t(45119);const u=(0,t(70929).op)({sparseToDense_:function(e,n,t,u=0){(0,o.SA)(t);const i=(0,a.YT)(e,"sparseIndices","sparseToDense","int32"),p=(0,a.YT)(n,"sparseValues","sparseToDense","string_or_numeric"),c=(0,a.YT)(u,"defaultValue","sparseToDense",p.dtype);!function(e,n,t,s){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const r=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(t.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${a}.`);const o=n.size;if(0!==n.rank&&(1!==n.rank||o!==r))throw new Error(`sparseValues has incorrect shape ${n.shape}, should be [] or [${r}]`);if(n.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(i,p,t,c);const h={sparseIndices:i,sparseValues:p,defaultValue:c},d={outputShape:t};return s.T2.runKernel(r.jgd,h,d)}})}}]);
//# sourceMappingURL=stylist-vendors-42fc337c.019d79d106883cc24693.js.map