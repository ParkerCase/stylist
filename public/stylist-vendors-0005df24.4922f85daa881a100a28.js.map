{"version":3,"file":"stylist-vendors-0005df24.4922f85daa881a100a28.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/tile_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/transform_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/unpack_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/version.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/transpose_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/webgl_util.js"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class TileProgram {\n    constructor(aShape, reps) {\n        this.variableNames = ['A'];\n        const outputShape = new Array(aShape.length);\n        for (let i = 0; i < outputShape.length; i++) {\n            outputShape[i] = aShape[i] * reps[i];\n        }\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        const dtype = getCoordsDataType(this.rank);\n        const sourceCoords = getSourceCoords(aShape);\n        this.userCode = `\n      void main() {\n        ${dtype} resRC = getOutputCoords();\n        setOutput(getA(${sourceCoords}));\n      }\n    `;\n    }\n}\nfunction getSourceCoords(aShape) {\n    const rank = aShape.length;\n    if (rank > 5) {\n        throw Error(`Tile for rank ${rank} is not yet supported`);\n    }\n    if (rank === 1) {\n        return `imod(resRC, ${aShape[0]})`;\n    }\n    const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u'];\n    const sourceCoords = [];\n    for (let i = 0; i < aShape.length; i++) {\n        sourceCoords.push(`imod(${currentCoords[i]}, ${aShape[i]})`);\n    }\n    return sourceCoords.join();\n}\n//# sourceMappingURL=tile_gpu.js.map","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class TransformProgram {\n    constructor(imageHeight, imageWidth, interpolation, fillMode, fillValue, outShape) {\n        this.variableNames = ['Image', 'Transforms'];\n        this.outputShape = outShape;\n        const interpolationModeId = interpolation === 'nearest' ? 1 : 2;\n        let fillModeId;\n        switch (fillMode) {\n            case 'constant':\n                fillModeId = 1;\n                break;\n            case 'reflect':\n                fillModeId = 2;\n                break;\n            case 'wrap':\n                fillModeId = 3;\n                break;\n            case 'nearest':\n                fillModeId = 4;\n                break;\n            default:\n                fillModeId = 1;\n                break;\n        }\n        this.userCode = `\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${fillModeId} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${fillModeId} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${fillModeId} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${imageHeight} && 0 <= coordX && coordX < ${imageWidth}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${fillValue});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${fillValue});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${imageWidth}));\n                float mapY = mapCoord(inY, float(${imageHeight}));\n\n                if (${interpolationModeId} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `;\n    }\n}\n//# sourceMappingURL=transform_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels, getSourceCoords } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class UnpackProgram {\n    constructor(outputShape) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = false;\n        this.outputShape = outputShape;\n        const rank = outputShape.length;\n        const channels = getChannels('rc', rank);\n        const dtype = getCoordsDataType(rank);\n        const sourceCoords = getSourceCoords(rank, channels);\n        const innerDims = channels.slice(-2);\n        const coords = rank <= 1 ? 'rc' : `vec2(${innerDims.join(',')})`;\n        this.userCode = `\n      void main() {\n        ${dtype} rc = getOutputCoords();\n        vec4 packedInput = getA(${sourceCoords});\n\n        setOutput(getChannel(packedInput, ${coords}));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=unpack_gpu.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getVecChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class TransposePackedProgram {\n    constructor(aShape, newDim) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        const outputShape = new Array(aShape.length);\n        for (let i = 0; i < outputShape.length; i++) {\n            outputShape[i] = aShape[newDim[i]];\n        }\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        if (this.rank > 6) {\n            throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);\n        }\n        const dtype = getCoordsDataType(this.rank);\n        const outputOrder = getVecChannels('rc', this.rank);\n        const switchedOrder = new Array(this.rank);\n        for (let i = 0; i < newDim.length; i++) {\n            switchedOrder[newDim[i]] = outputOrder[i];\n        }\n        const innerDims = `vec2(${switchedOrder.slice(-2).join()})`;\n        const nextColumn = `++${outputOrder[this.rank - 1]} < ${outputShape[this.rank - 1]}`;\n        const getc = `getChannel(getA(${switchedOrder.join()}), ${innerDims})`;\n        this.userCode = `\n    void main() {\n      ${dtype} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${getc};\n      if(${nextColumn}) {\n        result[1] = ${getc};\n      }\n      --${outputOrder[this.rank - 1]};\n      if(++${outputOrder[this.rank - 2]} < ${outputShape[this.rank - 2]}) {\n        result[2] = ${getc};\n        if(${nextColumn}) {\n          result[3] = ${getc};\n        }\n      }\n      setOutput(result);\n    }\n    `;\n    }\n}\n//# sourceMappingURL=transpose_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class UnaryOpProgram {\n    constructor(aShape, opSnippet) {\n        this.variableNames = ['A'];\n        this.outputShape = aShape;\n        this.userCode = `\n      float unaryOperation(float x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n    }\n}\nexport const CHECK_NAN_SNIPPET = `if (isnan(x)) return x;`;\nexport const LINEAR = `return x;`;\nexport const ABS = `return abs(x);`;\nexport function STEP(alpha = 0.0) {\n    return CHECK_NAN_SNIPPET + `\n    return x > 0.0 ? 1.0 : float(${alpha});\n  `;\n}\nexport const ELU = `return (x >= 0.0) ? x : (exp(x) - 1.0);`;\nexport const RELU = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : x;\n`;\nexport const RELU6 = CHECK_NAN_SNIPPET + `\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n`;\nexport const CLONE = 'return x;';\nexport const SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;\n//# sourceMappingURL=unaryop_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport const LINEAR = `return x;`;\nexport const ELU = `\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n`;\nexport const RELU = `\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\nexport const RELU6 = `\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n`;\nexport const SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * x));`;\nexport class UnaryOpPackedProgram {\n    constructor(aShape, opSnippet) {\n        this.variableNames = ['A'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = aShape;\n        this.userCode = `\n      vec4 unaryOperation(vec4 x) {\n        ${opSnippet}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=unaryop_packed_gpu.js.map","/** @license See the LICENSE file. */\n// This code is auto-generated, do not modify this file!\nconst version = '3.6.0';\nexport { version };\n//# sourceMappingURL=version.js.map","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as webgl_util from './webgl_util';\nexport { MathBackendWebGL } from './backend_webgl';\nexport { setWebGLContext } from './canvas_util';\nexport { GPGPUContext } from './gpgpu_context';\n// WebGL specific utils.\nexport { gpgpu_util, webgl_util };\n/**\n * Enforce use of half precision textures if available on the platform.\n *\n * @doc {heading: 'Environment', namespace: 'webgl'}\n */\nexport function forceHalfFloat() {\n    env().set('WEBGL_FORCE_F16_TEXTURES', true);\n}\n//# sourceMappingURL=webgl.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class TransposeProgram {\n    constructor(aShape, newDim) {\n        this.variableNames = ['A'];\n        const outputShape = new Array(aShape.length);\n        for (let i = 0; i < outputShape.length; i++) {\n            outputShape[i] = aShape[newDim[i]];\n        }\n        this.outputShape = outputShape;\n        this.rank = outputShape.length;\n        const dtype = getCoordsDataType(this.rank);\n        const switched = getSwitchedCoords(newDim);\n        this.userCode = `\n    void main() {\n      ${dtype} resRC = getOutputCoords();\n      setOutput(getA(${switched}));\n    }\n    `;\n    }\n}\nfunction getSwitchedCoords(newDim) {\n    const rank = newDim.length;\n    if (rank > 6) {\n        throw Error(`Transpose for rank ${rank} is not yet supported`);\n    }\n    const originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w', 'resRC.u', 'resRC.v'];\n    const switchedCoords = new Array(rank);\n    for (let i = 0; i < newDim.length; i++) {\n        switchedCoords[newDim[i]] = originalOrder[i];\n    }\n    return switchedCoords.join();\n}\n//# sourceMappingURL=transpose_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { getTextureConfig } from './tex_util';\nexport function callAndCheck(gl, func) {\n    const returnValue = func();\n    if (env().getBool('DEBUG')) {\n        checkWebGLError(gl);\n    }\n    return returnValue;\n}\nfunction checkWebGLError(gl) {\n    const error = gl.getError();\n    if (error !== gl.NO_ERROR) {\n        throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n    }\n}\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\nexport function canBeRepresented(num) {\n    if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n        (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n        return true;\n    }\n    return false;\n}\nexport function getWebGLErrorMessage(gl, status) {\n    switch (status) {\n        case gl.NO_ERROR:\n            return 'NO_ERROR';\n        case gl.INVALID_ENUM:\n            return 'INVALID_ENUM';\n        case gl.INVALID_VALUE:\n            return 'INVALID_VALUE';\n        case gl.INVALID_OPERATION:\n            return 'INVALID_OPERATION';\n        case gl.INVALID_FRAMEBUFFER_OPERATION:\n            return 'INVALID_FRAMEBUFFER_OPERATION';\n        case gl.OUT_OF_MEMORY:\n            return 'OUT_OF_MEMORY';\n        case gl.CONTEXT_LOST_WEBGL:\n            return 'CONTEXT_LOST_WEBGL';\n        default:\n            return `Unknown error code ${status}`;\n    }\n}\nexport function getExtensionOrThrow(gl, extensionName) {\n    return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nexport function createVertexShader(gl, vertexShaderSource) {\n    const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), 'Unable to create vertex WebGLShader.');\n    callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n    callAndCheck(gl, () => gl.compileShader(vertexShader));\n    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n        console.log(gl.getShaderInfoLog(vertexShader));\n        throw new Error('Failed to compile vertex shader.');\n    }\n    return vertexShader;\n}\nexport function createFragmentShader(gl, fragmentShaderSource) {\n    const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), 'Unable to create fragment WebGLShader.');\n    callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n    callAndCheck(gl, () => gl.compileShader(fragmentShader));\n    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n        throw new Error('Failed to compile fragment shader.');\n    }\n    return fragmentShader;\n}\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nfunction logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n    const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n    if (lineNumberRegexResult == null) {\n        console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n        console.log(shaderSource);\n        return;\n    }\n    const lineNumber = +lineNumberRegexResult[1];\n    const shaderLines = shaderSource.split('\\n');\n    const pad = shaderLines.length.toString().length + 2;\n    const linesWithLineNumbers = shaderLines.map((line, lineNumber) => util.rightPad((lineNumber + 1).toString(), pad) + line);\n    let maxLineLength = 0;\n    for (let i = 0; i < linesWithLineNumbers.length; i++) {\n        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n    }\n    const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n    const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n    const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n    console.log(beforeErrorLines.join('\\n'));\n    console.log(shaderInfoLog.split('\\n')[0]);\n    console.log(`%c ${util.rightPad(errorLine[0], maxLineLength)}`, 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n    console.log(afterErrorLines.join('\\n'));\n}\nexport function createProgram(gl) {\n    return throwIfNull(gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\nexport function linkProgram(gl, program) {\n    callAndCheck(gl, () => gl.linkProgram(program));\n    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Failed to link vertex and fragment shaders.');\n    }\n}\nexport function validateProgram(gl, program) {\n    callAndCheck(gl, () => gl.validateProgram(program));\n    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n        console.log(gl.getProgramInfoLog(program));\n        throw new Error('Shader program validation failed.');\n    }\n}\nexport function createStaticVertexBuffer(gl, data) {\n    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n    return buffer;\n}\nexport function createStaticIndexBuffer(gl, data) {\n    const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n    callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n    return buffer;\n}\nexport function getNumChannels() {\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n        return 1;\n    }\n    return 4;\n}\nexport function createTexture(gl) {\n    return throwIfNull(gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\nexport function validateTextureSize(width, height) {\n    const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    if ((width <= 0) || (height <= 0)) {\n        const requested = `[${width}x${height}]`;\n        throw new Error('Requested texture size ' + requested + ' is invalid.');\n    }\n    if ((width > maxTextureSize) || (height > maxTextureSize)) {\n        const requested = `[${width}x${height}]`;\n        const max = `[${maxTextureSize}x${maxTextureSize}]`;\n        throw new Error('Requested texture size ' + requested +\n            ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n    }\n}\nexport function createFramebuffer(gl) {\n    return throwIfNull(gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\nexport function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {\n    const loc = gl.getAttribLocation(program, attribute);\n    if (loc === -1) {\n        // The GPU compiler decided to strip out this attribute because it's unused,\n        // thus no need to bind.\n        return false;\n    }\n    callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n    callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));\n    callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n    return true;\n}\nexport function bindTextureUnit(gl, texture, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\nexport function unbindTextureUnit(gl, textureUnit) {\n    validateTextureUnit(gl, textureUnit);\n    callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n    callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function getProgramUniformLocationOrThrow(gl, program, uniformName) {\n    return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform \"' + uniformName + '\" not present in program.');\n}\nexport function getProgramUniformLocation(gl, program, uniformName) {\n    return gl.getUniformLocation(program, uniformName);\n}\nexport function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {\n    callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n    callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\nexport function bindCanvasToFramebuffer(gl) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n    callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\nexport function bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\nexport function unbindColorTextureFromFramebuffer(gl, framebuffer) {\n    callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n    callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\nexport function validateFramebuffer(gl) {\n    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (status !== gl.FRAMEBUFFER_COMPLETE) {\n        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n    }\n}\nexport function getFramebufferErrorMessage(gl, status) {\n    switch (status) {\n        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n        case gl.FRAMEBUFFER_UNSUPPORTED:\n            return 'FRAMEBUFFER_UNSUPPORTED';\n        default:\n            return `unknown error ${status}`;\n    }\n}\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n    const tOrNull = callAndCheck(gl, () => returnTOrNull());\n    if (tOrNull == null) {\n        throw new Error(failureMessage);\n    }\n    return tOrNull;\n}\nfunction validateTextureUnit(gl, textureUnit) {\n    const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n    const glTextureUnit = textureUnit + gl.TEXTURE0;\n    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n        const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n        throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n    }\n}\nexport function getBatchDim(shape, dimsToSkip = 2) {\n    return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\nexport function getRowsCols(shape) {\n    if (shape.length === 0) {\n        throw Error('Cannot get rows and columns of an empty shape array.');\n    }\n    return [\n        shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n    ];\n}\nexport function getShapeAs3D(shape) {\n    let shapeAs3D = [1, 1, 1];\n    const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n    if (!isScalar) {\n        shapeAs3D =\n            [getBatchDim(shape), ...getRowsCols(shape)];\n    }\n    return shapeAs3D;\n}\nexport function getTextureShapeFromLogicalShape(logShape, isPacked = false) {\n    let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n    if (isPacked) {\n        maxTexSize = maxTexSize * 2;\n        // This logic ensures we accurately count the number of packed texels needed\n        // to accommodate the tensor. We can only pack values in the same texel if\n        // they are from adjacent pairs of rows/cols within the same batch. So if a\n        // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n        // fact that the texels containing the third row are half empty.\n        logShape = logShape.map((d, i) => i >= logShape.length - 2 ?\n            util.nearestLargerEven(logShape[i]) :\n            logShape[i]);\n        // Packed texture height is at least 2 (the channel height of a single\n        // texel).\n        if (logShape.length === 1) {\n            logShape = [2, logShape[0]];\n        }\n    }\n    // If logical shape is 2, we don't squeeze, since we want to match physical.\n    if (logShape.length !== 2) {\n        const squeezeResult = util.squeezeShape(logShape);\n        logShape = squeezeResult.newShape;\n    }\n    let size = util.sizeFromShape(logShape);\n    if (logShape.length <= 1 && size <= maxTexSize) {\n        return [1, size];\n    }\n    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&\n        logShape[1] <= maxTexSize) {\n        return logShape;\n    }\n    else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n        logShape[2] <= maxTexSize) {\n        return [logShape[0] * logShape[1], logShape[2]];\n    }\n    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2]];\n    }\n    else if (logShape.length === 4 &&\n        logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n        logShape[3] <= maxTexSize) {\n        return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n    }\n    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&\n        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n    }\n    else {\n        if (isPacked) {\n            // For packed textures size equals the number of channels required to\n            // accommodate the texture data. However in order to squarify such that\n            // inner dimensions stay even, we rewrite size to equal the number of\n            // texels. Then in the return statement we rehydrate the squarified\n            // dimensions to channel units.\n            const batchDim = getBatchDim(logShape);\n            let rows = 2, cols = 2;\n            if (logShape.length) {\n                [rows, cols] = getRowsCols(logShape);\n            }\n            size = batchDim * (rows / 2) * (cols / 2);\n            return util.sizeToSquarishShape(size).map(d => d * 2);\n        }\n        return util.sizeToSquarishShape(size);\n    }\n}\nfunction isEven(n) {\n    return n % 2 === 0;\n}\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1, shape2) {\n    shape1 = shape1.slice(-2);\n    shape2 = shape2.slice(-2);\n    if (util.arraysEqual(shape1, shape2)) {\n        return true;\n    }\n    if (!shape1.length || !shape2.length) { // One of the shapes is a scalar.\n        return true;\n    }\n    if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n        shape2[1] === 0) {\n        return true;\n    }\n    if (shape1.length !== shape2.length) { // One of the shapes is a vector.\n        const shape1Cols = shape1.slice(-1)[0];\n        const shape2Cols = shape2.slice(-1)[0];\n        if (shape1Cols === shape2Cols) {\n            return true;\n        }\n        if (isEven(shape1Cols) && isEven(shape2Cols) &&\n            (shape1[0] === 1 || shape2[0] === 1)) {\n            return true;\n        }\n    }\n    return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE;\nlet MAX_TEXTURES_IN_SHADER;\nexport function getWebGLMaxTextureSize(webGLVersion) {\n    if (MAX_TEXTURE_SIZE == null) {\n        const gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    }\n    return MAX_TEXTURE_SIZE;\n}\nexport function resetMaxTextureSize() {\n    MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n    MAX_TEXTURES_IN_SHADER = null;\n}\nexport function getMaxTexturesInShader(webGLVersion) {\n    if (MAX_TEXTURES_IN_SHADER == null) {\n        const gl = getWebGLContext(webGLVersion);\n        MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    }\n    // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n    return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion) {\n    if (webGLVersion === 0) {\n        return 0;\n    }\n    let queryTimerVersion;\n    const gl = getWebGLContext(webGLVersion);\n    if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n        webGLVersion === 2) {\n        queryTimerVersion = 2;\n    }\n    else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n        queryTimerVersion = 1;\n    }\n    else {\n        queryTimerVersion = 0;\n    }\n    return queryTimerVersion;\n}\nexport function hasExtension(gl, extensionName) {\n    const ext = gl.getExtension(extensionName);\n    return ext != null;\n}\nexport function isWebGLVersionEnabled(webGLVersion) {\n    try {\n        const gl = getWebGLContext(webGLVersion);\n        if (gl != null) {\n            return true;\n        }\n    }\n    catch (e) {\n        console.log('Error when getting WebGL context: ', e);\n        return false;\n    }\n    return false;\n}\nexport function isCapableOfRenderingToFloatTexture(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n    }\n    else {\n        if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n            return false;\n        }\n    }\n    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion) {\n    if (webGLVersion === 0) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    if (webGLVersion === 1) {\n        if (!hasExtension(gl, 'OES_texture_float')) {\n            return false;\n        }\n        if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n            return false;\n        }\n    }\n    else {\n        if (hasExtension(gl, 'EXT_color_buffer_float')) {\n            return createFloatTextureAndBindToFramebuffer(gl);\n        }\n        const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n        if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n            const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n            return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);\n        }\n        return false;\n    }\n    const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n    return isFrameBufferComplete;\n}\nfunction createFloatTextureAndBindToFramebuffer(gl) {\n    const texConfig = getTextureConfig(gl);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const width = 1;\n    const height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nfunction createHalfFloatTextureAndBindToFramebuffer(\n// tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n    const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n    const texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    const width = 1;\n    const height = 1;\n    gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n    const frameBuffer = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n    const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteTexture(texture);\n    gl.deleteFramebuffer(frameBuffer);\n    return isFrameBufferComplete;\n}\nexport function isWebGLFenceEnabled(webGLVersion) {\n    if (webGLVersion !== 2) {\n        return false;\n    }\n    const gl = getWebGLContext(webGLVersion);\n    // tslint:disable-next-line:no-any\n    const isEnabled = gl.fenceSync != null;\n    return isEnabled;\n}\nexport function assertNotComplex(tensor, opName) {\n    if (!Array.isArray(tensor)) {\n        tensor = [tensor];\n    }\n    tensor.forEach(t => {\n        if (t != null) {\n            util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors ` +\n                'in the WebGL backend.');\n        }\n    });\n}\n//# sourceMappingURL=webgl_util.js.map"],"names":["TileProgram","constructor","aShape","reps","this","variableNames","outputShape","Array","length","i","rank","dtype","sourceCoords","Error","currentCoords","push","join","getSourceCoords","userCode","TransformProgram","imageHeight","imageWidth","interpolation","fillMode","fillValue","outShape","interpolationModeId","fillModeId","UnpackProgram","packedInputs","packedOutput","channels","innerDims","slice","coords","TransposePackedProgram","newDim","outputOrder","switchedOrder","nextColumn","getc","UnaryOpProgram","opSnippet","CHECK_NAN_SNIPPET","LINEAR","ABS","ELU","RELU","RELU6","CLONE","SIGMOID","UnaryOpPackedProgram","version","forceHalfFloat","env","set","TransposeProgram","switched","originalOrder","switchedCoords","getSwitchedCoords","callAndCheck","gl","func","returnValue","getBool","error","getError","NO_ERROR","status","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL","getWebGLErrorMessage","checkWebGLError","MIN_FLOAT16","MAX_FLOAT16","canBeRepresented","num","Math","abs","getExtensionOrThrow","extensionName","throwIfNull","getExtension","createVertexShader","vertexShaderSource","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","createFragmentShader","fragmentShaderSource","fragmentShader","FRAGMENT_SHADER","shaderInfoLog","lineNumberRegexResult","lineNumberRegex","exec","lineNumber","shaderLines","split","pad","toString","linesWithLineNumbers","map","line","util","maxLineLength","max","logShaderSourceAndInfoLog","getShaderInfoLog","createProgram","linkProgram","program","getProgramParameter","LINK_STATUS","validateProgram","VALIDATE_STATUS","createStaticVertexBuffer","data","buffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","createStaticIndexBuffer","ELEMENT_ARRAY_BUFFER","createTexture","validateTextureSize","width","height","maxTextureSize","getNumber","createFramebuffer","bindVertexBufferToProgramAttribute","attribute","arrayEntriesPerItem","itemStrideInBytes","itemOffsetInBytes","loc","getAttribLocation","vertexAttribPointer","FLOAT","enableVertexAttribArray","getProgramUniformLocationOrThrow","uniformName","getUniformLocation","getProgramUniformLocation","bindTextureToProgramUniformSampler","texture","uniformSamplerLocation","textureUnit","validateTextureUnit","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","bindTextureUnit","uniform1i","bindColorTextureToFramebuffer","framebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","unbindColorTextureFromFramebuffer","validateFramebuffer","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_UNSUPPORTED","getFramebufferErrorMessage","returnTOrNull","failureMessage","tOrNull","maxTextureUnit","MAX_COMBINED_TEXTURE_IMAGE_UNITS","glTextureUnit","getBatchDim","shape","dimsToSkip","getRowsCols","getShapeAs3D","shapeAs3D","getTextureShapeFromLogicalShape","logShape","isPacked","maxTexSize","d","squeezeResult","newShape","size","batchDim","rows","cols","isEven","n","isReshapeFree","shape1","shape2","shape1Cols","shape2Cols","MAX_TEXTURE_SIZE","MAX_TEXTURES_IN_SHADER","getWebGLMaxTextureSize","webGLVersion","getParameter","getMaxTexturesInShader","MAX_TEXTURE_IMAGE_UNITS","min","getWebGLDisjointQueryTimerVersion","queryTimerVersion","hasExtension","isWebGLVersionEnabled","e","isCapableOfRenderingToFloatTexture","createFloatTextureAndBindToFramebuffer","isDownloadFloatTextureEnabled","COLOR_BUFFER_HALF_FLOAT","textureHalfFloatExtension","texConfig","texImage2D","internalFormatHalfFloat","textureFormatFloat","textureTypeHalfFloat","frameBuffer","isFrameBufferComplete","deleteTexture","deleteFramebuffer","createHalfFloatTextureAndBindToFramebuffer","internalFormatFloat","textureTypeFloat","isWebGLFenceEnabled","fenceSync","assertNotComplex","tensor","opName","isArray","forEach","t"],"sourceRoot":""}