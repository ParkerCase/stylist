"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[2371],{22897:function(t,e,n){n.d(e,{dR:function(){return o},x:function(){return u}});var a=n(9495),s=n(22792);const o="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class u{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=a.backend_util.assertAndGetBroadcastShape(e,n),this.enableShapeUniforms=(0,s.ik)(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}},29643:function(t,e,n){n.d(e,{f:function(){return s}});var a=n(9495);class s{constructor(t,e,n,s,o,u){this.outputShape=[],this.variableNames=["x","mean","variance"],a.backend_util.assertAndGetBroadcastShape(t,e),a.backend_util.assertAndGetBroadcastShape(t,n);let r="0.0";null!=s&&(a.backend_util.assertAndGetBroadcastShape(t,s),this.variableNames.push("offset"),r="getOffsetAtOutCoords()");let i="1.0";null!=o&&(a.backend_util.assertAndGetBroadcastShape(t,o),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${r};\n        float scale = ${i};\n        float inv = scale * inversesqrt(variance + float(${u}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}},46334:function(t,e,n){n.d(e,{VI:function(){return i},qq:function(){return r}});var a=n(9495),s=n(22792),o=n(75694),u=n(27575);const r="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class i{constructor(t,e,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a.backend_util.assertAndGetBroadcastShape(e,n);const i=this.outputShape.length;this.enableShapeUniforms=(0,s.ik)(i);let l="";if(r)if(0===i||1===a.util.sizeFromShape(this.outputShape))l="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(l=`\n          ${(0,u.bf)(i)} coords = getOutputCoords();\n        `,1===i)this.enableShapeUniforms?l+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":l+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=(0,o.Jp)("coords",i);this.enableShapeUniforms?l+=`\n            bool nextRowOutOfBounds =\n              (${t[i-2]} + 1) >= outShape[${i} - 2];\n            bool nextColOutOfBounds =\n              (${t[i-1]} + 1) >= outShape[${i} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:l+=`\n            bool nextRowOutOfBounds =\n              (${t[i-2]} + 1) >= ${this.outputShape[i-2]};\n            bool nextColOutOfBounds =\n              (${t[i-1]} + 1) >= ${this.outputShape[i-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${l}\n\n        setOutput(result);\n      }\n    `}}},65274:function(t,e,n){n.d(e,{C:function(){return s},f:function(){return o}});var a=n(9495);const s={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class o{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=a.backend_util.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}},68616:function(t,e,n){n.d(e,{x:function(){return s}});var a=n(9495);class s{constructor(t,e,n,s,o,u){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],a.backend_util.assertAndGetBroadcastShape(t,e),a.backend_util.assertAndGetBroadcastShape(t,n);let r="vec4(0.0)";null!=s&&(a.backend_util.assertAndGetBroadcastShape(t,s),this.variableNames.push("offset"),r="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=o&&(a.backend_util.assertAndGetBroadcastShape(t,o),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${r};\n        vec4 scale = ${i};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${u}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}},86819:function(t,e,n){n.d(e,{$p:function(){return o.r}});var a=n(9495),s=n(77546),o=n(77104),u=n(80393);a.device_util.isBrowser()&&(0,a.registerBackend)("webgl",(()=>new s.Q6),2);u.bP}}]);
//# sourceMappingURL=stylist-vendors-c74f7528.7aae46dbca9566968c2c.js.map