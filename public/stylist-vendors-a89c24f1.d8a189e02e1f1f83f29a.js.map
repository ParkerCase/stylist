{"version":3,"file":"stylist-vendors-a89c24f1.d8a189e02e1f1f83f29a.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/crop_and_resize_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/cum_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { useShapeUniforms } from './gpgpu_math';\nexport class DepthwiseConvPacked2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.customUniforms = [\n            { name: 'pads', type: 'ivec2' },\n            { name: 'strides', type: 'ivec2' },\n            { name: 'dilations', type: 'ivec2' },\n            { name: 'inDims', type: 'ivec2' },\n        ];\n        this.outputShape = convInfo.outShape;\n        this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        const padLeft = convInfo.padInfo.left;\n        const strideWidth = convInfo.strideWidth;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const texelsAcross = filterWidth;\n        let mainLoop = `\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;`;\n        for (let c = 0; c < filterWidth; c++) {\n            mainLoop += `\n          vec4 xTexelC${c * 2};\n          int xTexelC${c * 2}Ready;\n          vec4 xTexelC${c * 2 + 1};\n          int xTexelC${c * 2 + 1}Ready;\n          vec4 xC${c};`;\n        }\n        /**\n         * This vectorized implementation works by gathering the values needed for\n         * each output channel's dot product into vec4's and then multiplying them\n         * all together (this happens in the final double for-loop below). Most of\n         * the main loop consists of constructing these vec4's with the minimum\n         * number of texture2D calls, which means making use of all four returned\n         * values from a texture2D call at once.\n         */\n        mainLoop += `\n    for (int r = 0; r < ${filterHeight}; r++) {\n      `;\n        for (let c = 0; c < filterWidth; c++) {\n            mainLoop += `\n          xTexelC${c * 2} = vec4(0.0);\n          xTexelC${c * 2}Ready = 0;\n          xTexelC${c * 2 + 1} = vec4(0.0);\n          xTexelC${c * 2 + 1}Ready = 0;\n          xC${c} = vec4(0.0);`;\n        }\n        mainLoop += `\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      `;\n        for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {\n            const colIndex = texelC * 2;\n            mainLoop += `\n          xC = xCCorner + ${colIndex * dilationWidth};\n          `;\n            if (strideWidth === 1) {\n                if (colIndex < filterWidth) {\n                    // If padding is odd, the outer texels have to be composed.\n                    if (padLeft % 2 === 1) {\n                        // TODO: Ensure vec4 previous does not result in redundant sample,\n                        // and avoid setting xTexelRC's that exceed the boundary in the\n                        // first place rather than resetting them to vec4(0)).\n                        // To compute xCOffset:\n                        // - If padding is odd, we must add 1 to ensure we ask for an\n                        // even-numbered row.\n                        // - We subtract 2 to access the previous texel.\n                        mainLoop += `\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${colIndex}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex}Ready = 1;\n                }\n              `;\n                        // This texel has been read in previous iteration if the dilation\n                        // is 1.\n                        if (dilationWidth === 1 && colIndex > 0) {\n                            mainLoop += `\n                xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${colIndex}.xy);\n                `;\n                        }\n                        else {\n                            mainLoop += `\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);\n                  } else {\n                    xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);\n                  }\n                  `;\n                        }\n                    }\n                    else {\n                        // Padding is even, so xRC corresponds to a single texel.\n                        mainLoop += `\n                if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                  xTexelC${colIndex} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${colIndex}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex}Ready = 1;\n                }\n\n                xC${colIndex} = xTexelC${colIndex};\n                `;\n                    }\n                    if (colIndex + 1 < filterWidth) {\n                        // If dilation is even, the second entry should match the first\n                        // (either both are composed or both are single samples). But if\n                        // dilation is odd, then the second entry should be the opposite\n                        // of the first (if the first is composed, the second is a single\n                        // sample, and vice versa.)\n                        const nextTexelOffset = padLeft % 2 === 0 ?\n                            util.nearestLargerEven(dilationWidth) :\n                            dilationWidth;\n                        if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                            (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n                            mainLoop += `\n                  xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                    xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${colIndex + 1}.zw = vec2(0.0);\n                    }\n                    xTexelC${colIndex + 1}Ready = 1;\n                  }\n                  `;\n                            // If dilation > 1 then the xRC's will not be able to share any\n                            // values, so each xRC will require two unique calls to getX.\n                            if (dilationWidth > 1) {\n                                mainLoop += `\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${colIndex + 1} = vec4(previous.zw, xTexelC${colIndex + 1}.xy);\n                    } else {\n                     xC${colIndex + 1} = vec4(0.0, 0.0, xTexelC${colIndex + 1}.xy);\n                    }\n                    `;\n                            }\n                            else {\n                                mainLoop += `\n                    xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.xy);\n                    `;\n                            }\n                        }\n                        else {\n                            // If dilation is 1 and padding is odd, we have already read the\n                            // texel when constructing the previous x value. Here we can\n                            // simply skip the texture read.\n                            if (nextTexelOffset === 1) {\n                                mainLoop += `\n                    xC${colIndex + 1} = xTexelC${colIndex};\n                    `;\n                            }\n                            else {\n                                mainLoop += `\n                    xCOffset = xC + ${nextTexelOffset};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                      xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${colIndex + 1}.zw = vec2(0.0);\n                      }\n                      xTexelC${colIndex + 1}Ready = 1;\n                    }\n\n                    xC${colIndex + 1} = xTexelC${colIndex + 1};\n                    `;\n                            }\n                        }\n                    }\n                }\n            }\n            else { // stride === 2\n                if (colIndex < filterWidth) {\n                    // Depending on whether padLeft is even or odd, we want either the\n                    // xy or zw channels from X texels for xC${colIndex}. If padLeft is\n                    // even, xC${colIndex +1} is simply the zw channels of texels we've\n                    // already sampled. But if padLeft is odd, xC{$c + 1}.zw will\n                    // need to come from the xy channels of a new texel, hence the `\n                    // vec4\n                    // final` initialized below.\n                    if (padLeft % 2 === 1) {\n                        mainLoop += `\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                  xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${colIndex}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                  xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${colIndex + 1}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex + 1}Ready = 1;\n                }\n\n                xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);\n              `;\n                        if (colIndex + 1 < filterWidth) {\n                            mainLoop += `\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);\n                `;\n                        }\n                    }\n                    else {\n                        mainLoop += `\n                if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                  xTexelC${colIndex} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${colIndex}.zw = vec2(0.0);\n                  }\n                  xTexelC${colIndex}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                  xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${colIndex + 1}.zw = vec2(0.);\n                  }\n                  xTexelC${colIndex + 1}Ready = 1;\n                }\n\n                xC${colIndex} = vec4(\n                  xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);\n              `;\n                        if (colIndex + 1 < filterWidth) {\n                            mainLoop += `\n                  xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);\n                `;\n                        }\n                    }\n                }\n            }\n            // localize the dotProd accumulation within the loop, the theory is for\n            // GPU with limited cache, accumulate sum across large amount of\n            // veriables will cause lots of cache misses. (i.e. 5x5 filter will have\n            // 50 variables)\n            if (colIndex < filterWidth) {\n                mainLoop += `\n            wTexel = getW(r, ${colIndex}, d1, q);\n            dotProd += xC${colIndex} * vec4(wTexel.xz, wTexel.xz);\n          `;\n                if (colIndex + 1 < filterWidth) {\n                    mainLoop += `\n              wTexel = getW(r, ${colIndex + 1}, d1, q);\n              dotProd += xC${colIndex + 1} * vec4(wTexel.xz, wTexel.xz);\n            `;\n                }\n            }\n        }\n        mainLoop += `\n    }\n  `;\n        mainLoop += `\n      }\n    `;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyReluAlpha) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyReluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${mainLoop}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9wYWNrZWRfZ3B1X2RlcHRod2lzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJnbC9zcmMvY29udl9wYWNrZWRfZ3B1X2RlcHRod2lzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQWUsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFekQsT0FBTyxFQUFlLGdCQUFnQixFQUFDLE1BQU0sY0FBYyxDQUFDO0FBRTVELE1BQU0sT0FBTyw0QkFBNEI7SUFjdkMsWUFDSSxRQUFpQyxFQUFFLE9BQU8sR0FBRyxLQUFLLEVBQ2xELGFBQXFCLElBQUksRUFBRSxrQkFBa0IsR0FBRyxLQUFLLEVBQ3JELGlCQUFpQixHQUFHLEtBQUs7UUFoQjdCLGtCQUFhLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDM0IsaUJBQVksR0FBRyxJQUFJLENBQUM7UUFDcEIsaUJBQVksR0FBRyxJQUFJLENBQUM7UUFJcEIsbUJBQWMsR0FBRztZQUNmLEVBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUsT0FBZ0IsRUFBRTtZQUN2QyxFQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLE9BQWdCLEVBQUU7WUFDMUMsRUFBQyxJQUFJLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxPQUFnQixFQUFFO1lBQzVDLEVBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsT0FBZ0IsRUFBRTtTQUMxQyxDQUFDO1FBTUEsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3JFLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxXQUFXLEdBQUcs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QixFQUFFO1lBQ3RCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLENBQUM7U0FDbkQ7UUFDRCxJQUFJLGlCQUFpQixFQUFFO1lBQ3JCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7U0FDM0M7UUFFRCxJQUFJLENBQUMsUUFBUSxHQUFHO1FBQ1osaUJBQWlCOzs7Ozs7O3dCQU9ELFVBQVU7NEJBQ04sVUFBVTs7Ozs7OztVQU81QixRQUFROzs7VUFHUixjQUFjO1VBQ2Qsc0JBQXNCOzs7S0FHM0IsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtiYWNrZW5kX3V0aWwsIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7R1BHUFVQcm9ncmFtLCB1c2VTaGFwZVVuaWZvcm1zfSBmcm9tICcuL2dwZ3B1X21hdGgnO1xuXG5leHBvcnQgY2xhc3MgRGVwdGh3aXNlQ29udlBhY2tlZDJEUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnVyddO1xuICBwYWNrZWRJbnB1dHMgPSB0cnVlO1xuICBwYWNrZWRPdXRwdXQgPSB0cnVlO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG4gIGVuYWJsZVNoYXBlVW5pZm9ybXM6IGJvb2xlYW47XG4gIGN1c3RvbVVuaWZvcm1zID0gW1xuICAgIHtuYW1lOiAncGFkcycsIHR5cGU6ICdpdmVjMicgYXMgY29uc3QgfSxcbiAgICB7bmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAnaXZlYzInIGFzIGNvbnN0IH0sXG4gICAge25hbWU6ICdkaWxhdGlvbnMnLCB0eXBlOiAnaXZlYzInIGFzIGNvbnN0IH0sXG4gICAge25hbWU6ICdpbkRpbXMnLCB0eXBlOiAnaXZlYzInIGFzIGNvbnN0IH0sXG4gIF07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBjb252SW5mbzogYmFja2VuZF91dGlsLkNvbnYyREluZm8sIGFkZEJpYXMgPSBmYWxzZSxcbiAgICAgIGFjdGl2YXRpb246IHN0cmluZyA9IG51bGwsIGhhc1ByZWx1QWN0aXZhdGlvbiA9IGZhbHNlLFxuICAgICAgaGFzTGVha3lSZWx1QWxwaGEgPSBmYWxzZSkge1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICB0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXMgPSB1c2VTaGFwZVVuaWZvcm1zKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgICBjb25zdCBjaGFubmVsTXVsID0gY29udkluZm8ub3V0Q2hhbm5lbHMgLyBjb252SW5mby5pbkNoYW5uZWxzO1xuICAgIGNvbnN0IHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgY29uc3Qgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICBjb25zdCBkaWxhdGlvbldpZHRoID0gY29udkluZm8uZGlsYXRpb25XaWR0aDtcbiAgICBjb25zdCBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgY29uc3QgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICBjb25zdCB0ZXhlbHNBY3Jvc3MgPSBmaWx0ZXJXaWR0aDtcblxuICAgIGxldCBtYWluTG9vcCA9IGBcbiAgICAgIGludCB4UjsgaW50IHhDOyBpbnQgeENPZmZzZXQ7XG4gICAgICB2ZWM0IHdUZXhlbDsgdmVjNCBwcmV2aW91czsgdmVjNCBmaW5hbDtgO1xuXG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBmaWx0ZXJXaWR0aDsgYysrKSB7XG4gICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgdmVjNCB4VGV4ZWxDJHtjICogMn07XG4gICAgICAgICAgaW50IHhUZXhlbEMke2MgKiAyfVJlYWR5O1xuICAgICAgICAgIHZlYzQgeFRleGVsQyR7YyAqIDIgKyAxfTtcbiAgICAgICAgICBpbnQgeFRleGVsQyR7YyAqIDIgKyAxfVJlYWR5O1xuICAgICAgICAgIHZlYzQgeEMke2N9O2A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyB2ZWN0b3JpemVkIGltcGxlbWVudGF0aW9uIHdvcmtzIGJ5IGdhdGhlcmluZyB0aGUgdmFsdWVzIG5lZWRlZCBmb3JcbiAgICAgKiBlYWNoIG91dHB1dCBjaGFubmVsJ3MgZG90IHByb2R1Y3QgaW50byB2ZWM0J3MgYW5kIHRoZW4gbXVsdGlwbHlpbmcgdGhlbVxuICAgICAqIGFsbCB0b2dldGhlciAodGhpcyBoYXBwZW5zIGluIHRoZSBmaW5hbCBkb3VibGUgZm9yLWxvb3AgYmVsb3cpLiBNb3N0IG9mXG4gICAgICogdGhlIG1haW4gbG9vcCBjb25zaXN0cyBvZiBjb25zdHJ1Y3RpbmcgdGhlc2UgdmVjNCdzIHdpdGggdGhlIG1pbmltdW1cbiAgICAgKiBudW1iZXIgb2YgdGV4dHVyZTJEIGNhbGxzLCB3aGljaCBtZWFucyBtYWtpbmcgdXNlIG9mIGFsbCBmb3VyIHJldHVybmVkXG4gICAgICogdmFsdWVzIGZyb20gYSB0ZXh0dXJlMkQgY2FsbCBhdCBvbmNlLlxuICAgICAqL1xuICAgIG1haW5Mb29wICs9IGBcbiAgICBmb3IgKGludCByID0gMDsgciA8ICR7ZmlsdGVySGVpZ2h0fTsgcisrKSB7XG4gICAgICBgO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgZmlsdGVyV2lkdGg7IGMrKykge1xuICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgIHhUZXhlbEMke2MgKiAyfSA9IHZlYzQoMC4wKTtcbiAgICAgICAgICB4VGV4ZWxDJHtjICogMn1SZWFkeSA9IDA7XG4gICAgICAgICAgeFRleGVsQyR7YyAqIDIgKyAxfSA9IHZlYzQoMC4wKTtcbiAgICAgICAgICB4VGV4ZWxDJHtjICogMiArIDF9UmVhZHkgPSAwO1xuICAgICAgICAgIHhDJHtjfSA9IHZlYzQoMC4wKTtgO1xuICAgIH1cbiAgICBtYWluTG9vcCArPSBgXG4gICAgICAgIHhSID0geFJDb3JuZXIgKyByICogZGlsYXRpb25zWzBdO1xuICAgICAgICBpZiAoeFIgPj0wICYmIHhSIDwgaW5EaW1zWzBdKSB7XG4gICAgICBgO1xuXG4gICAgZm9yIChsZXQgdGV4ZWxDID0gMDsgdGV4ZWxDIDwgKHRleGVsc0Fjcm9zcyArIDEpIC8gMjsgdGV4ZWxDKyspIHtcbiAgICAgIGNvbnN0IGNvbEluZGV4ID0gdGV4ZWxDICogMjtcblxuICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgIHhDID0geENDb3JuZXIgKyAke2NvbEluZGV4ICogZGlsYXRpb25XaWR0aH07XG4gICAgICAgICAgYDtcblxuICAgICAgaWYgKHN0cmlkZVdpZHRoID09PSAxKSB7XG4gICAgICAgIGlmIChjb2xJbmRleCA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgICAgLy8gSWYgcGFkZGluZyBpcyBvZGQsIHRoZSBvdXRlciB0ZXhlbHMgaGF2ZSB0byBiZSBjb21wb3NlZC5cbiAgICAgICAgICBpZiAocGFkTGVmdCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEVuc3VyZSB2ZWM0IHByZXZpb3VzIGRvZXMgbm90IHJlc3VsdCBpbiByZWR1bmRhbnQgc2FtcGxlLFxuICAgICAgICAgICAgLy8gYW5kIGF2b2lkIHNldHRpbmcgeFRleGVsUkMncyB0aGF0IGV4Y2VlZCB0aGUgYm91bmRhcnkgaW4gdGhlXG4gICAgICAgICAgICAvLyBmaXJzdCBwbGFjZSByYXRoZXIgdGhhbiByZXNldHRpbmcgdGhlbSB0byB2ZWM0KDApKS5cblxuICAgICAgICAgICAgLy8gVG8gY29tcHV0ZSB4Q09mZnNldDpcbiAgICAgICAgICAgIC8vIC0gSWYgcGFkZGluZyBpcyBvZGQsIHdlIG11c3QgYWRkIDEgdG8gZW5zdXJlIHdlIGFzayBmb3IgYW5cbiAgICAgICAgICAgIC8vIGV2ZW4tbnVtYmVyZWQgcm93LlxuICAgICAgICAgICAgLy8gLSBXZSBzdWJ0cmFjdCAyIHRvIGFjY2VzcyB0aGUgcHJldmlvdXMgdGV4ZWwuXG5cbiAgICAgICAgICAgIG1haW5Mb29wICs9IGBcbiAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICBjb2xJbmRleH1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH0gPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcblxuICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBtYW51YWxseSBjbGVhciB1bnVzZWQgY2hhbm5lbHMgaW4gY2FzZVxuICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgLy8gVGhpcyB0ZXhlbCBoYXMgYmVlbiByZWFkIGluIHByZXZpb3VzIGl0ZXJhdGlvbiBpZiB0aGUgZGlsYXRpb25cbiAgICAgICAgICAgIC8vIGlzIDEuXG4gICAgICAgICAgICBpZiAoZGlsYXRpb25XaWR0aCA9PT0gMSAmJiBjb2xJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleH0gPSB2ZWM0KHhUZXhlbEMke2NvbEluZGV4IC0gMn0uencsIHhUZXhlbEMke1xuICAgICAgICAgICAgICAgICAgY29sSW5kZXh9Lnh5KTtcbiAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSAyO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMuencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXh9ID0gdmVjNChwcmV2aW91cy56dywgeFRleGVsQyR7Y29sSW5kZXh9Lnh5KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleH0gPSB2ZWM0KDAuMCwgMC4wLCB4VGV4ZWxDJHtjb2xJbmRleH0ueHkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUGFkZGluZyBpcyBldmVuLCBzbyB4UkMgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGUgdGV4ZWwuXG4gICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgaWYgKHhDID49IDAgJiYgeEMgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7Y29sSW5kZXh9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9ID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEMgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeEMke2NvbEluZGV4fSA9IHhUZXhlbEMke2NvbEluZGV4fTtcbiAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb2xJbmRleCArIDEgPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAgLy8gSWYgZGlsYXRpb24gaXMgZXZlbiwgdGhlIHNlY29uZCBlbnRyeSBzaG91bGQgbWF0Y2ggdGhlIGZpcnN0XG4gICAgICAgICAgICAvLyAoZWl0aGVyIGJvdGggYXJlIGNvbXBvc2VkIG9yIGJvdGggYXJlIHNpbmdsZSBzYW1wbGVzKS4gQnV0IGlmXG4gICAgICAgICAgICAvLyBkaWxhdGlvbiBpcyBvZGQsIHRoZW4gdGhlIHNlY29uZCBlbnRyeSBzaG91bGQgYmUgdGhlIG9wcG9zaXRlXG4gICAgICAgICAgICAvLyBvZiB0aGUgZmlyc3QgKGlmIHRoZSBmaXJzdCBpcyBjb21wb3NlZCwgdGhlIHNlY29uZCBpcyBhIHNpbmdsZVxuICAgICAgICAgICAgLy8gc2FtcGxlLCBhbmQgdmljZSB2ZXJzYS4pXG5cbiAgICAgICAgICAgIGNvbnN0IG5leHRUZXhlbE9mZnNldCA9IHBhZExlZnQgJSAyID09PSAwID9cbiAgICAgICAgICAgICAgICB1dGlsLm5lYXJlc3RMYXJnZXJFdmVuKGRpbGF0aW9uV2lkdGgpIDpcbiAgICAgICAgICAgICAgICBkaWxhdGlvbldpZHRoO1xuXG4gICAgICAgICAgICBpZiAoKGRpbGF0aW9uV2lkdGggJSAyID09PSAwICYmIHBhZExlZnQgJSAyID09PSAxKSB8fFxuICAgICAgICAgICAgICAgIChkaWxhdGlvbldpZHRoICUgMiAhPT0gMCAmJiBwYWRMZWZ0ICUgMiAhPT0gMSkpIHtcbiAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIGltb2QocGFkc1sxXSwgMikgKyAke25leHRUZXhlbE9mZnNldH07XG5cbiAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke1xuICAgICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYDtcblxuICAgICAgICAgICAgICAvLyBJZiBkaWxhdGlvbiA+IDEgdGhlbiB0aGUgeFJDJ3Mgd2lsbCBub3QgYmUgYWJsZSB0byBzaGFyZSBhbnlcbiAgICAgICAgICAgICAgLy8gdmFsdWVzLCBzbyBlYWNoIHhSQyB3aWxsIHJlcXVpcmUgdHdvIHVuaXF1ZSBjYWxscyB0byBnZXRYLlxuICAgICAgICAgICAgICBpZiAoZGlsYXRpb25XaWR0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0IC09IDI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCA+PSAwICYmIHhDT2Zmc2V0IDwgaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB2ZWM0KHByZXZpb3VzLnp3LCB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfS54eSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXggKyAxfSA9IHZlYzQoMC4wLCAwLjAsIHhUZXhlbEMke1xuICAgICAgICAgICAgICAgICAgICAgICBjb2xJbmRleCArIDF9Lnh5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1haW5Mb29wICs9IGBcbiAgICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB2ZWM0KHhUZXhlbEMke2NvbEluZGV4fS56dywgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgICAgIGNvbEluZGV4ICsgMX0ueHkpO1xuICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJZiBkaWxhdGlvbiBpcyAxIGFuZCBwYWRkaW5nIGlzIG9kZCwgd2UgaGF2ZSBhbHJlYWR5IHJlYWQgdGhlXG4gICAgICAgICAgICAgIC8vIHRleGVsIHdoZW4gY29uc3RydWN0aW5nIHRoZSBwcmV2aW91cyB4IHZhbHVlLiBIZXJlIHdlIGNhblxuICAgICAgICAgICAgICAvLyBzaW1wbHkgc2tpcCB0aGUgdGV4dHVyZSByZWFkLlxuICAgICAgICAgICAgICBpZiAobmV4dFRleGVsT2Zmc2V0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXggKyAxfSA9IHhUZXhlbEMke2NvbEluZGV4fTtcbiAgICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAke25leHRUZXhlbE9mZnNldH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgICAgIGNvbEluZGV4ICsgMX1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9Lnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB4VGV4ZWxDJHtjb2xJbmRleCArIDF9O1xuICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgeyAgLy8gc3RyaWRlID09PSAyXG4gICAgICAgIGlmIChjb2xJbmRleCA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHdoZXRoZXIgcGFkTGVmdCBpcyBldmVuIG9yIG9kZCwgd2Ugd2FudCBlaXRoZXIgdGhlXG4gICAgICAgICAgLy8geHkgb3IgencgY2hhbm5lbHMgZnJvbSBYIHRleGVscyBmb3IgeEMke2NvbEluZGV4fS4gSWYgcGFkTGVmdCBpc1xuICAgICAgICAgIC8vIGV2ZW4sIHhDJHtjb2xJbmRleCArMX0gaXMgc2ltcGx5IHRoZSB6dyBjaGFubmVscyBvZiB0ZXhlbHMgd2UndmVcbiAgICAgICAgICAvLyBhbHJlYWR5IHNhbXBsZWQuIEJ1dCBpZiBwYWRMZWZ0IGlzIG9kZCwgeEN7JGMgKyAxfS56dyB3aWxsXG4gICAgICAgICAgLy8gbmVlZCB0byBjb21lIGZyb20gdGhlIHh5IGNoYW5uZWxzIG9mIGEgbmV3IHRleGVsLCBoZW5jZSB0aGUgYFxuICAgICAgICAgIC8vIHZlYzRcbiAgICAgICAgICAvLyBmaW5hbGAgaW5pdGlhbGl6ZWQgYmVsb3cuXG4gICAgICAgICAgaWYgKHBhZExlZnQgJSAyID09PSAxKSB7XG4gICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSBzdHJpZGVzWzFdO1xuICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgY29sSW5kZXh9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4fS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4fVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZih4QyArIDEgPj0gMCAmJiB4QyArIDEgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4ICsgMX0gPSBnZXRYKGJhdGNoLCB4UiwgeEMgKyAxLCBkMSk7XG4gICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgIGlmICh4QyArIDIgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4ICsgMX0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleH0gPSB2ZWM0KHhUZXhlbEMke2NvbEluZGV4fS56dywgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfS56dyk7XG4gICAgICAgICAgICAgIGA7XG5cbiAgICAgICAgICAgIGlmIChjb2xJbmRleCArIDEgPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICBmaW5hbCA9IHZlYzQoMC4wKTtcbiAgICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxICsgc3RyaWRlc1sxXTtcbiAgICAgICAgICAgICAgICAgIGlmKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWwgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleCArIDF9ID0gdmVjNCh4VGV4ZWxDJHtjb2xJbmRleCArIDF9Lnh5LCBmaW5hbC54eSk7XG4gICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgIGlmKHhDID49IDAgJiYgeEMgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7Y29sSW5kZXh9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9ID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEMgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIHN0cmlkZXNbMV07XG4gICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICBjb2xJbmRleCArIDF9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfS56dyA9IHZlYzIoMC4pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXh9ID0gdmVjNChcbiAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4fS54eSwgeFRleGVsQyR7Y29sSW5kZXggKyAxfS54eSk7XG4gICAgICAgICAgICAgIGA7XG5cbiAgICAgICAgICAgIGlmIChjb2xJbmRleCArIDEgPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXggKyAxfSA9IHZlYzQoeFRleGVsQyR7Y29sSW5kZXh9Lnp3LCB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgIGNvbEluZGV4ICsgMX0uencpO1xuICAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGxvY2FsaXplIHRoZSBkb3RQcm9kIGFjY3VtdWxhdGlvbiB3aXRoaW4gdGhlIGxvb3AsIHRoZSB0aGVvcnkgaXMgZm9yXG4gICAgICAvLyBHUFUgd2l0aCBsaW1pdGVkIGNhY2hlLCBhY2N1bXVsYXRlIHN1bSBhY3Jvc3MgbGFyZ2UgYW1vdW50IG9mXG4gICAgICAvLyB2ZXJpYWJsZXMgd2lsbCBjYXVzZSBsb3RzIG9mIGNhY2hlIG1pc3Nlcy4gKGkuZS4gNXg1IGZpbHRlciB3aWxsIGhhdmVcbiAgICAgIC8vIDUwIHZhcmlhYmxlcylcbiAgICAgIGlmIChjb2xJbmRleCA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgIG1haW5Mb29wICs9IGBcbiAgICAgICAgICAgIHdUZXhlbCA9IGdldFcociwgJHtjb2xJbmRleH0sIGQxLCBxKTtcbiAgICAgICAgICAgIGRvdFByb2QgKz0geEMke2NvbEluZGV4fSAqIHZlYzQod1RleGVsLnh6LCB3VGV4ZWwueHopO1xuICAgICAgICAgIGA7XG5cbiAgICAgICAgaWYgKGNvbEluZGV4ICsgMSA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICB3VGV4ZWwgPSBnZXRXKHIsICR7Y29sSW5kZXggKyAxfSwgZDEsIHEpO1xuICAgICAgICAgICAgICBkb3RQcm9kICs9IHhDJHtjb2xJbmRleCArIDF9ICogdmVjNCh3VGV4ZWwueHosIHdUZXhlbC54eik7XG4gICAgICAgICAgICBgO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1haW5Mb29wICs9IGBcbiAgICB9XG4gIGA7XG4gICAgbWFpbkxvb3AgKz0gYFxuICAgICAgfVxuICAgIGA7XG5cbiAgICBsZXQgYWN0aXZhdGlvblNuaXBwZXQgPSAnJywgYXBwbHlBY3RpdmF0aW9uU25pcHBldCA9ICcnO1xuICAgIGlmIChhY3RpdmF0aW9uKSB7XG4gICAgICBpZiAoaGFzUHJlbHVBY3RpdmF0aW9uKSB7XG4gICAgICAgIGFjdGl2YXRpb25TbmlwcGV0ID0gYHZlYzQgYWN0aXZhdGlvbih2ZWM0IGEpIHtcbiAgICAgICAgICB2ZWM0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcbiAgICAgICAgICAke2FjdGl2YXRpb259XG4gICAgICAgIH1gO1xuICAgICAgfSBlbHNlIGlmIChoYXNMZWFreVJlbHVBbHBoYSkge1xuICAgICAgICBhY3RpdmF0aW9uU25pcHBldCA9IGB2ZWM0IGFjdGl2YXRpb24odmVjNCBhKSB7XG4gICAgICAgICAgdmVjNCBiID0gZ2V0TGVha3lyZWx1QWxwaGFBdE91dENvb3JkcygpO1xuICAgICAgICAgICR7YWN0aXZhdGlvbn1cbiAgICAgICAgfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0aW9uU25pcHBldCA9IGB2ZWM0IGFjdGl2YXRpb24odmVjNCB4KSB7XG4gICAgICAgICAgJHthY3RpdmF0aW9ufVxuICAgICAgICB9YDtcbiAgICAgIH1cblxuICAgICAgYXBwbHlBY3RpdmF0aW9uU25pcHBldCA9IGByZXN1bHQgPSBhY3RpdmF0aW9uKHJlc3VsdCk7YDtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRCaWFzU25pcHBldCA9IGFkZEJpYXMgPyAncmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpOycgOiAnJztcbiAgICBpZiAoYWRkQmlhcykge1xuICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2JpYXMnKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUHJlbHVBY3RpdmF0aW9uKSB7XG4gICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgncHJlbHVBY3RpdmF0aW9uV2VpZ2h0cycpO1xuICAgIH1cbiAgICBpZiAoaGFzTGVha3lSZWx1QWxwaGEpIHtcbiAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdsZWFreXJlbHVBbHBoYScpO1xuICAgIH1cblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICAke2FjdGl2YXRpb25TbmlwcGV0fVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xuICAgICAgICBpbnQgZDEgPSBkMiAvICR7Y2hhbm5lbE11bH07XG4gICAgICAgIGludCBxID0gZDIgLSBkMSAqICR7Y2hhbm5lbE11bH07XG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xuICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcblxuICAgICAgICAvL2ludGlhbGl6ZSBkb3RQcm9kIHdpdGggYSBzbWFsbCBlcHNpbG9uIHNlZW1zIHRvIHJlZHVjZSBHUFUgYWNjdXJhY3kgbG9zcy5cbiAgICAgICAgdmVjNCBkb3RQcm9kID0gdmVjNCgwLjAwMDAwMDAwMDAwMDAwMSk7XG5cbiAgICAgICAgJHttYWluTG9vcH1cblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IGRvdFByb2QgLSB2ZWM0KDAuMDAwMDAwMDAwMDAwMDAxKTtcbiAgICAgICAgJHthZGRCaWFzU25pcHBldH1cbiAgICAgICAgJHthcHBseUFjdGl2YXRpb25TbmlwcGV0fVxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class CropAndResizeProgram {\n    constructor(imageShape, boxShape, cropSize, method, extrapolationValue) {\n        this.variableNames = ['Image', 'Boxes', 'BoxInd'];\n        this.outputShape = [];\n        const [batch, imageHeight, imageWidth, depth] = imageShape;\n        const [numBoxes,] = boxShape;\n        const [cropHeight, cropWidth] = cropSize;\n        this.outputShape = [numBoxes, cropHeight, cropWidth, depth];\n        const methodId = method === 'bilinear' ? 1 : 0;\n        const [inputHeightFloat, inputWidthFloat] = [`${imageHeight - 1}.0`, `${imageWidth - 1}.0`];\n        const [heightRatio, heightScale, inY] = cropHeight > 1 ?\n            [\n                `${(imageHeight - 1) / (cropHeight - 1)}`,\n                '(y2-y1) * height_ratio',\n                `y1*${inputHeightFloat} + float(y)*(height_scale)`,\n            ] :\n            [\n                '0.0',\n                '0.0',\n                `0.5 * (y1+y2) * ${inputHeightFloat}`,\n            ];\n        const [widthRatio, widthScale, inX] = cropWidth > 1 ?\n            [\n                `${(imageWidth - 1) / (cropWidth - 1)}`,\n                '(x2-x1) * width_ratio',\n                `x1*${inputWidthFloat} + float(x)*(width_scale)`,\n            ] :\n            [\n                '0.0',\n                '0.0',\n                `0.5 * (x1+x2) * ${inputWidthFloat}`,\n            ];\n        // Reference implementation\n        // tslint:disable-next-line:max-line-length\n        // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n        this.userCode = `\n      const float height_ratio = float(${heightRatio});\n      const float width_ratio = float(${widthRatio});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${batch}) {\n          return;\n        }\n\n        float height_scale = ${heightScale};\n        float width_scale = ${widthScale};\n\n        float in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n        float in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          setOutput(float(${extrapolationValue}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${methodId} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JvcF9hbmRfcmVzaXplX2dwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJnbC9zcmMvY3JvcF9hbmRfcmVzaXplX2dwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFJSCxNQUFNLE9BQU8sb0JBQW9CO0lBSy9CLFlBQ0ksVUFBNEMsRUFBRSxRQUEwQixFQUN4RSxRQUEwQixFQUFFLE1BQTRCLEVBQ3hELGtCQUEwQjtRQVA5QixrQkFBYSxHQUFHLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztRQUM3QyxnQkFBVyxHQUFhLEVBQUUsQ0FBQztRQU96QixNQUFNLENBQUMsS0FBSyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsS0FBSyxDQUFDLEdBQUcsVUFBVSxDQUFDO1FBQzNELE1BQU0sQ0FBQyxRQUFRLEVBQUcsR0FBRyxRQUFRLENBQUM7UUFDOUIsTUFBTSxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsR0FBRyxRQUFRLENBQUM7UUFDekMsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLFFBQVEsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzVELE1BQU0sUUFBUSxHQUFHLE1BQU0sS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRS9DLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxlQUFlLENBQUMsR0FDckMsQ0FBQyxHQUFHLFdBQVcsR0FBRyxDQUFDLElBQUksRUFBRSxHQUFHLFVBQVUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXBELE1BQU0sQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLEdBQUcsQ0FBQyxHQUFHLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNwRDtnQkFDRSxHQUFHLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFO2dCQUN6Qyx3QkFBd0I7Z0JBQ3hCLE1BQU0sZ0JBQWdCLDRCQUE0QjthQUNuRCxDQUFDLENBQUM7WUFDSDtnQkFDRSxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsbUJBQW1CLGdCQUFnQixFQUFFO2FBQ3RDLENBQUM7UUFDTixNQUFNLENBQUMsVUFBVSxFQUFFLFVBQVUsRUFBRSxHQUFHLENBQUMsR0FBRyxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDakQ7Z0JBQ0UsR0FBRyxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsRUFBRTtnQkFDdkMsdUJBQXVCO2dCQUN2QixNQUFNLGVBQWUsMkJBQTJCO2FBQ2pELENBQUMsQ0FBQztZQUNIO2dCQUNFLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxtQkFBbUIsZUFBZSxFQUFFO2FBQ3JDLENBQUM7UUFFTiwyQkFBMkI7UUFDM0IsMkNBQTJDO1FBQzNDLDRHQUE0RztRQUM1RyxJQUFJLENBQUMsUUFBUSxHQUFHO3lDQUNxQixXQUFXO3dDQUNaLFVBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7aUNBZ0JqQixLQUFLOzs7OytCQUlQLFdBQVc7OEJBQ1osVUFBVTs7dUJBRWpCLEdBQUc7bUNBQ1MsZ0JBQWdCOzRCQUN2QixrQkFBa0I7Ozt1QkFHdkIsR0FBRzttQ0FDUyxlQUFlOzRCQUN0QixrQkFBa0I7Ozs7O2FBS2pDLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXdCaEIsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtHUEdQVVByb2dyYW19IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbmV4cG9ydCBjbGFzcyBDcm9wQW5kUmVzaXplUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ0ltYWdlJywgJ0JveGVzJywgJ0JveEluZCddO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIGltYWdlU2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdLCBib3hTaGFwZTogW251bWJlciwgbnVtYmVyXSxcbiAgICAgIGNyb3BTaXplOiBbbnVtYmVyLCBudW1iZXJdLCBtZXRob2Q6ICdiaWxpbmVhcid8J25lYXJlc3QnLFxuICAgICAgZXh0cmFwb2xhdGlvblZhbHVlOiBudW1iZXIpIHtcbiAgICBjb25zdCBbYmF0Y2gsIGltYWdlSGVpZ2h0LCBpbWFnZVdpZHRoLCBkZXB0aF0gPSBpbWFnZVNoYXBlO1xuICAgIGNvbnN0IFtudW1Cb3hlcywgXSA9IGJveFNoYXBlO1xuICAgIGNvbnN0IFtjcm9wSGVpZ2h0LCBjcm9wV2lkdGhdID0gY3JvcFNpemU7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtudW1Cb3hlcywgY3JvcEhlaWdodCwgY3JvcFdpZHRoLCBkZXB0aF07XG4gICAgY29uc3QgbWV0aG9kSWQgPSBtZXRob2QgPT09ICdiaWxpbmVhcicgPyAxIDogMDtcblxuICAgIGNvbnN0IFtpbnB1dEhlaWdodEZsb2F0LCBpbnB1dFdpZHRoRmxvYXRdID1cbiAgICAgICAgW2Ake2ltYWdlSGVpZ2h0IC0gMX0uMGAsIGAke2ltYWdlV2lkdGggLSAxfS4wYF07XG5cbiAgICBjb25zdCBbaGVpZ2h0UmF0aW8sIGhlaWdodFNjYWxlLCBpblldID0gY3JvcEhlaWdodCA+IDEgP1xuICAgICAgICBbXG4gICAgICAgICAgYCR7KGltYWdlSGVpZ2h0IC0gMSkgLyAoY3JvcEhlaWdodCAtIDEpfWAsXG4gICAgICAgICAgJyh5Mi15MSkgKiBoZWlnaHRfcmF0aW8nLFxuICAgICAgICAgIGB5MSoke2lucHV0SGVpZ2h0RmxvYXR9ICsgZmxvYXQoeSkqKGhlaWdodF9zY2FsZSlgLFxuICAgICAgICBdIDpcbiAgICAgICAgW1xuICAgICAgICAgICcwLjAnLFxuICAgICAgICAgICcwLjAnLFxuICAgICAgICAgIGAwLjUgKiAoeTEreTIpICogJHtpbnB1dEhlaWdodEZsb2F0fWAsXG4gICAgICAgIF07XG4gICAgY29uc3QgW3dpZHRoUmF0aW8sIHdpZHRoU2NhbGUsIGluWF0gPSBjcm9wV2lkdGggPiAxID9cbiAgICAgICAgW1xuICAgICAgICAgIGAkeyhpbWFnZVdpZHRoIC0gMSkgLyAoY3JvcFdpZHRoIC0gMSl9YCxcbiAgICAgICAgICAnKHgyLXgxKSAqIHdpZHRoX3JhdGlvJyxcbiAgICAgICAgICBgeDEqJHtpbnB1dFdpZHRoRmxvYXR9ICsgZmxvYXQoeCkqKHdpZHRoX3NjYWxlKWAsXG4gICAgICAgIF0gOlxuICAgICAgICBbXG4gICAgICAgICAgJzAuMCcsXG4gICAgICAgICAgJzAuMCcsXG4gICAgICAgICAgYDAuNSAqICh4MSt4MikgKiAke2lucHV0V2lkdGhGbG9hdH1gLFxuICAgICAgICBdO1xuXG4gICAgLy8gUmVmZXJlbmNlIGltcGxlbWVudGF0aW9uXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RlbnNvcmZsb3cvYmxvYi9tYXN0ZXIvdGVuc29yZmxvdy9jb3JlL2tlcm5lbHMvY3JvcF9hbmRfcmVzaXplX29wX2dwdS5jdS5jY1xuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICBjb25zdCBmbG9hdCBoZWlnaHRfcmF0aW8gPSBmbG9hdCgke2hlaWdodFJhdGlvfSk7XG4gICAgICBjb25zdCBmbG9hdCB3aWR0aF9yYXRpbyA9IGZsb2F0KCR7d2lkdGhSYXRpb30pO1xuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XG4gICAgICAgIGludCB5ID0gY29vcmRzWzFdO1xuICAgICAgICBpbnQgeCA9IGNvb3Jkc1syXTtcbiAgICAgICAgaW50IGQgPSBjb29yZHNbM107XG5cbiAgICAgICAgLy8gZ2V0IGJveCB2YWxzXG4gICAgICAgIGZsb2F0IHkxID0gZ2V0Qm94ZXMoYiwwKTtcbiAgICAgICAgZmxvYXQgeDEgPSBnZXRCb3hlcyhiLDEpO1xuICAgICAgICBmbG9hdCB5MiA9IGdldEJveGVzKGIsMik7XG4gICAgICAgIGZsb2F0IHgyID0gZ2V0Qm94ZXMoYiwzKTtcblxuICAgICAgICAvLyBnZXQgaW1hZ2UgaW4gYmF0Y2ggaW5kZXhcbiAgICAgICAgaW50IGJJbmQgPSByb3VuZChnZXRCb3hJbmQoYikpO1xuICAgICAgICBpZihiSW5kIDwgMCB8fCBiSW5kID49ICR7YmF0Y2h9KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZmxvYXQgaGVpZ2h0X3NjYWxlID0gJHtoZWlnaHRTY2FsZX07XG4gICAgICAgIGZsb2F0IHdpZHRoX3NjYWxlID0gJHt3aWR0aFNjYWxlfTtcblxuICAgICAgICBmbG9hdCBpbl95ID0gJHtpbll9O1xuICAgICAgICBpZiggaW5feSA8IDAuMCB8fCBpbl95ID4gJHtpbnB1dEhlaWdodEZsb2F0fSApIHtcbiAgICAgICAgICBzZXRPdXRwdXQoZmxvYXQoJHtleHRyYXBvbGF0aW9uVmFsdWV9KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZsb2F0IGluX3ggPSAke2luWH07XG4gICAgICAgIGlmKCBpbl94IDwgMC4wIHx8IGluX3ggPiAke2lucHV0V2lkdGhGbG9hdH0gKSB7XG4gICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KCR7ZXh0cmFwb2xhdGlvblZhbHVlfSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlYzIgc291cmNlRnJhY0luZGV4Q1IgPSB2ZWMyKGluX3gsaW5feSk7XG4gICAgICAgIGlmKCR7bWV0aG9kSWR9ID09IDEpIHtcbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cbiAgICAgICAgICBpdmVjMiBzb3VyY2VGbG9vckNSID0gaXZlYzIoc291cmNlRnJhY0luZGV4Q1IpO1xuICAgICAgICAgIGl2ZWMyIHNvdXJjZUNlaWxDUiA9IGl2ZWMyKGNlaWwoc291cmNlRnJhY0luZGV4Q1IpKTtcblxuICAgICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRJbWFnZShiLCBzb3VyY2VGbG9vckNSLnksIHNvdXJjZUZsb29yQ1IueCwgZCk7XG4gICAgICAgICAgZmxvYXQgYm90dG9tTGVmdCA9IGdldEltYWdlKGIsIHNvdXJjZUNlaWxDUi55LCBzb3VyY2VGbG9vckNSLngsIGQpO1xuICAgICAgICAgIGZsb2F0IHRvcFJpZ2h0ID0gZ2V0SW1hZ2UoYiwgc291cmNlRmxvb3JDUi55LCBzb3VyY2VDZWlsQ1IueCwgZCk7XG4gICAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRJbWFnZShiLCBzb3VyY2VDZWlsQ1IueSwgc291cmNlQ2VpbENSLngsIGQpO1xuXG4gICAgICAgICAgdmVjMiBmcmFjQ1IgPSBzb3VyY2VGcmFjSW5kZXhDUiAtIHZlYzIoc291cmNlRmxvb3JDUik7XG5cbiAgICAgICAgICBmbG9hdCB0b3AgPSB0b3BMZWZ0ICsgKHRvcFJpZ2h0IC0gdG9wTGVmdCkgKiBmcmFjQ1IueDtcbiAgICAgICAgICBmbG9hdCBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBmcmFjQ1IueDtcbiAgICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY0NSLnk7XG4gICAgICAgICAgc2V0T3V0cHV0KG5ld1ZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDb21wdXRlIHRoZSBjb29yZGluYXRvcnMgb2YgbmVhcmVzdCBuZWlnaGJvciBwb2ludC5cbiAgICAgICAgICBpdmVjMiBzb3VyY2VOZWFyZXN0Q1IgPSBpdmVjMihmbG9vcihcbiAgICAgICAgICAgIHNvdXJjZUZyYWNJbmRleENSICsgdmVjMigwLjUsMC41KSkpO1xuICAgICAgICAgIGZsb2F0IG5ld1ZhbHVlID0gZ2V0SW1hZ2UoYiwgc291cmNlTmVhcmVzdENSLnksIHNvdXJjZU5lYXJlc3RDUi54LCBkKTtcbiAgICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuIl19","import { getCoordsDataType } from './shader_compiler';\nexport var CumOpType;\n(function (CumOpType) {\n    CumOpType[\"Prod\"] = \"*\";\n    CumOpType[\"Sum\"] = \"+\";\n})(CumOpType || (CumOpType = {}));\nexport class CumProgram {\n    constructor(op, outputShape, exclusive, reverse) {\n        this.op = op;\n        this.outputShape = outputShape;\n        this.variableNames = ['x'];\n        this.customUniforms = [{ name: 'index', type: 'float' }];\n        const rank = this.outputShape.length;\n        const initVal = this.op === CumOpType.Prod ? '1.0' : '0.0';\n        const val = exclusive ? initVal : `getX(${getCoords(rank, 'coords', this.op)})`;\n        const length = this.outputShape[this.outputShape.length - 1];\n        let condition = '';\n        let idxString = '';\n        // When exclusive is set, the cum op becomes roll op that copies the\n        // value from the previous index based on the direction specified by the\n        // reverse flag.\n        if (exclusive) {\n            condition = reverse ? `end != ${length - 1}` : 'end != 0';\n            idxString = reverse ? 'end + 1' : 'end - 1';\n        }\n        else {\n            condition = reverse ? `end + pow2 < ${length}` : 'end >= pow2';\n            idxString = (reverse ? 'end + pow2' : 'end - pow2');\n        }\n        this.userCode = `\n      void main() {\n        ${getCoordsDataType(rank)} coords = getOutputCoords();\n        int end = ${getFinalCoord(rank, 'coords', this.op)};\n        float val = ${val};\n        int pow2 = int(pow(2.0, index));\n        if (${condition}) {\n          int idx = ${idxString};\n          ${getFinalCoord(rank, 'coords', this.op)} = idx;\n          val ${this.op}= getX(${getCoords(rank, 'coords', this.op)});\n        }\n        setOutput(val);\n      }\n    `;\n    }\n}\nfunction getCoords(rank, name, op) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.x, ${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.x, ${name}.y, ${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.x, ${name}.y, ${name}.z, ${name}.w`;\n    }\n    else {\n        throw new Error(`Cumulative ${op} for rank ${rank} is not yet supported`);\n    }\n}\nfunction getFinalCoord(rank, name, op) {\n    if (rank === 1) {\n        return `${name}`;\n    }\n    else if (rank === 2) {\n        return `${name}.y`;\n    }\n    else if (rank === 3) {\n        return `${name}.z`;\n    }\n    else if (rank === 4) {\n        return `${name}.w`;\n    }\n    else {\n        throw new Error(`Cumulative ${op} for rank ${rank} is not yet supported`);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VtX2dwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJnbC9zcmMvY3VtX2dwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpQkEsT0FBTyxFQUFDLGlCQUFpQixFQUFjLE1BQU0sbUJBQW1CLENBQUM7QUFFakUsTUFBTSxDQUFOLElBQVksU0FHWDtBQUhELFdBQVksU0FBUztJQUNuQix1QkFBVSxDQUFBO0lBQ1Ysc0JBQVMsQ0FBQTtBQUNYLENBQUMsRUFIVyxTQUFTLEtBQVQsU0FBUyxRQUdwQjtBQUVELE1BQU0sT0FBTyxVQUFVO0lBS3JCLFlBQ1csRUFBYSxFQUFTLFdBQXFCLEVBQUUsU0FBa0IsRUFDdEUsT0FBZ0I7UUFEVCxPQUFFLEdBQUYsRUFBRSxDQUFXO1FBQVMsZ0JBQVcsR0FBWCxXQUFXLENBQVU7UUFMdEQsa0JBQWEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXRCLG1CQUFjLEdBQUcsQ0FBQyxFQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE9BQXNCLEVBQUMsQ0FBQyxDQUFDO1FBSy9ELE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDO1FBQ3JDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxFQUFFLEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFDM0QsTUFBTSxHQUFHLEdBQ0wsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFFBQVEsU0FBUyxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7UUFDeEUsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztRQUM3RCxJQUFJLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFDbkIsSUFBSSxTQUFTLEdBQUcsRUFBRSxDQUFDO1FBQ25CLG9FQUFvRTtRQUNwRSx3RUFBd0U7UUFDeEUsZ0JBQWdCO1FBQ2hCLElBQUksU0FBUyxFQUFFO1lBQ2IsU0FBUyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsVUFBVSxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztZQUMxRCxTQUFTLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztTQUM3QzthQUFNO1lBQ0wsU0FBUyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUM7WUFDL0QsU0FBUyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ3JEO1FBRUQsSUFBSSxDQUFDLFFBQVEsR0FBRzs7VUFFVixpQkFBaUIsQ0FBQyxJQUFJLENBQUM7b0JBQ2IsYUFBYSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQztzQkFDcEMsR0FBRzs7Y0FFWCxTQUFTO3NCQUNELFNBQVM7WUFDbkIsYUFBYSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDbEMsSUFBSSxDQUFDLEVBQUUsVUFBVSxTQUFTLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDOzs7O0tBSTlELENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFFRCxTQUFTLFNBQVMsQ0FBQyxJQUFZLEVBQUUsSUFBWSxFQUFFLEVBQWE7SUFDMUQsSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ2QsT0FBTyxHQUFHLElBQUksRUFBRSxDQUFDO0tBQ2xCO1NBQU0sSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLE9BQU8sR0FBRyxJQUFJLE9BQU8sSUFBSSxJQUFJLENBQUM7S0FDL0I7U0FBTSxJQUFJLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDckIsT0FBTyxHQUFHLElBQUksT0FBTyxJQUFJLE9BQU8sSUFBSSxJQUFJLENBQUM7S0FDMUM7U0FBTSxJQUFJLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDckIsT0FBTyxHQUFHLElBQUksT0FBTyxJQUFJLE9BQU8sSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDO0tBQ3JEO1NBQU07UUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLGNBQWMsRUFBRSxhQUFhLElBQUksdUJBQXVCLENBQUMsQ0FBQztLQUMzRTtBQUNILENBQUM7QUFFRCxTQUFTLGFBQWEsQ0FBQyxJQUFZLEVBQUUsSUFBWSxFQUFFLEVBQWE7SUFDOUQsSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ2QsT0FBTyxHQUFHLElBQUksRUFBRSxDQUFDO0tBQ2xCO1NBQU0sSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLE9BQU8sR0FBRyxJQUFJLElBQUksQ0FBQztLQUNwQjtTQUFNLElBQUksSUFBSSxLQUFLLENBQUMsRUFBRTtRQUNyQixPQUFPLEdBQUcsSUFBSSxJQUFJLENBQUM7S0FDcEI7U0FBTSxJQUFJLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDckIsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDO0tBQ3BCO1NBQU07UUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLGNBQWMsRUFBRSxhQUFhLElBQUksdUJBQXVCLENBQUMsQ0FBQztLQUMzRTtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5pbXBvcnQge0dQR1BVUHJvZ3JhbX0gZnJvbSAnLi9ncGdwdV9tYXRoJztcbmltcG9ydCB7Z2V0Q29vcmRzRGF0YVR5cGUsIFVuaWZvcm1UeXBlfSBmcm9tICcuL3NoYWRlcl9jb21waWxlcic7XG5cbmV4cG9ydCBlbnVtIEN1bU9wVHlwZSB7XG4gIFByb2QgPSAnKicsXG4gIFN1bSA9ICcrJyxcbn1cblxuZXhwb3J0IGNsYXNzIEN1bVByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWyd4J107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG4gIGN1c3RvbVVuaWZvcm1zID0gW3tuYW1lOiAnaW5kZXgnLCB0eXBlOiAnZmxvYXQnIGFzIFVuaWZvcm1UeXBlfV07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgb3A6IEN1bU9wVHlwZSwgcHVibGljIG91dHB1dFNoYXBlOiBudW1iZXJbXSwgZXhjbHVzaXZlOiBib29sZWFuLFxuICAgICAgcmV2ZXJzZTogYm9vbGVhbikge1xuICAgIGNvbnN0IHJhbmsgPSB0aGlzLm91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBpbml0VmFsID0gdGhpcy5vcCA9PT0gQ3VtT3BUeXBlLlByb2QgPyAnMS4wJyA6ICcwLjAnO1xuICAgIGNvbnN0IHZhbCA9XG4gICAgICAgIGV4Y2x1c2l2ZSA/IGluaXRWYWwgOiBgZ2V0WCgke2dldENvb3JkcyhyYW5rLCAnY29vcmRzJywgdGhpcy5vcCl9KWA7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5vdXRwdXRTaGFwZVt0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCAtIDFdO1xuICAgIGxldCBjb25kaXRpb24gPSAnJztcbiAgICBsZXQgaWR4U3RyaW5nID0gJyc7XG4gICAgLy8gV2hlbiBleGNsdXNpdmUgaXMgc2V0LCB0aGUgY3VtIG9wIGJlY29tZXMgcm9sbCBvcCB0aGF0IGNvcGllcyB0aGVcbiAgICAvLyB2YWx1ZSBmcm9tIHRoZSBwcmV2aW91cyBpbmRleCBiYXNlZCBvbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZCBieSB0aGVcbiAgICAvLyByZXZlcnNlIGZsYWcuXG4gICAgaWYgKGV4Y2x1c2l2ZSkge1xuICAgICAgY29uZGl0aW9uID0gcmV2ZXJzZSA/IGBlbmQgIT0gJHtsZW5ndGggLSAxfWAgOiAnZW5kICE9IDAnO1xuICAgICAgaWR4U3RyaW5nID0gcmV2ZXJzZSA/ICdlbmQgKyAxJyA6ICdlbmQgLSAxJztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZGl0aW9uID0gcmV2ZXJzZSA/IGBlbmQgKyBwb3cyIDwgJHtsZW5ndGh9YCA6ICdlbmQgPj0gcG93Mic7XG4gICAgICBpZHhTdHJpbmcgPSAocmV2ZXJzZSA/ICdlbmQgKyBwb3cyJyA6ICdlbmQgLSBwb3cyJyk7XG4gICAgfVxuXG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtnZXRDb29yZHNEYXRhVHlwZShyYW5rKX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCBlbmQgPSAke2dldEZpbmFsQ29vcmQocmFuaywgJ2Nvb3JkcycsIHRoaXMub3ApfTtcbiAgICAgICAgZmxvYXQgdmFsID0gJHt2YWx9O1xuICAgICAgICBpbnQgcG93MiA9IGludChwb3coMi4wLCBpbmRleCkpO1xuICAgICAgICBpZiAoJHtjb25kaXRpb259KSB7XG4gICAgICAgICAgaW50IGlkeCA9ICR7aWR4U3RyaW5nfTtcbiAgICAgICAgICAke2dldEZpbmFsQ29vcmQocmFuaywgJ2Nvb3JkcycsIHRoaXMub3ApfSA9IGlkeDtcbiAgICAgICAgICB2YWwgJHt0aGlzLm9wfT0gZ2V0WCgke2dldENvb3JkcyhyYW5rLCAnY29vcmRzJywgdGhpcy5vcCl9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQodmFsKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvb3JkcyhyYW5rOiBudW1iZXIsIG5hbWU6IHN0cmluZywgb3A6IEN1bU9wVHlwZSk6IHN0cmluZyB7XG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgcmV0dXJuIGAke25hbWV9YDtcbiAgfSBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgcmV0dXJuIGAke25hbWV9LngsICR7bmFtZX0ueWA7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gMykge1xuICAgIHJldHVybiBgJHtuYW1lfS54LCAke25hbWV9LnksICR7bmFtZX0uemA7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gNCkge1xuICAgIHJldHVybiBgJHtuYW1lfS54LCAke25hbWV9LnksICR7bmFtZX0ueiwgJHtuYW1lfS53YDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEN1bXVsYXRpdmUgJHtvcH0gZm9yIHJhbmsgJHtyYW5rfSBpcyBub3QgeWV0IHN1cHBvcnRlZGApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZpbmFsQ29vcmQocmFuazogbnVtYmVyLCBuYW1lOiBzdHJpbmcsIG9wOiBDdW1PcFR5cGUpOiBzdHJpbmcge1xuICBpZiAocmFuayA9PT0gMSkge1xuICAgIHJldHVybiBgJHtuYW1lfWA7XG4gIH0gZWxzZSBpZiAocmFuayA9PT0gMikge1xuICAgIHJldHVybiBgJHtuYW1lfS55YDtcbiAgfSBlbHNlIGlmIChyYW5rID09PSAzKSB7XG4gICAgcmV0dXJuIGAke25hbWV9LnpgO1xuICB9IGVsc2UgaWYgKHJhbmsgPT09IDQpIHtcbiAgICByZXR1cm4gYCR7bmFtZX0ud2A7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDdW11bGF0aXZlICR7b3B9IGZvciByYW5rICR7cmFua30gaXMgbm90IHlldCBzdXBwb3J0ZWRgKTtcbiAgfVxufVxuIl19","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { useShapeUniforms } from './gpgpu_math';\nexport class Conv2DPackedProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.customUniforms = [\n            { name: 'pads', type: 'ivec2' },\n            { name: 'strides', type: 'ivec2' },\n            { name: 'dilations', type: 'ivec2' },\n            { name: 'inDims', type: 'ivec2' },\n        ];\n        this.outputShape = convInfo.outShape;\n        this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n        const padLeft = convInfo.padInfo.left;\n        const strideWidth = convInfo.strideWidth;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const texelsAcross = filterWidth;\n        let mainLoop = `\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;`;\n        for (let c = 0; c < filterWidth; c++) {\n            mainLoop += `\n           vec4 xTexelC${c * 2};\n           int xTexelC${c * 2}Ready;\n           vec4 xTexelC${c * 2 + 1};\n           int xTexelC${c * 2 + 1}Ready;\n           vec4 xC${c};`;\n        }\n        /**\n         * This vectorized implementation works by gathering the values needed for\n         * each output channel's dot product into vec4's and then multiplying them\n         * all together (this happens in the final double for-loop below). Most of\n         * the main loop consists of constructing these vec4's with the minimum\n         * number of texture2D calls, which means making use of all four returned\n         * values from a texture2D call at once.\n         */\n        mainLoop += `\n     for (int r = 0; r < ${filterHeight}; r++) {\n      for (int d1 = 0; d1 < ${convInfo.inChannels}; d1 += 2) {\n       `;\n        for (let c = 0; c < filterWidth; c++) {\n            mainLoop += `\n           xTexelC${c * 2} = vec4(0.0);\n           xTexelC${c * 2}Ready = 0;\n           xTexelC${c * 2 + 1} = vec4(0.0);\n           xTexelC${c * 2 + 1}Ready = 0;\n           xC${c} = vec4(0.0);`;\n        }\n        mainLoop += `\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       `;\n        for (let texelC = 0; texelC < (texelsAcross + 1) / 2; texelC++) {\n            const colIndex = texelC * 2;\n            mainLoop += `\n           xC = xCCorner + ${colIndex * dilationWidth};\n           `;\n            if (strideWidth === 1) {\n                if (colIndex < filterWidth) {\n                    // If padding is odd, the outer texels have to be composed.\n                    if (padLeft % 2 === 1) {\n                        // TODO: Ensure vec4 previous does not result in redundant sample,\n                        // and avoid setting xTexelRC's that exceed the boundary in the\n                        // first place rather than resetting them to vec4(0)).\n                        // To compute xCOffset:\n                        // - If padding is odd, we must add 1 to ensure we ask for an\n                        // even-numbered row.\n                        // - We subtract 2 to access the previous texel.\n                        mainLoop += `\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                   xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${colIndex}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex}Ready = 1;\n                 }\n               `;\n                        // This texel has been read in previous iteration if the dilation\n                        // is 1.\n                        if (dilationWidth === 1 && colIndex > 0) {\n                            mainLoop += `\n                 xC${colIndex} = vec4(xTexelC${colIndex - 2}.zw, xTexelC${colIndex}.xy);\n                 `;\n                        }\n                        else {\n                            mainLoop += `\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${colIndex} = vec4(previous.zw, xTexelC${colIndex}.xy);\n                   } else {\n                     xC${colIndex} = vec4(0.0, 0.0, xTexelC${colIndex}.xy);\n                   }\n                   `;\n                        }\n                    }\n                    else {\n                        // Padding is even, so xRC corresponds to a single texel.\n                        mainLoop += `\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                   xTexelC${colIndex} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${colIndex}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex}Ready = 1;\n                 }\n\n                 xC${colIndex} = xTexelC${colIndex};\n                 `;\n                    }\n                    if (colIndex + 1 < filterWidth) {\n                        // If dilation is even, the second entry should match the first\n                        // (either both are composed or both are single samples). But if\n                        // dilation is odd, then the second entry should be the opposite\n                        // of the first (if the first is composed, the second is a single\n                        // sample, and vice versa.)\n                        const nextTexelOffset = padLeft % 2 === 0 ?\n                            util.nearestLargerEven(dilationWidth) :\n                            dilationWidth;\n                        if ((dilationWidth % 2 === 0 && padLeft % 2 === 1) ||\n                            (dilationWidth % 2 !== 0 && padLeft % 2 !== 1)) {\n                            mainLoop += `\n                   xCOffset = xC + imod(pads[1], 2) + ${nextTexelOffset};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                     xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${colIndex + 1}.zw = vec2(0.0);\n                     }\n                     xTexelC${colIndex + 1}Ready = 1;\n                   }\n                   `;\n                            // If dilation > 1 then the xRC's will not be able to share any\n                            // values, so each xRC will require two unique calls to getX.\n                            if (dilationWidth > 1) {\n                                mainLoop += `\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${colIndex + 1} = vec4(previous.zw, xTexelC${colIndex + 1}.xy);\n                     } else {\n                      xC${colIndex + 1} = vec4(0.0, 0.0, xTexelC${colIndex + 1}.xy);\n                     }\n                     `;\n                            }\n                            else {\n                                mainLoop += `\n                     xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.xy);\n                     `;\n                            }\n                        }\n                        else {\n                            // If dilation is 1 and padding is odd, we have already read the\n                            // texel when constructing the previous x value. Here we can\n                            // simply skip the texture read.\n                            if (nextTexelOffset === 1) {\n                                mainLoop += `\n                     xC${colIndex + 1} = xTexelC${colIndex};\n                     `;\n                            }\n                            else {\n                                mainLoop += `\n                     xCOffset = xC + ${nextTexelOffset};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                       xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${colIndex + 1}.zw = vec2(0.0);\n                       }\n                       xTexelC${colIndex + 1}Ready = 1;\n                     }\n\n                     xC${colIndex + 1} = xTexelC${colIndex + 1};\n                     `;\n                            }\n                        }\n                    }\n                }\n            }\n            else { // stride === 2\n                if (colIndex < filterWidth) {\n                    // Depending on whether padLeft is even or odd, we want either the\n                    // xy or zw channels from X texels for xC${colIndex}. If padLeft is\n                    // even, xC${colIndex +1} is simply the zw channels of texels we've\n                    // already sampled. But if padLeft is odd, xC{$c + 1}.zw will\n                    // need to come from the xy channels of a new texel, hence the `\n                    // vec4\n                    // final` initialized below.\n                    if (padLeft % 2 === 1) {\n                        mainLoop += `\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                   xTexelC${colIndex} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${colIndex}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                   xTexelC${colIndex + 1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${colIndex + 1}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex + 1}Ready = 1;\n                 }\n\n                 xC${colIndex} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);\n               `;\n                        if (colIndex + 1 < filterWidth) {\n                            mainLoop += `\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${colIndex + 1} = vec4(xTexelC${colIndex + 1}.xy, final.xy);\n                 `;\n                        }\n                    }\n                    else {\n                        mainLoop += `\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${colIndex}Ready == 0) {\n                   xTexelC${colIndex} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${colIndex}.zw = vec2(0.0);\n                   }\n                   xTexelC${colIndex}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${colIndex + 1}Ready == 0) {\n                   xTexelC${colIndex + 1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${colIndex + 1}.zw = vec2(0.);\n                   }\n                   xTexelC${colIndex + 1}Ready = 1;\n                 }\n\n                 xC${colIndex} = vec4(\n                   xTexelC${colIndex}.xy, xTexelC${colIndex + 1}.xy);\n               `;\n                        if (colIndex + 1 < filterWidth) {\n                            mainLoop += `\n                   xC${colIndex + 1} = vec4(xTexelC${colIndex}.zw, xTexelC${colIndex + 1}.zw);\n                 `;\n                        }\n                    }\n                }\n            }\n            // localize the dotProd accumulation within the loop, the theory is for\n            // GPU with limited cache, accumulate sum across large amount of\n            // veriables will cause lots of cache misses. (i.e. 5x5 filter will have\n            // 50 variables)\n            if (colIndex < filterWidth) {\n                mainLoop += `\n             wTexel = getW(r, ${colIndex}, d1, d2);\n             dotProd += xC${colIndex}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${convInfo.inChannels}) {\n               dotProd += xC${colIndex}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `;\n                if (colIndex + 1 < filterWidth) {\n                    mainLoop += `\n               wTexel = getW(r, ${colIndex + 1}, d1, d2);\n               dotProd += xC${colIndex + 1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${convInfo.inChannels}) {\n                 dotProd += xC${colIndex + 1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `;\n                }\n            }\n        }\n        mainLoop += `\n     }\n   `;\n        mainLoop += `\n     }\n   `;\n        mainLoop += `\n     }\n   `;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${activation}\n         }`;\n            }\n            else if (hasLeakyReluAlpha) {\n                activationSnippet = `vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${activation}\n         }`;\n            }\n            else {\n                activationSnippet = `vec4 activation(vec4 x) {\n           ${activation}\n         }`;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyReluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n       ${activationSnippet}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${mainLoop}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${addBiasSnippet}\n         ${applyActivationSnippet}\n         setOutput(result);\n       }\n     `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9wYWNrZWRfZ3B1LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1iYWNrZW5kLXdlYmdsL3NyYy9jb252X3BhY2tlZF9ncHUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUYsT0FBTyxFQUFlLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRXpELE9BQU8sRUFBZSxnQkFBZ0IsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUU1RCxNQUFNLE9BQU8sbUJBQW1CO0lBYzlCLFlBQ0ksUUFBaUMsRUFBRSxPQUFPLEdBQUcsS0FBSyxFQUNsRCxhQUFxQixJQUFJLEVBQUUsa0JBQWtCLEdBQUcsS0FBSyxFQUNyRCxpQkFBaUIsR0FBRyxLQUFLO1FBaEI3QixrQkFBYSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzNCLGlCQUFZLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLGlCQUFZLEdBQUcsSUFBSSxDQUFDO1FBSXBCLG1CQUFjLEdBQUc7WUFDZixFQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQWdCLEVBQUU7WUFDdkMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxPQUFnQixFQUFFO1lBQzFDLEVBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsT0FBZ0IsRUFBRTtZQUM1QyxFQUFDLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLE9BQWdCLEVBQUU7U0FDMUMsQ0FBQztRQU1BLElBQUksQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLFFBQVEsQ0FBQztRQUNyQyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNyRSxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztRQUN0QyxNQUFN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LElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNqQztRQUVELElBQUksa0JBQWtCLEVBQUU7WUFDdEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsQ0FBQztTQUNuRDtRQUNELElBQUksaUJBQWlCLEVBQUU7WUFDckIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztTQUMzQztRQUVELElBQUksQ0FBQyxRQUFRLEdBQUc7U0FDWixpQkFBaUI7Ozs7Ozs7Ozs7Ozs7V0FhZixRQUFROzs7V0FHUixjQUFjO1dBQ2Qsc0JBQXNCOzs7TUFHM0IsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuIGltcG9ydCB7YmFja2VuZF91dGlsLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG4gaW1wb3J0IHtHUEdQVVByb2dyYW0sIHVzZVNoYXBlVW5pZm9ybXN9IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbiBleHBvcnQgY2xhc3MgQ29udjJEUGFja2VkUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gICB2YXJpYWJsZU5hbWVzID0gWyd4JywgJ1cnXTtcbiAgIHBhY2tlZElucHV0cyA9IHRydWU7XG4gICBwYWNrZWRPdXRwdXQgPSB0cnVlO1xuICAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICAgdXNlckNvZGU6IHN0cmluZztcbiAgIGVuYWJsZVNoYXBlVW5pZm9ybXM6IGJvb2xlYW47XG4gICBjdXN0b21Vbmlmb3JtcyA9IFtcbiAgICAge25hbWU6ICdwYWRzJywgdHlwZTogJ2l2ZWMyJyBhcyBjb25zdCB9LFxuICAgICB7bmFtZTogJ3N0cmlkZXMnLCB0eXBlOiAnaXZlYzInIGFzIGNvbnN0IH0sXG4gICAgIHtuYW1lOiAnZGlsYXRpb25zJywgdHlwZTogJ2l2ZWMyJyBhcyBjb25zdCB9LFxuICAgICB7bmFtZTogJ2luRGltcycsIHR5cGU6ICdpdmVjMicgYXMgY29uc3QgfSxcbiAgIF07XG5cbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgIGNvbnZJbmZvOiBiYWNrZW5kX3V0aWwuQ29udjJESW5mbywgYWRkQmlhcyA9IGZhbHNlLFxuICAgICAgIGFjdGl2YXRpb246IHN0cmluZyA9IG51bGwsIGhhc1ByZWx1QWN0aXZhdGlvbiA9IGZhbHNlLFxuICAgICAgIGhhc0xlYWt5UmVsdUFscGhhID0gZmFsc2UpIHtcbiAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgICB0aGlzLmVuYWJsZVNoYXBlVW5pZm9ybXMgPSB1c2VTaGFwZVVuaWZvcm1zKHRoaXMub3V0cHV0U2hhcGUubGVuZ3RoKTtcbiAgICAgY29uc3QgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgY29uc3Qgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgY29uc3QgZGlsYXRpb25XaWR0aCA9IGNvbnZJbmZvLmRpbGF0aW9uV2lkdGg7XG4gICAgIGNvbnN0IGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgY29uc3QgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgY29uc3QgdGV4ZWxzQWNyb3NzID0gZmlsdGVyV2lkdGg7XG5cbiAgICAgbGV0IG1haW5Mb29wID0gYFxuICAgICAgIGludCB4UjsgaW50IHhDOyBpbnQgeENPZmZzZXQ7XG4gICAgICAgdmVjNCB3VGV4ZWw7IHZlYzQgcHJldmlvdXM7IHZlYzQgZmluYWw7YDtcblxuICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGZpbHRlcldpZHRoOyBjKyspIHtcbiAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgIHZlYzQgeFRleGVsQyR7YyAqIDJ9O1xuICAgICAgICAgICBpbnQgeFRleGVsQyR7YyAqIDJ9UmVhZHk7XG4gICAgICAgICAgIHZlYzQgeFRleGVsQyR7YyAqIDIgKyAxfTtcbiAgICAgICAgICAgaW50IHhUZXhlbEMke2MgKiAyICsgMX1SZWFkeTtcbiAgICAgICAgICAgdmVjNCB4QyR7Y307YDtcbiAgICAgfVxuXG4gICAgIC8qKlxuICAgICAgKiBUaGlzIHZlY3Rvcml6ZWQgaW1wbGVtZW50YXRpb24gd29ya3MgYnkgZ2F0aGVyaW5nIHRoZSB2YWx1ZXMgbmVlZGVkIGZvclxuICAgICAgKiBlYWNoIG91dHB1dCBjaGFubmVsJ3MgZG90IHByb2R1Y3QgaW50byB2ZWM0J3MgYW5kIHRoZW4gbXVsdGlwbHlpbmcgdGhlbVxuICAgICAgKiBhbGwgdG9nZXRoZXIgKHRoaXMgaGFwcGVucyBpbiB0aGUgZmluYWwgZG91YmxlIGZvci1sb29wIGJlbG93KS4gTW9zdCBvZlxuICAgICAgKiB0aGUgbWFpbiBsb29wIGNvbnNpc3RzIG9mIGNvbnN0cnVjdGluZyB0aGVzZSB2ZWM0J3Mgd2l0aCB0aGUgbWluaW11bVxuICAgICAgKiBudW1iZXIgb2YgdGV4dHVyZTJEIGNhbGxzLCB3aGljaCBtZWFucyBtYWtpbmcgdXNlIG9mIGFsbCBmb3VyIHJldHVybmVkXG4gICAgICAqIHZhbHVlcyBmcm9tIGEgdGV4dHVyZTJEIGNhbGwgYXQgb25jZS5cbiAgICAgICovXG4gICAgIG1haW5Mb29wICs9IGBcbiAgICAgZm9yIChpbnQgciA9IDA7IHIgPCAke2ZpbHRlckhlaWdodH07IHIrKykge1xuICAgICAgZm9yIChpbnQgZDEgPSAwOyBkMSA8ICR7Y29udkluZm8uaW5DaGFubmVsc307IGQxICs9IDIpIHtcbiAgICAgICBgO1xuICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGZpbHRlcldpZHRoOyBjKyspIHtcbiAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgIHhUZXhlbEMke2MgKiAyfSA9IHZlYzQoMC4wKTtcbiAgICAgICAgICAgeFRleGVsQyR7YyAqIDJ9UmVhZHkgPSAwO1xuICAgICAgICAgICB4VGV4ZWxDJHtjICogMiArIDF9ID0gdmVjNCgwLjApO1xuICAgICAgICAgICB4VGV4ZWxDJHtjICogMiArIDF9UmVhZHkgPSAwO1xuICAgICAgICAgICB4QyR7Y30gPSB2ZWM0KDAuMCk7YDtcbiAgICAgfVxuICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICB4UiA9IHhSQ29ybmVyICsgciAqIGRpbGF0aW9uc1swXTtcbiAgICAgICAgIGlmICh4UiA+PTAgJiYgeFIgPCBpbkRpbXNbMF0pIHtcbiAgICAgICBgO1xuXG4gICAgIGZvciAobGV0IHRleGVsQyA9IDA7IHRleGVsQyA8ICh0ZXhlbHNBY3Jvc3MgKyAxKSAvIDI7IHRleGVsQysrKSB7XG4gICAgICAgY29uc3QgY29sSW5kZXggPSB0ZXhlbEMgKiAyO1xuXG4gICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICB4QyA9IHhDQ29ybmVyICsgJHtjb2xJbmRleCAqIGRpbGF0aW9uV2lkdGh9O1xuICAgICAgICAgICBgO1xuXG4gICAgICAgaWYgKHN0cmlkZVdpZHRoID09PSAxKSB7XG4gICAgICAgICBpZiAoY29sSW5kZXggPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAvLyBJZiBwYWRkaW5nIGlzIG9kZCwgdGhlIG91dGVyIHRleGVscyBoYXZlIHRvIGJlIGNvbXBvc2VkLlxuICAgICAgICAgICBpZiAocGFkTGVmdCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAvLyBUT0RPOiBFbnN1cmUgdmVjNCBwcmV2aW91cyBkb2VzIG5vdCByZXN1bHQgaW4gcmVkdW5kYW50IHNhbXBsZSxcbiAgICAgICAgICAgICAvLyBhbmQgYXZvaWQgc2V0dGluZyB4VGV4ZWxSQydzIHRoYXQgZXhjZWVkIHRoZSBib3VuZGFyeSBpbiB0aGVcbiAgICAgICAgICAgICAvLyBmaXJzdCBwbGFjZSByYXRoZXIgdGhhbiByZXNldHRpbmcgdGhlbSB0byB2ZWM0KDApKS5cblxuICAgICAgICAgICAgIC8vIFRvIGNvbXB1dGUgeENPZmZzZXQ6XG4gICAgICAgICAgICAgLy8gLSBJZiBwYWRkaW5nIGlzIG9kZCwgd2UgbXVzdCBhZGQgMSB0byBlbnN1cmUgd2UgYXNrIGZvciBhblxuICAgICAgICAgICAgIC8vIGV2ZW4tbnVtYmVyZWQgcm93LlxuICAgICAgICAgICAgIC8vIC0gV2Ugc3VidHJhY3QgMiB0byBhY2Nlc3MgdGhlIHByZXZpb3VzIHRleGVsLlxuXG4gICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMTtcbiAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgIGNvbEluZGV4fVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH0gPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcblxuICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9Lnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgICAgLy8gVGhpcyB0ZXhlbCBoYXMgYmVlbiByZWFkIGluIHByZXZpb3VzIGl0ZXJhdGlvbiBpZiB0aGUgZGlsYXRpb25cbiAgICAgICAgICAgICAvLyBpcyAxLlxuICAgICAgICAgICAgIGlmIChkaWxhdGlvbldpZHRoID09PSAxICYmIGNvbEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXh9ID0gdmVjNCh4VGV4ZWxDJHtjb2xJbmRleCAtIDJ9Lnp3LCB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgICBjb2xJbmRleH0ueHkpO1xuICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIDEgLSAyO1xuXG4gICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHJlYWRpbmcgZnJvbSByZWN5Y2xlZCB0ZXh0dXJlLlxuICAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMuencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleH0gPSB2ZWM0KHByZXZpb3VzLnp3LCB4VGV4ZWxDJHtjb2xJbmRleH0ueHkpO1xuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXh9ID0gdmVjNCgwLjAsIDAuMCwgeFRleGVsQyR7Y29sSW5kZXh9Lnh5KTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgLy8gUGFkZGluZyBpcyBldmVuLCBzbyB4UkMgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGUgdGV4ZWwuXG4gICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICBpZiAoeEMgPj0gMCAmJiB4QyA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9ID0gZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICAgaWYgKHhDICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4fS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4fSA9IHhUZXhlbEMke2NvbEluZGV4fTtcbiAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGlmIChjb2xJbmRleCArIDEgPCBmaWx0ZXJXaWR0aCkge1xuICAgICAgICAgICAgIC8vIElmIGRpbGF0aW9uIGlzIGV2ZW4sIHRoZSBzZWNvbmQgZW50cnkgc2hvdWxkIG1hdGNoIHRoZSBmaXJzdFxuICAgICAgICAgICAgIC8vIChlaXRoZXIgYm90aCBhcmUgY29tcG9zZWQgb3IgYm90aCBhcmUgc2luZ2xlIHNhbXBsZXMpLiBCdXQgaWZcbiAgICAgICAgICAgICAvLyBkaWxhdGlvbiBpcyBvZGQsIHRoZW4gdGhlIHNlY29uZCBlbnRyeSBzaG91bGQgYmUgdGhlIG9wcG9zaXRlXG4gICAgICAgICAgICAgLy8gb2YgdGhlIGZpcnN0IChpZiB0aGUgZmlyc3QgaXMgY29tcG9zZWQsIHRoZSBzZWNvbmQgaXMgYSBzaW5nbGVcbiAgICAgICAgICAgICAvLyBzYW1wbGUsIGFuZCB2aWNlIHZlcnNhLilcblxuICAgICAgICAgICAgIGNvbnN0IG5leHRUZXhlbE9mZnNldCA9IHBhZExlZnQgJSAyID09PSAwID9cbiAgICAgICAgICAgICAgICAgdXRpbC5uZWFyZXN0TGFyZ2VyRXZlbihkaWxhdGlvbldpZHRoKSA6XG4gICAgICAgICAgICAgICAgIGRpbGF0aW9uV2lkdGg7XG5cbiAgICAgICAgICAgICBpZiAoKGRpbGF0aW9uV2lkdGggJSAyID09PSAwICYmIHBhZExlZnQgJSAyID09PSAxKSB8fFxuICAgICAgICAgICAgICAgICAoZGlsYXRpb25XaWR0aCAlIDIgIT09IDAgJiYgcGFkTGVmdCAlIDIgIT09IDEpKSB7XG4gICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArIGltb2QocGFkc1sxXSwgMikgKyAke25leHRUZXhlbE9mZnNldH07XG5cbiAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgICBjb2xJbmRleCArIDF9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4ICsgMX0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBgO1xuXG4gICAgICAgICAgICAgICAvLyBJZiBkaWxhdGlvbiA+IDEgdGhlbiB0aGUgeFJDJ3Mgd2lsbCBub3QgYmUgYWJsZSB0byBzaGFyZSBhbnlcbiAgICAgICAgICAgICAgIC8vIHZhbHVlcywgc28gZWFjaCB4UkMgd2lsbCByZXF1aXJlIHR3byB1bmlxdWUgY2FsbHMgdG8gZ2V0WC5cbiAgICAgICAgICAgICAgIGlmIChkaWxhdGlvbldpZHRoID4gMSkge1xuICAgICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICAgICB4Q09mZnNldCAtPSAyO1xuICAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleCArIDF9ID0gdmVjNChwcmV2aW91cy56dywgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xJbmRleCArIDF9Lnh5KTtcbiAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB2ZWM0KDAuMCwgMC4wLCB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbEluZGV4ICsgMX0ueHkpO1xuICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIG1haW5Mb29wICs9IGBcbiAgICAgICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleCArIDF9ID0gdmVjNCh4VGV4ZWxDJHtjb2xJbmRleH0uencsIHhUZXhlbEMke1xuICAgICAgICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfS54eSk7XG4gICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIC8vIElmIGRpbGF0aW9uIGlzIDEgYW5kIHBhZGRpbmcgaXMgb2RkLCB3ZSBoYXZlIGFscmVhZHkgcmVhZCB0aGVcbiAgICAgICAgICAgICAgIC8vIHRleGVsIHdoZW4gY29uc3RydWN0aW5nIHRoZSBwcmV2aW91cyB4IHZhbHVlLiBIZXJlIHdlIGNhblxuICAgICAgICAgICAgICAgLy8gc2ltcGx5IHNraXAgdGhlIHRleHR1cmUgcmVhZC5cbiAgICAgICAgICAgICAgIGlmIChuZXh0VGV4ZWxPZmZzZXQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB4VGV4ZWxDJHtjb2xJbmRleH07XG4gICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICAgICAgeENPZmZzZXQgPSB4QyArICR7bmV4dFRleGVsT2Zmc2V0fTtcblxuICAgICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ID49IDAgJiYgeENPZmZzZXQgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgICAgICBjb2xJbmRleCArIDF9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgIGlmICh4Q09mZnNldCArIDEgPj0gaW5EaW1zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfS56dyA9IHZlYzIoMC4wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9UmVhZHkgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXggKyAxfSA9IHhUZXhlbEMke2NvbEluZGV4ICsgMX07XG4gICAgICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgIH0gZWxzZSB7ICAvLyBzdHJpZGUgPT09IDJcbiAgICAgICAgIGlmIChjb2xJbmRleCA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB3aGV0aGVyIHBhZExlZnQgaXMgZXZlbiBvciBvZGQsIHdlIHdhbnQgZWl0aGVyIHRoZVxuICAgICAgICAgICAvLyB4eSBvciB6dyBjaGFubmVscyBmcm9tIFggdGV4ZWxzIGZvciB4QyR7Y29sSW5kZXh9LiBJZiBwYWRMZWZ0IGlzXG4gICAgICAgICAgIC8vIGV2ZW4sIHhDJHtjb2xJbmRleCArMX0gaXMgc2ltcGx5IHRoZSB6dyBjaGFubmVscyBvZiB0ZXhlbHMgd2UndmVcbiAgICAgICAgICAgLy8gYWxyZWFkeSBzYW1wbGVkLiBCdXQgaWYgcGFkTGVmdCBpcyBvZGQsIHhDeyRjICsgMX0uencgd2lsbFxuICAgICAgICAgICAvLyBuZWVkIHRvIGNvbWUgZnJvbSB0aGUgeHkgY2hhbm5lbHMgb2YgYSBuZXcgdGV4ZWwsIGhlbmNlIHRoZSBgXG4gICAgICAgICAgIC8vIHZlYzRcbiAgICAgICAgICAgLy8gZmluYWxgIGluaXRpYWxpemVkIGJlbG93LlxuICAgICAgICAgICBpZiAocGFkTGVmdCAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgIHhDT2Zmc2V0ID0geEMgKyAxIC0gc3RyaWRlc1sxXTtcbiAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgY29sSW5kZXh9UmVhZHkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4fSA9IGdldFgoYmF0Y2gsIHhSLCB4Q09mZnNldCwgZDEpO1xuICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gbWFudWFsbHkgY2xlYXIgdW51c2VkIGNoYW5uZWxzIGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSByZWFkaW5nIGZyb20gcmVjeWNsZWQgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICBpZiAoeENPZmZzZXQgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9Lnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICBpZih4QyArIDEgPj0gMCAmJiB4QyArIDEgPCBpbkRpbXNbMV0gJiYgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgIGNvbEluZGV4ICsgMX1SZWFkeSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfSA9IGdldFgoYmF0Y2gsIHhSLCB4QyArIDEsIGQxKTtcbiAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIG1hbnVhbGx5IGNsZWFyIHVudXNlZCBjaGFubmVscyBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgLy8gd2UncmUgcmVhZGluZyBmcm9tIHJlY3ljbGVkIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgaWYgKHhDICsgMiA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4ICsgMX0uencgPSB2ZWMyKDAuMCk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4ICsgMX1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICB4QyR7Y29sSW5kZXh9ID0gdmVjNCh4VGV4ZWxDJHtjb2xJbmRleH0uencsIHhUZXhlbEMke1xuICAgICAgICAgICAgICAgICBjb2xJbmRleCArIDF9Lnp3KTtcbiAgICAgICAgICAgICAgIGA7XG5cbiAgICAgICAgICAgICBpZiAoY29sSW5kZXggKyAxIDwgZmlsdGVyV2lkdGgpIHtcbiAgICAgICAgICAgICAgIG1haW5Mb29wICs9IGBcbiAgICAgICAgICAgICAgICAgICBmaW5hbCA9IHZlYzQoMC4wKTtcbiAgICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgMSArIHN0cmlkZXNbMV07XG4gICAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgZmluYWwgPSBnZXRYKGJhdGNoLCB4UiwgeENPZmZzZXQsIGQxKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB2ZWM0KHhUZXhlbEMke2NvbEluZGV4ICsgMX0ueHksIGZpbmFsLnh5KTtcbiAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgICBpZih4QyA+PSAwICYmIHhDIDwgaW5EaW1zWzFdICYmIHhUZXhlbEMke2NvbEluZGV4fVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH0gPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICAgICBpZiAoeEMgKyAxID49IGluRGltc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXh9Lnp3ID0gdmVjMigwLjApO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleH1SZWFkeSA9IDE7XG4gICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICB4Q09mZnNldCA9IHhDICsgc3RyaWRlc1sxXTtcbiAgICAgICAgICAgICAgICAgaWYoeENPZmZzZXQgPj0gMCAmJiB4Q09mZnNldCA8IGluRGltc1sxXSAmJiB4VGV4ZWxDJHtcbiAgICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfVJlYWR5ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICB4VGV4ZWxDJHtjb2xJbmRleCArIDF9ID0gZ2V0WChiYXRjaCwgeFIsIHhDT2Zmc2V0LCBkMSk7XG4gICAgICAgICAgICAgICAgICAgaWYgKHhDT2Zmc2V0ICsgMSA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4ICsgMX0uencgPSB2ZWMyKDAuKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgeFRleGVsQyR7Y29sSW5kZXggKyAxfVJlYWR5ID0gMTtcbiAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgIHhDJHtjb2xJbmRleH0gPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgIHhUZXhlbEMke2NvbEluZGV4fS54eSwgeFRleGVsQyR7Y29sSW5kZXggKyAxfS54eSk7XG4gICAgICAgICAgICAgICBgO1xuXG4gICAgICAgICAgICAgaWYgKGNvbEluZGV4ICsgMSA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgICAgICAgeEMke2NvbEluZGV4ICsgMX0gPSB2ZWM0KHhUZXhlbEMke2NvbEluZGV4fS56dywgeFRleGVsQyR7XG4gICAgICAgICAgICAgICAgICAgY29sSW5kZXggKyAxfS56dyk7XG4gICAgICAgICAgICAgICAgIGA7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgfVxuXG4gICAgICAgLy8gbG9jYWxpemUgdGhlIGRvdFByb2QgYWNjdW11bGF0aW9uIHdpdGhpbiB0aGUgbG9vcCwgdGhlIHRoZW9yeSBpcyBmb3JcbiAgICAgICAvLyBHUFUgd2l0aCBsaW1pdGVkIGNhY2hlLCBhY2N1bXVsYXRlIHN1bSBhY3Jvc3MgbGFyZ2UgYW1vdW50IG9mXG4gICAgICAgLy8gdmVyaWFibGVzIHdpbGwgY2F1c2UgbG90cyBvZiBjYWNoZSBtaXNzZXMuIChpLmUuIDV4NSBmaWx0ZXIgd2lsbCBoYXZlXG4gICAgICAgLy8gNTAgdmFyaWFibGVzKVxuICAgICAgIGlmIChjb2xJbmRleCA8IGZpbHRlcldpZHRoKSB7XG4gICAgICAgICBtYWluTG9vcCArPSBgXG4gICAgICAgICAgICAgd1RleGVsID0gZ2V0VyhyLCAke2NvbEluZGV4fSwgZDEsIGQyKTtcbiAgICAgICAgICAgICBkb3RQcm9kICs9IHhDJHtjb2xJbmRleH0ueHh6eiAqIHZlYzQod1RleGVsLnh5LCB3VGV4ZWwueHkpO1xuICAgICAgICAgICAgIGlmKGQxICsgMSA8ICR7Y29udkluZm8uaW5DaGFubmVsc30pIHtcbiAgICAgICAgICAgICAgIGRvdFByb2QgKz0geEMke2NvbEluZGV4fS55eXd3ICogdmVjNCh3VGV4ZWwuencsIHdUZXhlbC56dyk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICBgO1xuXG4gICAgICAgICBpZiAoY29sSW5kZXggKyAxIDwgZmlsdGVyV2lkdGgpIHtcbiAgICAgICAgICAgbWFpbkxvb3AgKz0gYFxuICAgICAgICAgICAgICAgd1RleGVsID0gZ2V0VyhyLCAke2NvbEluZGV4ICsgMX0sIGQxLCBkMik7XG4gICAgICAgICAgICAgICBkb3RQcm9kICs9IHhDJHtjb2xJbmRleCArIDF9Lnh4enogKiB2ZWM0KHdUZXhlbC54eSwgd1RleGVsLnh5KTtcbiAgICAgICAgICAgICAgIGlmKGQxICsgMSA8ICR7Y29udkluZm8uaW5DaGFubmVsc30pIHtcbiAgICAgICAgICAgICAgICAgZG90UHJvZCArPSB4QyR7Y29sSW5kZXggKyAxfS55eXd3ICogdmVjNCh3VGV4ZWwuencsIHdUZXhlbC56dyk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgYDtcbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1cbiAgICAgbWFpbkxvb3AgKz0gYFxuICAgICB9XG4gICBgO1xuICAgbWFpbkxvb3AgKz0gYFxuICAgICB9XG4gICBgO1xuICAgbWFpbkxvb3AgKz0gYFxuICAgICB9XG4gICBgO1xuXG4gICAgIGxldCBhY3RpdmF0aW9uU25pcHBldCA9ICcnLCBhcHBseUFjdGl2YXRpb25TbmlwcGV0ID0gJyc7XG4gICAgIGlmIChhY3RpdmF0aW9uKSB7XG4gICAgICAgaWYgKGhhc1ByZWx1QWN0aXZhdGlvbikge1xuICAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBgdmVjNCBhY3RpdmF0aW9uKHZlYzQgYSkge1xuICAgICAgICAgICB2ZWM0IGIgPSBnZXRQcmVsdUFjdGl2YXRpb25XZWlnaHRzQXRPdXRDb29yZHMoKTtcbiAgICAgICAgICAgJHthY3RpdmF0aW9ufVxuICAgICAgICAgfWA7XG4gICAgICAgfSBlbHNlIGlmIChoYXNMZWFreVJlbHVBbHBoYSkge1xuICAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBgdmVjNCBhY3RpdmF0aW9uKHZlYzQgYSkge1xuICAgICAgICAgICB2ZWM0IGIgPSBnZXRMZWFreXJlbHVBbHBoYUF0T3V0Q29vcmRzKCk7XG4gICAgICAgICAgICR7YWN0aXZhdGlvbn1cbiAgICAgICAgIH1gO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICBhY3RpdmF0aW9uU25pcHBldCA9IGB2ZWM0IGFjdGl2YXRpb24odmVjNCB4KSB7XG4gICAgICAgICAgICR7YWN0aXZhdGlvbn1cbiAgICAgICAgIH1gO1xuICAgICAgIH1cblxuICAgICAgIGFwcGx5QWN0aXZhdGlvblNuaXBwZXQgPSBgcmVzdWx0ID0gYWN0aXZhdGlvbihyZXN1bHQpO2A7XG4gICAgIH1cblxuICAgICBjb25zdCBhZGRCaWFzU25pcHBldCA9IGFkZEJpYXMgPyAncmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpOycgOiAnJztcbiAgICAgaWYgKGFkZEJpYXMpIHtcbiAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgICB9XG5cbiAgICAgaWYgKGhhc1ByZWx1QWN0aXZhdGlvbikge1xuICAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdwcmVsdUFjdGl2YXRpb25XZWlnaHRzJyk7XG4gICAgIH1cbiAgICAgaWYgKGhhc0xlYWt5UmVsdUFscGhhKSB7XG4gICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2xlYWt5cmVsdUFscGhhJyk7XG4gICAgIH1cblxuICAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgICR7YWN0aXZhdGlvblNuaXBwZXR9XG5cbiAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xuICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcbiAgICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xuICAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XG5cbiAgICAgICAgIC8vaW50aWFsaXplIGRvdFByb2Qgd2l0aCBhIHNtYWxsIGVwc2lsb24gc2VlbXMgdG8gcmVkdWNlIEdQVSBhY2N1cmFjeSBsb3NzLlxuICAgICAgICAgdmVjNCBkb3RQcm9kID0gdmVjNCgwLjAwMDAwMDAwMDAwMDAwMSk7XG5cbiAgICAgICAgICR7bWFpbkxvb3B9XG5cbiAgICAgICAgIHZlYzQgcmVzdWx0ID0gZG90UHJvZCAtIHZlYzQoMC4wMDAwMDAwMDAwMDAwMDEpO1xuICAgICAgICAgJHthZGRCaWFzU25pcHBldH1cbiAgICAgICAgICR7YXBwbHlBY3RpdmF0aW9uU25pcHBldH1cbiAgICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgIH1cbiAgICAgYDtcbiAgIH1cbiB9XG4iXX0="],"names":["DepthwiseConvPacked2DProgram","constructor","convInfo","addBias","activation","hasPreluActivation","hasLeakyReluAlpha","this","variableNames","packedInputs","packedOutput","customUniforms","name","type","outputShape","outShape","enableShapeUniforms","length","channelMul","outChannels","inChannels","padLeft","padInfo","left","strideWidth","dilationWidth","filterHeight","filterWidth","texelsAcross","mainLoop","c","texelC","colIndex","nextTexelOffset","util","activationSnippet","applyActivationSnippet","addBiasSnippet","push","userCode","CropAndResizeProgram","imageShape","boxShape","cropSize","method","extrapolationValue","batch","imageHeight","imageWidth","depth","numBoxes","cropHeight","cropWidth","methodId","inputHeightFloat","inputWidthFloat","heightRatio","heightScale","inY","widthRatio","widthScale","inX","CumOpType","CumProgram","op","exclusive","reverse","rank","initVal","Prod","val","getCoords","condition","idxString","getFinalCoord","Error","Conv2DPackedProgram"],"sourceRoot":""}