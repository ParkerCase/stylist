{"version":3,"file":"stylist-vendors-18ac46db.d80c80849691050ea929.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/tex_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/texture_manager.js"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nexport var PackingScheme;\n(function (PackingScheme) {\n    /**\n     * All values in a single texel are densely packed without any constraints.\n     *\n     * This is how the shader encodes a tensor with shape = [2, 3, 4]\n     * (indices are [batch, row, col]).\n     *\n     * 000|001   010|011   020|021\n     * -------   -------   -------\n     * 002|003   012|013   022|023\n     *\n     * 100|101   110|111   120|121\n     * -------   -------   -------\n     * 102|103   112|113   122|123\n     *\n     */\n    PackingScheme[PackingScheme[\"DENSE\"] = 0] = \"DENSE\";\n    /**\n     * Single texels contain only values from the same batch, and from adjacent\n     * rows and columns.\n     *\n     * This is how the shader encodes a tensor with shape = [2, 3, 5]\n     * (indices are [batch, row, col]).\n     *\n     * 000|001   002|003   004|xxx   020|021   022|023   024|xxx\n     * -------   -------   -------   -------   -------   -------\n     * 010|011   012|013   014|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n     *\n     * 100|101   102|103   104|xxx   120|121   122|123   124|xxx\n     * -------   -------   -------   -------   -------   -------\n     * 110|111   112|113   114|xxx   xxx|xxx   xxx|xxx   xxx|xxx\n     *\n     */\n    PackingScheme[PackingScheme[\"SHARED_BATCH\"] = 1] = \"SHARED_BATCH\";\n})(PackingScheme || (PackingScheme = {}));\nexport var TextureUsage;\n(function (TextureUsage) {\n    TextureUsage[TextureUsage[\"RENDER\"] = 0] = \"RENDER\";\n    TextureUsage[TextureUsage[\"UPLOAD\"] = 1] = \"UPLOAD\";\n    TextureUsage[TextureUsage[\"PIXELS\"] = 2] = \"PIXELS\";\n    TextureUsage[TextureUsage[\"DOWNLOAD\"] = 3] = \"DOWNLOAD\";\n})(TextureUsage || (TextureUsage = {}));\nexport var PhysicalTextureType;\n(function (PhysicalTextureType) {\n    PhysicalTextureType[PhysicalTextureType[\"UNPACKED_FLOAT16\"] = 0] = \"UNPACKED_FLOAT16\";\n    PhysicalTextureType[PhysicalTextureType[\"UNPACKED_FLOAT32\"] = 1] = \"UNPACKED_FLOAT32\";\n    PhysicalTextureType[PhysicalTextureType[\"PACKED_4X1_UNSIGNED_BYTE\"] = 2] = \"PACKED_4X1_UNSIGNED_BYTE\";\n    PhysicalTextureType[PhysicalTextureType[\"PACKED_2X2_FLOAT32\"] = 3] = \"PACKED_2X2_FLOAT32\";\n    PhysicalTextureType[PhysicalTextureType[\"PACKED_2X2_FLOAT16\"] = 4] = \"PACKED_2X2_FLOAT16\";\n})(PhysicalTextureType || (PhysicalTextureType = {}));\nexport function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {\n    return [columns, rows];\n}\nexport function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {\n    return matrixSize * channelsPerTexture;\n}\nexport function getColorMatrixTextureShapeWidthHeight(rows, columns) {\n    return [columns * 4, rows];\n}\n/**\n * Get shape for densely packed RGBA texture.\n */\nexport function getDenseTexShape(shape) {\n    const size = util.sizeFromShape(shape);\n    const texelsNeeded = Math.ceil(size / 4);\n    return util.sizeToSquarishShape(texelsNeeded);\n}\nexport function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {\n    if (unpackedSize % channelsPerTexture !== 0) {\n        throw new Error(`unpackedSize (${unpackedSize}) must be a multiple of ` +\n            `${channelsPerTexture}`);\n    }\n    return unpackedSize / channelsPerTexture;\n}\nexport function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {\n    const requiredSize = unpackedArray.length * channels / 4;\n    if (matrix.length < requiredSize) {\n        throw new Error(`matrix length (${matrix.length}) must be >= ${requiredSize}`);\n    }\n    let dst = 0;\n    for (let src = 0; src < unpackedArray.length; src += 4) {\n        for (let c = 0; c < channels; c++) {\n            matrix[dst++] = unpackedArray[src + c];\n        }\n    }\n}\nexport function getPackedMatrixTextureShapeWidthHeight(rows, columns) {\n    return [\n        Math.max(1, Math.ceil(columns / 2)), Math.max(1, Math.ceil(rows / 2))\n    ];\n}\nexport function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {\n    const [w, h] = getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    return w * h * 4;\n}\nexport function getTextureConfig(\n// tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n    // tslint:disable-next-line:no-any\n    const glany = gl;\n    let internalFormatFloat;\n    let internalFormatHalfFloat;\n    let internalFormatPackedHalfFloat;\n    let internalFormatPackedFloat;\n    let textureFormatFloat;\n    let downloadTextureFormat;\n    let downloadUnpackNumChannels;\n    let defaultNumChannels;\n    let textureTypeHalfFloat;\n    let textureTypeFloat;\n    if (env().getNumber('WEBGL_VERSION') === 2) {\n        internalFormatFloat = glany.R32F;\n        internalFormatHalfFloat = glany.R16F;\n        internalFormatPackedHalfFloat = glany.RGBA16F;\n        internalFormatPackedFloat = glany.RGBA32F;\n        textureFormatFloat = glany.RED;\n        downloadUnpackNumChannels = 4;\n        defaultNumChannels = 1;\n        textureTypeHalfFloat = glany.HALF_FLOAT;\n        textureTypeFloat = glany.FLOAT;\n    }\n    else {\n        internalFormatFloat = gl.RGBA;\n        internalFormatHalfFloat = gl.RGBA;\n        internalFormatPackedHalfFloat = gl.RGBA;\n        internalFormatPackedFloat = glany.RGBA;\n        textureFormatFloat = gl.RGBA;\n        downloadUnpackNumChannels = 4;\n        defaultNumChannels = 4;\n        textureTypeHalfFloat = textureHalfFloatExtension != null ?\n            textureHalfFloatExtension.HALF_FLOAT_OES :\n            null;\n        textureTypeFloat = gl.FLOAT;\n    }\n    downloadTextureFormat = gl.RGBA;\n    return {\n        internalFormatFloat,\n        internalFormatHalfFloat,\n        internalFormatPackedHalfFloat,\n        internalFormatPackedFloat,\n        textureFormatFloat,\n        downloadTextureFormat,\n        downloadUnpackNumChannels,\n        defaultNumChannels,\n        textureTypeHalfFloat,\n        textureTypeFloat\n    };\n}\n//# sourceMappingURL=tex_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { getInternalFormatForFloat16MatrixTexture, getInternalFormatForFloat16PackedMatrixTexture, getInternalFormatForFloat32MatrixTexture, getInternalFormatForPackedMatrixTexture, getInternalFormatForUnsignedBytesMatrixTexture } from './gpgpu_util';\nimport { getPackedMatrixTextureShapeWidthHeight, getUnpackedMatrixTextureShapeWidthHeight, PhysicalTextureType, TextureUsage } from './tex_util';\nexport class TextureManager {\n    constructor(gpgpu) {\n        this.gpgpu = gpgpu;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0; // How many bytes that have been allocated\n        // are available for reuse.\n        this.freeTextures = {};\n        this.logEnabled = false;\n        this.usedTextures = {};\n    }\n    acquireTexture(shapeRC, usage, isPacked) {\n        const physicalTexType = getPhysicalFromLogicalTextureType(usage, isPacked);\n        const shapeKey = getKeyFromTextureShape(shapeRC, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        if (!(shapeKey in this.usedTextures)) {\n            this.usedTextures[shapeKey] = [];\n        }\n        const texBytes = computeBytes(shapeRC, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        if (this.freeTextures[shapeKey].length > 0) {\n            this.numFreeTextures--;\n            this.numUsedTextures++;\n            this._numBytesFree -= texBytes;\n            this.log();\n            const newTexture = this.freeTextures[shapeKey].shift();\n            this.usedTextures[shapeKey].push(newTexture);\n            return newTexture;\n        }\n        let newTexture;\n        if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT32) {\n            newTexture = this.gpgpu.createPackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_2X2_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16PackedMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT32) {\n            newTexture =\n                this.gpgpu.createFloat32MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.UNPACKED_FLOAT16) {\n            newTexture =\n                this.gpgpu.createFloat16MatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        else if (physicalTexType === PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE) {\n            newTexture =\n                this.gpgpu.createUnsignedBytesMatrixTexture(shapeRC[0], shapeRC[1]);\n        }\n        this.usedTextures[shapeKey].push(newTexture);\n        this.numUsedTextures++;\n        this._numBytesAllocated += texBytes;\n        this.log();\n        return newTexture;\n    }\n    releaseTexture(texture, shape, logicalTexType, isPacked) {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        const physicalTexType = getPhysicalFromLogicalTextureType(logicalTexType, isPacked);\n        const shapeKey = getKeyFromTextureShape(shape, physicalTexType, isPacked);\n        if (!(shapeKey in this.freeTextures)) {\n            this.freeTextures[shapeKey] = [];\n        }\n        const texBytes = computeBytes(shape, physicalTexType, this.gpgpu.gl, this.gpgpu.textureConfig, isPacked);\n        const deleteTexThreshold = env().get('WEBGL_DELETE_TEXTURE_THRESHOLD');\n        if (deleteTexThreshold !== -1 &&\n            this._numBytesAllocated > deleteTexThreshold) {\n            this.gpgpu.deleteMatrixTexture(texture);\n            this._numBytesAllocated -= texBytes;\n        }\n        else {\n            this.freeTextures[shapeKey].push(texture);\n            this.numFreeTextures++;\n            this._numBytesFree += texBytes;\n        }\n        this.numUsedTextures--;\n        const texList = this.usedTextures[shapeKey];\n        const texIndex = texList.indexOf(texture);\n        if (texIndex < 0) {\n            throw new Error('Cannot release a texture that was never provided by this ' +\n                'texture manager');\n        }\n        texList.splice(texIndex, 1);\n        this.log();\n    }\n    log() {\n        if (!this.logEnabled) {\n            return;\n        }\n        const total = this.numFreeTextures + this.numUsedTextures;\n        console.log('Free/Used', `${this.numFreeTextures} / ${this.numUsedTextures}`, `(${total})`);\n        const freeRatio = this._numBytesFree / this._numBytesAllocated;\n        console.log(`Bytes allocated: ${this._numBytesAllocated}`);\n        console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100 * freeRatio)}%)`);\n    }\n    get numBytesAllocated() {\n        return this._numBytesAllocated;\n    }\n    get numBytesFree() {\n        return this._numBytesFree;\n    }\n    getNumUsedTextures() {\n        return this.numUsedTextures;\n    }\n    getNumFreeTextures() {\n        return this.numFreeTextures;\n    }\n    dispose() {\n        if (this.freeTextures == null) {\n            // Already disposed.\n            return;\n        }\n        for (const texShape in this.freeTextures) {\n            this.freeTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        for (const texShape in this.usedTextures) {\n            this.usedTextures[texShape].forEach(tex => {\n                this.gpgpu.deleteMatrixTexture(tex);\n            });\n        }\n        this.freeTextures = null;\n        this.usedTextures = null;\n        this.numUsedTextures = 0;\n        this.numFreeTextures = 0;\n        this._numBytesAllocated = 0;\n        this._numBytesFree = 0;\n    }\n}\nfunction numBytesForInternalFormat(gl, internalFormat) {\n    // tslint:disable-next-line:no-any\n    const glany = gl;\n    if (internalFormat === glany.R32F) {\n        return 4;\n    }\n    else if (internalFormat === glany.R16F) {\n        return 2;\n    }\n    else if (internalFormat === glany.RGBA32F) {\n        return 16;\n    }\n    else if (internalFormat === gl.RGBA) {\n        return 16;\n    }\n    else if (internalFormat === glany.RGBA16F) {\n        return 8;\n    }\n    throw new Error(`Unknown internal format ${internalFormat}`);\n}\nexport function computeBytes(shape, physicalTexType, gl, textureConfig, isPacked) {\n    // It is not possible to infer packed status from the texture type because\n    // depending on the textureConfig, different  texture types may resolve to the\n    // same internal format (e.g. in WebGL1, the internal format for\n    // UNPACKED_FLOAT16 textures is gl.RGBA). Therefore we pass in `isPacked`\n    // explicitly.\n    const internalFormat = internalFormatForPhysicalTexType(physicalTexType, textureConfig);\n    let numElements;\n    if (isPacked) {\n        const [packedWidth, packedHeight] = getPackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n        numElements = packedWidth * packedHeight;\n    }\n    else {\n        const [width, height] = getUnpackedMatrixTextureShapeWidthHeight(shape[0], shape[1]);\n        numElements = width * height;\n    }\n    const bytesPerElement = numBytesForInternalFormat(gl, internalFormat);\n    return numElements * bytesPerElement;\n}\nfunction internalFormatForPhysicalTexType(physicalTexType, textureConfig) {\n    switch (physicalTexType) {\n        case PhysicalTextureType.PACKED_2X2_FLOAT32:\n            return getInternalFormatForPackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_2X2_FLOAT16:\n            return getInternalFormatForFloat16PackedMatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT32:\n            return getInternalFormatForFloat32MatrixTexture(textureConfig);\n        case PhysicalTextureType.UNPACKED_FLOAT16:\n            return getInternalFormatForFloat16MatrixTexture(textureConfig);\n        case PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:\n            return getInternalFormatForUnsignedBytesMatrixTexture(textureConfig);\n        default:\n            throw new Error(`Unknown physical texture type ${physicalTexType}`);\n    }\n}\nfunction getPhysicalTextureForRendering(isPacked) {\n    if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED')) {\n        if (isPacked) {\n            return PhysicalTextureType.PACKED_2X2_FLOAT32;\n        }\n        return PhysicalTextureType.UNPACKED_FLOAT32;\n    }\n    if (isPacked) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT16;\n    }\n    return PhysicalTextureType.UNPACKED_FLOAT16;\n}\nfunction getPhysicalFromLogicalTextureType(logicalTexType, isPacked) {\n    if (logicalTexType === TextureUsage.UPLOAD) {\n        return PhysicalTextureType.PACKED_2X2_FLOAT32;\n    }\n    else if (logicalTexType === TextureUsage.RENDER || logicalTexType == null) {\n        return getPhysicalTextureForRendering(isPacked);\n    }\n    else if (logicalTexType === TextureUsage.DOWNLOAD ||\n        logicalTexType === TextureUsage.PIXELS) {\n        return PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;\n    }\n    throw new Error(`Unknown logical texture type ${logicalTexType}`);\n}\nfunction getKeyFromTextureShape(shapeRowsCol, physicalTexType, isPacked) {\n    return `${shapeRowsCol[0]}_${shapeRowsCol[1]}_${physicalTexType}_${isPacked}`;\n}\n//# sourceMappingURL=texture_manager.js.map"],"names":["PackingScheme","TextureUsage","PhysicalTextureType","getUnpackedMatrixTextureShapeWidthHeight","rows","columns","getUnpackedArraySizeFromMatrixSize","matrixSize","channelsPerTexture","getDenseTexShape","shape","size","util","texelsNeeded","Math","ceil","getPackedMatrixTextureShapeWidthHeight","max","getPackedRGBAArraySizeFromMatrixShape","w","h","getTextureConfig","gl","textureHalfFloatExtension","glany","internalFormatFloat","internalFormatHalfFloat","internalFormatPackedHalfFloat","internalFormatPackedFloat","textureFormatFloat","downloadTextureFormat","downloadUnpackNumChannels","defaultNumChannels","textureTypeHalfFloat","textureTypeFloat","env","getNumber","R32F","R16F","RGBA16F","RGBA32F","RED","HALF_FLOAT","FLOAT","RGBA","HALF_FLOAT_OES","TextureManager","constructor","gpgpu","this","numUsedTextures","numFreeTextures","_numBytesAllocated","_numBytesFree","freeTextures","logEnabled","usedTextures","acquireTexture","shapeRC","usage","isPacked","physicalTexType","getPhysicalFromLogicalTextureType","shapeKey","getKeyFromTextureShape","texBytes","computeBytes","textureConfig","length","log","newTexture","shift","push","PACKED_2X2_FLOAT32","createPackedMatrixTexture","PACKED_2X2_FLOAT16","createFloat16PackedMatrixTexture","UNPACKED_FLOAT32","createFloat32MatrixTexture","UNPACKED_FLOAT16","createFloat16MatrixTexture","PACKED_4X1_UNSIGNED_BYTE","createUnsignedBytesMatrixTexture","releaseTexture","texture","logicalTexType","deleteTexThreshold","get","deleteMatrixTexture","texList","texIndex","indexOf","Error","splice","numBytesAllocated","numBytesFree","getNumUsedTextures","getNumFreeTextures","dispose","texShape","forEach","tex","internalFormat","internalFormatForPhysicalTexType","numElements","packedWidth","packedHeight","width","height","bytesPerElement","numBytesForInternalFormat","UPLOAD","RENDER","getBool","getPhysicalTextureForRendering","DOWNLOAD","PIXELS","shapeRowsCol"],"sourceRoot":""}