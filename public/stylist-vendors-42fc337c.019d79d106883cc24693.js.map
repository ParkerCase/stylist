{"version":3,"file":"stylist-vendors-42fc337c.019d79d106883cc24693.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/space_to_batch_nd.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_reshape.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_segment_mean.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_segment_sum.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_segment_reduction_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_fill_empty_rows.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_fill_empty_rows_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sparse/sparse_reshape_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sparse_to_dense.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/sparse_to_dense_util.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { SpaceToBatchND } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { op } from './operation';\n/**\n * This operation divides \"spatial\" dimensions `[1, ..., M]` of the input into\n * a grid of blocks of shape `blockShape`, and interleaves these blocks with\n * the \"batch\" dimension (0) such that in the output, the spatial\n * dimensions `[1, ..., M]` correspond to the position within the grid,\n * and the batch dimension combines both the position within a spatial block\n * and the original batch position. Prior to division into blocks,\n * the spatial dimensions of the input are optionally zero padded\n * according to `paddings`. See below for a precise description.\n *\n * ```js\n * const x = tf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]);\n * const blockShape = [2, 2];\n * const paddings = [[0, 0], [0, 0]];\n *\n * x.spaceToBatchND(blockShape, paddings).print();\n * ```\n *\n * @param x A `tf.Tensor`. N-D with `x.shape` = `[batch] + spatialShape +\n * remainingShape`, where spatialShape has `M` dimensions.\n * @param blockShape A 1-D array. Must have shape `[M]`, all values must\n * be >= 1.\n * @param paddings A 2-D array. Must have shape `[M, 2]`, all values must be >=\n *     0. `paddings[i] = [padStart, padEnd]` specifies the amount to zero-pad\n * from input dimension `i + 1`, which corresponds to spatial dimension `i`. It\n * is required that\n * `(inputShape[i + 1] + padStart + padEnd) % blockShape[i] === 0`\n *\n * This operation is equivalent to the following steps:\n *\n * 1. Zero-pad the start and end of dimensions `[1, ..., M]` of the input\n * according to `paddings` to produce `padded` of shape paddedShape.\n *\n * 2. Reshape `padded` to `reshapedPadded` of shape:\n * `[batch] + [paddedShape[1] / blockShape[0], blockShape[0], ...,\n * paddedShape[M] / blockShape[M-1], blockShape[M-1]] + remainingShape`\n *\n * 3. Permute dimensions of `reshapedPadded` to produce `permutedReshapedPadded`\n * of shape: `blockShape + [batch] + [paddedShape[1] / blockShape[0], ...,\n * paddedShape[M] / blockShape[M-1]] + remainingShape`\n *\n * 4. Reshape `permutedReshapedPadded` to flatten `blockShape` into the\n * batch dimension, producing an output tensor of shape:\n * `[batch * prod(blockShape)] + [paddedShape[1] / blockShape[0], ...,\n * paddedShape[M] / blockShape[M-1]] + remainingShape`\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction spaceToBatchND_(x, blockShape, paddings) {\n    const $x = convertToTensor(x, 'x', 'spaceToBatchND');\n    util.assert($x.rank >= 1 + blockShape.length, () => `input rank ${$x.rank} should be > than [blockShape] ${blockShape.length}`);\n    util.assert(paddings.length === blockShape.length, () => `paddings.shape[0] ${paddings.length} must be equal to [blockShape] ${blockShape.length}`);\n    util.assert($x.shape.reduce((a, b, i) => {\n        if (i > 0 && i <= blockShape.length) {\n            return a &&\n                ((b + paddings[i - 1][0] + paddings[i - 1][1]) %\n                    blockShape[i - 1] ===\n                    0);\n        }\n        return a;\n    }, true), () => `input spatial dimensions ${$x.shape.slice(1)} with paddings ${paddings.toString()} must be divisible by blockShapes ${blockShape.toString()}`);\n    const inputs = { x: $x };\n    const attrs = { blockShape, paddings };\n    return ENGINE.runKernel(SpaceToBatchND, inputs, attrs);\n}\nexport const spaceToBatchND = /* @__PURE__ */ op({ spaceToBatchND_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BhY2VfdG9fYmF0Y2hfbmQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9zcGFjZV90b19iYXRjaF9uZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQ2pDLE9BQU8sRUFBQyxjQUFjLEVBQTRDLE1BQU0saUJBQWlCLENBQUM7QUFJMUYsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBRW5ELE9BQU8sS0FBSyxJQUFJLE1BQU0sU0FBUyxDQUFDO0FBRWhDLE9BQU8sRUFBQyxFQUFFLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFFL0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBK0NHO0FBQ0gsU0FBUyxlQUFlLENBQ3BCLENBQWUsRUFBRSxVQUFvQixFQUFFLFFBQW9CO0lBQzdELE1BQU0sRUFBRSxHQUFHLGVBQWUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLGdCQUFnQixDQUFDLENBQUM7SUFFckQsSUFBSSxDQUFDLE1BQU0sQ0FDUCxFQUFFLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUNoQyxHQUFHLEVBQUUsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxJQUFJLGtDQUN2QixVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUU3QixJQUFJLENBQUMsTUFBTSxDQUNQLFFBQVEsQ0FBQyxNQUFNLEtBQUssVUFBVSxDQUFDLE1BQU0sRUFDckMsR0FBRyxFQUFFLENBQUMscUJBQ0YsUUFBUSxDQUFDLE1BQU0sa0NBQWtDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBRTlFLElBQUksQ0FBQyxNQUFNLENBQ1AsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQ1gsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ1YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxVQUFVLENBQUMsTUFBTSxFQUFFO1lBQ25DLE9BQU8sQ0FBQztnQkFDSixDQUFDLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDekMsVUFBVSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ3JCLENBQUMsQ0FBQyxDQUFDO1NBQ1Q7UUFDRCxPQUFPLENBQUMsQ0FBQztJQUNYLENBQUMsRUFDRCxJQUFJLENBQUMsRUFDVCxHQUFHLEVBQUUsQ0FBQyw0QkFBNEIsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLGtCQUMvQyxRQUFRLENBQUMsUUFBUSxFQUFFLHFDQUNuQixVQUFVLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRWpDLE1BQU0sTUFBTSxHQUF5QixFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUMsQ0FBQztJQUM3QyxNQUFNLEtBQUssR0FBd0IsRUFBQyxVQUFVLEVBQUUsUUFBUSxFQUFDLENBQUM7SUFFMUQsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUNuQixjQUFjLEVBQUUsTUFBbUMsRUFDbkQsS0FBZ0MsQ0FBQyxDQUFDO0FBQ3hDLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxjQUFjLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFDLGVBQWUsRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi9lbmdpbmUnO1xuaW1wb3J0IHtTcGFjZVRvQmF0Y2hORCwgU3BhY2VUb0JhdGNoTkRBdHRycywgU3BhY2VUb0JhdGNoTkRJbnB1dHN9IGZyb20gJy4uL2tlcm5lbF9uYW1lcyc7XG5pbXBvcnQge05hbWVkQXR0ck1hcH0gZnJvbSAnLi4va2VybmVsX3JlZ2lzdHJ5JztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuaW1wb3J0IHtOYW1lZFRlbnNvck1hcH0gZnJvbSAnLi4vdGVuc29yX3R5cGVzJztcbmltcG9ydCB7Y29udmVydFRvVGVuc29yfSBmcm9tICcuLi90ZW5zb3JfdXRpbF9lbnYnO1xuaW1wb3J0IHtUZW5zb3JMaWtlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uL3V0aWwnO1xuXG5pbXBvcnQge29wfSBmcm9tICcuL29wZXJhdGlvbic7XG5cbi8qKlxuICogVGhpcyBvcGVyYXRpb24gZGl2aWRlcyBcInNwYXRpYWxcIiBkaW1lbnNpb25zIGBbMSwgLi4uLCBNXWAgb2YgdGhlIGlucHV0IGludG9cbiAqIGEgZ3JpZCBvZiBibG9ja3Mgb2Ygc2hhcGUgYGJsb2NrU2hhcGVgLCBhbmQgaW50ZXJsZWF2ZXMgdGhlc2UgYmxvY2tzIHdpdGhcbiAqIHRoZSBcImJhdGNoXCIgZGltZW5zaW9uICgwKSBzdWNoIHRoYXQgaW4gdGhlIG91dHB1dCwgdGhlIHNwYXRpYWxcbiAqIGRpbWVuc2lvbnMgYFsxLCAuLi4sIE1dYCBjb3JyZXNwb25kIHRvIHRoZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGdyaWQsXG4gKiBhbmQgdGhlIGJhdGNoIGRpbWVuc2lvbiBjb21iaW5lcyBib3RoIHRoZSBwb3NpdGlvbiB3aXRoaW4gYSBzcGF0aWFsIGJsb2NrXG4gKiBhbmQgdGhlIG9yaWdpbmFsIGJhdGNoIHBvc2l0aW9uLiBQcmlvciB0byBkaXZpc2lvbiBpbnRvIGJsb2NrcyxcbiAqIHRoZSBzcGF0aWFsIGRpbWVuc2lvbnMgb2YgdGhlIGlucHV0IGFyZSBvcHRpb25hbGx5IHplcm8gcGFkZGVkXG4gKiBhY2NvcmRpbmcgdG8gYHBhZGRpbmdzYC4gU2VlIGJlbG93IGZvciBhIHByZWNpc2UgZGVzY3JpcHRpb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHggPSB0Zi50ZW5zb3I0ZChbMSwgMiwgMywgNF0sIFsxLCAyLCAyLCAxXSk7XG4gKiBjb25zdCBibG9ja1NoYXBlID0gWzIsIDJdO1xuICogY29uc3QgcGFkZGluZ3MgPSBbWzAsIDBdLCBbMCwgMF1dO1xuICpcbiAqIHguc3BhY2VUb0JhdGNoTkQoYmxvY2tTaGFwZSwgcGFkZGluZ3MpLnByaW50KCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0geCBBIGB0Zi5UZW5zb3JgLiBOLUQgd2l0aCBgeC5zaGFwZWAgPSBgW2JhdGNoXSArIHNwYXRpYWxTaGFwZSArXG4gKiByZW1haW5pbmdTaGFwZWAsIHdoZXJlIHNwYXRpYWxTaGFwZSBoYXMgYE1gIGRpbWVuc2lvbnMuXG4gKiBAcGFyYW0gYmxvY2tTaGFwZSBBIDEtRCBhcnJheS4gTXVzdCBoYXZlIHNoYXBlIGBbTV1gLCBhbGwgdmFsdWVzIG11c3RcbiAqIGJlID49IDEuXG4gKiBAcGFyYW0gcGFkZGluZ3MgQSAyLUQgYXJyYXkuIE11c3QgaGF2ZSBzaGFwZSBgW00sIDJdYCwgYWxsIHZhbHVlcyBtdXN0IGJlID49XG4gKiAgICAgMC4gYHBhZGRpbmdzW2ldID0gW3BhZFN0YXJ0LCBwYWRFbmRdYCBzcGVjaWZpZXMgdGhlIGFtb3VudCB0byB6ZXJvLXBhZFxuICogZnJvbSBpbnB1dCBkaW1lbnNpb24gYGkgKyAxYCwgd2hpY2ggY29ycmVzcG9uZHMgdG8gc3BhdGlhbCBkaW1lbnNpb24gYGlgLiBJdFxuICogaXMgcmVxdWlyZWQgdGhhdFxuICogYChpbnB1dFNoYXBlW2kgKyAxXSArIHBhZFN0YXJ0ICsgcGFkRW5kKSAlIGJsb2NrU2hhcGVbaV0gPT09IDBgXG4gKlxuICogVGhpcyBvcGVyYXRpb24gaXMgZXF1aXZhbGVudCB0byB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICpcbiAqIDEuIFplcm8tcGFkIHRoZSBzdGFydCBhbmQgZW5kIG9mIGRpbWVuc2lvbnMgYFsxLCAuLi4sIE1dYCBvZiB0aGUgaW5wdXRcbiAqIGFjY29yZGluZyB0byBgcGFkZGluZ3NgIHRvIHByb2R1Y2UgYHBhZGRlZGAgb2Ygc2hhcGUgcGFkZGVkU2hhcGUuXG4gKlxuICogMi4gUmVzaGFwZSBgcGFkZGVkYCB0byBgcmVzaGFwZWRQYWRkZWRgIG9mIHNoYXBlOlxuICogYFtiYXRjaF0gKyBbcGFkZGVkU2hhcGVbMV0gLyBibG9ja1NoYXBlWzBdLCBibG9ja1NoYXBlWzBdLCAuLi4sXG4gKiBwYWRkZWRTaGFwZVtNXSAvIGJsb2NrU2hhcGVbTS0xXSwgYmxvY2tTaGFwZVtNLTFdXSArIHJlbWFpbmluZ1NoYXBlYFxuICpcbiAqIDMuIFBlcm11dGUgZGltZW5zaW9ucyBvZiBgcmVzaGFwZWRQYWRkZWRgIHRvIHByb2R1Y2UgYHBlcm11dGVkUmVzaGFwZWRQYWRkZWRgXG4gKiBvZiBzaGFwZTogYGJsb2NrU2hhcGUgKyBbYmF0Y2hdICsgW3BhZGRlZFNoYXBlWzFdIC8gYmxvY2tTaGFwZVswXSwgLi4uLFxuICogcGFkZGVkU2hhcGVbTV0gLyBibG9ja1NoYXBlW00tMV1dICsgcmVtYWluaW5nU2hhcGVgXG4gKlxuICogNC4gUmVzaGFwZSBgcGVybXV0ZWRSZXNoYXBlZFBhZGRlZGAgdG8gZmxhdHRlbiBgYmxvY2tTaGFwZWAgaW50byB0aGVcbiAqIGJhdGNoIGRpbWVuc2lvbiwgcHJvZHVjaW5nIGFuIG91dHB1dCB0ZW5zb3Igb2Ygc2hhcGU6XG4gKiBgW2JhdGNoICogcHJvZChibG9ja1NoYXBlKV0gKyBbcGFkZGVkU2hhcGVbMV0gLyBibG9ja1NoYXBlWzBdLCAuLi4sXG4gKiBwYWRkZWRTaGFwZVtNXSAvIGJsb2NrU2hhcGVbTS0xXV0gKyByZW1haW5pbmdTaGFwZWBcbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdUcmFuc2Zvcm1hdGlvbnMnfVxuICovXG5mdW5jdGlvbiBzcGFjZVRvQmF0Y2hORF88VCBleHRlbmRzIFRlbnNvcj4oXG4gICAgeDogVHxUZW5zb3JMaWtlLCBibG9ja1NoYXBlOiBudW1iZXJbXSwgcGFkZGluZ3M6IG51bWJlcltdW10pOiBUIHtcbiAgY29uc3QgJHggPSBjb252ZXJ0VG9UZW5zb3IoeCwgJ3gnLCAnc3BhY2VUb0JhdGNoTkQnKTtcblxuICB1dGlsLmFzc2VydChcbiAgICAgICR4LnJhbmsgPj0gMSArIGJsb2NrU2hhcGUubGVuZ3RoLFxuICAgICAgKCkgPT4gYGlucHV0IHJhbmsgJHskeC5yYW5rfSBzaG91bGQgYmUgPiB0aGFuIFtibG9ja1NoYXBlXSAke1xuICAgICAgICAgIGJsb2NrU2hhcGUubGVuZ3RofWApO1xuXG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgcGFkZGluZ3MubGVuZ3RoID09PSBibG9ja1NoYXBlLmxlbmd0aCxcbiAgICAgICgpID0+IGBwYWRkaW5ncy5zaGFwZVswXSAke1xuICAgICAgICAgIHBhZGRpbmdzLmxlbmd0aH0gbXVzdCBiZSBlcXVhbCB0byBbYmxvY2tTaGFwZV0gJHtibG9ja1NoYXBlLmxlbmd0aH1gKTtcblxuICB1dGlsLmFzc2VydChcbiAgICAgICR4LnNoYXBlLnJlZHVjZShcbiAgICAgICAgICAoYSwgYiwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPiAwICYmIGkgPD0gYmxvY2tTaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGEgJiZcbiAgICAgICAgICAgICAgICAgICgoYiArIHBhZGRpbmdzW2kgLSAxXVswXSArIHBhZGRpbmdzW2kgLSAxXVsxXSkgJVxuICAgICAgICAgICAgICAgICAgICAgICBibG9ja1NoYXBlW2kgLSAxXSA9PT1cbiAgICAgICAgICAgICAgICAgICAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZSksXG4gICAgICAoKSA9PiBgaW5wdXQgc3BhdGlhbCBkaW1lbnNpb25zICR7JHguc2hhcGUuc2xpY2UoMSl9IHdpdGggcGFkZGluZ3MgJHtcbiAgICAgICAgICBwYWRkaW5ncy50b1N0cmluZygpfSBtdXN0IGJlIGRpdmlzaWJsZSBieSBibG9ja1NoYXBlcyAke1xuICAgICAgICAgIGJsb2NrU2hhcGUudG9TdHJpbmcoKX1gKTtcblxuICBjb25zdCBpbnB1dHM6IFNwYWNlVG9CYXRjaE5ESW5wdXRzID0ge3g6ICR4fTtcbiAgY29uc3QgYXR0cnM6IFNwYWNlVG9CYXRjaE5EQXR0cnMgPSB7YmxvY2tTaGFwZSwgcGFkZGluZ3N9O1xuXG4gIHJldHVybiBFTkdJTkUucnVuS2VybmVsKFxuICAgICAgU3BhY2VUb0JhdGNoTkQsIGlucHV0cyBhcyB1bmtub3duIGFzIE5hbWVkVGVuc29yTWFwLFxuICAgICAgYXR0cnMgYXMgdW5rbm93biBhcyBOYW1lZEF0dHJNYXApO1xufVxuXG5leHBvcnQgY29uc3Qgc3BhY2VUb0JhdGNoTkQgPSAvKiBAX19QVVJFX18gKi8gb3Aoe3NwYWNlVG9CYXRjaE5EX30pO1xuIl19","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { SparseReshape } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * This operation has the same semantics as reshape on the represented dense\n * tensor. The `inputIndices` are recomputed based on the requested `newShape`.\n * If one component of `newShape` is the special value -1, the size of that\n * dimension is computed so that the total dense size remains constant. At most\n * one component of `newShape` can be -1. The number of dense elements implied\n * by `newShape` must be the same as the number of dense elements originally\n * implied by `inputShape`. Reshaping does not affect the order of values in the\n * SparseTensor. If the input tensor has rank R_in and N non-empty values, and\n * `newShape` has length R_out, then `inputIndices` has shape [N, R_in],\n * `inputShape` has length R_in, `outputIndices` has shape [N, R_out], and\n * `outputShape` has length R_out.\n *\n * ```js\n * const result = tf.sparse.sparseReshape(\n *   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],\n *   [2, 3, 6], [9, -1]);\n * console.log(result);\n * result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]\n * result['outputShape'].print(); // [9, 4]\n * ```\n * @param inputIndices: 2-D. N x R_in matrix with the indices of non-empty\n * values in a SparseTensor.\n * @param inputShape: 1-D. R_in Tensor1D with the input SparseTensor's dense\n * shape.\n * @param newShape: 1-D. R_out Tensor1D with the requested new dense shape.\n * @return A map with the following properties:\n *     - outputIndices: 2-D. N x R_out matrix with the updated indices of\n *       non-empty values in the output SparseTensor.\n *     - outputShape: 1-D. R_out vector with the full dense shape of the output\n *       SparseTensor. This is the same as newShape but with any -1 dimensions\n *        filled in.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseReshape_(inputIndices, inputShape, newShape) {\n    const $inputIndices = convertToTensor(inputIndices, 'inputIndices', 'sparseReshape', 'int32');\n    const $inputShape = convertToTensor(inputShape, 'inputShape', 'sparseReshape', 'int32');\n    const $newShape = convertToTensor(newShape, 'newShape', 'sparseReshape', 'int32');\n    if ($inputIndices.rank !== 2) {\n        throw new Error(`Input indices should be Tensor2D but received shape\n        ${$inputIndices.shape}`);\n    }\n    if ($inputShape.rank !== 1) {\n        throw new Error(`Input shape should be Tensor1D but received shape ${$inputShape.shape}`);\n    }\n    if ($newShape.rank !== 1) {\n        throw new Error(`New shape should be Tensor1D but received shape ${$newShape.shape}`);\n    }\n    const inputs = {\n        inputIndices: $inputIndices,\n        inputShape: $inputShape,\n        newShape: $newShape\n    };\n    const result = ENGINE.runKernel(SparseReshape, inputs);\n    return { outputIndices: result[0], outputShape: result[1] };\n}\nexport const sparseReshape = /* @__PURE__ */ op({ sparseReshape_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BhcnNlX3Jlc2hhcGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9zcGFyc2Uvc3BhcnNlX3Jlc2hhcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUNwQyxPQUFPLEVBQUMsYUFBYSxFQUFzQixNQUFNLG9CQUFvQixDQUFDO0FBR3RFLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUV0RCxPQUFPLEVBQUMsRUFBRSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBRWhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQ0c7QUFDSCxTQUFTLGNBQWMsQ0FDbkIsWUFBaUMsRUFBRSxVQUErQixFQUNsRSxRQUE2QjtJQUMvQixNQUFNLGFBQWEsR0FDZixlQUFlLENBQUMsWUFBWSxFQUFFLGNBQWMsRUFBRSxlQUFlLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDNUUsTUFBTSxXQUFXLEdBQ2IsZUFBZSxDQUFDLFVBQVUsRUFBRSxZQUFZLEVBQUUsZUFBZSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3hFLE1BQU0sU0FBUyxHQUNYLGVBQWUsQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUVwRSxJQUFJLGFBQWEsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQzVCLE1BQU0sSUFBSSxLQUFLLENBQUM7VUFDVixhQUFhLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztLQUM5QjtJQUNELElBQUksV0FBVyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxxREFDWixXQUFXLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztLQUMxQjtJQUNELElBQUksU0FBUyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDeEIsTUFBTSxJQUFJLEtBQUssQ0FDWCxtREFBbUQsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7S0FDM0U7SUFFRCxNQUFNLE1BQU0sR0FBd0I7UUFDbEMsWUFBWSxFQUFFLGFBQWE7UUFDM0IsVUFBVSxFQUFFLFdBQVc7UUFDdkIsUUFBUSxFQUFFLFNBQVM7S0FDcEIsQ0FBQztJQUNGLE1BQU0sTUFBTSxHQUFhLE1BQU0sQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLE1BQVksQ0FBQyxDQUFDO0lBQ3ZFLE9BQU8sRUFBQyxhQUFhLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUMsQ0FBQztBQUM1RCxDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0sYUFBYSxHQUFHLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBQyxjQUFjLEVBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0VOR0lORX0gZnJvbSAnLi4vLi4vZW5naW5lJztcbmltcG9ydCB7U3BhcnNlUmVzaGFwZSwgU3BhcnNlUmVzaGFwZUlucHV0c30gZnJvbSAnLi4vLi4va2VybmVsX25hbWVzJztcbmltcG9ydCB7VGVuc29yLCBUZW5zb3IxRCwgVGVuc29yMkR9IGZyb20gJy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge05hbWVkVGVuc29yTWFwfSBmcm9tICcuLi8uLi90ZW5zb3JfdHlwZXMnO1xuaW1wb3J0IHtjb252ZXJ0VG9UZW5zb3J9IGZyb20gJy4uLy4uL3RlbnNvcl91dGlsX2Vudic7XG5pbXBvcnQge1RlbnNvckxpa2V9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7b3B9IGZyb20gJy4uL29wZXJhdGlvbic7XG5cbi8qKlxuICogVGhpcyBvcGVyYXRpb24gaGFzIHRoZSBzYW1lIHNlbWFudGljcyBhcyByZXNoYXBlIG9uIHRoZSByZXByZXNlbnRlZCBkZW5zZVxuICogdGVuc29yLiBUaGUgYGlucHV0SW5kaWNlc2AgYXJlIHJlY29tcHV0ZWQgYmFzZWQgb24gdGhlIHJlcXVlc3RlZCBgbmV3U2hhcGVgLlxuICogSWYgb25lIGNvbXBvbmVudCBvZiBgbmV3U2hhcGVgIGlzIHRoZSBzcGVjaWFsIHZhbHVlIC0xLCB0aGUgc2l6ZSBvZiB0aGF0XG4gKiBkaW1lbnNpb24gaXMgY29tcHV0ZWQgc28gdGhhdCB0aGUgdG90YWwgZGVuc2Ugc2l6ZSByZW1haW5zIGNvbnN0YW50LiBBdCBtb3N0XG4gKiBvbmUgY29tcG9uZW50IG9mIGBuZXdTaGFwZWAgY2FuIGJlIC0xLiBUaGUgbnVtYmVyIG9mIGRlbnNlIGVsZW1lbnRzIGltcGxpZWRcbiAqIGJ5IGBuZXdTaGFwZWAgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIGRlbnNlIGVsZW1lbnRzIG9yaWdpbmFsbHlcbiAqIGltcGxpZWQgYnkgYGlucHV0U2hhcGVgLiBSZXNoYXBpbmcgZG9lcyBub3QgYWZmZWN0IHRoZSBvcmRlciBvZiB2YWx1ZXMgaW4gdGhlXG4gKiBTcGFyc2VUZW5zb3IuIElmIHRoZSBpbnB1dCB0ZW5zb3IgaGFzIHJhbmsgUl9pbiBhbmQgTiBub24tZW1wdHkgdmFsdWVzLCBhbmRcbiAqIGBuZXdTaGFwZWAgaGFzIGxlbmd0aCBSX291dCwgdGhlbiBgaW5wdXRJbmRpY2VzYCBoYXMgc2hhcGUgW04sIFJfaW5dLFxuICogYGlucHV0U2hhcGVgIGhhcyBsZW5ndGggUl9pbiwgYG91dHB1dEluZGljZXNgIGhhcyBzaGFwZSBbTiwgUl9vdXRdLCBhbmRcbiAqIGBvdXRwdXRTaGFwZWAgaGFzIGxlbmd0aCBSX291dC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcmVzdWx0ID0gdGYuc3BhcnNlLnNwYXJzZVJlc2hhcGUoXG4gKiAgIFtbMCwgMCwgMF0sIFswLCAwLCAxXSwgWzAsIDEsIDBdLCBbMSwgMCwgMF0sIFsxLCAyLCAzXV0sXG4gKiAgIFsyLCAzLCA2XSwgWzksIC0xXSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICogcmVzdWx0WydvdXRwdXRJbmRpY2VzJ10ucHJpbnQoKTsgLy9bWzAsIDBdLCBbMCwgMV0sIFsxLCAyXSwgWzQsIDJdLCBbOCwgMV1dXG4gKiByZXN1bHRbJ291dHB1dFNoYXBlJ10ucHJpbnQoKTsgLy8gWzksIDRdXG4gKiBgYGBcbiAqIEBwYXJhbSBpbnB1dEluZGljZXM6IDItRC4gTiB4IFJfaW4gbWF0cml4IHdpdGggdGhlIGluZGljZXMgb2Ygbm9uLWVtcHR5XG4gKiB2YWx1ZXMgaW4gYSBTcGFyc2VUZW5zb3IuXG4gKiBAcGFyYW0gaW5wdXRTaGFwZTogMS1ELiBSX2luIFRlbnNvcjFEIHdpdGggdGhlIGlucHV0IFNwYXJzZVRlbnNvcidzIGRlbnNlXG4gKiBzaGFwZS5cbiAqIEBwYXJhbSBuZXdTaGFwZTogMS1ELiBSX291dCBUZW5zb3IxRCB3aXRoIHRoZSByZXF1ZXN0ZWQgbmV3IGRlbnNlIHNoYXBlLlxuICogQHJldHVybiBBIG1hcCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqICAgICAtIG91dHB1dEluZGljZXM6IDItRC4gTiB4IFJfb3V0IG1hdHJpeCB3aXRoIHRoZSB1cGRhdGVkIGluZGljZXMgb2ZcbiAqICAgICAgIG5vbi1lbXB0eSB2YWx1ZXMgaW4gdGhlIG91dHB1dCBTcGFyc2VUZW5zb3IuXG4gKiAgICAgLSBvdXRwdXRTaGFwZTogMS1ELiBSX291dCB2ZWN0b3Igd2l0aCB0aGUgZnVsbCBkZW5zZSBzaGFwZSBvZiB0aGUgb3V0cHV0XG4gKiAgICAgICBTcGFyc2VUZW5zb3IuIFRoaXMgaXMgdGhlIHNhbWUgYXMgbmV3U2hhcGUgYnV0IHdpdGggYW55IC0xIGRpbWVuc2lvbnNcbiAqICAgICAgICBmaWxsZWQgaW4uXG4gKiBAZG9jIHtoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdTcGFyc2UnfVxuICovXG5mdW5jdGlvbiBzcGFyc2VSZXNoYXBlXyhcbiAgICBpbnB1dEluZGljZXM6IFRlbnNvcjJEfFRlbnNvckxpa2UsIGlucHV0U2hhcGU6IFRlbnNvcjFEfFRlbnNvckxpa2UsXG4gICAgbmV3U2hhcGU6IFRlbnNvcjFEfFRlbnNvckxpa2UpOiBOYW1lZFRlbnNvck1hcCB7XG4gIGNvbnN0ICRpbnB1dEluZGljZXMgPVxuICAgICAgY29udmVydFRvVGVuc29yKGlucHV0SW5kaWNlcywgJ2lucHV0SW5kaWNlcycsICdzcGFyc2VSZXNoYXBlJywgJ2ludDMyJyk7XG4gIGNvbnN0ICRpbnB1dFNoYXBlID1cbiAgICAgIGNvbnZlcnRUb1RlbnNvcihpbnB1dFNoYXBlLCAnaW5wdXRTaGFwZScsICdzcGFyc2VSZXNoYXBlJywgJ2ludDMyJyk7XG4gIGNvbnN0ICRuZXdTaGFwZSA9XG4gICAgICBjb252ZXJ0VG9UZW5zb3IobmV3U2hhcGUsICduZXdTaGFwZScsICdzcGFyc2VSZXNoYXBlJywgJ2ludDMyJyk7XG5cbiAgaWYgKCRpbnB1dEluZGljZXMucmFuayAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgaW5kaWNlcyBzaG91bGQgYmUgVGVuc29yMkQgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICR7JGlucHV0SW5kaWNlcy5zaGFwZX1gKTtcbiAgfVxuICBpZiAoJGlucHV0U2hhcGUucmFuayAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgc2hhcGUgc2hvdWxkIGJlIFRlbnNvcjFEIGJ1dCByZWNlaXZlZCBzaGFwZSAke1xuICAgICAgICAkaW5wdXRTaGFwZS5zaGFwZX1gKTtcbiAgfVxuICBpZiAoJG5ld1NoYXBlLnJhbmsgIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBOZXcgc2hhcGUgc2hvdWxkIGJlIFRlbnNvcjFEIGJ1dCByZWNlaXZlZCBzaGFwZSAkeyRuZXdTaGFwZS5zaGFwZX1gKTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0czogU3BhcnNlUmVzaGFwZUlucHV0cyA9IHtcbiAgICBpbnB1dEluZGljZXM6ICRpbnB1dEluZGljZXMsXG4gICAgaW5wdXRTaGFwZTogJGlucHV0U2hhcGUsXG4gICAgbmV3U2hhcGU6ICRuZXdTaGFwZVxuICB9O1xuICBjb25zdCByZXN1bHQ6IFRlbnNvcltdID0gRU5HSU5FLnJ1bktlcm5lbChTcGFyc2VSZXNoYXBlLCBpbnB1dHMgYXMge30pO1xuICByZXR1cm4ge291dHB1dEluZGljZXM6IHJlc3VsdFswXSwgb3V0cHV0U2hhcGU6IHJlc3VsdFsxXX07XG59XG5cbmV4cG9ydCBjb25zdCBzcGFyc2VSZXNoYXBlID0gLyogQF9fUFVSRV9fICovIG9wKHtzcGFyc2VSZXNoYXBlX30pO1xuIl19","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { SparseSegmentMean } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * Computes the mean along sparse segments of a tensor.\n *\n * ```js\n * const c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [6,7,8,9]]);\n * // Select two rows, one segment.\n * const result1 = tf.sparse.sparseSegmentMean(c,\n *                                           tf.tensor1d([0, 1], 'int32'),\n *                                           tf.tensor1d([0, 0], 'int32'));\n * result1.print(); // [[0, 0, 0, 0]]\n *\n * // Select two rows, two segments.\n * const result2 = tf.sparse.sparseSegmentMean(c,\n *                                             tf.tensor1d([0, 1], 'int32'),\n *                                             tf.tensor1d([0, 1], 'int32'));\n * result2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]\n *\n * // Select all rows, two segments.\n * const result3 = tf.sparse.sparseSegmentMean(c,\n *                                             tf.tensor1d([0, 1, 2], 'int32'),\n *                                             tf.tensor1d([0, 1, 1], 'int32'));\n * result3.print(); // [[1.0, 2.0, 3.0, 4.0], [2.5, 2.5, 2.5, 2.5]]\n * ```\n * @param data: A Tensor of at least one dimension with data that will be\n *     assembled in the output.\n * @param indices: A 1-D Tensor with indices into data. Has same rank as\n *     segmentIds.\n * @param segmentIds: A 1-D Tensor with indices into the output Tensor. Values\n *     should be sorted and can be repeated.\n * @return Has same shape as data, except for dimension 0 which has equal to\n *         the number of segments.\n *\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseSegmentMean_(data, indices, segmentIds) {\n    const $data = convertToTensor(data, 'data', 'sparseSegmentMean');\n    const $indices = convertToTensor(indices, 'indices', 'sparseSegmentMean', 'int32');\n    const $segmentIds = convertToTensor(segmentIds, 'segmentIds', 'sparseSegmentMean', 'int32');\n    if ($data.rank < 1) {\n        throw new Error(`Data should be at least 1 dimensional but received scalar`);\n    }\n    if ($indices.rank !== 1) {\n        throw new Error(`Indices should be Tensor1D but received shape\n          ${$indices.shape}`);\n    }\n    if ($segmentIds.rank !== 1) {\n        throw new Error(`Segment ids should be Tensor1D but received shape\n          ${$segmentIds.shape}`);\n    }\n    const inputs = {\n        data: $data,\n        indices: $indices,\n        segmentIds: $segmentIds\n    };\n    return ENGINE.runKernel(SparseSegmentMean, inputs);\n}\nexport const sparseSegmentMean = /* @__PURE__ */ op({ sparseSegmentMean_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BhcnNlX3NlZ21lbnRfbWVhbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL3NwYXJzZS9zcGFyc2Vfc2VnbWVudF9tZWFuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFDcEMsT0FBTyxFQUFDLGlCQUFpQixFQUEwQixNQUFNLG9CQUFvQixDQUFDO0FBRTlFLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUV0RCxPQUFPLEVBQUMsRUFBRSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBRWhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQ0c7QUFDSCxTQUFTLGtCQUFrQixDQUN2QixJQUF1QixFQUFFLE9BQTRCLEVBQ3JELFVBQStCO0lBQ2pDLE1BQU0sS0FBSyxHQUFHLGVBQWUsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLG1CQUFtQixDQUFDLENBQUM7SUFDakUsTUFBTSxRQUFRLEdBQ1YsZUFBZSxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsbUJBQW1CLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDdEUsTUFBTSxXQUFXLEdBQ2IsZUFBZSxDQUFDLFVBQVUsRUFBRSxZQUFZLEVBQUUsbUJBQW1CLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFNUUsSUFBSSxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRTtRQUNsQixNQUFNLElBQUksS0FBSyxDQUNYLDJEQUEyRCxDQUFDLENBQUM7S0FDbEU7SUFDRCxJQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUM7WUFDUixRQUFRLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztLQUMzQjtJQUNELElBQUksV0FBVyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQztZQUNSLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0tBQzlCO0lBRUQsTUFBTSxNQUFNLEdBQTRCO1FBQ3RDLElBQUksRUFBRSxLQUFLO1FBQ1gsT0FBTyxFQUFFLFFBQVE7UUFDakIsVUFBVSxFQUFFLFdBQVc7S0FDeEIsQ0FBQztJQUVGLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsRUFBRSxNQUFZLENBQUMsQ0FBQztBQUMzRCxDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0saUJBQWlCLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFDLGtCQUFrQixFQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtFTkdJTkV9IGZyb20gJy4uLy4uL2VuZ2luZSc7XG5pbXBvcnQge1NwYXJzZVNlZ21lbnRNZWFuLCBTcGFyc2VTZWdtZW50TWVhbklucHV0c30gZnJvbSAnLi4vLi4va2VybmVsX25hbWVzJztcbmltcG9ydCB7VGVuc29yLCBUZW5zb3IxRH0gZnJvbSAnLi4vLi4vdGVuc29yJztcbmltcG9ydCB7Y29udmVydFRvVGVuc29yfSBmcm9tICcuLi8uLi90ZW5zb3JfdXRpbF9lbnYnO1xuaW1wb3J0IHtUZW5zb3JMaWtlfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQge29wfSBmcm9tICcuLi9vcGVyYXRpb24nO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtZWFuIGFsb25nIHNwYXJzZSBzZWdtZW50cyBvZiBhIHRlbnNvci5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgYyA9IHRmLnRlbnNvcjJkKFtbMSwyLDMsNF0sIFstMSwtMiwtMywtNF0sIFs2LDcsOCw5XV0pO1xuICogLy8gU2VsZWN0IHR3byByb3dzLCBvbmUgc2VnbWVudC5cbiAqIGNvbnN0IHJlc3VsdDEgPSB0Zi5zcGFyc2Uuc3BhcnNlU2VnbWVudE1lYW4oYyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmLnRlbnNvcjFkKFswLCAxXSwgJ2ludDMyJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Zi50ZW5zb3IxZChbMCwgMF0sICdpbnQzMicpKTtcbiAqIHJlc3VsdDEucHJpbnQoKTsgLy8gW1swLCAwLCAwLCAwXV1cbiAqXG4gKiAvLyBTZWxlY3QgdHdvIHJvd3MsIHR3byBzZWdtZW50cy5cbiAqIGNvbnN0IHJlc3VsdDIgPSB0Zi5zcGFyc2Uuc3BhcnNlU2VnbWVudE1lYW4oYyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGYudGVuc29yMWQoWzAsIDFdLCAnaW50MzInKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGYudGVuc29yMWQoWzAsIDFdLCAnaW50MzInKSk7XG4gKiByZXN1bHQyLnByaW50KCk7IC8vIFtbMSwgMiwgMywgNF0sIFstMSwgLTIsIC0zLCAtNF1dXG4gKlxuICogLy8gU2VsZWN0IGFsbCByb3dzLCB0d28gc2VnbWVudHMuXG4gKiBjb25zdCByZXN1bHQzID0gdGYuc3BhcnNlLnNwYXJzZVNlZ21lbnRNZWFuKGMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmLnRlbnNvcjFkKFswLCAxLCAyXSwgJ2ludDMyJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmLnRlbnNvcjFkKFswLCAxLCAxXSwgJ2ludDMyJykpO1xuICogcmVzdWx0My5wcmludCgpOyAvLyBbWzEuMCwgMi4wLCAzLjAsIDQuMF0sIFsyLjUsIDIuNSwgMi41LCAyLjVdXVxuICogYGBgXG4gKiBAcGFyYW0gZGF0YTogQSBUZW5zb3Igb2YgYXQgbGVhc3Qgb25lIGRpbWVuc2lvbiB3aXRoIGRhdGEgdGhhdCB3aWxsIGJlXG4gKiAgICAgYXNzZW1ibGVkIGluIHRoZSBvdXRwdXQuXG4gKiBAcGFyYW0gaW5kaWNlczogQSAxLUQgVGVuc29yIHdpdGggaW5kaWNlcyBpbnRvIGRhdGEuIEhhcyBzYW1lIHJhbmsgYXNcbiAqICAgICBzZWdtZW50SWRzLlxuICogQHBhcmFtIHNlZ21lbnRJZHM6IEEgMS1EIFRlbnNvciB3aXRoIGluZGljZXMgaW50byB0aGUgb3V0cHV0IFRlbnNvci4gVmFsdWVzXG4gKiAgICAgc2hvdWxkIGJlIHNvcnRlZCBhbmQgY2FuIGJlIHJlcGVhdGVkLlxuICogQHJldHVybiBIYXMgc2FtZSBzaGFwZSBhcyBkYXRhLCBleGNlcHQgZm9yIGRpbWVuc2lvbiAwIHdoaWNoIGhhcyBlcXVhbCB0b1xuICogICAgICAgICB0aGUgbnVtYmVyIG9mIHNlZ21lbnRzLlxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1NwYXJzZSd9XG4gKi9cbmZ1bmN0aW9uIHNwYXJzZVNlZ21lbnRNZWFuXyhcbiAgICBkYXRhOiBUZW5zb3J8VGVuc29yTGlrZSwgaW5kaWNlczogVGVuc29yMUR8VGVuc29yTGlrZSxcbiAgICBzZWdtZW50SWRzOiBUZW5zb3IxRHxUZW5zb3JMaWtlKTogVGVuc29yIHtcbiAgY29uc3QgJGRhdGEgPSBjb252ZXJ0VG9UZW5zb3IoZGF0YSwgJ2RhdGEnLCAnc3BhcnNlU2VnbWVudE1lYW4nKTtcbiAgY29uc3QgJGluZGljZXMgPVxuICAgICAgY29udmVydFRvVGVuc29yKGluZGljZXMsICdpbmRpY2VzJywgJ3NwYXJzZVNlZ21lbnRNZWFuJywgJ2ludDMyJyk7XG4gIGNvbnN0ICRzZWdtZW50SWRzID1cbiAgICAgIGNvbnZlcnRUb1RlbnNvcihzZWdtZW50SWRzLCAnc2VnbWVudElkcycsICdzcGFyc2VTZWdtZW50TWVhbicsICdpbnQzMicpO1xuXG4gIGlmICgkZGF0YS5yYW5rIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYERhdGEgc2hvdWxkIGJlIGF0IGxlYXN0IDEgZGltZW5zaW9uYWwgYnV0IHJlY2VpdmVkIHNjYWxhcmApO1xuICB9XG4gIGlmICgkaW5kaWNlcy5yYW5rICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbmRpY2VzIHNob3VsZCBiZSBUZW5zb3IxRCBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgICAkeyRpbmRpY2VzLnNoYXBlfWApO1xuICB9XG4gIGlmICgkc2VnbWVudElkcy5yYW5rICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTZWdtZW50IGlkcyBzaG91bGQgYmUgVGVuc29yMUQgYnV0IHJlY2VpdmVkIHNoYXBlXG4gICAgICAgICAgJHskc2VnbWVudElkcy5zaGFwZX1gKTtcbiAgfVxuXG4gIGNvbnN0IGlucHV0czogU3BhcnNlU2VnbWVudE1lYW5JbnB1dHMgPSB7XG4gICAgZGF0YTogJGRhdGEsXG4gICAgaW5kaWNlczogJGluZGljZXMsXG4gICAgc2VnbWVudElkczogJHNlZ21lbnRJZHNcbiAgfTtcblxuICByZXR1cm4gRU5HSU5FLnJ1bktlcm5lbChTcGFyc2VTZWdtZW50TWVhbiwgaW5wdXRzIGFzIHt9KTtcbn1cblxuZXhwb3J0IGNvbnN0IHNwYXJzZVNlZ21lbnRNZWFuID0gLyogQF9fUFVSRV9fICovIG9wKHtzcGFyc2VTZWdtZW50TWVhbl99KTtcbiJdfQ==","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { SparseSegmentSum } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * Computes the sum along sparse segments of a tensor.\n *\n * ```js\n * const c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]]);\n * // Select two rows, one segment.\n * const result1 = tf.sparse.sparseSegmentSum(c,\n *                                           tf.tensor1d([0, 1], 'int32'),\n *                                           tf.tensor1d([0, 0], 'int32'));\n * result1.print(); // [[0, 0, 0, 0]]\n *\n * // Select two rows, two segments.\n * const result2 = tf.sparse.sparseSegmentSum(c,\n *                                           tf.tensor1d([0, 1], 'int32'),\n *                                           tf.tensor1d([0, 1], 'int32'));\n * result2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]\n *\n * // Select all rows, two segments.\n * const result3 = tf.sparse.sparseSegmentSum(c,\n *                                           tf.tensor1d([0, 1, 2], 'int32'),\n *                                           tf.tensor1d([0, 0, 1], 'int32'));\n * result3.print(); // [[0, 0, 0, 0], [5, 6, 7, 8]]\n * ```\n * @param data: A Tensor of at least one dimension with data that will be\n *     assembled in the output.\n * @param indices: A 1-D Tensor with indices into data. Has same rank as\n *     segmentIds.\n * @param segmentIds: A 1-D Tensor with indices into the output Tensor. Values\n *     should be sorted and can be repeated.\n * @return Has same shape as data, except for dimension 0 which has equal to\n *         the number of segments.\n *\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseSegmentSum_(data, indices, segmentIds) {\n    const $data = convertToTensor(data, 'data', 'sparseSegmentSum');\n    const $indices = convertToTensor(indices, 'indices', 'sparseSegmentSum', 'int32');\n    const $segmentIds = convertToTensor(segmentIds, 'segmentIds', 'sparseSegmentSum', 'int32');\n    if ($data.rank < 1) {\n        throw new Error(`Data should be at least 1 dimensional but received scalar`);\n    }\n    if ($indices.rank !== 1) {\n        throw new Error(`Indices should be Tensor1D but received shape\n         ${$indices.shape}`);\n    }\n    if ($segmentIds.rank !== 1) {\n        throw new Error(`Segment ids should be Tensor1D but received shape\n         ${$segmentIds.shape}`);\n    }\n    const inputs = {\n        data: $data,\n        indices: $indices,\n        segmentIds: $segmentIds\n    };\n    return ENGINE.runKernel(SparseSegmentSum, inputs);\n}\nexport const sparseSegmentSum = /* @__PURE__ */ op({ sparseSegmentSum_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BhcnNlX3NlZ21lbnRfc3VtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc3BhcnNlL3NwYXJzZV9zZWdtZW50X3N1bS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBQ3BDLE9BQU8sRUFBQyxnQkFBZ0IsRUFBeUIsTUFBTSxvQkFBb0IsQ0FBQztBQUU1RSxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFdEQsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUVoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUNHO0FBQ0gsU0FBUyxpQkFBaUIsQ0FDdEIsSUFBdUIsRUFBRSxPQUE0QixFQUNyRCxVQUErQjtJQUNqQyxNQUFNLEtBQUssR0FBRyxlQUFlLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO0lBQ2hFLE1BQU0sUUFBUSxHQUNWLGVBQWUsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLGtCQUFrQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3JFLE1BQU0sV0FBVyxHQUNiLGVBQWUsQ0FBQyxVQUFVLEVBQUUsWUFBWSxFQUFFLGtCQUFrQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRTNFLElBQUksS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUU7UUFDbEIsTUFBTSxJQUFJLEtBQUssQ0FDWCwyREFBMkQsQ0FBQyxDQUFDO0tBQ2xFO0lBQ0QsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtRQUN2QixNQUFNLElBQUksS0FBSyxDQUFDO1dBQ1QsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7S0FDMUI7SUFDRCxJQUFJLFdBQVcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQzFCLE1BQU0sSUFBSSxLQUFLLENBQUM7V0FDVCxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztLQUM3QjtJQUVELE1BQU0sTUFBTSxHQUEyQjtRQUNyQyxJQUFJLEVBQUUsS0FBSztRQUNYLE9BQU8sRUFBRSxRQUFRO1FBQ2pCLFVBQVUsRUFBRSxXQUFXO0tBQ3hCLENBQUM7SUFFRixPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEVBQUUsTUFBWSxDQUFDLENBQUM7QUFDMUQsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLGdCQUFnQixHQUFHLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBQyxpQkFBaUIsRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi8uLi9lbmdpbmUnO1xuaW1wb3J0IHtTcGFyc2VTZWdtZW50U3VtLCBTcGFyc2VTZWdtZW50U3VtSW5wdXRzfSBmcm9tICcuLi8uLi9rZXJuZWxfbmFtZXMnO1xuaW1wb3J0IHtUZW5zb3IsIFRlbnNvcjFEfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtjb252ZXJ0VG9UZW5zb3J9IGZyb20gJy4uLy4uL3RlbnNvcl91dGlsX2Vudic7XG5pbXBvcnQge1RlbnNvckxpa2V9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7b3B9IGZyb20gJy4uL29wZXJhdGlvbic7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHN1bSBhbG9uZyBzcGFyc2Ugc2VnbWVudHMgb2YgYSB0ZW5zb3IuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGMgPSB0Zi50ZW5zb3IyZChbWzEsMiwzLDRdLCBbLTEsLTIsLTMsLTRdLCBbNSw2LDcsOF1dKTtcbiAqIC8vIFNlbGVjdCB0d28gcm93cywgb25lIHNlZ21lbnQuXG4gKiBjb25zdCByZXN1bHQxID0gdGYuc3BhcnNlLnNwYXJzZVNlZ21lbnRTdW0oYyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmLnRlbnNvcjFkKFswLCAxXSwgJ2ludDMyJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Zi50ZW5zb3IxZChbMCwgMF0sICdpbnQzMicpKTtcbiAqIHJlc3VsdDEucHJpbnQoKTsgLy8gW1swLCAwLCAwLCAwXV1cbiAqXG4gKiAvLyBTZWxlY3QgdHdvIHJvd3MsIHR3byBzZWdtZW50cy5cbiAqIGNvbnN0IHJlc3VsdDIgPSB0Zi5zcGFyc2Uuc3BhcnNlU2VnbWVudFN1bShjLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGYudGVuc29yMWQoWzAsIDFdLCAnaW50MzInKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRmLnRlbnNvcjFkKFswLCAxXSwgJ2ludDMyJykpO1xuICogcmVzdWx0Mi5wcmludCgpOyAvLyBbWzEsIDIsIDMsIDRdLCBbLTEsIC0yLCAtMywgLTRdXVxuICpcbiAqIC8vIFNlbGVjdCBhbGwgcm93cywgdHdvIHNlZ21lbnRzLlxuICogY29uc3QgcmVzdWx0MyA9IHRmLnNwYXJzZS5zcGFyc2VTZWdtZW50U3VtKGMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Zi50ZW5zb3IxZChbMCwgMSwgMl0sICdpbnQzMicpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGYudGVuc29yMWQoWzAsIDAsIDFdLCAnaW50MzInKSk7XG4gKiByZXN1bHQzLnByaW50KCk7IC8vIFtbMCwgMCwgMCwgMF0sIFs1LCA2LCA3LCA4XV1cbiAqIGBgYFxuICogQHBhcmFtIGRhdGE6IEEgVGVuc29yIG9mIGF0IGxlYXN0IG9uZSBkaW1lbnNpb24gd2l0aCBkYXRhIHRoYXQgd2lsbCBiZVxuICogICAgIGFzc2VtYmxlZCBpbiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIGluZGljZXM6IEEgMS1EIFRlbnNvciB3aXRoIGluZGljZXMgaW50byBkYXRhLiBIYXMgc2FtZSByYW5rIGFzXG4gKiAgICAgc2VnbWVudElkcy5cbiAqIEBwYXJhbSBzZWdtZW50SWRzOiBBIDEtRCBUZW5zb3Igd2l0aCBpbmRpY2VzIGludG8gdGhlIG91dHB1dCBUZW5zb3IuIFZhbHVlc1xuICogICAgIHNob3VsZCBiZSBzb3J0ZWQgYW5kIGNhbiBiZSByZXBlYXRlZC5cbiAqIEByZXR1cm4gSGFzIHNhbWUgc2hhcGUgYXMgZGF0YSwgZXhjZXB0IGZvciBkaW1lbnNpb24gMCB3aGljaCBoYXMgZXF1YWwgdG9cbiAqICAgICAgICAgdGhlIG51bWJlciBvZiBzZWdtZW50cy5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdTcGFyc2UnfVxuICovXG5mdW5jdGlvbiBzcGFyc2VTZWdtZW50U3VtXyhcbiAgICBkYXRhOiBUZW5zb3J8VGVuc29yTGlrZSwgaW5kaWNlczogVGVuc29yMUR8VGVuc29yTGlrZSxcbiAgICBzZWdtZW50SWRzOiBUZW5zb3IxRHxUZW5zb3JMaWtlKTogVGVuc29yIHtcbiAgY29uc3QgJGRhdGEgPSBjb252ZXJ0VG9UZW5zb3IoZGF0YSwgJ2RhdGEnLCAnc3BhcnNlU2VnbWVudFN1bScpO1xuICBjb25zdCAkaW5kaWNlcyA9XG4gICAgICBjb252ZXJ0VG9UZW5zb3IoaW5kaWNlcywgJ2luZGljZXMnLCAnc3BhcnNlU2VnbWVudFN1bScsICdpbnQzMicpO1xuICBjb25zdCAkc2VnbWVudElkcyA9XG4gICAgICBjb252ZXJ0VG9UZW5zb3Ioc2VnbWVudElkcywgJ3NlZ21lbnRJZHMnLCAnc3BhcnNlU2VnbWVudFN1bScsICdpbnQzMicpO1xuXG4gIGlmICgkZGF0YS5yYW5rIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYERhdGEgc2hvdWxkIGJlIGF0IGxlYXN0IDEgZGltZW5zaW9uYWwgYnV0IHJlY2VpdmVkIHNjYWxhcmApO1xuICB9XG4gIGlmICgkaW5kaWNlcy5yYW5rICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbmRpY2VzIHNob3VsZCBiZSBUZW5zb3IxRCBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgICR7JGluZGljZXMuc2hhcGV9YCk7XG4gIH1cbiAgaWYgKCRzZWdtZW50SWRzLnJhbmsgIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNlZ21lbnQgaWRzIHNob3VsZCBiZSBUZW5zb3IxRCBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgICR7JHNlZ21lbnRJZHMuc2hhcGV9YCk7XG4gIH1cblxuICBjb25zdCBpbnB1dHM6IFNwYXJzZVNlZ21lbnRTdW1JbnB1dHMgPSB7XG4gICAgZGF0YTogJGRhdGEsXG4gICAgaW5kaWNlczogJGluZGljZXMsXG4gICAgc2VnbWVudElkczogJHNlZ21lbnRJZHNcbiAgfTtcblxuICByZXR1cm4gRU5HSU5FLnJ1bktlcm5lbChTcGFyc2VTZWdtZW50U3VtLCBpbnB1dHMgYXMge30pO1xufVxuXG5leHBvcnQgY29uc3Qgc3BhcnNlU2VnbWVudFN1bSA9IC8qIEBfX1BVUkVfXyAqLyBvcCh7c3BhcnNlU2VnbWVudFN1bV99KTtcbiJdfQ==","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Generates sparse segment reduction negative segment ids error message.\n *\n */\nexport function getSparseSegmentReductionNegativeSegmentIdsErrorMessage() {\n    return `segment ids must be >= 0`;\n}\n/**\n * Generates sparse segment reduction non increasing segment ids error message.\n *\n */\nexport function getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage() {\n    return `segment ids are not increasing`;\n}\n/**\n * Generates sparse segment reduction segment id out of range error message.\n *\n * @param segmentId The segment id index that is out of range.\n * @param outputRows Upper bound of valid segment id values.\n */\nexport function getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(segmentId, outputRows) {\n    return `Segment id ${segmentId} out of range [0, ${outputRows}), possibly because segmentIds input is not sorted.`;\n}\n/**\n * Generates sparse segment reduction input indice out of range error message.\n *\n * @param index The index that holds the out of range value.\n * @param indexValue The value that is out of range.\n * @param inputRows Upper bound of valid index values.\n */\nexport function getSparseSegmentReductionIndicesOutOfRangeErrorMessage(index, indexValue, inputRows) {\n    return `Bad: indices[${index}] == ${indexValue} out of range [0, ${inputRows})`;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BhcnNlX3NlZ21lbnRfcmVkdWN0aW9uX3V0aWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9zcGFyc2Uvc3BhcnNlX3NlZ21lbnRfcmVkdWN0aW9uX3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUg7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLHVEQUF1RDtJQUNyRSxPQUFPLDBCQUEwQixDQUFDO0FBQ3BDLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsNERBQTREO0lBQzFFLE9BQU8sZ0NBQWdDLENBQUM7QUFDMUMsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLHdEQUF3RCxDQUNwRSxTQUFpQixFQUFFLFVBQWtCO0lBQ3ZDLE9BQU8sY0FBYyxTQUFTLHFCQUMxQixVQUFVLHFEQUFxRCxDQUFDO0FBQ3RFLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsc0RBQXNELENBQ2xFLEtBQWEsRUFBRSxVQUFrQixFQUFFLFNBQWlCO0lBQ3RELE9BQU8sZ0JBQWdCLEtBQUssUUFBUSxVQUFVLHFCQUMxQyxTQUFTLEdBQUcsQ0FBQztBQUNuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIEdlbmVyYXRlcyBzcGFyc2Ugc2VnbWVudCByZWR1Y3Rpb24gbmVnYXRpdmUgc2VnbWVudCBpZHMgZXJyb3IgbWVzc2FnZS5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uTmVnYXRpdmVTZWdtZW50SWRzRXJyb3JNZXNzYWdlKCkge1xuICByZXR1cm4gYHNlZ21lbnQgaWRzIG11c3QgYmUgPj0gMGA7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHNwYXJzZSBzZWdtZW50IHJlZHVjdGlvbiBub24gaW5jcmVhc2luZyBzZWdtZW50IGlkcyBlcnJvciBtZXNzYWdlLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNwYXJzZVNlZ21lbnRSZWR1Y3Rpb25Ob25JbmNyZWFzaW5nU2VnbWVudElkc0Vycm9yTWVzc2FnZSgpIHtcbiAgcmV0dXJuIGBzZWdtZW50IGlkcyBhcmUgbm90IGluY3JlYXNpbmdgO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBzcGFyc2Ugc2VnbWVudCByZWR1Y3Rpb24gc2VnbWVudCBpZCBvdXQgb2YgcmFuZ2UgZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gc2VnbWVudElkIFRoZSBzZWdtZW50IGlkIGluZGV4IHRoYXQgaXMgb3V0IG9mIHJhbmdlLlxuICogQHBhcmFtIG91dHB1dFJvd3MgVXBwZXIgYm91bmQgb2YgdmFsaWQgc2VnbWVudCBpZCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uU2VnbWVudElkT3V0T2ZSYW5nZUVycm9yTWVzc2FnZShcbiAgICBzZWdtZW50SWQ6IG51bWJlciwgb3V0cHV0Um93czogbnVtYmVyKSB7XG4gIHJldHVybiBgU2VnbWVudCBpZCAke3NlZ21lbnRJZH0gb3V0IG9mIHJhbmdlIFswLCAke1xuICAgICAgb3V0cHV0Um93c30pLCBwb3NzaWJseSBiZWNhdXNlIHNlZ21lbnRJZHMgaW5wdXQgaXMgbm90IHNvcnRlZC5gO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBzcGFyc2Ugc2VnbWVudCByZWR1Y3Rpb24gaW5wdXQgaW5kaWNlIG91dCBvZiByYW5nZSBlcnJvciBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggdGhhdCBob2xkcyB0aGUgb3V0IG9mIHJhbmdlIHZhbHVlLlxuICogQHBhcmFtIGluZGV4VmFsdWUgVGhlIHZhbHVlIHRoYXQgaXMgb3V0IG9mIHJhbmdlLlxuICogQHBhcmFtIGlucHV0Um93cyBVcHBlciBib3VuZCBvZiB2YWxpZCBpbmRleCB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTcGFyc2VTZWdtZW50UmVkdWN0aW9uSW5kaWNlc091dE9mUmFuZ2VFcnJvck1lc3NhZ2UoXG4gICAgaW5kZXg6IG51bWJlciwgaW5kZXhWYWx1ZTogbnVtYmVyLCBpbnB1dFJvd3M6IG51bWJlcikge1xuICByZXR1cm4gYEJhZDogaW5kaWNlc1ske2luZGV4fV0gPT0gJHtpbmRleFZhbHVlfSBvdXQgb2YgcmFuZ2UgWzAsICR7XG4gICAgICBpbnB1dFJvd3N9KWA7XG59XG4iXX0=","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { SparseFillEmptyRows } from '../../kernel_names';\nimport { convertToTensor } from '../../tensor_util_env';\nimport { op } from '../operation';\n/**\n * The input SparseTensor is represented via the map of inputs {`indices`,\n * `values`, `denseShape`}. The output SparseTensor has the same `denseShape`\n * but with indices `outputIndices` and values `outputValues`. This op inserts a\n * single entry for every row that doesn't have any values. The index is created\n * as `[row, 0, ..., 0]` and the inserted value is `defaultValue`.\n *\n * For example, suppose `spInput` has shape [5, 6] and non-empty values:\n * [0, 1]: a\n * [0, 3]: b\n * [2, 0]: c\n * [3, 1]: d\n *\n * Rows 1 and 4 are empty, so the output will be of shape [5, 6] with values:\n * [0, 1]: a\n * [0, 3]: b\n * [1, 0]: `defaultValue`\n * [2, 0]: c\n * [3, 1]: d\n * [4, 0]: `defaultValue`\n *\n * The output SparseTensor will be in row-major order and will have the same\n * shape as the input.\n *\n * This op also returns an indicator vector shaped [dense_shape[0]] such that\n * emptyRowIndicator[i] = True iff row i was an empty row.\n *\n * And a reverse index map vector shaped [indices.shape[0]] that is used during\n * backpropagation, reverseIndexMap[i] = outi s.t. indices[i, j] ==\n * outputIndices[outi, j] for all j\n *\n * ```js\n * const result = tf.sparse.sparseFillEmptyRows(\n *   [[0, 0], [1, 0], [1, 3], [1, 4], [3, 2], [3, 3]],\n *   [0, 10, 13, 14, 32, 33], [5, 6], -1);\n * console.log(result);\n * result['outputIndices'].print(); // [[0, 0], [1, 0], [1, 3], [1, 4],\n *                                  //  [2, 0], [3, 2], [3, 3], [4, 0]]\n * result['outputValues'].print(); // [0, 10, 13, 14,-1, 32, 33, -1]\n * result['emptyRowIndicator'].print(); // [false, false, true, false, true]\n * result['reverseIndexMap'].print(); // [0, 1, 2, 3, 5, 6]\n * ```\n * @param indices: 2-D. The indices of the sparse tensor.\n * @param values: 1-D. The values of the sparse tensor.\n * @param denseShape: 1-D. The shape of the sparse tensor.\n * @param defaultValue: 0-D. Default value to insert into location [row, 0, ...,\n *     0] for rows missing from the input sparse tensor.\n * @return A map with the following properties:\n *     - outputIndices\n *     - outputValues: 1-D. The values of the filled sparse tensor.\n *     - emptyRowIndicator: 1-D. Whether the dense row was missing in the input\n * sparse tensor.\n *     - reverseIndexMap: 1-D. A map from the input indices to the output\n * indices.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseFillEmptyRows_(indices, values, denseShape, defaultValue) {\n    const $indices = convertToTensor(indices, 'indices', 'sparseFillEmptyRows', 'int32');\n    const $values = convertToTensor(values, 'values', 'sparseFillEmptyRows');\n    const $denseShape = convertToTensor(denseShape, 'denseShape', 'sparseFillEmptyRows', 'int32');\n    const $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'sparseFillEmptyRows', $values.dtype);\n    if ($indices.rank !== 2) {\n        throw new Error(`Indices should be Tensor2D but received shape\n        ${$indices.shape}`);\n    }\n    if ($values.rank !== 1) {\n        throw new Error(`Values should be Tensor1D but received shape ${$values.shape}`);\n    }\n    if ($denseShape.rank !== 1) {\n        throw new Error(`Dense shape should be Tensor1D but received shape ${$denseShape.shape}`);\n    }\n    if ($defaultValue.rank !== 0) {\n        throw new Error(`Default value should be a scalar but received shape ${$defaultValue.shape}`);\n    }\n    const inputs = {\n        indices: $indices,\n        values: $values,\n        denseShape: $denseShape,\n        defaultValue: $defaultValue\n    };\n    const result = ENGINE.runKernel(SparseFillEmptyRows, inputs);\n    return {\n        outputIndices: result[0],\n        outputValues: result[1],\n        emptyRowIndicator: result[2],\n        reverseIndexMap: result[3]\n    };\n}\nexport const sparseFillEmptyRows = /* @__PURE__ */ op({ sparseFillEmptyRows_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BhcnNlX2ZpbGxfZW1wdHlfcm93cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL3NwYXJzZS9zcGFyc2VfZmlsbF9lbXB0eV9yb3dzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFDcEMsT0FBTyxFQUFDLG1CQUFtQixFQUE0QixNQUFNLG9CQUFvQixDQUFDO0FBR2xGLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUV0RCxPQUFPLEVBQUMsRUFBRSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBRWhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdURHO0FBQ0gsU0FBUyxvQkFBb0IsQ0FDekIsT0FBNEIsRUFBRSxNQUEyQixFQUN6RCxVQUErQixFQUMvQixZQUErQjtJQUNqQyxNQUFNLFFBQVEsR0FDVixlQUFlLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxxQkFBcUIsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN4RSxNQUFNLE9BQU8sR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO0lBQ3pFLE1BQU0sV0FBVyxHQUNiLGVBQWUsQ0FBQyxVQUFVLEVBQUUsWUFBWSxFQUFFLHFCQUFxQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzlFLE1BQU0sYUFBYSxHQUFHLGVBQWUsQ0FDakMsWUFBWSxFQUFFLGNBQWMsRUFBRSxxQkFBcUIsRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFeEUsSUFBSSxRQUFRLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtRQUN2QixNQUFNLElBQUksS0FBSyxDQUFDO1VBQ1YsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7S0FDekI7SUFDRCxJQUFJLE9BQU8sQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ3RCLE1BQU0sSUFBSSxLQUFLLENBQ1gsZ0RBQWdELE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0tBQ3RFO0lBQ0QsSUFBSSxXQUFXLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtRQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLHFEQUNaLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0tBQzFCO0lBQ0QsSUFBSSxhQUFhLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtRQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLHVEQUNaLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO0tBQzVCO0lBRUQsTUFBTSxNQUFNLEdBQThCO1FBQ3hDLE9BQU8sRUFBRSxRQUFRO1FBQ2pCLE1BQU0sRUFBRSxPQUFPO1FBQ2YsVUFBVSxFQUFFLFdBQVc7UUFDdkIsWUFBWSxFQUFFLGFBQWE7S0FDNUIsQ0FBQztJQUVGLE1BQU0sTUFBTSxHQUFhLE1BQU0sQ0FBQyxTQUFTLENBQUMsbUJBQW1CLEVBQUUsTUFBWSxDQUFDLENBQUM7SUFDN0UsT0FBTztRQUNMLGFBQWEsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3hCLFlBQVksRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLGlCQUFpQixFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDNUIsZUFBZSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7S0FDM0IsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxtQkFBbUIsR0FBRyxlQUFlLENBQUMsRUFBRSxDQUFDLEVBQUMsb0JBQW9CLEVBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0VOR0lORX0gZnJvbSAnLi4vLi4vZW5naW5lJztcbmltcG9ydCB7U3BhcnNlRmlsbEVtcHR5Um93cywgU3BhcnNlRmlsbEVtcHR5Um93c0lucHV0c30gZnJvbSAnLi4vLi4va2VybmVsX25hbWVzJztcbmltcG9ydCB7U2NhbGFyLCBUZW5zb3IsIFRlbnNvcjFELCBUZW5zb3IyRH0gZnJvbSAnLi4vLi4vdGVuc29yJztcbmltcG9ydCB7TmFtZWRUZW5zb3JNYXB9IGZyb20gJy4uLy4uL3RlbnNvcl90eXBlcyc7XG5pbXBvcnQge2NvbnZlcnRUb1RlbnNvcn0gZnJvbSAnLi4vLi4vdGVuc29yX3V0aWxfZW52JztcbmltcG9ydCB7U2NhbGFyTGlrZSwgVGVuc29yTGlrZX0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHtvcH0gZnJvbSAnLi4vb3BlcmF0aW9uJztcblxuLyoqXG4gKiBUaGUgaW5wdXQgU3BhcnNlVGVuc29yIGlzIHJlcHJlc2VudGVkIHZpYSB0aGUgbWFwIG9mIGlucHV0cyB7YGluZGljZXNgLFxuICogYHZhbHVlc2AsIGBkZW5zZVNoYXBlYH0uIFRoZSBvdXRwdXQgU3BhcnNlVGVuc29yIGhhcyB0aGUgc2FtZSBgZGVuc2VTaGFwZWBcbiAqIGJ1dCB3aXRoIGluZGljZXMgYG91dHB1dEluZGljZXNgIGFuZCB2YWx1ZXMgYG91dHB1dFZhbHVlc2AuIFRoaXMgb3AgaW5zZXJ0cyBhXG4gKiBzaW5nbGUgZW50cnkgZm9yIGV2ZXJ5IHJvdyB0aGF0IGRvZXNuJ3QgaGF2ZSBhbnkgdmFsdWVzLiBUaGUgaW5kZXggaXMgY3JlYXRlZFxuICogYXMgYFtyb3csIDAsIC4uLiwgMF1gIGFuZCB0aGUgaW5zZXJ0ZWQgdmFsdWUgaXMgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogRm9yIGV4YW1wbGUsIHN1cHBvc2UgYHNwSW5wdXRgIGhhcyBzaGFwZSBbNSwgNl0gYW5kIG5vbi1lbXB0eSB2YWx1ZXM6XG4gKiBbMCwgMV06IGFcbiAqIFswLCAzXTogYlxuICogWzIsIDBdOiBjXG4gKiBbMywgMV06IGRcbiAqXG4gKiBSb3dzIDEgYW5kIDQgYXJlIGVtcHR5LCBzbyB0aGUgb3V0cHV0IHdpbGwgYmUgb2Ygc2hhcGUgWzUsIDZdIHdpdGggdmFsdWVzOlxuICogWzAsIDFdOiBhXG4gKiBbMCwgM106IGJcbiAqIFsxLCAwXTogYGRlZmF1bHRWYWx1ZWBcbiAqIFsyLCAwXTogY1xuICogWzMsIDFdOiBkXG4gKiBbNCwgMF06IGBkZWZhdWx0VmFsdWVgXG4gKlxuICogVGhlIG91dHB1dCBTcGFyc2VUZW5zb3Igd2lsbCBiZSBpbiByb3ctbWFqb3Igb3JkZXIgYW5kIHdpbGwgaGF2ZSB0aGUgc2FtZVxuICogc2hhcGUgYXMgdGhlIGlucHV0LlxuICpcbiAqIFRoaXMgb3AgYWxzbyByZXR1cm5zIGFuIGluZGljYXRvciB2ZWN0b3Igc2hhcGVkIFtkZW5zZV9zaGFwZVswXV0gc3VjaCB0aGF0XG4gKiBlbXB0eVJvd0luZGljYXRvcltpXSA9IFRydWUgaWZmIHJvdyBpIHdhcyBhbiBlbXB0eSByb3cuXG4gKlxuICogQW5kIGEgcmV2ZXJzZSBpbmRleCBtYXAgdmVjdG9yIHNoYXBlZCBbaW5kaWNlcy5zaGFwZVswXV0gdGhhdCBpcyB1c2VkIGR1cmluZ1xuICogYmFja3Byb3BhZ2F0aW9uLCByZXZlcnNlSW5kZXhNYXBbaV0gPSBvdXRpIHMudC4gaW5kaWNlc1tpLCBqXSA9PVxuICogb3V0cHV0SW5kaWNlc1tvdXRpLCBqXSBmb3IgYWxsIGpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcmVzdWx0ID0gdGYuc3BhcnNlLnNwYXJzZUZpbGxFbXB0eVJvd3MoXG4gKiAgIFtbMCwgMF0sIFsxLCAwXSwgWzEsIDNdLCBbMSwgNF0sIFszLCAyXSwgWzMsIDNdXSxcbiAqICAgWzAsIDEwLCAxMywgMTQsIDMyLCAzM10sIFs1LCA2XSwgLTEpO1xuICogY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIHJlc3VsdFsnb3V0cHV0SW5kaWNlcyddLnByaW50KCk7IC8vIFtbMCwgMF0sIFsxLCAwXSwgWzEsIDNdLCBbMSwgNF0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgWzIsIDBdLCBbMywgMl0sIFszLCAzXSwgWzQsIDBdXVxuICogcmVzdWx0WydvdXRwdXRWYWx1ZXMnXS5wcmludCgpOyAvLyBbMCwgMTAsIDEzLCAxNCwtMSwgMzIsIDMzLCAtMV1cbiAqIHJlc3VsdFsnZW1wdHlSb3dJbmRpY2F0b3InXS5wcmludCgpOyAvLyBbZmFsc2UsIGZhbHNlLCB0cnVlLCBmYWxzZSwgdHJ1ZV1cbiAqIHJlc3VsdFsncmV2ZXJzZUluZGV4TWFwJ10ucHJpbnQoKTsgLy8gWzAsIDEsIDIsIDMsIDUsIDZdXG4gKiBgYGBcbiAqIEBwYXJhbSBpbmRpY2VzOiAyLUQuIFRoZSBpbmRpY2VzIG9mIHRoZSBzcGFyc2UgdGVuc29yLlxuICogQHBhcmFtIHZhbHVlczogMS1ELiBUaGUgdmFsdWVzIG9mIHRoZSBzcGFyc2UgdGVuc29yLlxuICogQHBhcmFtIGRlbnNlU2hhcGU6IDEtRC4gVGhlIHNoYXBlIG9mIHRoZSBzcGFyc2UgdGVuc29yLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZTogMC1ELiBEZWZhdWx0IHZhbHVlIHRvIGluc2VydCBpbnRvIGxvY2F0aW9uIFtyb3csIDAsIC4uLixcbiAqICAgICAwXSBmb3Igcm93cyBtaXNzaW5nIGZyb20gdGhlIGlucHV0IHNwYXJzZSB0ZW5zb3IuXG4gKiBAcmV0dXJuIEEgbWFwIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogICAgIC0gb3V0cHV0SW5kaWNlc1xuICogICAgIC0gb3V0cHV0VmFsdWVzOiAxLUQuIFRoZSB2YWx1ZXMgb2YgdGhlIGZpbGxlZCBzcGFyc2UgdGVuc29yLlxuICogICAgIC0gZW1wdHlSb3dJbmRpY2F0b3I6IDEtRC4gV2hldGhlciB0aGUgZGVuc2Ugcm93IHdhcyBtaXNzaW5nIGluIHRoZSBpbnB1dFxuICogc3BhcnNlIHRlbnNvci5cbiAqICAgICAtIHJldmVyc2VJbmRleE1hcDogMS1ELiBBIG1hcCBmcm9tIHRoZSBpbnB1dCBpbmRpY2VzIHRvIHRoZSBvdXRwdXRcbiAqIGluZGljZXMuXG4gKiBAZG9jIHtoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdTcGFyc2UnfVxuICovXG5mdW5jdGlvbiBzcGFyc2VGaWxsRW1wdHlSb3dzXyhcbiAgICBpbmRpY2VzOiBUZW5zb3IyRHxUZW5zb3JMaWtlLCB2YWx1ZXM6IFRlbnNvcjFEfFRlbnNvckxpa2UsXG4gICAgZGVuc2VTaGFwZTogVGVuc29yMUR8VGVuc29yTGlrZSxcbiAgICBkZWZhdWx0VmFsdWU6IFNjYWxhcnxTY2FsYXJMaWtlKTogTmFtZWRUZW5zb3JNYXAge1xuICBjb25zdCAkaW5kaWNlcyA9XG4gICAgICBjb252ZXJ0VG9UZW5zb3IoaW5kaWNlcywgJ2luZGljZXMnLCAnc3BhcnNlRmlsbEVtcHR5Um93cycsICdpbnQzMicpO1xuICBjb25zdCAkdmFsdWVzID0gY29udmVydFRvVGVuc29yKHZhbHVlcywgJ3ZhbHVlcycsICdzcGFyc2VGaWxsRW1wdHlSb3dzJyk7XG4gIGNvbnN0ICRkZW5zZVNoYXBlID1cbiAgICAgIGNvbnZlcnRUb1RlbnNvcihkZW5zZVNoYXBlLCAnZGVuc2VTaGFwZScsICdzcGFyc2VGaWxsRW1wdHlSb3dzJywgJ2ludDMyJyk7XG4gIGNvbnN0ICRkZWZhdWx0VmFsdWUgPSBjb252ZXJ0VG9UZW5zb3IoXG4gICAgICBkZWZhdWx0VmFsdWUsICdkZWZhdWx0VmFsdWUnLCAnc3BhcnNlRmlsbEVtcHR5Um93cycsICR2YWx1ZXMuZHR5cGUpO1xuXG4gIGlmICgkaW5kaWNlcy5yYW5rICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbmRpY2VzIHNob3VsZCBiZSBUZW5zb3IyRCBidXQgcmVjZWl2ZWQgc2hhcGVcbiAgICAgICAgJHskaW5kaWNlcy5zaGFwZX1gKTtcbiAgfVxuICBpZiAoJHZhbHVlcy5yYW5rICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVmFsdWVzIHNob3VsZCBiZSBUZW5zb3IxRCBidXQgcmVjZWl2ZWQgc2hhcGUgJHskdmFsdWVzLnNoYXBlfWApO1xuICB9XG4gIGlmICgkZGVuc2VTaGFwZS5yYW5rICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBEZW5zZSBzaGFwZSBzaG91bGQgYmUgVGVuc29yMUQgYnV0IHJlY2VpdmVkIHNoYXBlICR7XG4gICAgICAgICRkZW5zZVNoYXBlLnNoYXBlfWApO1xuICB9XG4gIGlmICgkZGVmYXVsdFZhbHVlLnJhbmsgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYERlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIGEgc2NhbGFyIGJ1dCByZWNlaXZlZCBzaGFwZSAke1xuICAgICAgICAkZGVmYXVsdFZhbHVlLnNoYXBlfWApO1xuICB9XG5cbiAgY29uc3QgaW5wdXRzOiBTcGFyc2VGaWxsRW1wdHlSb3dzSW5wdXRzID0ge1xuICAgIGluZGljZXM6ICRpbmRpY2VzLFxuICAgIHZhbHVlczogJHZhbHVlcyxcbiAgICBkZW5zZVNoYXBlOiAkZGVuc2VTaGFwZSxcbiAgICBkZWZhdWx0VmFsdWU6ICRkZWZhdWx0VmFsdWVcbiAgfTtcblxuICBjb25zdCByZXN1bHQ6IFRlbnNvcltdID0gRU5HSU5FLnJ1bktlcm5lbChTcGFyc2VGaWxsRW1wdHlSb3dzLCBpbnB1dHMgYXMge30pO1xuICByZXR1cm4ge1xuICAgIG91dHB1dEluZGljZXM6IHJlc3VsdFswXSxcbiAgICBvdXRwdXRWYWx1ZXM6IHJlc3VsdFsxXSxcbiAgICBlbXB0eVJvd0luZGljYXRvcjogcmVzdWx0WzJdLFxuICAgIHJldmVyc2VJbmRleE1hcDogcmVzdWx0WzNdXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBzcGFyc2VGaWxsRW1wdHlSb3dzID0gLyogQF9fUFVSRV9fICovIG9wKHtzcGFyc2VGaWxsRW1wdHlSb3dzX30pO1xuIl19","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Generates sparse fill empty rows indices, dense shape mismatch error message.\n *\n * @param indicesLength The first dimension of indices.\n */\nexport function getSparseFillEmptyRowsIndicesDenseShapeMismatch(indicesLength) {\n    return `Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${indicesLength}`;\n}\n/**\n * Generates sparse fill empty rows negative index error message.\n *\n * @param index The index with a negative value.\n * @param value The negative value.\n */\nexport function getSparseFillEmptyRowsNegativeIndexErrorMessage(index, value) {\n    return `indices(${index}, 0) is invalid: ${value} < 0`;\n}\n/**\n * Generates sparse fill empty rows out of range index error message.\n *\n * @param index The index with an out of range value.\n * @param value The out of range value.\n * @param limit The upper limit for indices.\n */\nexport function getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(index, value, limit) {\n    return `indices(${index}, 0) is invalid: ${value} >= ${limit}`;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BhcnNlX2ZpbGxfZW1wdHlfcm93c191dGlsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc3BhcnNlL3NwYXJzZV9maWxsX2VtcHR5X3Jvd3NfdXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLCtDQUErQyxDQUMzRCxhQUFxQjtJQUN2QixPQUFPO3VCQUNjLGFBQWEsRUFBRSxDQUFDO0FBQ3ZDLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSwrQ0FBK0MsQ0FDM0QsS0FBYSxFQUFFLEtBQWE7SUFDOUIsT0FBTyxXQUFXLEtBQUssb0JBQW9CLEtBQUssTUFBTSxDQUFDO0FBQ3pELENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsaURBQWlELENBQzdELEtBQWEsRUFBRSxLQUFhLEVBQUUsS0FBYTtJQUM3QyxPQUFPLFdBQVcsS0FBSyxvQkFBb0IsS0FBSyxPQUFPLEtBQUssRUFBRSxDQUFDO0FBQ2pFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogR2VuZXJhdGVzIHNwYXJzZSBmaWxsIGVtcHR5IHJvd3MgaW5kaWNlcywgZGVuc2Ugc2hhcGUgbWlzbWF0Y2ggZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gaW5kaWNlc0xlbmd0aCBUaGUgZmlyc3QgZGltZW5zaW9uIG9mIGluZGljZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTcGFyc2VGaWxsRW1wdHlSb3dzSW5kaWNlc0RlbnNlU2hhcGVNaXNtYXRjaChcbiAgICBpbmRpY2VzTGVuZ3RoOiBudW1iZXIpIHtcbiAgcmV0dXJuIGBSZWNlaXZlZCBTcGFyc2VUZW5zb3Igd2l0aCBkZW5zZVNoYXBlWzBdID0gMCBidXRcbiAgaW5kaWNlcy5zaGFwZVswXSA9ICR7aW5kaWNlc0xlbmd0aH1gO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBzcGFyc2UgZmlsbCBlbXB0eSByb3dzIG5lZ2F0aXZlIGluZGV4IGVycm9yIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCB3aXRoIGEgbmVnYXRpdmUgdmFsdWUuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIG5lZ2F0aXZlIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3BhcnNlRmlsbEVtcHR5Um93c05lZ2F0aXZlSW5kZXhFcnJvck1lc3NhZ2UoXG4gICAgaW5kZXg6IG51bWJlciwgdmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gYGluZGljZXMoJHtpbmRleH0sIDApIGlzIGludmFsaWQ6ICR7dmFsdWV9IDwgMGA7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHNwYXJzZSBmaWxsIGVtcHR5IHJvd3Mgb3V0IG9mIHJhbmdlIGluZGV4IGVycm9yIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCB3aXRoIGFuIG91dCBvZiByYW5nZSB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgb3V0IG9mIHJhbmdlIHZhbHVlLlxuICogQHBhcmFtIGxpbWl0IFRoZSB1cHBlciBsaW1pdCBmb3IgaW5kaWNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNwYXJzZUZpbGxFbXB0eVJvd3NPdXRPZlJhbmdlSW5kZXhFcnJvck1lc3NhZ2UoXG4gICAgaW5kZXg6IG51bWJlciwgdmFsdWU6IG51bWJlciwgbGltaXQ6IG51bWJlcikge1xuICByZXR1cm4gYGluZGljZXMoJHtpbmRleH0sIDApIGlzIGludmFsaWQ6ICR7dmFsdWV9ID49ICR7bGltaXR9YDtcbn1cbiJdfQ==","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { sizeFromShape } from '../../util';\n/**\n * Generates sparse reshape multiple negative 1 output dimension error message.\n *\n * @param dim1 The first dimension with a negative 1 value.\n * @param dim2 The second dimension with a negative 1 value.\n */\nexport function getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(dim1, dim2) {\n    return `only one output dimension may be -1, not both ${dim1} and ${dim2}`;\n}\n/**\n * Generates sparse reshape negative output dimension error message.\n *\n * @param dim The dimension with a negative value.\n * @param value The negative value.\n */\nexport function getSparseReshapeNegativeOutputDimErrorMessage(dim, value) {\n    return `size ${dim} must be non-negative, not ${value}`;\n}\n/**\n * Generates sparse reshape empty tensor zero output dimension error message.\n *\n */\nexport function getSparseReshapeEmptyTensorZeroOutputDimErrorMessage() {\n    return 'reshape cannot infer the missing input size for an empty tensor ' +\n        'unless all specified input sizes are non-zero';\n}\n/**\n * Generates sparse reshape input output multiple mismatch error message.\n *\n * @param inputShape the input shape.\n * @param outputShape the requested output shape.\n */\nexport function getSparseReshapeInputOutputMultipleErrorMessage(inputShape, outputShape) {\n    const inputSize = sizeFromShape(inputShape);\n    const outputSize = sizeFromShape(outputShape);\n    return `Input to reshape is a SparseTensor with ${inputSize}\n  dense values, but the requested shape requires a multiple of ${outputSize}. inputShape=${inputShape} outputShape= ${outputShape}`;\n}\n/**\n * Generates sparse reshape input output inequality error message.\n *\n * @param inputShape the input shape.\n * @param outputShape the requested output shape.\n */\nexport function getSparseReshapeInputOutputMismatchErrorMessage(inputShape, outputShape) {\n    const inputSize = sizeFromShape(inputShape);\n    const outputSize = sizeFromShape(outputShape);\n    return `Input to reshape is a tensor with ${inputSize} dense values, but the requested shape has ${outputSize}. inputShape=${inputShape} outputShape=${outputShape}`;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BhcnNlX3Jlc2hhcGVfdXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL3NwYXJzZS9zcGFyc2VfcmVzaGFwZV91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFFekM7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsd0RBQXdELENBQ3BFLElBQVksRUFBRSxJQUFZO0lBQzVCLE9BQU8saURBQWlELElBQUksUUFBUSxJQUFJLEVBQUUsQ0FBQztBQUM3RSxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsNkNBQTZDLENBQ3pELEdBQVcsRUFBRSxLQUFhO0lBQzVCLE9BQU8sUUFBUSxHQUFHLDhCQUE4QixLQUFLLEVBQUUsQ0FBQztBQUMxRCxDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLG9EQUFvRDtJQUNsRSxPQUFPLGtFQUFrRTtRQUNyRSwrQ0FBK0MsQ0FBQztBQUN0RCxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsK0NBQStDLENBQzNELFVBQW9CLEVBQUUsV0FBcUI7SUFDN0MsTUFBTSxTQUFTLEdBQUcsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzVDLE1BQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUM5QyxPQUFPLDJDQUEyQyxTQUFTO2lFQUV2RCxVQUFVLGdCQUFnQixVQUFVLGlCQUFpQixXQUFXLEVBQUUsQ0FBQztBQUN6RSxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsK0NBQStDLENBQzNELFVBQW9CLEVBQUUsV0FBcUI7SUFDN0MsTUFBTSxTQUFTLEdBQUcsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzVDLE1BQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUM5QyxPQUFPLHFDQUNILFNBQVMsOENBQ1QsVUFBVSxnQkFBZ0IsVUFBVSxnQkFBZ0IsV0FBVyxFQUFFLENBQUM7QUFDeEUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmltcG9ydCB7c2l6ZUZyb21TaGFwZX0gZnJvbSAnLi4vLi4vdXRpbCc7XG5cbi8qKlxuICogR2VuZXJhdGVzIHNwYXJzZSByZXNoYXBlIG11bHRpcGxlIG5lZ2F0aXZlIDEgb3V0cHV0IGRpbWVuc2lvbiBlcnJvciBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBkaW0xIFRoZSBmaXJzdCBkaW1lbnNpb24gd2l0aCBhIG5lZ2F0aXZlIDEgdmFsdWUuXG4gKiBAcGFyYW0gZGltMiBUaGUgc2Vjb25kIGRpbWVuc2lvbiB3aXRoIGEgbmVnYXRpdmUgMSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNwYXJzZVJlc2hhcGVNdWx0aXBsZU5lZ2F0aXZlT25lT3V0cHV0RGltRXJyb3JNZXNzYWdlKFxuICAgIGRpbTE6IG51bWJlciwgZGltMjogbnVtYmVyKSB7XG4gIHJldHVybiBgb25seSBvbmUgb3V0cHV0IGRpbWVuc2lvbiBtYXkgYmUgLTEsIG5vdCBib3RoICR7ZGltMX0gYW5kICR7ZGltMn1gO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBzcGFyc2UgcmVzaGFwZSBuZWdhdGl2ZSBvdXRwdXQgZGltZW5zaW9uIGVycm9yIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGRpbSBUaGUgZGltZW5zaW9uIHdpdGggYSBuZWdhdGl2ZSB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZSBUaGUgbmVnYXRpdmUgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTcGFyc2VSZXNoYXBlTmVnYXRpdmVPdXRwdXREaW1FcnJvck1lc3NhZ2UoXG4gICAgZGltOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcbiAgcmV0dXJuIGBzaXplICR7ZGltfSBtdXN0IGJlIG5vbi1uZWdhdGl2ZSwgbm90ICR7dmFsdWV9YDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgc3BhcnNlIHJlc2hhcGUgZW1wdHkgdGVuc29yIHplcm8gb3V0cHV0IGRpbWVuc2lvbiBlcnJvciBtZXNzYWdlLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNwYXJzZVJlc2hhcGVFbXB0eVRlbnNvclplcm9PdXRwdXREaW1FcnJvck1lc3NhZ2UoKSB7XG4gIHJldHVybiAncmVzaGFwZSBjYW5ub3QgaW5mZXIgdGhlIG1pc3NpbmcgaW5wdXQgc2l6ZSBmb3IgYW4gZW1wdHkgdGVuc29yICcgK1xuICAgICAgJ3VubGVzcyBhbGwgc3BlY2lmaWVkIGlucHV0IHNpemVzIGFyZSBub24temVybyc7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHNwYXJzZSByZXNoYXBlIGlucHV0IG91dHB1dCBtdWx0aXBsZSBtaXNtYXRjaCBlcnJvciBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBpbnB1dFNoYXBlIHRoZSBpbnB1dCBzaGFwZS5cbiAqIEBwYXJhbSBvdXRwdXRTaGFwZSB0aGUgcmVxdWVzdGVkIG91dHB1dCBzaGFwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNwYXJzZVJlc2hhcGVJbnB1dE91dHB1dE11bHRpcGxlRXJyb3JNZXNzYWdlKFxuICAgIGlucHV0U2hhcGU6IG51bWJlcltdLCBvdXRwdXRTaGFwZTogbnVtYmVyW10pIHtcbiAgY29uc3QgaW5wdXRTaXplID0gc2l6ZUZyb21TaGFwZShpbnB1dFNoYXBlKTtcbiAgY29uc3Qgb3V0cHV0U2l6ZSA9IHNpemVGcm9tU2hhcGUob3V0cHV0U2hhcGUpO1xuICByZXR1cm4gYElucHV0IHRvIHJlc2hhcGUgaXMgYSBTcGFyc2VUZW5zb3Igd2l0aCAke2lucHV0U2l6ZX1cbiAgZGVuc2UgdmFsdWVzLCBidXQgdGhlIHJlcXVlc3RlZCBzaGFwZSByZXF1aXJlcyBhIG11bHRpcGxlIG9mICR7XG4gICAgICBvdXRwdXRTaXplfS4gaW5wdXRTaGFwZT0ke2lucHV0U2hhcGV9IG91dHB1dFNoYXBlPSAke291dHB1dFNoYXBlfWA7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHNwYXJzZSByZXNoYXBlIGlucHV0IG91dHB1dCBpbmVxdWFsaXR5IGVycm9yIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGlucHV0U2hhcGUgdGhlIGlucHV0IHNoYXBlLlxuICogQHBhcmFtIG91dHB1dFNoYXBlIHRoZSByZXF1ZXN0ZWQgb3V0cHV0IHNoYXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3BhcnNlUmVzaGFwZUlucHV0T3V0cHV0TWlzbWF0Y2hFcnJvck1lc3NhZ2UoXG4gICAgaW5wdXRTaGFwZTogbnVtYmVyW10sIG91dHB1dFNoYXBlOiBudW1iZXJbXSkge1xuICBjb25zdCBpbnB1dFNpemUgPSBzaXplRnJvbVNoYXBlKGlucHV0U2hhcGUpO1xuICBjb25zdCBvdXRwdXRTaXplID0gc2l6ZUZyb21TaGFwZShvdXRwdXRTaGFwZSk7XG4gIHJldHVybiBgSW5wdXQgdG8gcmVzaGFwZSBpcyBhIHRlbnNvciB3aXRoICR7XG4gICAgICBpbnB1dFNpemV9IGRlbnNlIHZhbHVlcywgYnV0IHRoZSByZXF1ZXN0ZWQgc2hhcGUgaGFzICR7XG4gICAgICBvdXRwdXRTaXplfS4gaW5wdXRTaGFwZT0ke2lucHV0U2hhcGV9IG91dHB1dFNoYXBlPSR7b3V0cHV0U2hhcGV9YDtcbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { SparseToDense } from '../kernel_names';\nimport * as sparse_to_dense from '../ops/sparse_to_dense_util';\nimport { convertToTensor } from '../tensor_util_env';\nimport { assertNonNegativeIntegerDimensions } from '../util_base';\nimport { op } from './operation';\n/**\n * Converts a sparse representation into a dense tensor.\n *\n * Builds an array dense with shape outputShape such that:\n *\n * // If sparseIndices is scalar\n * dense[i] = (i == sparseIndices ? sparseValues : defaultValue)\n *\n * // If sparseIndices is a vector, then for each i\n * dense[sparseIndices[i]] = sparseValues[i]\n *\n * // If sparseIndices is an n by d matrix, then for each i in [0, n)\n * dense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i]\n * All other values in dense are set to defaultValue. If sparseValues is a\n * scalar, all sparse indices are set to this single value.\n *\n * If indices are repeated the final value is summed over all values for those\n * indices.\n *\n * ```js\n * const indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');\n * const values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');\n * const shape = [8];\n * tf.sparseToDense(indices, values, shape).print();\n * ```\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape Shape of the dense output tensor. The type is inferred.\n * @param defaultValue Scalar. Value to set for indices not specified in\n * sparseIndices. Defaults to zero.\n *\n * @doc {heading: 'Operations', subheading: 'Normalization'}\n */\nfunction sparseToDense_(sparseIndices, sparseValues, outputShape, defaultValue = 0) {\n    assertNonNegativeIntegerDimensions(outputShape);\n    const $sparseIndices = convertToTensor(sparseIndices, 'sparseIndices', 'sparseToDense', 'int32');\n    const $sparseValues = convertToTensor(sparseValues, 'sparseValues', 'sparseToDense', 'string_or_numeric');\n    const $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'sparseToDense', $sparseValues.dtype);\n    sparse_to_dense.validateInput($sparseIndices, $sparseValues, outputShape, $defaultValue);\n    const inputs = {\n        sparseIndices: $sparseIndices,\n        sparseValues: $sparseValues,\n        defaultValue: $defaultValue\n    };\n    const attrs = { outputShape };\n    return ENGINE.runKernel(SparseToDense, inputs, attrs);\n}\nexport const sparseToDense = /* @__PURE__ */ op({ sparseToDense_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BhcnNlX3RvX2RlbnNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc3BhcnNlX3RvX2RlbnNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDakMsT0FBTyxFQUFDLGFBQWEsRUFBMEMsTUFBTSxpQkFBaUIsQ0FBQztBQUV2RixPQUFPLEtBQUssZUFBZSxNQUFNLDZCQUE2QixDQUFDO0FBRy9ELE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUVuRCxPQUFPLEVBQUMsa0NBQWtDLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFFaEUsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUUvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFDRztBQUNILFNBQVMsY0FBYyxDQUNuQixhQUFnQyxFQUFFLFlBQStCLEVBQ2pFLFdBQXdCLEVBQUUsZUFBa0MsQ0FBQztJQUMvRCxrQ0FBa0MsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUVoRCxNQUFNLGNBQWMsR0FDaEIsZUFBZSxDQUFDLGFBQWEsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzlFLE1BQU0sYUFBYSxHQUFHLGVBQWUsQ0FDakMsWUFBWSxFQUFFLGNBQWMsRUFBRSxlQUFlLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztJQUN4RSxNQUFNLGFBQWEsR0FBRyxlQUFlLENBQ2pDLFlBQVksRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUV4RSxlQUFlLENBQUMsYUFBYSxDQUN6QixjQUFjLEVBQUUsYUFBYSxFQUFFLFdBQVcsRUFBRSxhQUFhLENBQUMsQ0FBQztJQUUvRCxNQUFNLE1BQU0sR0FBd0I7UUFDbEMsYUFBYSxFQUFFLGNBQWM7UUFDN0IsWUFBWSxFQUFFLGFBQWE7UUFDM0IsWUFBWSxFQUFFLGFBQWE7S0FDNUIsQ0FBQztJQUVGLE1BQU0sS0FBSyxHQUF1QixFQUFDLFdBQVcsRUFBQyxDQUFDO0lBRWhELE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FDbkIsYUFBYSxFQUFFLE1BQW1DLEVBQ2xELEtBQWdDLENBQUMsQ0FBQztBQUN4QyxDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0sYUFBYSxHQUFHLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBQyxjQUFjLEVBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0VOR0lORX0gZnJvbSAnLi4vZW5naW5lJztcbmltcG9ydCB7U3BhcnNlVG9EZW5zZSwgU3BhcnNlVG9EZW5zZUF0dHJzLCBTcGFyc2VUb0RlbnNlSW5wdXRzfSBmcm9tICcuLi9rZXJuZWxfbmFtZXMnO1xuaW1wb3J0IHtOYW1lZEF0dHJNYXB9IGZyb20gJy4uL2tlcm5lbF9yZWdpc3RyeSc7XG5pbXBvcnQgKiBhcyBzcGFyc2VfdG9fZGVuc2UgZnJvbSAnLi4vb3BzL3NwYXJzZV90b19kZW5zZV91dGlsJztcbmltcG9ydCB7U2NhbGFyLCBUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5pbXBvcnQge05hbWVkVGVuc29yTWFwfSBmcm9tICcuLi90ZW5zb3JfdHlwZXMnO1xuaW1wb3J0IHtjb252ZXJ0VG9UZW5zb3J9IGZyb20gJy4uL3RlbnNvcl91dGlsX2Vudic7XG5pbXBvcnQge1JhbmssIFNjYWxhckxpa2UsIFNoYXBlTWFwLCBUZW5zb3JMaWtlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge2Fzc2VydE5vbk5lZ2F0aXZlSW50ZWdlckRpbWVuc2lvbnN9IGZyb20gJy4uL3V0aWxfYmFzZSc7XG5cbmltcG9ydCB7b3B9IGZyb20gJy4vb3BlcmF0aW9uJztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHNwYXJzZSByZXByZXNlbnRhdGlvbiBpbnRvIGEgZGVuc2UgdGVuc29yLlxuICpcbiAqIEJ1aWxkcyBhbiBhcnJheSBkZW5zZSB3aXRoIHNoYXBlIG91dHB1dFNoYXBlIHN1Y2ggdGhhdDpcbiAqXG4gKiAvLyBJZiBzcGFyc2VJbmRpY2VzIGlzIHNjYWxhclxuICogZGVuc2VbaV0gPSAoaSA9PSBzcGFyc2VJbmRpY2VzID8gc3BhcnNlVmFsdWVzIDogZGVmYXVsdFZhbHVlKVxuICpcbiAqIC8vIElmIHNwYXJzZUluZGljZXMgaXMgYSB2ZWN0b3IsIHRoZW4gZm9yIGVhY2ggaVxuICogZGVuc2Vbc3BhcnNlSW5kaWNlc1tpXV0gPSBzcGFyc2VWYWx1ZXNbaV1cbiAqXG4gKiAvLyBJZiBzcGFyc2VJbmRpY2VzIGlzIGFuIG4gYnkgZCBtYXRyaXgsIHRoZW4gZm9yIGVhY2ggaSBpbiBbMCwgbilcbiAqIGRlbnNlW3NwYXJzZUluZGljZXNbaV1bMF0sIC4uLiwgc3BhcnNlSW5kaWNlc1tpXVtkLTFdXSA9IHNwYXJzZVZhbHVlc1tpXVxuICogQWxsIG90aGVyIHZhbHVlcyBpbiBkZW5zZSBhcmUgc2V0IHRvIGRlZmF1bHRWYWx1ZS4gSWYgc3BhcnNlVmFsdWVzIGlzIGFcbiAqIHNjYWxhciwgYWxsIHNwYXJzZSBpbmRpY2VzIGFyZSBzZXQgdG8gdGhpcyBzaW5nbGUgdmFsdWUuXG4gKlxuICogSWYgaW5kaWNlcyBhcmUgcmVwZWF0ZWQgdGhlIGZpbmFsIHZhbHVlIGlzIHN1bW1lZCBvdmVyIGFsbCB2YWx1ZXMgZm9yIHRob3NlXG4gKiBpbmRpY2VzLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBpbmRpY2VzID0gdGYudGVuc29yMWQoWzQsIDUsIDYsIDEsIDIsIDNdLCAnaW50MzInKTtcbiAqIGNvbnN0IHZhbHVlcyA9IHRmLnRlbnNvcjFkKFsxMCwgMTEsIDEyLCAxMywgMTQsIDE1XSwgJ2Zsb2F0MzInKTtcbiAqIGNvbnN0IHNoYXBlID0gWzhdO1xuICogdGYuc3BhcnNlVG9EZW5zZShpbmRpY2VzLCB2YWx1ZXMsIHNoYXBlKS5wcmludCgpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNwYXJzZUluZGljZXMgQSAwLUQsIDEtRCwgb3IgMi1EIFRlbnNvciBvZiB0eXBlIGludDMyLlxuICogc3BhcnNlSW5kaWNlc1tpXSBjb250YWlucyB0aGUgY29tcGxldGUgaW5kZXggd2hlcmUgc3BhcnNlVmFsdWVzW2ldIHdpbGwgYmVcbiAqIHBsYWNlZC5cbiAqIEBwYXJhbSBzcGFyc2VWYWx1ZXMgQSAwLUQgb3IgMS1EIFRlbnNvci4gVmFsdWVzXG4gKiBjb3JyZXNwb25kaW5nIHRvIGVhY2ggcm93IG9mIHNwYXJzZUluZGljZXMsIG9yIGEgc2NhbGFyIHZhbHVlIHRvIGJlIHVzZWQgZm9yXG4gKiBhbGwgc3BhcnNlIGluZGljZXMuXG4gKiBAcGFyYW0gb3V0cHV0U2hhcGUgU2hhcGUgb2YgdGhlIGRlbnNlIG91dHB1dCB0ZW5zb3IuIFRoZSB0eXBlIGlzIGluZmVycmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBTY2FsYXIuIFZhbHVlIHRvIHNldCBmb3IgaW5kaWNlcyBub3Qgc3BlY2lmaWVkIGluXG4gKiBzcGFyc2VJbmRpY2VzLiBEZWZhdWx0cyB0byB6ZXJvLlxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ05vcm1hbGl6YXRpb24nfVxuICovXG5mdW5jdGlvbiBzcGFyc2VUb0RlbnNlXzxSIGV4dGVuZHMgUmFuaz4oXG4gICAgc3BhcnNlSW5kaWNlczogVGVuc29yfFRlbnNvckxpa2UsIHNwYXJzZVZhbHVlczogVGVuc29yfFRlbnNvckxpa2UsXG4gICAgb3V0cHV0U2hhcGU6IFNoYXBlTWFwW1JdLCBkZWZhdWx0VmFsdWU6IFNjYWxhcnxTY2FsYXJMaWtlID0gMCk6IFRlbnNvcjxSPiB7XG4gIGFzc2VydE5vbk5lZ2F0aXZlSW50ZWdlckRpbWVuc2lvbnMob3V0cHV0U2hhcGUpO1xuXG4gIGNvbnN0ICRzcGFyc2VJbmRpY2VzID1cbiAgICAgIGNvbnZlcnRUb1RlbnNvcihzcGFyc2VJbmRpY2VzLCAnc3BhcnNlSW5kaWNlcycsICdzcGFyc2VUb0RlbnNlJywgJ2ludDMyJyk7XG4gIGNvbnN0ICRzcGFyc2VWYWx1ZXMgPSBjb252ZXJ0VG9UZW5zb3IoXG4gICAgICBzcGFyc2VWYWx1ZXMsICdzcGFyc2VWYWx1ZXMnLCAnc3BhcnNlVG9EZW5zZScsICdzdHJpbmdfb3JfbnVtZXJpYycpO1xuICBjb25zdCAkZGVmYXVsdFZhbHVlID0gY29udmVydFRvVGVuc29yKFxuICAgICAgZGVmYXVsdFZhbHVlLCAnZGVmYXVsdFZhbHVlJywgJ3NwYXJzZVRvRGVuc2UnLCAkc3BhcnNlVmFsdWVzLmR0eXBlKTtcblxuICBzcGFyc2VfdG9fZGVuc2UudmFsaWRhdGVJbnB1dChcbiAgICAgICRzcGFyc2VJbmRpY2VzLCAkc3BhcnNlVmFsdWVzLCBvdXRwdXRTaGFwZSwgJGRlZmF1bHRWYWx1ZSk7XG5cbiAgY29uc3QgaW5wdXRzOiBTcGFyc2VUb0RlbnNlSW5wdXRzID0ge1xuICAgIHNwYXJzZUluZGljZXM6ICRzcGFyc2VJbmRpY2VzLFxuICAgIHNwYXJzZVZhbHVlczogJHNwYXJzZVZhbHVlcyxcbiAgICBkZWZhdWx0VmFsdWU6ICRkZWZhdWx0VmFsdWVcbiAgfTtcblxuICBjb25zdCBhdHRyczogU3BhcnNlVG9EZW5zZUF0dHJzID0ge291dHB1dFNoYXBlfTtcblxuICByZXR1cm4gRU5HSU5FLnJ1bktlcm5lbChcbiAgICAgIFNwYXJzZVRvRGVuc2UsIGlucHV0cyBhcyB1bmtub3duIGFzIE5hbWVkVGVuc29yTWFwLFxuICAgICAgYXR0cnMgYXMgdW5rbm93biBhcyBOYW1lZEF0dHJNYXApO1xufVxuXG5leHBvcnQgY29uc3Qgc3BhcnNlVG9EZW5zZSA9IC8qIEBfX1BVUkVfXyAqLyBvcCh7c3BhcnNlVG9EZW5zZV99KTtcbiJdfQ==","/**\n * Validate sparseToDense inputs.\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape number[]. Shape of the dense output tensor.\n * @param validateIndices boolean. indice validation is not supported, error\n * will be thrown if it is set.\n */\nexport function validateInput(sparseIndices, sparseValues, outputShape, defaultValues) {\n    if (sparseIndices.dtype !== 'int32') {\n        throw new Error('tf.sparseToDense() expects the indices to be int32 type,' +\n            ` but the dtype was ${sparseIndices.dtype}.`);\n    }\n    if (sparseIndices.rank > 2) {\n        throw new Error('sparseIndices should be a scalar, vector, or matrix,' +\n            ` but got shape ${sparseIndices.shape}.`);\n    }\n    const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\n    const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\n    if (outputShape.length !== numDims) {\n        throw new Error('outputShape has incorrect number of elements:,' +\n            ` ${outputShape.length}, should be: ${numDims}.`);\n    }\n    const numValues = sparseValues.size;\n    if (!(sparseValues.rank === 0 ||\n        sparseValues.rank === 1 && numValues === numElems)) {\n        throw new Error('sparseValues has incorrect shape ' +\n            `${sparseValues.shape}, should be [] or [${numElems}]`);\n    }\n    if (sparseValues.dtype !== defaultValues.dtype) {\n        throw new Error('sparseValues.dtype must match defaultValues.dtype');\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BhcnNlX3RvX2RlbnNlX3V0aWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9zcGFyc2VfdG9fZGVuc2VfdXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFrQkE7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsTUFBTSxVQUFVLGFBQWEsQ0FDekIsYUFBcUIsRUFBRSxZQUFvQixFQUFFLFdBQXFCLEVBQ2xFLGFBQXFCO0lBQ3ZCLElBQUksYUFBYSxDQUFDLEtBQUssS0FBSyxPQUFPLEVBQUU7UUFDbkMsTUFBTSxJQUFJLEtBQUssQ0FDWCwwREFBMEQ7WUFDMUQsc0JBQXNCLGFBQWEsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0tBQ25EO0lBQ0QsSUFBSSxhQUFhLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBRTtRQUMxQixNQUFNLElBQUksS0FBSyxDQUNYLHNEQUFzRDtZQUN0RCxrQkFBa0IsYUFBYSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7S0FDL0M7SUFFRCxNQUFNLFFBQVEsR0FBRyxhQUFhLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JFLE1BQU0sT0FBTyxHQUFHLGFBQWEsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFcEUsSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLE9BQU8sRUFBRTtRQUNsQyxNQUFNLElBQUksS0FBSyxDQUNYLGdEQUFnRDtZQUNoRCxJQUFJLFdBQVcsQ0FBQyxNQUFNLGdCQUFnQixPQUFPLEdBQUcsQ0FBQyxDQUFDO0tBQ3ZEO0lBRUQsTUFBTSxTQUFTLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQztJQUNwQyxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxLQUFLLENBQUM7UUFDdkIsWUFBWSxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksU0FBUyxLQUFLLFFBQVEsQ0FBQyxFQUFFO1FBQ3hELE1BQU0sSUFBSSxLQUFLLENBQ1gsbUNBQW1DO1lBQ25DLEdBQUcsWUFBWSxDQUFDLEtBQUssc0JBQXNCLFFBQVEsR0FBRyxDQUFDLENBQUM7S0FDN0Q7SUFFRCxJQUFJLFlBQVksQ0FBQyxLQUFLLEtBQUssYUFBYSxDQUFDLEtBQUssRUFBRTtRQUM5QyxNQUFNLElBQUksS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7S0FDdEU7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbi8qKlxuICogVmFsaWRhdGUgc3BhcnNlVG9EZW5zZSBpbnB1dHMuXG4gKlxuICogQHBhcmFtIHNwYXJzZUluZGljZXMgQSAwLUQsIDEtRCwgb3IgMi1EIFRlbnNvciBvZiB0eXBlIGludDMyLlxuICogc3BhcnNlSW5kaWNlc1tpXSBjb250YWlucyB0aGUgY29tcGxldGUgaW5kZXggd2hlcmUgc3BhcnNlVmFsdWVzW2ldIHdpbGwgYmVcbiAqIHBsYWNlZC5cbiAqIEBwYXJhbSBzcGFyc2VWYWx1ZXMgQSAwLUQgb3IgMS1EIFRlbnNvci4gVmFsdWVzXG4gKiBjb3JyZXNwb25kaW5nIHRvIGVhY2ggcm93IG9mIHNwYXJzZUluZGljZXMsIG9yIGEgc2NhbGFyIHZhbHVlIHRvIGJlIHVzZWQgZm9yXG4gKiBhbGwgc3BhcnNlIGluZGljZXMuXG4gKiBAcGFyYW0gb3V0cHV0U2hhcGUgbnVtYmVyW10uIFNoYXBlIG9mIHRoZSBkZW5zZSBvdXRwdXQgdGVuc29yLlxuICogQHBhcmFtIHZhbGlkYXRlSW5kaWNlcyBib29sZWFuLiBpbmRpY2UgdmFsaWRhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLCBlcnJvclxuICogd2lsbCBiZSB0aHJvd24gaWYgaXQgaXMgc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVJbnB1dChcbiAgICBzcGFyc2VJbmRpY2VzOiBUZW5zb3IsIHNwYXJzZVZhbHVlczogVGVuc29yLCBvdXRwdXRTaGFwZTogbnVtYmVyW10sXG4gICAgZGVmYXVsdFZhbHVlczogVGVuc29yKSB7XG4gIGlmIChzcGFyc2VJbmRpY2VzLmR0eXBlICE9PSAnaW50MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAndGYuc3BhcnNlVG9EZW5zZSgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgaW50MzIgdHlwZSwnICtcbiAgICAgICAgYCBidXQgdGhlIGR0eXBlIHdhcyAke3NwYXJzZUluZGljZXMuZHR5cGV9LmApO1xuICB9XG4gIGlmIChzcGFyc2VJbmRpY2VzLnJhbmsgPiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnc3BhcnNlSW5kaWNlcyBzaG91bGQgYmUgYSBzY2FsYXIsIHZlY3Rvciwgb3IgbWF0cml4LCcgK1xuICAgICAgICBgIGJ1dCBnb3Qgc2hhcGUgJHtzcGFyc2VJbmRpY2VzLnNoYXBlfS5gKTtcbiAgfVxuXG4gIGNvbnN0IG51bUVsZW1zID0gc3BhcnNlSW5kaWNlcy5yYW5rID4gMCA/IHNwYXJzZUluZGljZXMuc2hhcGVbMF0gOiAxO1xuICBjb25zdCBudW1EaW1zID0gc3BhcnNlSW5kaWNlcy5yYW5rID4gMSA/IHNwYXJzZUluZGljZXMuc2hhcGVbMV0gOiAxO1xuXG4gIGlmIChvdXRwdXRTaGFwZS5sZW5ndGggIT09IG51bURpbXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdvdXRwdXRTaGFwZSBoYXMgaW5jb3JyZWN0IG51bWJlciBvZiBlbGVtZW50czosJyArXG4gICAgICAgIGAgJHtvdXRwdXRTaGFwZS5sZW5ndGh9LCBzaG91bGQgYmU6ICR7bnVtRGltc30uYCk7XG4gIH1cblxuICBjb25zdCBudW1WYWx1ZXMgPSBzcGFyc2VWYWx1ZXMuc2l6ZTtcbiAgaWYgKCEoc3BhcnNlVmFsdWVzLnJhbmsgPT09IDAgfHxcbiAgICAgICAgc3BhcnNlVmFsdWVzLnJhbmsgPT09IDEgJiYgbnVtVmFsdWVzID09PSBudW1FbGVtcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzcGFyc2VWYWx1ZXMgaGFzIGluY29ycmVjdCBzaGFwZSAnICtcbiAgICAgICAgYCR7c3BhcnNlVmFsdWVzLnNoYXBlfSwgc2hvdWxkIGJlIFtdIG9yIFske251bUVsZW1zfV1gKTtcbiAgfVxuXG4gIGlmIChzcGFyc2VWYWx1ZXMuZHR5cGUgIT09IGRlZmF1bHRWYWx1ZXMuZHR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwYXJzZVZhbHVlcy5kdHlwZSBtdXN0IG1hdGNoIGRlZmF1bHRWYWx1ZXMuZHR5cGUnKTtcbiAgfVxufVxuIl19"],"names":["spaceToBatchND","op","spaceToBatchND_","x","blockShape","paddings","$x","rank","length","shape","reduce","a","b","i","slice","toString","inputs","attrs","runKernel","sparseReshape","sparseReshape_","inputIndices","inputShape","newShape","$inputIndices","$inputShape","$newShape","Error","result","outputIndices","outputShape","sparseSegmentMean","sparseSegmentMean_","data","indices","segmentIds","$data","$indices","$segmentIds","sparseSegmentSum","sparseSegmentSum_","getSparseSegmentReductionNegativeSegmentIdsErrorMessage","getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage","getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage","segmentId","outputRows","getSparseSegmentReductionIndicesOutOfRangeErrorMessage","index","indexValue","inputRows","sparseFillEmptyRows","sparseFillEmptyRows_","values","denseShape","defaultValue","$values","$denseShape","$defaultValue","dtype","outputValues","emptyRowIndicator","reverseIndexMap","getSparseFillEmptyRowsIndicesDenseShapeMismatch","indicesLength","getSparseFillEmptyRowsNegativeIndexErrorMessage","value","getSparseFillEmptyRowsOutOfRangeIndexErrorMessage","limit","getSparseReshapeMultipleNegativeOneOutputDimErrorMessage","dim1","dim2","getSparseReshapeNegativeOutputDimErrorMessage","dim","getSparseReshapeEmptyTensorZeroOutputDimErrorMessage","getSparseReshapeInputOutputMultipleErrorMessage","getSparseReshapeInputOutputMismatchErrorMessage","sparseToDense","sparseToDense_","sparseIndices","sparseValues","$sparseIndices","$sparseValues","defaultValues","numElems","numDims","numValues","size"],"sourceRoot":""}