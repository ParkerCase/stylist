"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[6895],{5550:function(e,t,n){n.d(t,{r:function(){return s}});var a=n(9495),r=n(97870),o=n(46936);const s={kernelName:a.Reverse,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:c}=t,{dims:i}=s;(0,r.C)(c,"reverse");const l=c.shape.length,u=a.util.parseAxisParam(i,c.shape);if(0===l)return(0,o.D)({inputs:{x:c},backend:n});const f=new a.TensorBuffer(c.shape,c.dtype),d=n.bufferSync(c);for(let a=0;a<f.size;a++){const e=f.indexToLoc(a),t=e.slice();u.forEach((e=>t[e]=c.shape[e]-1-t[e])),f.set(d.get(...t),...e)}return n.makeTensorInfo(f.shape,f.dtype,f.values)}}},14590:function(e,t,n){n.d(t,{V:function(){return o},t:function(){return r}});var a=n(9495);function r(e){const{inputs:t,backend:n,attrs:r}=e,{x:o}=t,{shape:s}=r,c=a.util.sizeFromShape(o.shape),i=a.util.inferFromImplicitShape(s,c),l=a.util.sizeFromShape(i);a.util.assert(c===l,(()=>`The new shape (${i}) has ${l} elements and the old shape (${o.shape}) has ${c} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(o.dataId);const u=n.data.get(o.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=i,t.shape=i}return{dataId:o.dataId,shape:i,dtype:o.dtype}}const o={kernelName:a.Reshape,backendName:"cpu",kernelFunc:r}},17714:function(e,t,n){n.d(t,{f:function(){return r}});var a=n(9495);const r={kernelName:a.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:o,fillValue:s,center:c}=t,i=n,l=a.util.getTypedArrayFromDType(r.dtype,a.util.sizeFromShape(r.shape)),[u,f,d,h]=r.shape,[p,m]=a.backend_util.getImageCenter(c,f,d),k=Math.sin(o),M=Math.cos(o),N=i.data.get(r.dataId).values;for(let a=0;a<u;a++){const e=a*d*f*h;for(let t=0;t<f;t++){const n=t*(d*h);for(let a=0;a<d;a++){const r=a*h;for(let o=0;o<h;o++){const c=[u,t,a,o],i=c[2],b=c[1];let g=(i-p)*M-(b-m)*k,v=(i-p)*k+(b-m)*M;g=Math.round(g+p),v=Math.round(v+m);let y=s;if("number"!==typeof s&&(y=3===o?255:s[o]),g>=0&&g<d&&v>=0&&v<f){y=N[e+v*(d*h)+g*h+o]}l[e+n+r+o]=y}}}}return{dataId:i.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}}},27882:function(e,t,n){n.d(t,{T:function(){return o}});var a=n(9495),r=n(97870);const o={kernelName:a.ResizeBilinear,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{images:s}=t,{alignCorners:c,halfPixelCenters:i,size:l}=o;(0,r.C)(s,"resizeBilinear");const u=a.util.computeStrides(s.shape),[f,d]=l,[h,p,m,k]=s.shape,M=n.data.get(s.dataId).values,N=new Float32Array(a.util.sizeFromShape([h,f,d,k])),b=[c&&f>1?p-1:p,c&&d>1?m-1:m],g=[c&&f>1?f-1:f,c&&d>1?d-1:d];let v=0;const y=b[0]/g[0],I=b[1]/g[1];for(let a=0;a<h;a++)for(let e=0;e<f;e++){let t;t=i?y*(e+.5)-.5:y*e;const n=Math.max(0,Math.floor(t)),r=t-n,o=Math.min(p-1,Math.ceil(t)),s=a*u[0]+n*u[1],c=a*u[0]+o*u[1];for(let e=0;e<d;e++){let t;t=i?I*(e+.5)-.5:I*e;const n=Math.max(0,Math.floor(t)),a=t-n,o=Math.min(m-1,Math.ceil(t)),l=s+n*u[2],f=c+n*u[2],d=s+o*u[2],h=c+o*u[2];for(let e=0;e<k;e++){const t=M[l+e],n=M[f+e],o=t+(M[d+e]-t)*a,s=o+(n+(M[h+e]-n)*a-o)*r;N[v++]=s}}}return n.makeTensorInfo([h,f,d,k],"float32",N)}}},53652:function(e,t,n){n.d(t,{X:function(){return o},j:function(){return r}});var a=n(9495);const r=(0,n(21694).v)(a.Relu6,(e=>Math.min(Math.max(0,e),6))),o={kernelName:a.Relu6,backendName:"cpu",kernelFunc:r}},60990:function(e,t,n){n.d(t,{l:function(){return o}});var a=n(9495);const r=(0,n(21694).v)(a.Reciprocal,(e=>1/e)),o={kernelName:a.Reciprocal,backendName:"cpu",kernelFunc:r}},61879:function(e,t,n){n.d(t,{GN:function(){return i},y4:function(){return c}});var a=n(9495),r=n(8195),o=n(98880);const s=(0,r.Z)(((e,t)=>e/t)),c=(0,o.j)(a.RealDiv,s),i={kernelName:a.RealDiv,backendName:"cpu",kernelFunc:c}},67296:function(e,t,n){n.d(t,{j:function(){return o}});var a=n(9495),r=n(97870);const o={kernelName:a.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{images:s}=t,{alignCorners:c,halfPixelCenters:i,size:l}=o;(0,r.C)(s,"resizeNearestNeighbor");const u=a.util.computeStrides(s.shape),[f,d]=l,[h,p,m,k]=s.shape,M=n.data.get(s.dataId).values,N=new Float32Array(h*f*d*k),b=[c&&f>1?p-1:p,c&&d>1?m-1:m],g=[c&&f>1?f-1:f,c&&d>1?d-1:d],v=b[0]/g[0],y=b[1]/g[1];let I=0;for(let a=0;a<h;a++){const e=a*u[0];for(let t=0;t<f;t++){const n=i?v*(t+.5):v*t;let a=Math.min(p-1,c?Math.round(n):Math.floor(n));i&&(a=Math.max(0,a));const r=e+a*u[1];for(let e=0;e<d;e++){const t=i?y*(e+.5):y*e;let n=Math.min(m-1,c?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const a=r+n*u[2];for(let e=0;e<k;e++){const t=M[a+e];N[I++]=t}}}}return n.makeTensorInfo([h,f,d,k],s.dtype,N)}}},74016:function(e,t,n){n.d(t,{V:function(){return r},z:function(){return o}});var a=n(9495);const r=(0,n(21694).v)(a.Relu,(e=>Math.max(0,e))),o={kernelName:a.Relu,backendName:"cpu",kernelFunc:r}},83478:function(e,t,n){n.d(t,{j:function(){return o}});var a=n(9495),r=n(97870);const o={kernelName:a.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{images:s,dy:c}=t,{alignCorners:i}=o;(0,r.C)([c,s],"resizeBilinearGrad");const l=a.util.computeStrides(s.shape),[u,f,d,h]=s.shape,[,p,m]=c.shape,k=new Float32Array(u*f*d*h),M=[i&&p>1?f-1:f,i&&m>1?d-1:d],N=[i&&p>1?p-1:p,i&&m>1?m-1:m],b=M[0]/N[0],g=M[1]/N[1],v=n.data.get(c.dataId).values;let y=0;for(let a=0;a<u;a++){const e=a*l[0];for(let t=0;t<p;t++){const n=t*b,a=Math.floor(n),r=Math.min(Math.ceil(n),f-1),o=e+a*l[1],s=e+r*l[1],c=n-a,i=1-c;for(let e=0;e<m;e++){const t=e*g,n=Math.floor(t),a=Math.min(Math.ceil(t),d-1),r=t-n,u=1-r,f=o+n*l[2],p=o+a*l[2],m=s+n*l[2],M=s+a*l[2],N=i*u,b=i*r,I=c*u,F=c*r;for(let e=0;e<h;e++){const t=v[y++];k[f+e]+=t*N,k[p+e]+=t*b,k[m+e]+=t*I,k[M+e]+=t*F}}}}return n.makeTensorInfo([u,d,f,h],"float32",k)}}},85806:function(e,t,n){function a(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}n.d(t,{r:function(){return r},x:function(){return a}});const r={kernelName:n(9495).Real,backendName:"cpu",kernelFunc:a}},94260:function(e,t,n){n.d(t,{n:function(){return o}});var a=n(9495),r=n(97870);const o={kernelName:a.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{images:s,dy:c}=t,{alignCorners:i}=o;(0,r.C)([c,s],"resizeNearestNeighborGrad");const l=a.util.computeStrides(s.shape),u=a.util.computeStrides(c.shape),[f,d,h,p]=s.shape,[,m,k]=c.shape,M=new Float32Array(f*d*h*p),N=n.data.get(c.dataId).values,b=[i&&m>1?d-1:d,i&&k>1?h-1:h],g=[i&&m>1?m-1:m,i&&k>1?k-1:k],v=b[0]/g[0],y=b[1]/g[1],I=1/v,F=1/y,x=2*Math.ceil(I)+2,R=2*Math.ceil(F)+2;for(let a=0;a<f;a++){const e=a*l[0];for(let t=0;t<d;t++){const n=e+t*l[1],a=Math.floor(t*I),r=Math.floor(a-x/2);for(let o=0;o<h;o++){const a=n+o*l[2],s=Math.floor(o*F),c=Math.floor(s-R/2);for(let n=0;n<p;n++){let s=0;for(let a=0;a<x;a++){const l=a+r;if(l<0||l>=m)continue;const f=e+l*u[1],p=l*v;if(t===Math.min(d-1,i?Math.round(p):Math.floor(p)))for(let e=0;e<R;e++){const t=e+c;if(t<0||t>=k)continue;const a=f+t*u[2],r=t*y;o===Math.min(h-1,i?Math.round(r):Math.floor(r))&&(s+=N[a+n])}}M[a+n]=s}}}}return n.makeTensorInfo(s.shape,s.dtype,M)}}}}]);
//# sourceMappingURL=stylist-vendors-bb708955.108bc24deb4990b8a3f9.js.map