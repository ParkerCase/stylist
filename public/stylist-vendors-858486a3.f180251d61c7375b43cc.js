"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[2574],{12695:function(t,e,a){var r=a(9495),i=a(47661),s=a(39459),n=a(79730),l=a(15841),c=a(84604),o=a(44813),u=a(63057),h=a(76481),g=a(55795);class d extends n.Wd{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,a={}){const r=e.layer,i=(0,g.i)(r,a);delete e.layer;const s={layer:i};return Object.assign(s,e),new t(s)}}class y extends d{constructor(t){super(t),this.supportsMasking=!0}build(t){if((t=(0,u.U$)(t)).length<3)throw new l.Qp(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){const e=[(t=(0,u.U$)(t))[0]].concat(t.slice(2)),a=this.layer.computeOutputShape(e),r=t[1];return[a[0],r].concat(a.slice(1))}call(t,e){return(0,r.tidy)((()=>{t=(0,u.un)(t);return(0,h.L7)(((t,a)=>[(0,u.un)(this.layer.call(t,e)),[]]),t,[],!1,null,null,!1,!0)[1]}))}}y.className="TimeDistributed",r.serialization.registerClass(y);class p extends d{constructor(t){super(t);const e=t.layer.getConfig(),a={};a.className=t.layer.getClassName(),a.config=e,this.forwardLayer=(0,g.i)(a),e.goBackwards=!0!==e.goBackwards;const r={};var i;if(r.className=t.layer.getClassName(),r.config=e,this.backwardLayer=(0,g.i)(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===t.mergeMode?"concat":t.mergeMode,i=this.mergeMode,o.E6(c.r$,"BidirectionalMergeMode",i),t.weights)throw new l.EH("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,null!=this.forwardLayer&&(this.forwardLayer.trainable=t),null!=this.backwardLayer&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,a=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,a)),this.backwardLayer.setWeights(t.slice(a))}computeOutputShape(t){let e,a,r,i=this.forwardLayer.computeOutputShape(t);return Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),this.returnState?(r=i.slice(1),e=i[0]):e=i[0],"concat"===this.mergeMode?(e[e.length-1]*=2,a=[e]):a=null==this.mergeMode?[e,e.slice()]:[e],this.returnState?null==this.mergeMode?a.concat(r).concat(r.slice()):[e].concat(r).concat(r.slice()):o.wL(a)}apply(t,e){let a=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const i=(0,h.tL)(t,a,r,this.numConstants);if(t=i.inputs,a=i.initialState,r=i.constants,Array.isArray(t)&&(a=t.slice(1),t=t[0]),(null==a||0===a.length)&&null==r)return super.apply(t,e);const s=[],c=[];if(null!=a){const t=a.length;if(t%2>0)throw new l.Qp("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=a,s.push(...a);const r=a.map((t=>new n.eO({shape:t.shape})));this.forwardLayer.stateSpec=r.slice(0,t/2),this.backwardLayer.stateSpec=r.slice(t/2),c.push(...r)}if(null!=r)throw new l.EH("Support for constants in Bidirectional layers is not implemented yet.");const o=s[0]instanceof n.Ar;for(const u of s)if(u instanceof n.Ar!==o)throw new l.Qp("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const a=[t].concat(s),r=this.inputSpec.concat(c),i=this.inputSpec;this.inputSpec=r;const n=super.apply(a,e);return this.inputSpec=i,n}return super.apply(t,e)}call(t,e){return(0,r.tidy)((()=>{const a=e.initialState;let s,n,l,c;if(null==a)s=this.forwardLayer.call(t,e),n=this.backwardLayer.call(t,e);else{const r=a.slice(0,a.length/2),i=a.slice(a.length/2);s=this.forwardLayer.call(t,Object.assign(e,{initialState:r})),n=this.backwardLayer.call(t,Object.assign(e,{initialState:i}))}return this.returnState&&(Array.isArray(s)&&(l=s.slice(1).concat(n.slice(1))),s=s[0],n=n[0]),this.returnSequences&&(n=r.reverse(n,1)),"concat"===this.mergeMode?c=i.u1([s,n]):"sum"===this.mergeMode?c=r.add(s,n):"ave"===this.mergeMode?c=r.mul(.5,r.add(s,n)):"mul"===this.mergeMode?c=r.mul(s,n):null==this.mergeMode&&(c=[s,n]),this.returnState?null==this.mergeMode?c.concat(l):[c].concat(l):c}))}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){(0,s.IU)(this.forwardLayer.name,(()=>{this.forwardLayer.build(t)})),(0,s.IU)(this.backwardLayer.name,(()=>{this.backwardLayer.build(t)})),this.built=!0}computeMask(t,e){let a;if(Array.isArray(e)&&(e=e[0]),a=this.returnSequences?null==this.mergeMode?[e,e]:e:null==this.mergeMode?[null,null]:null,this.returnState){const t=this.forwardLayer.states.map((t=>null));return Array.isArray(a)?a.concat(t).concat(t):[a].concat(t).concat(t)}return a}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(t),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const a=(0,g.i)(e.layer);if(delete e.layer,null!=e.numConstants)throw new l.EH("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=e;return r.layer=a,new t(r)}}p.className="Bidirectional",r.serialization.registerClass(p)}}]);
//# sourceMappingURL=stylist-vendors-858486a3.f180251d61c7375b43cc.js.map