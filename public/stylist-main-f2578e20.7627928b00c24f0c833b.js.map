{"version":3,"file":"stylist-main-f2578e20.7627928b00c24f0c833b.js","mappings":"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","sources":["webpack://StylistWidget/./src/services/mockApiMiddleware.ts","webpack://StylistWidget/./src/services/SyncProvider.tsx","webpack://StylistWidget/./src/services/image-processing/imageScaling.ts","webpack://StylistWidget/./src/services/syncService.ts","webpack://StylistWidget/./src/services/image-processing/fileUtils.ts","webpack://StylistWidget/./src/services/feedbackSyncService.ts","webpack://StylistWidget/./src/services/image-processing/canvasUtils.ts","webpack://StylistWidget/./src/services/chatService.ts","webpack://StylistWidget/./src/services/analytics/analyticsService.ts","webpack://StylistWidget/./src/services/offlineService.ts","webpack://StylistWidget/./src/services/background-removal/removeBackgroundApi.ts","webpack://StylistWidget/./src/services/background-removal/tfBackgroundRemoval.ts","webpack://StylistWidget/./src/services/background-removal/utils.ts","webpack://StylistWidget/./src/services/image-processing/imagePositioning.ts"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// Mock API middleware for intercepting requests and providing mock responses\nimport axios from 'axios';\nimport { get, shouldUseMockData } from '../mock-data';\nimport { FORCE_DEMO_MODE, USE_MOCK_RETAILER } from '../utils/environment';\n/**\n * Setup mock API interceptors on an API client\n * @param apiClient - The ApiClient instance to enhance with mock capability\n * @returns The enhanced API client\n */\nexport function setupMockApiInterceptors(apiClient) {\n    // Store original request method\n    const originalRequestWithRetry = apiClient['requestWithRetry'].bind(apiClient);\n    // Override requestWithRetry method to handle mock data\n    apiClient['requestWithRetry'] = function (method, url, data, config) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Determine if we should use mock data\n            if (shouldUseMockResponseForRequest(url, method)) {\n                try {\n                    // Log the intercepted request\n                    console.debug(`[MockAPI] Intercepting ${method.toUpperCase()} request to ${url}`);\n                    // Build options from request data\n                    const options = Object.assign(Object.assign(Object.assign({}, ((config === null || config === void 0 ? void 0 : config.params) ? config.params : {})), (data ? (typeof data === 'object' ? data : {}) : {})), { url,\n                        method });\n                    // Generate mock response\n                    const mockResponse = get(url, options);\n                    // Simulate network delay for realism\n                    yield simulateNetworkDelay();\n                    // Log the mock response\n                    console.debug(`[MockAPI] Returning mock data for ${url}`, mockResponse);\n                    return mockResponse;\n                }\n                catch (error) {\n                    console.error(`[MockAPI] Error generating mock response for ${url}:`, error);\n                    // Fall through to real API request on error\n                }\n            }\n            // Proceed with the original request if we're not using mock data\n            return originalRequestWithRetry(method, url, data, config);\n        });\n    };\n    return apiClient;\n}\n/**\n * Setup a proper axios interceptor for use with other instances\n * @param axiosInstance - Axios instance to add interceptors to\n */\nexport function setupAxiosMockInterceptor(axiosInstance) {\n    axiosInstance.interceptors.request.use((config) => __awaiter(this, void 0, void 0, function* () {\n        const url = config.url || '';\n        const method = config.method;\n        // Proceed with real request if we shouldn't mock this request\n        if (!shouldUseMockResponseForRequest(url, method)) {\n            return config;\n        }\n        // Create a canceled request that will be replaced with mock data\n        const cancelToken = new axios.CancelToken((cancel) => {\n            cancel('Request intercepted by mock API middleware');\n        });\n        return Object.assign(Object.assign({}, config), { cancelToken });\n    }), (error) => Promise.reject(error));\n    // Response interceptor to provide mock data for canceled requests\n    axiosInstance.interceptors.response.use((response) => response, (error) => __awaiter(this, void 0, void 0, function* () {\n        // Check if this error was from our cancellation\n        if (axios.isCancel(error)) {\n            const url = error.config.url || '';\n            const method = error.config.method;\n            // Build options from request data\n            const options = Object.assign(Object.assign(Object.assign({}, (error.config.params ? error.config.params : {})), (error.config.data ?\n                (typeof error.config.data === 'string' ?\n                    JSON.parse(error.config.data) :\n                    error.config.data) : {})), { url,\n                method });\n            // Generate mock response\n            const mockResponse = get(url, options);\n            // Simulate network delay\n            yield simulateNetworkDelay();\n            // Create a synthetic response\n            const response = {\n                data: mockResponse,\n                status: 200,\n                statusText: 'OK',\n                headers: {},\n                config: error.config,\n            };\n            return response;\n        }\n        // For real errors, reject the promise\n        return Promise.reject(error);\n    }));\n}\n/**\n * Determine if we should use a mock response for this request\n */\nfunction shouldUseMockResponseForRequest(url, method) {\n    // Always use mock data if forced demo mode is enabled\n    if (FORCE_DEMO_MODE) {\n        return true;\n    }\n    // Check if we should use mock data based on environment and settings\n    if (shouldUseMockData()) {\n        return true;\n    }\n    // Use mock data for retailer-specific endpoints if mock retailer is enabled\n    if (USE_MOCK_RETAILER &&\n        (url.includes('/products') ||\n            url.includes('/inventory') ||\n            url.includes('/recommendations'))) {\n        return true;\n    }\n    // Add other specific endpoint rules here\n    // Default to real API\n    return false;\n}\n/**\n * Simulate realistic network delay\n */\nfunction simulateNetworkDelay() {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Randomize delay between 100-500ms for realism\n        const delay = 100 + Math.random() * 400;\n        return new Promise(resolve => setTimeout(resolve, delay));\n    });\n}\n","import { jsxs as _jsxs } from \"react/jsx-runtime\";\n// Provider for data synchronization across the application\nimport { createContext, useContext, useEffect, useState, useRef } from 'react';\nimport { useSyncService } from './syncService';\nimport useNetworkStatus from '../hooks/useNetworkStatus';\nimport { useUserStore } from '../store/userStore';\n// Initialize lifecycle log\nconsole.log('[LIFECYCLE:SyncProvider] Module load started');\nconst SyncContext = createContext(undefined);\nexport const useSyncContext = () => {\n    const context = useContext(SyncContext);\n    if (context === undefined) {\n        throw new Error('useSyncContext must be used within a SyncProvider');\n    }\n    return context;\n};\n// Provider component\nexport const SyncProvider = ({ children }) => {\n    console.log('[LIFECYCLE:SyncProvider] Provider component rendering');\n    const syncService = useSyncService();\n    const network = useNetworkStatus();\n    const userStore = useUserStore();\n    const [isMounted, setIsMounted] = useState(false);\n    // Add diagnostic task tracking\n    const backgroundTasksStarted = useRef(false);\n    const backgroundTasksCompleted = useRef(false);\n    const maxSyncTimeout = useRef(null);\n    console.log('[LIFECYCLE:SyncProvider] Initial state:', {\n        isMounted,\n        isOnline: network.isOnline,\n        hasUser: !!userStore.user,\n        syncState: syncService.state\n    });\n    // Initial sync when the component mounts and user is available\n    useEffect(() => {\n        console.log('[LIFECYCLE:SyncProvider] Initial sync effect running', {\n            isMounted,\n            isOnline: network.isOnline,\n            hasUser: !!userStore.user\n        });\n        if (!isMounted) {\n            console.log('[LIFECYCLE:SyncProvider] First mount detected, setting isMounted true');\n            setIsMounted(true);\n            return;\n        }\n        // Start tracking background initialization tasks\n        if (!backgroundTasksStarted.current) {\n            backgroundTasksStarted.current = true;\n            console.log('[TASK:START] Background initialization tasks starting');\n            // Set an absolute maximum timeout to ensure background tasks always complete\n            maxSyncTimeout.current = setTimeout(() => {\n                if (!backgroundTasksCompleted.current) {\n                    console.warn('[LIFECYCLE:SyncProvider] Maximum timeout reached, forcing background tasks completion');\n                    backgroundTasksCompleted.current = true;\n                    console.log('[TASK:COMPLETE] Background initialization tasks completed (forced by timeout)');\n                    // Set a global flag to indicate background initialization is complete\n                    if (window && typeof window !== 'undefined') {\n                        window.__STYLIST_BACKGROUND_INIT_COMPLETE = true;\n                    }\n                }\n            }, 15000); // 15 seconds absolute maximum\n        }\n        // Defer sync operation to avoid blocking initial render\n        console.log('[LIFECYCLE:SyncProvider] Setting initial sync timeout (2000ms)');\n        const timer = setTimeout(() => {\n            console.log('[LIFECYCLE:SyncProvider] Initial sync timeout fired, checking conditions');\n            if (userStore.user && network.isOnline) {\n                console.log('[LIFECYCLE:SyncProvider] Conditions met, triggering initial sync');\n                syncService.syncNow();\n            }\n            else {\n                console.log('[LIFECYCLE:SyncProvider] Initial sync skipped - offline or no user', {\n                    isOnline: network.isOnline,\n                    hasUser: !!userStore.user\n                });\n            }\n            // After sync attempt, mark background tasks as complete if not already done\n            if (!backgroundTasksCompleted.current) {\n                setTimeout(() => {\n                    if (!backgroundTasksCompleted.current) {\n                        console.log('[LIFECYCLE:SyncProvider] Marking background tasks as complete after sync attempt');\n                        backgroundTasksCompleted.current = true;\n                        console.log('[TASK:COMPLETE] Background initialization tasks completed after sync');\n                        // Set a global flag to indicate background initialization is complete\n                        if (window && typeof window !== 'undefined') {\n                            window.__STYLIST_BACKGROUND_INIT_COMPLETE = true;\n                        }\n                    }\n                }, 5000); // 5 seconds after sync attempt\n            }\n        }, 2000); // 2-second delay to ensure other components load first\n        return () => {\n            console.log('[LIFECYCLE:SyncProvider] Cleaning up initial sync timer');\n            clearTimeout(timer);\n            if (maxSyncTimeout.current) {\n                clearTimeout(maxSyncTimeout.current);\n            }\n        };\n    }, [isMounted, userStore.user, network.isOnline, syncService]);\n    // Perform sync when coming back online\n    useEffect(() => {\n        console.log('[LIFECYCLE:SyncProvider] Network status change effect', {\n            isOnline: network.isOnline,\n            hasUser: !!userStore.user\n        });\n        if (network.isOnline && userStore.user) {\n            // Slight delay to ensure stable connection\n            console.log('[LIFECYCLE:SyncProvider] Online detected, setting sync timeout (2000ms)');\n            const timer = setTimeout(() => {\n                console.log('[LIFECYCLE:SyncProvider] Online sync timeout fired, triggering sync');\n                syncService.syncNow();\n            }, 2000);\n            return () => {\n                console.log('[LIFECYCLE:SyncProvider] Cleaning up online sync timer');\n                clearTimeout(timer);\n            };\n        }\n    }, [network.isOnline, userStore.user, syncService]);\n    // Perform sync on page visibility change (user returns to tab)\n    useEffect(() => {\n        console.log('[LIFECYCLE:SyncProvider] Setting up visibility change listener');\n        const handleVisibilityChange = () => {\n            console.log('[LIFECYCLE:SyncProvider] Visibility changed', {\n                visibilityState: document.visibilityState,\n                isOnline: network.isOnline,\n                hasUser: !!userStore.user\n            });\n            if (document.visibilityState === 'visible' && network.isOnline && userStore.user) {\n                console.log('[LIFECYCLE:SyncProvider] Tab became visible while online, triggering sync');\n                syncService.syncNow();\n            }\n        };\n        document.addEventListener('visibilitychange', handleVisibilityChange);\n        return () => {\n            console.log('[LIFECYCLE:SyncProvider] Removing visibility change listener');\n            document.removeEventListener('visibilitychange', handleVisibilityChange);\n        };\n    }, [network.isOnline, userStore.user, syncService]);\n    // Provide sync service to children\n    const value = {\n        syncState: syncService.state,\n        syncNow: syncService.syncNow,\n        isOnline: network.isOnline,\n        isSlowConnection: network.isSlowConnection\n    };\n    console.log('[LIFECYCLE:SyncProvider] Rendering provider with sync state:', {\n        isSyncing: syncService.state.isSyncing,\n        pendingOperations: syncService.state.pendingOperations,\n        isOnline: network.isOnline,\n        lastSyncTimestamp: syncService.state.lastSyncTimestamp ?\n            new Date(syncService.state.lastSyncTimestamp).toISOString() : null\n    });\n    // Add effect to set render complete flag\n    useEffect(() => {\n        // Ensure we set the render complete flag after component has mounted\n        const timer = setTimeout(() => {\n            console.log('[LIFECYCLE:SyncProvider] Setting widget render complete flag');\n            // Set global flag to indicate widget is fully rendered\n            if (window && typeof window !== 'undefined') {\n                window.__STYLIST_WIDGET_RENDER_COMPLETE = true;\n                // Log a diagnostic message\n                console.log('[RENDER:COMPLETE] Widget rendering completed');\n            }\n        }, 5000);\n        return () => {\n            clearTimeout(timer);\n        };\n    }, []);\n    return (_jsxs(SyncContext.Provider, Object.assign({ value: value }, { children: [(() => {\n                console.log('[LIFECYCLE:SyncProvider] Before rendering children');\n                return null;\n            })(), children, (() => {\n                console.log('[LIFECYCLE:SyncProvider] After rendering children');\n                return null;\n            })()] })));\n};\nexport default SyncProvider;\n","// Utilities for scaling images proportionally\n/**\n * Calculate new dimensions while maintaining aspect ratio\n */\nexport const calculateAspectRatioDimensions = (originalWidth, originalHeight, targetWidth, targetHeight, maxWidth, maxHeight) => {\n    let width = originalWidth;\n    let height = originalHeight;\n    // Apply target width if specified\n    if (targetWidth) {\n        width = targetWidth;\n        height = (originalHeight * targetWidth) / originalWidth;\n    }\n    // Apply target height if specified\n    if (targetHeight) {\n        height = targetHeight;\n        // Only recalculate width if target width wasn't specified\n        if (!targetWidth) {\n            width = (originalWidth * targetHeight) / originalHeight;\n        }\n    }\n    // Apply maximum width constraint if needed\n    if (maxWidth && width > maxWidth) {\n        height = (height * maxWidth) / width;\n        width = maxWidth;\n    }\n    // Apply maximum height constraint if needed\n    if (maxHeight && height > maxHeight) {\n        width = (width * maxHeight) / height;\n        height = maxHeight;\n    }\n    return {\n        width: Math.round(width),\n        height: Math.round(height)\n    };\n};\n/**\n * Scale dimensions by a factor\n */\nexport const scaleDimensions = (dimensions, scaleFactor) => {\n    return {\n        width: Math.round(dimensions.width * scaleFactor),\n        height: Math.round(dimensions.height * scaleFactor)\n    };\n};\n/**\n * Scale a point by a factor\n */\nexport const scalePoint = (point, scaleFactor) => {\n    return {\n        x: point.x * scaleFactor,\n        y: point.y * scaleFactor\n    };\n};\n/**\n * Calculate the scale factor needed to fit source dimensions into target dimensions\n */\nexport const calculateScaleFactor = (sourceDimensions, targetDimensions, contain = true) => {\n    const sourceRatio = sourceDimensions.width / sourceDimensions.height;\n    const targetRatio = targetDimensions.width / targetDimensions.height;\n    // If contain is true, the entire source must fit within target\n    // If contain is false, the source must cover the entire target\n    if ((contain && sourceRatio > targetRatio) || (!contain && sourceRatio < targetRatio)) {\n        // Width limited\n        return targetDimensions.width / sourceDimensions.width;\n    }\n    else {\n        // Height limited\n        return targetDimensions.height / sourceDimensions.height;\n    }\n};\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// Data synchronization service for handling online/offline state\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { useUserStore } from '../store/userStore';\nimport useRecommendationStore from '../store/recommendationStore';\nimport { UserApi } from '../api/userApi';\nimport { ApiClient } from '../api/apiClient';\nimport { getWithExpiry, setWithExpiry } from '../utils/localStorage';\n// Constants for sync operation\nconst SYNC_INTERVAL = 30000; // 30 seconds\nconst SYNC_STORAGE_PREFIX = 'stylist_sync_';\nconst SYNC_LAST_TIMESTAMP = 'stylist_last_sync';\nconst SYNC_QUEUE_KEY = 'stylist_sync_queue';\nconst SYNC_EXPIRY = 7 * 24 * 60 * 60; // 7 days in seconds\n// Sync operation types\nexport var SyncOperationType;\n(function (SyncOperationType) {\n    SyncOperationType[\"ADD_CLOSET_ITEM\"] = \"ADD_CLOSET_ITEM\";\n    SyncOperationType[\"REMOVE_CLOSET_ITEM\"] = \"REMOVE_CLOSET_ITEM\";\n    SyncOperationType[\"UPDATE_CLOSET_ITEM\"] = \"UPDATE_CLOSET_ITEM\";\n    SyncOperationType[\"TOGGLE_FAVORITE\"] = \"TOGGLE_FAVORITE\";\n    SyncOperationType[\"UPDATE_PREFERENCES\"] = \"UPDATE_PREFERENCES\";\n    SyncOperationType[\"SUBMIT_QUIZ\"] = \"SUBMIT_QUIZ\";\n    SyncOperationType[\"ADD_LIKED_ITEM\"] = \"ADD_LIKED_ITEM\";\n    SyncOperationType[\"ADD_DISLIKED_ITEM\"] = \"ADD_DISLIKED_ITEM\";\n    SyncOperationType[\"REMOVE_LIKED_ITEM\"] = \"REMOVE_LIKED_ITEM\";\n    SyncOperationType[\"REMOVE_DISLIKED_ITEM\"] = \"REMOVE_DISLIKED_ITEM\";\n    SyncOperationType[\"SAVE_OUTFIT\"] = \"SAVE_OUTFIT\";\n    SyncOperationType[\"REMOVE_OUTFIT\"] = \"REMOVE_OUTFIT\";\n})(SyncOperationType || (SyncOperationType = {}));\n// Create API client for sync operations\nimport { API_URL, API_TIMEOUT, MAX_RETRY_ATTEMPTS } from '@/utils/environment';\nconst createSyncApiClient = () => {\n    const apiClient = new ApiClient({\n        baseURL: API_URL,\n        timeout: API_TIMEOUT,\n        maxRetries: MAX_RETRY_ATTEMPTS,\n        getAuthHeader: () => {\n            const token = localStorage.getItem('stylist_auth_token');\n            return token ? { Authorization: `Bearer ${token}` } : { Authorization: '' };\n        }\n    });\n    return new UserApi(apiClient);\n};\n// Main sync service hook\nexport const useSyncService = () => {\n    const [state, setState] = useState({\n        isOnline: navigator.onLine,\n        isSyncing: false,\n        lastSyncTimestamp: Number(localStorage.getItem(SYNC_LAST_TIMESTAMP)) || null,\n        pendingOperations: 0,\n        syncQueue: []\n    });\n    const userStore = useUserStore();\n    const recommendationStore = useRecommendationStore();\n    const syncIntervalRef = useRef(null);\n    const apiClient = useRef(createSyncApiClient());\n    // Load sync queue from localStorage\n    const loadSyncQueue = useCallback(() => {\n        const queueStr = localStorage.getItem(SYNC_QUEUE_KEY);\n        if (!queueStr)\n            return [];\n        try {\n            return JSON.parse(queueStr);\n        }\n        catch (error) {\n            console.error('Failed to parse sync queue:', error);\n            return [];\n        }\n    }, []);\n    // Save sync queue to localStorage\n    const saveSyncQueue = useCallback((queue) => {\n        try {\n            localStorage.setItem(SYNC_QUEUE_KEY, JSON.stringify(queue));\n        }\n        catch (error) {\n            console.error('Failed to save sync queue:', error);\n        }\n    }, []);\n    // Initialize or update sync queue\n    useEffect(() => {\n        const queue = loadSyncQueue();\n        setState(prev => (Object.assign(Object.assign({}, prev), { syncQueue: queue, pendingOperations: queue.filter(item => !item.resolved).length })));\n    }, [loadSyncQueue]);\n    // Online/offline status detection\n    useEffect(() => {\n        const handleOnline = () => {\n            setState(prev => (Object.assign(Object.assign({}, prev), { isOnline: true })));\n            // Trigger immediate sync when coming back online\n            syncData();\n        };\n        const handleOffline = () => {\n            setState(prev => (Object.assign(Object.assign({}, prev), { isOnline: false })));\n        };\n        window.addEventListener('online', handleOnline);\n        window.addEventListener('offline', handleOffline);\n        return () => {\n            window.removeEventListener('online', handleOnline);\n            window.removeEventListener('offline', handleOffline);\n        };\n    }, []);\n    // Add an operation to the sync queue\n    const queueOperation = useCallback((operation, data, userId) => {\n        const newItem = {\n            id: `sync_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,\n            timestamp: Date.now(),\n            userId,\n            operation,\n            data,\n            retryCount: 0,\n            resolved: false\n        };\n        setState(prev => {\n            const updatedQueue = [...prev.syncQueue, newItem];\n            saveSyncQueue(updatedQueue);\n            return Object.assign(Object.assign({}, prev), { syncQueue: updatedQueue, pendingOperations: updatedQueue.filter(item => !item.resolved).length });\n        });\n        // If online, try to sync immediately\n        if (navigator.onLine) {\n            syncData();\n        }\n    }, [saveSyncQueue]);\n    // Execute a specific operation against the API\n    const executeOperation = useCallback((item) => __awaiter(void 0, void 0, void 0, function* () {\n        const { operation, data, userId } = item;\n        try {\n            switch (operation) {\n                case SyncOperationType.ADD_CLOSET_ITEM:\n                    yield apiClient.current.addClosetItem(userId, data);\n                    break;\n                case SyncOperationType.REMOVE_CLOSET_ITEM:\n                    yield apiClient.current.removeClosetItem(userId, data.itemId);\n                    break;\n                case SyncOperationType.UPDATE_CLOSET_ITEM:\n                    yield apiClient.current.updateClosetItem(userId, data.itemId, data.updates);\n                    break;\n                case SyncOperationType.TOGGLE_FAVORITE:\n                    yield apiClient.current.toggleFavoriteItem(userId, data.itemId, data.favorite);\n                    break;\n                case SyncOperationType.UPDATE_PREFERENCES:\n                    yield apiClient.current.updatePreferences(userId, data);\n                    break;\n                case SyncOperationType.SUBMIT_QUIZ:\n                    yield apiClient.current.submitStyleQuiz(userId, data);\n                    break;\n                case SyncOperationType.SAVE_OUTFIT:\n                    // Implement when server API is available\n                    console.log('Saving outfit to server:', data);\n                    break;\n                case SyncOperationType.REMOVE_OUTFIT:\n                    // Implement when server API is available\n                    console.log('Removing outfit from server:', data);\n                    break;\n                case SyncOperationType.ADD_LIKED_ITEM:\n                case SyncOperationType.ADD_DISLIKED_ITEM:\n                case SyncOperationType.REMOVE_LIKED_ITEM:\n                case SyncOperationType.REMOVE_DISLIKED_ITEM:\n                    // These are handled in the full profile sync\n                    console.log('Preference feedback will be synced with full profile');\n                    break;\n                default:\n                    console.warn('Unknown operation type:', operation);\n                    return false;\n            }\n            return true;\n        }\n        catch (error) {\n            console.error(`Error executing operation ${operation}:`, error);\n            return false;\n        }\n    }), []);\n    // Detect and resolve conflicts between local and server data\n    const resolveConflicts = useCallback((localUser, serverUser) => {\n        if (!localUser || !serverUser)\n            return serverUser || localUser;\n        // Use the most recent data\n        const localTimestamp = new Date(localUser.lastActive).getTime();\n        const serverTimestamp = new Date(serverUser.lastActive).getTime();\n        // If server data is newer, use it as the base\n        let mergedUser = serverTimestamp > localTimestamp ? Object.assign({}, serverUser) : Object.assign({}, localUser);\n        // Special handling for closet items - merge them intelligently\n        const closetMap = new Map();\n        // Add all server items to the map\n        serverUser.closet.forEach(item => {\n            closetMap.set(item.id, item);\n        });\n        // Merge or override with local items based on timestamp\n        localUser.closet.forEach(localItem => {\n            const serverItem = closetMap.get(localItem.id);\n            if (!serverItem) {\n                // Item exists only locally, add it\n                closetMap.set(localItem.id, localItem);\n            }\n            else {\n                // Item exists in both - use the newer one\n                const localItemTime = new Date(localItem.dateAdded).getTime();\n                const serverItemTime = new Date(serverItem.dateAdded).getTime();\n                if (localItemTime > serverItemTime) {\n                    closetMap.set(localItem.id, localItem);\n                }\n            }\n        });\n        // Convert map back to array\n        mergedUser.closet = Array.from(closetMap.values());\n        // Merge feedback data - use sets to avoid duplicates\n        const likedItems = new Set([...serverUser.feedback.likedItems, ...localUser.feedback.likedItems]);\n        const dislikedItems = new Set([...serverUser.feedback.dislikedItems, ...localUser.feedback.dislikedItems]);\n        const viewedItems = new Set([...serverUser.feedback.viewedItems, ...localUser.feedback.viewedItems]);\n        // For saved outfits, keep all from both sources (can refine this later)\n        // This is a simple approach, could be enhanced with more sophisticated merging\n        const savedOutfits = [...serverUser.feedback.savedOutfits];\n        localUser.feedback.savedOutfits.forEach(localOutfit => {\n            if (!savedOutfits.some(outfit => outfit.length === localOutfit.length &&\n                outfit.every(id => localOutfit.includes(id)))) {\n                savedOutfits.push(localOutfit);\n            }\n        });\n        // Update feedback with merged data\n        mergedUser.feedback = Object.assign(Object.assign({}, mergedUser.feedback), { likedItems: Array.from(likedItems), dislikedItems: Array.from(dislikedItems), viewedItems: Array.from(viewedItems), savedOutfits, lastInteraction: new Date(Math.max(new Date(localUser.feedback.lastInteraction).getTime(), new Date(serverUser.feedback.lastInteraction).getTime())) });\n        return mergedUser;\n    }, []);\n    // Pull latest data from the server and merge with local state\n    const syncWithServer = useCallback((userId) => __awaiter(void 0, void 0, void 0, function* () {\n        if (!userId)\n            return;\n        try {\n            // Get user profile from server\n            const serverUser = yield apiClient.current.getUserProfile(userId);\n            // Get local user profile from store\n            const localUser = userStore.user;\n            if (serverUser && localUser) {\n                // Resolve conflicts and update local state\n                const mergedUser = resolveConflicts(localUser, serverUser);\n                userStore.setUser(mergedUser);\n            }\n            else if (serverUser) {\n                // No local user, just use server data\n                userStore.setUser(serverUser);\n            }\n            else if (localUser) {\n                // No server user, upload local data\n                console.log('Server user not found, will upload local data on next sync');\n            }\n            // Update last sync timestamp\n            const now = Date.now();\n            localStorage.setItem(SYNC_LAST_TIMESTAMP, now.toString());\n            setState(prev => (Object.assign(Object.assign({}, prev), { lastSyncTimestamp: now })));\n        }\n        catch (error) {\n            console.error('Error syncing with server:', error);\n        }\n    }), [userStore, resolveConflicts]);\n    // Main sync function - processes the sync queue and syncs with server\n    const syncData = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        var _a;\n        // Skip if already syncing or offline\n        if (state.isSyncing || !navigator.onLine || !userStore.user)\n            return;\n        setState(prev => (Object.assign(Object.assign({}, prev), { isSyncing: true })));\n        try {\n            // Load the latest queue\n            const queue = loadSyncQueue();\n            const pendingItems = queue.filter(item => !item.resolved);\n            if (pendingItems.length > 0) {\n                // Process pending operations\n                const updatedQueue = [...queue];\n                for (const item of pendingItems) {\n                    // Skip if already resolved\n                    if (item.resolved)\n                        continue;\n                    // Try to execute the operation\n                    const success = yield executeOperation(item);\n                    if (success) {\n                        // Mark as resolved if successful\n                        const index = updatedQueue.findIndex(q => q.id === item.id);\n                        if (index !== -1) {\n                            updatedQueue[index] = Object.assign(Object.assign({}, updatedQueue[index]), { resolved: true });\n                        }\n                    }\n                    else {\n                        // Increment retry count if failed\n                        const index = updatedQueue.findIndex(q => q.id === item.id);\n                        if (index !== -1) {\n                            const retryCount = updatedQueue[index].retryCount + 1;\n                            // If retried too many times, mark as resolved to prevent endless retries\n                            const resolved = retryCount >= 5;\n                            updatedQueue[index] = Object.assign(Object.assign({}, updatedQueue[index]), { retryCount,\n                                resolved });\n                        }\n                    }\n                }\n                // Save updated queue\n                saveSyncQueue(updatedQueue);\n                // Update state\n                setState(prev => (Object.assign(Object.assign({}, prev), { syncQueue: updatedQueue, pendingOperations: updatedQueue.filter(item => !item.resolved).length })));\n            }\n            // Pull latest data from server and merge with local state\n            yield syncWithServer(((_a = userStore.user) === null || _a === void 0 ? void 0 : _a.userId) || '');\n        }\n        catch (error) {\n            console.error('Error during sync:', error);\n        }\n        finally {\n            setState(prev => (Object.assign(Object.assign({}, prev), { isSyncing: false })));\n        }\n    }), [state.isSyncing, userStore.user, loadSyncQueue, executeOperation, saveSyncQueue, syncWithServer]);\n    // Set up periodic sync\n    useEffect(() => {\n        if (syncIntervalRef.current) {\n            window.clearInterval(syncIntervalRef.current);\n        }\n        syncIntervalRef.current = window.setInterval(() => {\n            if (navigator.onLine && userStore.user) {\n                syncData();\n            }\n        }, SYNC_INTERVAL);\n        return () => {\n            if (syncIntervalRef.current) {\n                window.clearInterval(syncIntervalRef.current);\n            }\n        };\n    }, [syncData, userStore.user]);\n    // Public API for the hook\n    return {\n        state,\n        syncNow: syncData,\n        // Queue specific operations\n        addClosetItem: (item, userId) => {\n            queueOperation(SyncOperationType.ADD_CLOSET_ITEM, item, userId);\n        },\n        removeClosetItem: (itemId, userId) => {\n            queueOperation(SyncOperationType.REMOVE_CLOSET_ITEM, { itemId }, userId);\n        },\n        updateClosetItem: (itemId, updates, userId) => {\n            queueOperation(SyncOperationType.UPDATE_CLOSET_ITEM, { itemId, updates }, userId);\n        },\n        toggleFavorite: (itemId, favorite, userId) => {\n            queueOperation(SyncOperationType.TOGGLE_FAVORITE, { itemId, favorite }, userId);\n        },\n        updatePreferences: (preferences, userId) => {\n            queueOperation(SyncOperationType.UPDATE_PREFERENCES, preferences, userId);\n        },\n        submitQuiz: (answers, userId) => {\n            queueOperation(SyncOperationType.SUBMIT_QUIZ, answers, userId);\n        },\n        saveOutfit: (outfit, userId) => {\n            queueOperation(SyncOperationType.SAVE_OUTFIT, outfit, userId);\n        },\n        removeOutfit: (outfitId, userId) => {\n            queueOperation(SyncOperationType.REMOVE_OUTFIT, { outfitId }, userId);\n        }\n    };\n};\n// Utility function to check if data needs to be synced\nexport const needsSync = () => {\n    const lastSync = localStorage.getItem(SYNC_LAST_TIMESTAMP);\n    if (!lastSync)\n        return true;\n    const lastSyncTime = parseInt(lastSync, 10);\n    const now = Date.now();\n    // Sync if more than 15 minutes have passed\n    return now - lastSyncTime > 15 * 60 * 1000;\n};\n// Utility to get the status of the sync queue\nexport const getSyncStatus = () => {\n    const queueStr = localStorage.getItem(SYNC_QUEUE_KEY);\n    let pendingCount = 0;\n    if (queueStr) {\n        try {\n            const queue = JSON.parse(queueStr);\n            pendingCount = queue.filter((item) => !item.resolved).length;\n        }\n        catch (error) {\n            console.error('Error parsing sync queue:', error);\n        }\n    }\n    return {\n        pendingCount,\n        isOnline: navigator.onLine\n    };\n};\n// Utility to get sync data for specific user\nexport const getUserSyncData = (userId) => {\n    const key = `${SYNC_STORAGE_PREFIX}${userId}`;\n    return getWithExpiry(key);\n};\n// Utility to store sync data for specific user\nexport const storeUserSyncData = (userId, data) => {\n    const key = `${SYNC_STORAGE_PREFIX}${userId}`;\n    setWithExpiry(key, data, SYNC_EXPIRY);\n};\n","// Utilities for file handling and image loading\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * Load an image from a URL and get its dimensions\n */\nexport const loadImage = (url) => {\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.crossOrigin = 'anonymous'; // Enable CORS if possible\n        img.onload = () => {\n            resolve(img);\n        };\n        img.onerror = (error) => {\n            reject(new Error(`Failed to load image: ${error}`));\n        };\n        img.src = url;\n    });\n};\n/**\n * Get image dimensions\n */\nexport const getImageDimensions = (imageUrl) => __awaiter(void 0, void 0, void 0, function* () {\n    const img = yield loadImage(imageUrl);\n    return {\n        width: img.width,\n        height: img.height\n    };\n});\n/**\n * Convert a File to a data URL\n */\nexport const fileToDataUrl = (file) => {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = (e) => {\n            var _a;\n            if ((_a = e.target) === null || _a === void 0 ? void 0 : _a.result) {\n                resolve(e.target.result);\n            }\n            else {\n                reject(new Error('Failed to convert file to data URL'));\n            }\n        };\n        reader.onerror = (error) => {\n            reject(error);\n        };\n        reader.readAsDataURL(file);\n    });\n};\n/**\n * Check if a file is an image\n */\nexport const isImageFile = (file) => {\n    return file.type.startsWith('image/');\n};\n/**\n * Get the size of a file in a human-readable format\n */\nexport const getFormattedFileSize = (sizeInBytes) => {\n    if (sizeInBytes < 1024) {\n        return `${sizeInBytes} bytes`;\n    }\n    else if (sizeInBytes < 1024 * 1024) {\n        return `${(sizeInBytes / 1024).toFixed(1)} KB`;\n    }\n    else {\n        return `${(sizeInBytes / (1024 * 1024)).toFixed(1)} MB`;\n    }\n};\n/**\n * Create a blob URL from a data URL\n */\nexport const dataUrlToBlob = (dataUrl) => {\n    // Extract the base64 data\n    const base64Data = dataUrl.split(',')[1];\n    const contentType = dataUrl.split(',')[0].split(':')[1].split(';')[0];\n    // Decode base64 data\n    const byteCharacters = atob(base64Data);\n    const byteArrays = [];\n    for (let offset = 0; offset < byteCharacters.length; offset += 512) {\n        const slice = byteCharacters.slice(offset, offset + 512);\n        const byteNumbers = new Array(slice.length);\n        for (let i = 0; i < slice.length; i++) {\n            byteNumbers[i] = slice.charCodeAt(i);\n        }\n        const byteArray = new Uint8Array(byteNumbers);\n        byteArrays.push(byteArray);\n    }\n    const blob = new Blob(byteArrays, { type: contentType });\n    return URL.createObjectURL(blob);\n};\n/**\n * Get an image file's information\n */\nexport const getImageInfo = (file) => __awaiter(void 0, void 0, void 0, function* () {\n    const url = yield fileToDataUrl(file);\n    const img = yield loadImage(url);\n    return {\n        id: `img_${Date.now()}_${Math.floor(Math.random() * 1000)}`,\n        url,\n        file,\n        dimensions: {\n            width: img.width,\n            height: img.height\n        },\n        originalDimensions: {\n            width: img.width,\n            height: img.height\n        },\n        withoutBackground: false,\n        processed: false\n    };\n});\n","// Feedback synchronization service\n// This service periodically syncs locally stored feedback with the backend\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { createStylistApi } from '@/api';\nimport { useFeedbackStore } from '@/store/feedbackStore';\nimport { getUserId } from '@/utils/localStorage';\nimport { trackEvent, AnalyticsEventType } from '@/utils/analytics';\n// Initialize lifecycle log\nconsole.log('[LIFECYCLE:FeedbackSync] Module load started');\nexport class FeedbackSyncService {\n    constructor() {\n        this.syncIntervalId = null;\n        this.syncInterval = 60000; // 1 minute\n        this.isInitialized = false;\n        this.apiConfig = null;\n    }\n    /**\n     * Initialize the feedback sync service\n     */\n    initialize(apiConfig) {\n        console.log('[LIFECYCLE:FeedbackSync] Initialize called', {\n            isAlreadyInitialized: this.isInitialized,\n            apiKeyProvided: !!(apiConfig === null || apiConfig === void 0 ? void 0 : apiConfig.apiKey),\n            retailerIdProvided: !!(apiConfig === null || apiConfig === void 0 ? void 0 : apiConfig.retailerId)\n        });\n        if (this.isInitialized) {\n            console.log('[LIFECYCLE:FeedbackSync] Already initialized, skipping');\n            return;\n        }\n        console.log('[LIFECYCLE:FeedbackSync] Setting up service with config');\n        this.apiConfig = apiConfig;\n        this.isInitialized = true;\n        // Register with the network online/offline events\n        console.log('[LIFECYCLE:FeedbackSync] Adding online/offline event listeners');\n        window.addEventListener('online', this.handleOnline.bind(this));\n        window.addEventListener('offline', this.handleOffline.bind(this));\n        // Delay sync initialization to avoid blocking initial render\n        console.log('[LIFECYCLE:FeedbackSync] Setting initialization delay timeout (3000ms)');\n        setTimeout(() => {\n            console.log('[LIFECYCLE:FeedbackSync] Initialization delay completed, checking online status');\n            // Check if currently online and start sync if needed\n            if (navigator.onLine) {\n                console.log('[LIFECYCLE:FeedbackSync] Device is online, starting sync interval');\n                this.startSyncInterval();\n            }\n            else {\n                console.log('[LIFECYCLE:FeedbackSync] Device is offline, deferring sync');\n            }\n        }, 3000); // 3-second delay to ensure widget loads smoothly\n    }\n    /**\n     * Start the sync interval\n     */\n    startSyncInterval() {\n        console.log('[LIFECYCLE:FeedbackSync] startSyncInterval called', {\n            hasExistingInterval: this.syncIntervalId !== null\n        });\n        if (this.syncIntervalId !== null) {\n            console.log('[LIFECYCLE:FeedbackSync] Sync interval already active, skipping');\n            return;\n        }\n        // Perform initial sync\n        console.log('[LIFECYCLE:FeedbackSync] Performing initial feedback sync');\n        this.syncFeedback();\n        // Set up recurring sync\n        console.log(`[LIFECYCLE:FeedbackSync] Setting up recurring sync every ${this.syncInterval}ms`);\n        this.syncIntervalId = window.setInterval(() => {\n            console.log('[LIFECYCLE:FeedbackSync] Recurring sync interval triggered');\n            this.syncFeedback();\n        }, this.syncInterval);\n    }\n    /**\n     * Stop the sync interval\n     */\n    stopSyncInterval() {\n        console.log('[LIFECYCLE:FeedbackSync] stopSyncInterval called', {\n            hasActiveInterval: this.syncIntervalId !== null\n        });\n        if (this.syncIntervalId === null) {\n            console.log('[LIFECYCLE:FeedbackSync] No active sync interval to stop');\n            return;\n        }\n        console.log('[LIFECYCLE:FeedbackSync] Clearing sync interval');\n        window.clearInterval(this.syncIntervalId);\n        this.syncIntervalId = null;\n        console.log('[LIFECYCLE:FeedbackSync] Sync interval stopped');\n    }\n    /**\n     * Handle online event\n     */\n    handleOnline() {\n        console.log('[LIFECYCLE:FeedbackSync] Online event detected');\n        this.startSyncInterval();\n    }\n    /**\n     * Handle offline event\n     */\n    handleOffline() {\n        console.log('[LIFECYCLE:FeedbackSync] Offline event detected');\n        this.stopSyncInterval();\n    }\n    /**\n     * Sync feedback with the backend\n     */\n    syncFeedback() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log('[LIFECYCLE:FeedbackSync] syncFeedback called', {\n                isInitialized: this.isInitialized,\n                hasApiConfig: !!this.apiConfig\n            });\n            if (!this.isInitialized || !this.apiConfig) {\n                console.log('[LIFECYCLE:FeedbackSync] Cannot sync - not initialized or missing config');\n                return;\n            }\n            const feedbackStore = useFeedbackStore.getState();\n            const pendingItems = feedbackStore.getPendingSyncItems();\n            console.log('[LIFECYCLE:FeedbackSync] Pending feedback items:', pendingItems.length);\n            // No items to sync\n            if (pendingItems.length === 0) {\n                console.log('[LIFECYCLE:FeedbackSync] No pending items to sync');\n                return;\n            }\n            // Don't try to sync if already syncing\n            if (feedbackStore.isSyncing) {\n                console.log('[LIFECYCLE:FeedbackSync] Already syncing, skipping');\n                return;\n            }\n            try {\n                console.log('[LIFECYCLE:FeedbackSync] Starting sync process');\n                feedbackStore.setIsSyncing(true);\n                const userId = getUserId();\n                console.log('[LIFECYCLE:FeedbackSync] Creating API client for sync');\n                const api = createStylistApi(this.apiConfig);\n                console.log('[LIFECYCLE:FeedbackSync] Sending sync request to API', {\n                    userId,\n                    itemCount: pendingItems.length\n                });\n                const response = yield api.feedback.syncFeedback({\n                    userId,\n                    feedbackItems: pendingItems\n                });\n                console.log('[LIFECYCLE:FeedbackSync] Sync response received', {\n                    success: response.success,\n                    syncedCount: ((_a = response.syncedItemIds) === null || _a === void 0 ? void 0 : _a.length) || 0\n                });\n                if (response.success && response.syncedItemIds.length > 0) {\n                    // Mark items as synced\n                    console.log('[LIFECYCLE:FeedbackSync] Marking items as synced');\n                    feedbackStore.markAsSynced(response.syncedItemIds);\n                    // Track successful sync\n                    console.log('[LIFECYCLE:FeedbackSync] Tracking sync event');\n                    trackEvent(AnalyticsEventType.FEEDBACK_SYNCED, userId, {\n                        count: response.syncedItemIds.length\n                    });\n                }\n            }\n            catch (error) {\n                console.error('[LIFECYCLE:FeedbackSync] Error syncing feedback:', error);\n            }\n            finally {\n                console.log('[LIFECYCLE:FeedbackSync] Completing sync process');\n                feedbackStore.setIsSyncing(false);\n            }\n        });\n    }\n    /**\n     * Clean up resources\n     */\n    cleanup() {\n        console.log('[LIFECYCLE:FeedbackSync] Cleanup called');\n        this.stopSyncInterval();\n        console.log('[LIFECYCLE:FeedbackSync] Removing event listeners');\n        window.removeEventListener('online', this.handleOnline.bind(this));\n        window.removeEventListener('offline', this.handleOffline.bind(this));\n        this.isInitialized = false;\n        console.log('[LIFECYCLE:FeedbackSync] Service marked as uninitialized');\n    }\n}\n// Create singleton instance\nexport const feedbackSyncService = new FeedbackSyncService();\n","// Utilities for canvas manipulation\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * Draw an image onto a canvas with a specified position, scale, and rotation\n */\nexport const drawImageToCanvas = (ctx, image, rect, rotation = 0, flipHorizontal = false, flipVertical = false) => {\n    // Save the current state\n    ctx.save();\n    // Move to the center of where we want to draw the image\n    const centerX = rect.x + rect.width / 2;\n    const centerY = rect.y + rect.height / 2;\n    ctx.translate(centerX, centerY);\n    // Rotate if needed\n    if (rotation !== 0) {\n        ctx.rotate((rotation * Math.PI) / 180); // Convert degrees to radians\n    }\n    // Scale (and flip) if needed\n    const scaleX = flipHorizontal ? -1 : 1;\n    const scaleY = flipVertical ? -1 : 1;\n    ctx.scale(scaleX, scaleY);\n    // Draw the image centered\n    ctx.drawImage(image, -rect.width / 2, -rect.height / 2, rect.width, rect.height);\n    // Restore the context\n    ctx.restore();\n};\n/**\n * Optimized version of drawImageToCanvas for low-performance devices\n * Skips some rendering features for better performance\n */\nexport const drawImageToCanvasLowQuality = (ctx, image, rect, rotation = 0, flipHorizontal = false, flipVertical = false) => {\n    // For low quality rendering, skip rotation if it's minimal\n    if (Math.abs(rotation) < 5) {\n        rotation = 0;\n    }\n    // Use the standard drawing function but with integer positions\n    // to avoid subpixel rendering which can be expensive\n    const optimizedRect = {\n        x: Math.round(rect.x),\n        y: Math.round(rect.y),\n        width: Math.round(rect.width),\n        height: Math.round(rect.height)\n    };\n    // Use standard drawing function with optimized rectangle\n    drawImageToCanvas(ctx, image, optimizedRect, rotation, flipHorizontal, flipVertical);\n};\n/**\n * Compose multiple images onto a canvas in specified order\n */\nexport const compositeImages = (canvas, userImage, garments, loadImage) => __awaiter(void 0, void 0, void 0, function* () {\n    const ctx = canvas.getContext('2d');\n    if (!ctx)\n        return;\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    // Draw user image\n    ctx.drawImage(userImage, 0, 0, canvas.width, canvas.height);\n    // Sort garments by zIndex\n    const sortedGarments = [...garments].sort((a, b) => a.zIndex - b.zIndex);\n    // Draw each garment\n    for (const garment of sortedGarments) {\n        try {\n            const garmentImage = yield loadImage(garment.url);\n            // Calculate position and dimensions\n            const dimensions = garment.dimensions || {\n                width: garmentImage.width,\n                height: garmentImage.height\n            };\n            const scale = garment.scale || 1;\n            const scaledDimensions = {\n                width: dimensions.width * scale,\n                height: dimensions.height * scale\n            };\n            const offset = garment.offset || { x: 0, y: 0 };\n            const position = {\n                x: (canvas.width - scaledDimensions.width) / 2 + offset.x,\n                y: (canvas.height - scaledDimensions.height) / 2 + offset.y,\n                width: scaledDimensions.width,\n                height: scaledDimensions.height\n            };\n            // Draw the garment\n            drawImageToCanvas(ctx, garmentImage, position, garment.rotation || 0, garment.flipHorizontal || false, garment.flipVertical || false);\n        }\n        catch (error) {\n            console.error(`Failed to load or draw garment ${garment.id}:`, error);\n        }\n    }\n});\n/**\n * Low-quality implementation of compositeImages for performance-constrained devices\n */\nexport const compositeImagesLowQuality = (canvas, userImage, garments, loadImage) => __awaiter(void 0, void 0, void 0, function* () {\n    const ctx = canvas.getContext('2d', { alpha: false });\n    if (!ctx)\n        return;\n    // Use a lower quality flag if available on the context\n    const ctx2d = ctx;\n    if (ctx2d.imageSmoothingQuality) {\n        ctx2d.imageSmoothingQuality = 'low';\n    }\n    // Use lower resolution for the canvas during processing\n    const originalWidth = canvas.width;\n    const originalHeight = canvas.height;\n    const scaleFactor = 0.75; // Reduce canvas size for processing\n    // Temporarily resize canvas to improve performance\n    canvas.width = Math.round(originalWidth * scaleFactor);\n    canvas.height = Math.round(originalHeight * scaleFactor);\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    // Draw user image at reduced resolution\n    ctx.drawImage(userImage, 0, 0, canvas.width, canvas.height);\n    // Sort garments by zIndex\n    const sortedGarments = [...garments].sort((a, b) => a.zIndex - b.zIndex);\n    // Keep track of loaded images to avoid reloading\n    const imageCache = new Map();\n    // Draw each garment\n    for (const garment of sortedGarments) {\n        try {\n            // Use cached image if available\n            let garmentImage;\n            if (imageCache.has(garment.url)) {\n                garmentImage = imageCache.get(garment.url);\n            }\n            else {\n                garmentImage = yield loadImage(garment.url);\n                imageCache.set(garment.url, garmentImage);\n            }\n            // Calculate position and dimensions\n            const dimensions = garment.dimensions || {\n                width: garmentImage.width,\n                height: garmentImage.height\n            };\n            const scale = (garment.scale || 1) * scaleFactor;\n            const scaledDimensions = {\n                width: dimensions.width * scale,\n                height: dimensions.height * scale\n            };\n            const offset = garment.offset\n                ? { x: garment.offset.x * scaleFactor, y: garment.offset.y * scaleFactor }\n                : { x: 0, y: 0 };\n            const position = {\n                x: (canvas.width - scaledDimensions.width) / 2 + offset.x,\n                y: (canvas.height - scaledDimensions.height) / 2 + offset.y,\n                width: scaledDimensions.width,\n                height: scaledDimensions.height\n            };\n            // Round all values to integers for better performance\n            Object.keys(position).forEach(key => {\n                position[key] = Math.round(position[key]);\n            });\n            // Draw the garment with optimized rendering\n            drawImageToCanvasLowQuality(ctx, garmentImage, position, garment.rotation || 0, garment.flipHorizontal || false, garment.flipVertical || false);\n        }\n        catch (error) {\n            console.error(`Failed to load or draw garment ${garment.id}:`, error);\n        }\n    }\n    // Create a temporary canvas to hold the low-res result\n    const tempCanvas = document.createElement('canvas');\n    tempCanvas.width = canvas.width;\n    tempCanvas.height = canvas.height;\n    const tempCtx = tempCanvas.getContext('2d');\n    if (tempCtx) {\n        tempCtx.drawImage(canvas, 0, 0);\n        // Restore original canvas size\n        canvas.width = originalWidth;\n        canvas.height = originalHeight;\n        // Scale back to original size\n        ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);\n    }\n    else {\n        // Fallback if temporary canvas failed\n        // Restore original canvas size\n        canvas.width = originalWidth;\n        canvas.height = originalHeight;\n        // Redraw at original resolution\n        ctx.drawImage(userImage, 0, 0, canvas.width, canvas.height);\n        // Basic draw operation for garments if we couldn't use the optimization\n        for (const garment of sortedGarments) {\n            try {\n                const garmentImage = imageCache.get(garment.url) || (yield loadImage(garment.url));\n                const dimensions = garment.dimensions || {\n                    width: garmentImage.width,\n                    height: garmentImage.height\n                };\n                const scale = garment.scale || 1;\n                const scaledDimensions = {\n                    width: dimensions.width * scale,\n                    height: dimensions.height * scale\n                };\n                const offset = garment.offset || { x: 0, y: 0 };\n                const position = {\n                    x: (canvas.width - scaledDimensions.width) / 2 + offset.x,\n                    y: (canvas.height - scaledDimensions.height) / 2 + offset.y,\n                    width: scaledDimensions.width,\n                    height: scaledDimensions.height\n                };\n                drawImageToCanvas(ctx, garmentImage, position, garment.rotation || 0, garment.flipHorizontal || false, garment.flipVertical || false);\n            }\n            catch (error) {\n                console.error(`Failed in fallback rendering for garment ${garment.id}:`, error);\n            }\n        }\n    }\n});\n/**\n * Create an image from a canvas\n */\nexport const canvasToImage = (canvas) => {\n    return new Promise((resolve, reject) => {\n        try {\n            // Convert canvas to data URL\n            const dataUrl = canvas.toDataURL('image/png');\n            resolve(dataUrl);\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n};\n/**\n * Low-quality version of canvasToImage that produces a smaller file\n */\nexport const canvasToImageLowQuality = (canvas) => {\n    return new Promise((resolve, reject) => {\n        try {\n            // Convert canvas to data URL with JPEG for smaller size\n            const dataUrl = canvas.toDataURL('image/jpeg', 0.8);\n            resolve(dataUrl);\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n};\n/**\n * Fill canvas with color or pattern\n */\nexport const fillCanvas = (canvas, fillStyle) => {\n    const ctx = canvas.getContext('2d');\n    if (!ctx)\n        return;\n    ctx.fillStyle = fillStyle;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n};\n/**\n * Draw grid lines for positioning guidance\n */\nexport const drawGuidelines = (canvas, lineColor = 'rgba(0, 0, 255, 0.2)', lineWidth = 1) => {\n    const ctx = canvas.getContext('2d');\n    if (!ctx)\n        return;\n    ctx.save();\n    // Set line style\n    ctx.strokeStyle = lineColor;\n    ctx.lineWidth = lineWidth;\n    // Draw horizontal lines\n    for (let i = 1; i < 3; i++) {\n        const y = (canvas.height / 3) * i;\n        ctx.beginPath();\n        ctx.moveTo(0, y);\n        ctx.lineTo(canvas.width, y);\n        ctx.stroke();\n    }\n    // Draw vertical lines\n    for (let i = 1; i < 3; i++) {\n        const x = (canvas.width / 3) * i;\n        ctx.beginPath();\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, canvas.height);\n        ctx.stroke();\n    }\n    // Draw center cross\n    ctx.beginPath();\n    ctx.moveTo(canvas.width / 2, 0);\n    ctx.lineTo(canvas.width / 2, canvas.height);\n    ctx.moveTo(0, canvas.height / 2);\n    ctx.lineTo(canvas.width, canvas.height / 2);\n    ctx.stroke();\n    ctx.restore();\n};\n/**\n * Simpler version of guidelines for low-performance devices\n */\nexport const drawGuidelinesLowQuality = (canvas, lineColor = 'rgba(0, 0, 255, 0.2)', lineWidth = 1) => {\n    const ctx = canvas.getContext('2d');\n    if (!ctx)\n        return;\n    ctx.save();\n    // Set line style\n    ctx.strokeStyle = lineColor;\n    ctx.lineWidth = lineWidth;\n    // Draw only center cross for minimal rendering\n    ctx.beginPath();\n    ctx.moveTo(canvas.width / 2, 0);\n    ctx.lineTo(canvas.width / 2, canvas.height);\n    ctx.moveTo(0, canvas.height / 2);\n    ctx.lineTo(canvas.width, canvas.height / 2);\n    ctx.stroke();\n    ctx.restore();\n};\n/**\n * Resize an image to target dimensions\n */\nexport const resizeImage = (image, maxWidth, maxHeight) => {\n    const canvas = document.createElement('canvas');\n    let width = image.width;\n    let height = image.height;\n    // Calculate new dimensions\n    if (width > maxWidth || height > maxHeight) {\n        const ratio = Math.min(maxWidth / width, maxHeight / height);\n        width = Math.floor(width * ratio);\n        height = Math.floor(height * ratio);\n    }\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n        ctx.drawImage(image, 0, 0, width, height);\n    }\n    return canvas;\n};\n","// Enhanced ChatService with context awareness and advanced input features\n// src/services/chatService.ts\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { MessageSender, MessageType } from '@/types/index';\nimport { v4 as uuidv4 } from 'uuid';\nimport { trackMessageSent } from '@/services/analytics/analyticsService';\nimport { ANTHROPIC_API_KEY, CLAUDE_API_URL, CLAUDE_MODEL, FORCE_DEMO_MODE, USE_CLAUDE_DEMO } from '@/utils/environment';\nexport class ChatService {\n    constructor(recommendationApi, userId, userApi) {\n        this.conversationHistory = [];\n        this.conversationContext = [];\n        this.userContext = {\n            stylePreferences: {},\n            closetItems: [],\n            likedItems: [],\n            dislikedItems: [],\n            recentSearches: [],\n            recentInteractions: []\n        };\n        this.specialCommands = [];\n        this.recommendationApi = recommendationApi;\n        this.userApi = userApi;\n        this.userId = userId;\n        // Initialize Claude configuration\n        this.claudeConfig = {\n            apiKey: ANTHROPIC_API_KEY,\n            baseUrl: CLAUDE_API_URL,\n            modelName: CLAUDE_MODEL,\n            // Use fallback mode if API key is missing or demo mode is forced\n            fallbackMode: !ANTHROPIC_API_KEY || FORCE_DEMO_MODE\n        };\n        // Add initial context for the conversation\n        this.conversationContext = [\n            `You are an AI style assistant for a fashion recommendation platform called \"The Stylist\". \n      The current date is ${new Date().toLocaleDateString()}.\n      You help users discover clothing items and outfits that match their personal style.\n      Keep responses concise, helpful, and focus on providing personalized fashion advice.\n      When you recommend items, focus on why they would work for the user.\n      If you don't know something specific about fashion, you can suggest general style principles.\n      \n      Remember to be conversational yet professional. Reference the user's past preferences and items in their closet when relevant.\n      You can handle multiple types of input including text, image uploads for finding similar items, and URL inputs for specific product lookups.\n      `\n        ];\n        // Initialize special commands\n        this.initializeSpecialCommands();\n        // Initialize user context if possible\n        this.loadUserContext();\n        // For demo purposes, print helpful info about Claude status\n        if (USE_CLAUDE_DEMO) {\n            console.info('🤖 Claude demo mode is ENABLED - will provide realistic AI responses without API key');\n        }\n        if (FORCE_DEMO_MODE) {\n            console.info('🧪 Forced demo mode is ENABLED - using fallback for Claude API despite keys');\n        }\n        else if (ANTHROPIC_API_KEY) {\n            console.info('✅ Claude API key present - will attempt to use real Claude API');\n        }\n        else {\n            console.info('ℹ️ No Claude API key found - using rule-based fallback responses');\n        }\n    }\n    /**\n     * Initialize special commands/queries the chat can handle\n     */\n    /**\n     * Generate insights about trending items\n     */\n    generateTrendInsights(category, trendingItems) {\n        // Extract patterns from trending items\n        const brands = trendingItems.map(item => item.brand).filter(Boolean);\n        const uniqueBrands = [...new Set(brands)];\n        // Extract colors from trending items if they exist in the data\n        const colors = [];\n        trendingItems.forEach(item => {\n            if (item.colors && Array.isArray(item.colors)) {\n                colors.push(...item.colors);\n            }\n        });\n        const uniqueColors = [...new Set(colors)];\n        let insights = '';\n        if (category) {\n            insights += `Current ${category} trends are focused on `;\n        }\n        else {\n            insights += 'Current fashion trends are highlighting ';\n        }\n        // Add color insights if available\n        if (uniqueColors.length > 0) {\n            insights += `${uniqueColors.slice(0, 3).join(', ')} colors`;\n            // Add brand insights if available\n            if (uniqueBrands.length > 0) {\n                insights += ` with designers like ${uniqueBrands.slice(0, 2).join(' and ')} leading the way`;\n            }\n        }\n        // If no colors but have brands\n        else if (uniqueBrands.length > 0) {\n            insights += `styles from ${uniqueBrands.slice(0, 3).join(', ')}`;\n        }\n        // Generic fallback\n        else {\n            insights += 'innovative designs and fresh styles';\n        }\n        insights += '. These trends are expected to continue gaining popularity over the coming weeks.';\n        return insights;\n    }\n    initializeSpecialCommands() {\n        // Special command: Show me dresses for [event]\n        this.specialCommands.push({\n            pattern: /show\\s+me\\s+([\\w\\s]+)(?:\\s+for\\s+([\\w\\s]+))?/i,\n            handler: (text, matches) => __awaiter(this, void 0, void 0, function* () {\n                var _a, _b;\n                const itemType = ((_a = matches[1]) === null || _a === void 0 ? void 0 : _a.trim().toLowerCase()) || '';\n                const occasion = ((_b = matches[2]) === null || _b === void 0 ? void 0 : _b.trim().toLowerCase()) || '';\n                const context = occasion || itemType;\n                this.userContext.recentSearches.push(context);\n                const messages = [];\n                messages.push(this.createTextMessage(`I'd be happy to show you ${itemType}${occasion ? ` for ${occasion}` : ''}! Here are some recommendations:`, MessageSender.ASSISTANT));\n                yield this.addRecommendationMessage(messages, context);\n                return messages;\n            })\n        });\n        // Special command: Match this with my closet\n        this.specialCommands.push({\n            pattern: /match\\s+this\\s+with\\s+my\\s+closet/i,\n            handler: () => __awaiter(this, void 0, void 0, function* () {\n                const messages = [];\n                if (this.userContext.closetItems.length === 0) {\n                    messages.push(this.createTextMessage(\"I don't see any items in your closet yet. Would you like to add some items first? You can upload photos of your clothing to your closet.\", MessageSender.ASSISTANT));\n                    return messages;\n                }\n                messages.push(this.createTextMessage(\"Let me find items that would pair well with what's in your closet!\", MessageSender.ASSISTANT));\n                yield this.addRecommendationMessage(messages, 'closet_match');\n                return messages;\n            })\n        });\n        // Special command: Find under $[price]\n        this.specialCommands.push({\n            pattern: /find\\s+(?:items|clothes|clothing)?\\s*under\\s*\\$?(\\d+)/i,\n            handler: (text, matches) => __awaiter(this, void 0, void 0, function* () {\n                const priceLimit = parseInt(matches[1] || '0', 10);\n                const messages = [];\n                messages.push(this.createTextMessage(`Here are some stylish options under $${priceLimit}:`, MessageSender.ASSISTANT));\n                yield this.addRecommendationMessage(messages, `under_${priceLimit}`);\n                return messages;\n            })\n        });\n        // Special command: Complete this outfit\n        this.specialCommands.push({\n            pattern: /complete\\s+this\\s+outfit/i,\n            handler: () => __awaiter(this, void 0, void 0, function* () {\n                const messages = [];\n                messages.push(this.createTextMessage(\"I'll help you complete your outfit with these complementary pieces:\", MessageSender.ASSISTANT));\n                // Get a complete outfit recommendation\n                try {\n                    const recommendations = yield this.recommendationApi.getRecommendations({\n                        userId: this.userId,\n                        context: 'complete_outfit',\n                        includeOutfits: true,\n                        limit: 1\n                    });\n                    if (recommendations.outfits.length > 0) {\n                        // Add the outfit\n                        const outfit = recommendations.outfits[0];\n                        const chatOutfit = this.convertRecommendationOutfitToChatOutfit(outfit);\n                        messages.push(this.createOutfitMessage(chatOutfit));\n                    }\n                    else {\n                        // Fallback if no outfit is returned\n                        yield this.addRecommendationMessage(messages, 'outfit_pieces');\n                    }\n                }\n                catch (error) {\n                    console.error('Error getting outfit recommendations:', error);\n                    messages.push(this.createTextMessage(\"I'm having trouble finding the perfect outfit pieces right now. Please try again.\", MessageSender.SYSTEM));\n                }\n                return messages;\n            })\n        });\n        // Special command: What's trending in [category]\n        this.specialCommands.push({\n            pattern: /what(?:'s|\\s+is)\\s+trending\\s+(?:in\\s+)([\\w\\s]+)/i,\n            handler: (text, matches) => __awaiter(this, void 0, void 0, function* () {\n                var _c;\n                const category = ((_c = matches[1]) === null || _c === void 0 ? void 0 : _c.trim().toLowerCase()) || '';\n                const messages = [];\n                messages.push(this.createTextMessage(`Here are the top trending ${category} items right now:`, MessageSender.ASSISTANT));\n                yield this.addRecommendationMessage(messages, `trending_${category}`);\n                return messages;\n            })\n        });\n        // Special command: /outfit [item] - Generate complete outfit based on item\n        this.specialCommands.push({\n            pattern: /^\\/outfit(?:\\s+([\\w\\s]+))?$/i,\n            handler: (text, matches) => __awaiter(this, void 0, void 0, function* () {\n                var _d;\n                const itemType = ((_d = matches[1]) === null || _d === void 0 ? void 0 : _d.trim().toLowerCase()) || '';\n                const messages = [];\n                if (itemType) {\n                    messages.push(this.createTextMessage(`Creating a complete outfit based on ${itemType}. Here's what I recommend:`, MessageSender.ASSISTANT));\n                }\n                else {\n                    messages.push(this.createTextMessage(\"Let me create a complete outfit for you based on your style preferences:\", MessageSender.ASSISTANT));\n                }\n                // Get a complete outfit recommendation\n                try {\n                    const recommendations = yield this.recommendationApi.getRecommendations({\n                        userId: this.userId,\n                        context: itemType ? `outfit_${itemType}` : 'complete_outfit',\n                        includeOutfits: true,\n                        limit: 1\n                    });\n                    if (recommendations.outfits.length > 0) {\n                        // Add the outfit\n                        const outfit = recommendations.outfits[0];\n                        const chatOutfit = this.convertRecommendationOutfitToChatOutfit(outfit);\n                        messages.push(this.createOutfitMessage(chatOutfit));\n                        // Add explanation of the outfit\n                        messages.push(this.createTextMessage(`This outfit combines pieces that work well together based on color harmony, style consistency, and your preferences. Each item was selected to create a cohesive look that's appropriate for ${outfit.occasion || 'everyday wear'}.`, MessageSender.ASSISTANT));\n                    }\n                    else {\n                        // Fallback if no outfit is returned\n                        yield this.addRecommendationMessage(messages, itemType ? `items_${itemType}` : 'outfit_pieces');\n                    }\n                }\n                catch (error) {\n                    console.error('Error getting outfit recommendations:', error);\n                    messages.push(this.createTextMessage(\"I'm having trouble generating a complete outfit right now. Please try again.\", MessageSender.SYSTEM));\n                }\n                return messages;\n            })\n        });\n        // Special command: /trends [category] - Show trending items for a specific category\n        this.specialCommands.push({\n            pattern: /^\\/trends(?:\\s+([\\w\\s]+))?$/i,\n            handler: (text, matches) => __awaiter(this, void 0, void 0, function* () {\n                var _e;\n                const category = ((_e = matches[1]) === null || _e === void 0 ? void 0 : _e.trim().toLowerCase()) || '';\n                const messages = [];\n                if (category) {\n                    messages.push(this.createTextMessage(`Here are the trending ${category} items right now:`, MessageSender.ASSISTANT));\n                }\n                else {\n                    messages.push(this.createTextMessage(\"Here are the trending fashion items across all categories:\", MessageSender.ASSISTANT));\n                }\n                try {\n                    const recommendations = yield this.recommendationApi.getRecommendations({\n                        userId: this.userId,\n                        context: category ? `trending_${category}` : 'trending',\n                        trending: true,\n                        category: category || undefined,\n                        limit: 6\n                    });\n                    if (recommendations.items.length > 0) {\n                        // Generate trend insights\n                        const trendInsights = this.generateTrendInsights(category, recommendations.items);\n                        messages.push(this.createTextMessage(trendInsights, MessageSender.ASSISTANT));\n                        // Add recommendation message\n                        const chatItems = this.convertRecommendationItemsToChatItems(recommendations.items);\n                        messages.push(this.createRecommendationMessage(chatItems));\n                    }\n                    else {\n                        messages.push(this.createTextMessage(\"I couldn't find any trending items at the moment. Please try again later.\", MessageSender.SYSTEM));\n                    }\n                }\n                catch (error) {\n                    console.error('Error getting trending recommendations:', error);\n                    messages.push(this.createTextMessage(\"I'm having trouble finding trending items right now. Please try again.\", MessageSender.SYSTEM));\n                }\n                return messages;\n            })\n        });\n        // Special command: /quiz - Start the style quiz\n        this.specialCommands.push({\n            pattern: /^\\/quiz$/i,\n            handler: () => __awaiter(this, void 0, void 0, function* () {\n                const messages = [];\n                messages.push(this.createTextMessage(\"I've opened the style quiz for you! Complete it to help me understand your fashion preferences better.\", MessageSender.ASSISTANT));\n                messages.push(this.createTextMessage(\"After completing the quiz, I'll be able to provide more personalized recommendations that match your unique style profile.\", MessageSender.ASSISTANT));\n                return messages;\n            })\n        });\n        // Special command: /find [item] - Deep search functionality\n        this.specialCommands.push({\n            pattern: /^\\/find(?:\\s+([\\w\\s]+))?$/i,\n            handler: (text, matches) => __awaiter(this, void 0, void 0, function* () {\n                var _f;\n                const searchQuery = ((_f = matches[1]) === null || _f === void 0 ? void 0 : _f.trim()) || '';\n                const messages = [];\n                if (!searchQuery) {\n                    messages.push(this.createTextMessage(\"Please provide a search term after the /find command. For example: /find black dress\", MessageSender.SYSTEM));\n                    return messages;\n                }\n                messages.push(this.createTextMessage(`Searching across all inventory for \"${searchQuery}\"...`, MessageSender.ASSISTANT));\n                try {\n                    const recommendations = yield this.recommendationApi.getRecommendations({\n                        userId: this.userId,\n                        context: `search_${searchQuery}`,\n                        deepSearch: true,\n                        limit: 8\n                    });\n                    if (recommendations.items.length > 0) {\n                        messages.push(this.createTextMessage(`Here are the best matches for \"${searchQuery}\" from our complete inventory:`, MessageSender.ASSISTANT));\n                        // Add recommendation message\n                        const chatItems = this.convertRecommendationItemsToChatItems(recommendations.items);\n                        messages.push(this.createRecommendationMessage(chatItems));\n                    }\n                    else {\n                        messages.push(this.createTextMessage(`I couldn't find any items matching \"${searchQuery}\". Try a different search term or browse our trending items instead.`, MessageSender.ASSISTANT));\n                    }\n                }\n                catch (error) {\n                    console.error('Error performing deep search:', error);\n                    messages.push(this.createTextMessage(\"I'm having trouble searching our inventory right now. Please try again.\", MessageSender.SYSTEM));\n                }\n                return messages;\n            })\n        });\n    }\n    /**\n     * Process a user message and generate appropriate responses\n     */\n    processMessage(text) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Track the message sent\n            trackMessageSent(this.userId, text);\n            // Add to recent searches for context\n            this.userContext.recentSearches.push(text);\n            if (this.userContext.recentSearches.length > 5) {\n                this.userContext.recentSearches.shift();\n            }\n            // Update last message timestamp\n            this.userContext.lastMessageTimestamp = new Date();\n            // Initialize response messages array\n            const responseMessages = [];\n            // Create user message for conversation history\n            const userMessage = {\n                id: uuidv4(),\n                type: MessageType.TEXT,\n                sender: MessageSender.USER,\n                text,\n                timestamp: new Date()\n            };\n            // Add to conversation history\n            this.conversationHistory.push(userMessage);\n            // Check for special commands first\n            const specialCommandResponse = yield this.processSpecialCommands(text);\n            if (specialCommandResponse.length > 0) {\n                // Add responses to conversation history\n                this.conversationHistory.push(...specialCommandResponse);\n                return specialCommandResponse;\n            }\n            // Determine the intent for possible demo responses\n            const intent = this.categorizeIntent(text);\n            // Try to use Claude API if available and not in forced demo mode\n            if (!this.claudeConfig.fallbackMode) {\n                try {\n                    const claudeResponse = yield this.callClaudeAPI(text);\n                    // Add the response from Claude\n                    const responseMessage = this.createTextMessage(claudeResponse, MessageSender.ASSISTANT);\n                    // Add to conversation history\n                    this.conversationHistory.push(responseMessage);\n                    responseMessages.push(responseMessage);\n                    // Process for special instructions in Claude response\n                    if (this.containsRecommendationIntent(claudeResponse, text)) {\n                        // Add a recommendation message if Claude suggested showing items\n                        const additionalMessages = yield this.addRecommendationMessage([], this.extractContext(text));\n                        // Add to conversation history and response\n                        this.conversationHistory.push(...additionalMessages);\n                        responseMessages.push(...additionalMessages);\n                    }\n                    return responseMessages;\n                }\n                catch (error) {\n                    console.error('Error calling Claude API:', error);\n                    // Fall back to rule-based responses\n                }\n            }\n            // Check for demo response if Claude demo mode is enabled\n            const demoResponse = this.getDemoResponse(intent, text);\n            if (demoResponse) {\n                // This is a simulated Claude response in demo mode\n                const responseMessage = this.createTextMessage(demoResponse, MessageSender.ASSISTANT);\n                // Add to conversation history\n                this.conversationHistory.push(responseMessage);\n                responseMessages.push(responseMessage);\n                // If it's a wedding dress query, also add recommendations\n                if (intent === 'wedding_dress') {\n                    // Add a recommendation message after the initial response\n                    const additionalMessages = yield this.addRecommendationMessage([], 'wedding');\n                    // Add to conversation history and response\n                    this.conversationHistory.push(...additionalMessages);\n                    responseMessages.push(...additionalMessages);\n                }\n                return responseMessages;\n            }\n            // If no demo response and Claude is not available or failed, use rule-based approach\n            switch (intent) {\n                case 'recommendation':\n                    // Add a simple acknowledgment message\n                    const acknowledgeMessage = this.createTextMessage('I found some items that match your style! Here are my recommendations:', MessageSender.ASSISTANT);\n                    // Add to conversation history\n                    this.conversationHistory.push(acknowledgeMessage);\n                    responseMessages.push(acknowledgeMessage);\n                    // Get recommendations from API\n                    const additionalMessages = yield this.addRecommendationMessage([], this.extractContext(text));\n                    // Add to conversation history and response\n                    this.conversationHistory.push(...additionalMessages);\n                    responseMessages.push(...additionalMessages);\n                    break;\n                case 'style_quiz':\n                    const quizMessage = this.createTextMessage('Would you like to take our style quiz? It will help me understand your preferences better so I can make more personalized recommendations.', MessageSender.ASSISTANT);\n                    // Add to conversation history\n                    this.conversationHistory.push(quizMessage);\n                    responseMessages.push(quizMessage);\n                    break;\n                case 'virtual_try_on':\n                    const tryOnMessage = this.createTextMessage('You can try on any clothing item by clicking the \"Try On\" button on a recommendation. Upload your photo, and see how the item looks on you!', MessageSender.ASSISTANT);\n                    // Add to conversation history\n                    this.conversationHistory.push(tryOnMessage);\n                    responseMessages.push(tryOnMessage);\n                    break;\n                case 'greeting':\n                    // Use context awareness to personalize greeting\n                    let greeting = 'Hello! I\\'m your personal AI style assistant. I can help you discover clothing that matches your unique style. ';\n                    if (this.userContext.stylePreferences && Object.keys(this.userContext.stylePreferences).length > 0) {\n                        greeting += 'Based on your style preferences, I can give you personalized recommendations. ';\n                    }\n                    if (this.userContext.lastMessageTimestamp) {\n                        const lastMsgTime = this.userContext.lastMessageTimestamp;\n                        const now = new Date();\n                        const hoursSinceLastMessage = (now.getTime() - lastMsgTime.getTime()) / (1000 * 60 * 60);\n                        if (hoursSinceLastMessage < 24) {\n                            greeting = 'Welcome back! Glad to see you again. ';\n                        }\n                    }\n                    greeting += 'Would you like some personalized recommendations?';\n                    const greetingMessage = this.createTextMessage(greeting, MessageSender.ASSISTANT);\n                    // Add to conversation history\n                    this.conversationHistory.push(greetingMessage);\n                    responseMessages.push(greetingMessage);\n                    break;\n                case 'help':\n                    const helpMessage = this.createTextMessage('I can help you with: \\n- Finding clothing recommendations based on your style\\n- Creating complete outfits\\n- Virtual try-on of garments\\n- Style advice and tips\\n\\nTry these special commands:\\n- \"Show me dresses for wedding\"\\n- \"Match this with my closet\"\\n- \"Find under $50\"\\n- \"Complete this outfit\"\\n- \"What\\'s trending in shoes\"\\n- \"/trends [category]\" - Show trending items\\n- \"/quiz\" - Start style quiz\\n- \"/find [item]\" - Deep search our inventory\\n- \"/outfit [item]\" - Create complete outfit\\n\\nJust let me know what you\\'re looking for!', MessageSender.ASSISTANT);\n                    // Add to conversation history\n                    this.conversationHistory.push(helpMessage);\n                    responseMessages.push(helpMessage);\n                    break;\n                case 'wedding_dress':\n                    // Special handling for wedding dress case when not in demo mode\n                    const weddingMessage = this.createTextMessage('I can help you find the perfect wedding dress! Here are some recommendations based on current trends:', MessageSender.ASSISTANT);\n                    // Add to conversation history\n                    this.conversationHistory.push(weddingMessage);\n                    responseMessages.push(weddingMessage);\n                    // Get wedding dress recommendations\n                    const weddingRecommendations = yield this.addRecommendationMessage([], 'wedding');\n                    // Add to conversation history and response\n                    this.conversationHistory.push(...weddingRecommendations);\n                    responseMessages.push(...weddingRecommendations);\n                    break;\n                default:\n                    const defaultMessage = this.createTextMessage('I can help you discover fashion items that match your style. Would you like to see some personalized recommendations?', MessageSender.ASSISTANT);\n                    // Add to conversation history\n                    this.conversationHistory.push(defaultMessage);\n                    responseMessages.push(defaultMessage);\n            }\n            return responseMessages;\n        });\n    }\n    /**\n     * Process image upload to find similar items\n     */\n    processImageUpload(imageFile) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const responseMessages = [];\n            try {\n                // Create a message to acknowledge the image upload\n                const uploadMessage = this.createTextMessage(\"I've received your image and I'm analyzing it to find similar items...\", MessageSender.ASSISTANT);\n                // Add to conversation history\n                this.conversationHistory.push(uploadMessage);\n                responseMessages.push(uploadMessage);\n                // Here you would normally upload the image to your backend\n                // For now we'll simulate a successful analysis\n                const analysisDelay = new Promise(resolve => setTimeout(resolve, 1500));\n                yield analysisDelay;\n                // Create a response message\n                const analysisMessage = this.createTextMessage(\"I found several items that match the style in your image. Here are the closest matches:\", MessageSender.ASSISTANT);\n                // Add to conversation history\n                this.conversationHistory.push(analysisMessage);\n                responseMessages.push(analysisMessage);\n                // Get recommendations with image context\n                const additionalMessages = yield this.addRecommendationMessage([], 'image_match');\n                // Add to conversation history and response\n                this.conversationHistory.push(...additionalMessages);\n                responseMessages.push(...additionalMessages);\n            }\n            catch (error) {\n                console.error('Error processing image:', error);\n                const errorMessage = this.createTextMessage(\"I'm sorry, I encountered an error while analyzing your image. Please try again or describe what you're looking for instead.\", MessageSender.SYSTEM);\n                // Add to conversation history\n                this.conversationHistory.push(errorMessage);\n                responseMessages.push(errorMessage);\n            }\n            return responseMessages;\n        });\n    }\n    /**\n     * Process URL input to find specific product\n     */\n    processURLInput(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const responseMessages = [];\n            try {\n                // Create a message to acknowledge the URL input\n                const urlMessage = this.createTextMessage(`I'm looking up the product at this URL: ${url}...`, MessageSender.ASSISTANT);\n                // Add to conversation history\n                this.conversationHistory.push(urlMessage);\n                responseMessages.push(urlMessage);\n                // Here you would normally send the URL to your backend for processing\n                // For now we'll simulate a successful lookup\n                const lookupDelay = new Promise(resolve => setTimeout(resolve, 1000));\n                yield lookupDelay;\n                // Create a response message\n                const productMessage = this.createTextMessage(\"I found the product! Here are the details and some items that would go well with it:\", MessageSender.ASSISTANT);\n                // Add to conversation history\n                this.conversationHistory.push(productMessage);\n                responseMessages.push(productMessage);\n                // Get recommendations with URL context\n                const additionalMessages = yield this.addRecommendationMessage([], 'product_url');\n                // Add to conversation history and response\n                this.conversationHistory.push(...additionalMessages);\n                responseMessages.push(...additionalMessages);\n            }\n            catch (error) {\n                console.error('Error processing URL:', error);\n                const errorMessage = this.createTextMessage(\"I'm sorry, I couldn't retrieve information about this product. The URL might be invalid or the product might not be available. Please try another URL or describe what you're looking for.\", MessageSender.SYSTEM);\n                // Add to conversation history\n                this.conversationHistory.push(errorMessage);\n                responseMessages.push(errorMessage);\n            }\n            return responseMessages;\n        });\n    }\n    /**\n     * Process special commands\n     */\n    processSpecialCommands(text) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const command of this.specialCommands) {\n                const matches = text.match(command.pattern);\n                if (matches) {\n                    try {\n                        return yield command.handler(text, matches);\n                    }\n                    catch (error) {\n                        console.error(`Error processing special command: ${text}`, error);\n                        return [\n                            this.createTextMessage(\"I'm sorry, I had trouble processing that command. Please try again.\", MessageSender.SYSTEM)\n                        ];\n                    }\n                }\n            }\n            return [];\n        });\n    }\n    /**\n     * Load user context from backend or localStorage\n     */\n    loadUserContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.userApi) {\n                    // Try to get user profile from API\n                    const userProfile = yield this.userApi.getUserProfile(this.userId);\n                    if (userProfile) {\n                        // Update style preferences - access from preferences property\n                        this.userContext.stylePreferences = userProfile.preferences || {};\n                        // Get user closet if available\n                        try {\n                            // Fallback to user profile closet since getUserCloset doesn't exist in the interface\n                            const closet = { items: userProfile.closet || [] };\n                            this.userContext.closetItems = (closet === null || closet === void 0 ? void 0 : closet.items) || [];\n                        }\n                        catch (e) {\n                            console.error('Error loading user closet:', e);\n                        }\n                        // Get user liked/disliked items if available\n                        try {\n                            // Get feedback from user profile instead since API methods don't have the right structure\n                            const feedback = userProfile.feedback || { likedItems: [], dislikedItems: [] };\n                            this.userContext.likedItems = feedback.likedItems || [];\n                            this.userContext.dislikedItems = feedback.dislikedItems || [];\n                        }\n                        catch (e) {\n                            console.error('Error loading item feedback:', e);\n                        }\n                    }\n                }\n                else {\n                    // Try to load from localStorage as fallback\n                    try {\n                        const savedContext = localStorage.getItem(`stylist_chat_context_${this.userId}`);\n                        if (savedContext) {\n                            const parsedContext = JSON.parse(savedContext);\n                            this.userContext = Object.assign(Object.assign({}, this.userContext), parsedContext);\n                        }\n                    }\n                    catch (e) {\n                        console.error('Error loading user context from localStorage:', e);\n                    }\n                }\n                // Update conversation context with user preferences\n                this.updateConversationContext();\n            }\n            catch (error) {\n                console.error('Error loading user context:', error);\n            }\n        });\n    }\n    /**\n     * Update conversation context with user preferences\n     */\n    updateConversationContext() {\n        const contextUpdates = [];\n        // Add style preferences to context\n        if (Object.keys(this.userContext.stylePreferences).length > 0) {\n            const stylePrefs = this.userContext.stylePreferences;\n            let stylesContext = 'User style preferences: ';\n            // Add key style preferences from quiz\n            if (stylePrefs.favoriteColors) {\n                stylesContext += `Favorite colors: ${stylePrefs.favoriteColors.join(', ')}. `;\n            }\n            if (stylePrefs.stylePersona) {\n                stylesContext += `Style persona: ${stylePrefs.stylePersona}. `;\n            }\n            if (stylePrefs.preferredFit) {\n                stylesContext += `Preferred fit: ${stylePrefs.preferredFit}. `;\n            }\n            contextUpdates.push(stylesContext);\n        }\n        // Add closet items to context\n        if (this.userContext.closetItems.length > 0) {\n            const closetSummary = `User has ${this.userContext.closetItems.length} items in their closet.`;\n            contextUpdates.push(closetSummary);\n        }\n        // Add liked/disliked items to context\n        if (this.userContext.likedItems.length > 0 || this.userContext.dislikedItems.length > 0) {\n            let feedbackContext = 'User preferences based on feedback: ';\n            if (this.userContext.likedItems.length > 0) {\n                feedbackContext += `Liked ${this.userContext.likedItems.length} items. `;\n            }\n            if (this.userContext.dislikedItems.length > 0) {\n                feedbackContext += `Disliked ${this.userContext.dislikedItems.length} items. `;\n            }\n            contextUpdates.push(feedbackContext);\n        }\n        // Add recent searches to context\n        if (this.userContext.recentSearches.length > 0) {\n            const recentSearches = `Recent user searches: ${this.userContext.recentSearches.slice(-3).join(', ')}`;\n            contextUpdates.push(recentSearches);\n        }\n        // Add to conversation context if we have updates\n        if (contextUpdates.length > 0) {\n            // Only update if we have more than the initial system prompt\n            if (this.conversationContext.length <= 1) {\n                this.conversationContext.push(contextUpdates.join('\\n'));\n            }\n            else {\n                // Replace the existing context with updated info\n                this.conversationContext[1] = contextUpdates.join('\\n');\n            }\n        }\n    }\n    /**\n     * Call the Claude API to get a response\n     */\n    callClaudeAPI(userMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Add the user message to context\n                this.conversationContext.push(userMessage);\n                // Make sure context is updated with latest user preferences\n                this.updateConversationContext();\n                // API endpoint - prioritize direct Claude API if we have API key\n                if (this.claudeConfig.apiKey) {\n                    try {\n                        return yield this.callDirectClaudeAPI(userMessage);\n                    }\n                    catch (directError) {\n                        console.error('Direct Claude API call failed, falling back to backend proxy:', directError);\n                        // Fall back to proxy\n                    }\n                }\n                // Fall back to backend proxy\n                const apiUrl = this.recommendationApi.apiClient\n                    ? `${this.recommendationApi.apiClient.baseURL || ''}/chat`\n                    : '/api/chat';\n                console.log('Calling Claude API via backend proxy at:', apiUrl);\n                // Prepare the API request to backend proxy\n                const response = yield fetch(apiUrl, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'X-API-Key': this.recommendationApi.apiClient.apiKey || '',\n                    },\n                    body: JSON.stringify({\n                        userId: this.userId,\n                        message: userMessage,\n                        context: this.conversationContext.slice(-5) // Keep last 5 messages for context\n                    }),\n                });\n                if (!response.ok) {\n                    console.warn(`Claude API request failed with status: ${response.status}`);\n                    // Don't throw error - return fallback response instead\n                    return \"I'm having trouble connecting to my backend services. Let me show you some recommendations based on your request.\";\n                }\n                const data = yield response.json();\n                // Add the response to context\n                this.conversationContext.push(data.response);\n                return data.response;\n            }\n            catch (error) {\n                console.error('Error calling Claude API via backend:', error);\n                // Return fallback response instead of throwing\n                return \"I'm having trouble connecting right now. Let me show you some recommendations instead.\";\n            }\n        });\n    }\n    /**\n     * Call the Claude API directly from the frontend\n     */\n    callDirectClaudeAPI(userMessage) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.claudeConfig.apiKey) {\n                throw new Error('No Claude API key available');\n            }\n            const apiUrl = this.claudeConfig.baseUrl || 'https://api.anthropic.com';\n            const model = this.claudeConfig.modelName || 'claude-3-haiku-20240307';\n            console.log(`Calling Claude API directly with model: ${model}`);\n            // Prepare the messages array for Claude API\n            const messages = this.conversationContext.slice(-5).map((message, index) => {\n                // First message is system prompt, then alternate between user and assistant\n                if (index === 0) {\n                    return { role: \"system\", content: message };\n                }\n                else {\n                    return {\n                        role: index % 2 === 1 ? \"user\" : \"assistant\",\n                        content: message\n                    };\n                }\n            });\n            // Add the current user message\n            messages.push({ role: \"user\", content: userMessage });\n            // Prepare the request to the Claude API\n            const response = yield fetch(`${apiUrl}/v1/messages`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'x-api-key': this.claudeConfig.apiKey,\n                    'anthropic-version': '2023-06-01'\n                },\n                body: JSON.stringify({\n                    model,\n                    messages,\n                    max_tokens: 1000\n                }),\n            });\n            if (!response.ok) {\n                const errorText = yield response.text();\n                console.error(`Claude API direct request failed: ${response.status} - ${errorText}`);\n                throw new Error(`Failed to get response from Claude API: ${response.statusText}`);\n            }\n            const data = yield response.json();\n            const assistantResponse = ((_b = (_a = data.content) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.text) || '';\n            // Add the response to context\n            this.conversationContext.push(assistantResponse);\n            return assistantResponse;\n        });\n    }\n    /**\n     * Check if the AI response or user message suggests recommendations\n     */\n    containsRecommendationIntent(aiResponse, userMessage) {\n        const lowerAiResponse = aiResponse.toLowerCase();\n        const lowerUserMessage = userMessage.toLowerCase();\n        // Recommendation phrases in AI response\n        const aiRecommendPhrases = [\n            'here are some recommendations',\n            'i recommend',\n            'would you like to see',\n            'i can show you',\n            'i\\'ll show you some items',\n            'i can recommend',\n            'here\\'s what i found',\n            'similar items',\n            'items that match'\n        ];\n        // Recommendation phrases in user message\n        const userRecommendPhrases = [\n            'show me',\n            'recommend',\n            'what should i wear',\n            'find me',\n            'can you show',\n            'give me ideas',\n            'what would look good',\n            'similar to',\n            'like this',\n            'matching'\n        ];\n        // Check AI response for recommendation intent\n        for (const phrase of aiRecommendPhrases) {\n            if (lowerAiResponse.includes(phrase)) {\n                return true;\n            }\n        }\n        // Check user message for recommendation intent\n        for (const phrase of userRecommendPhrases) {\n            if (lowerUserMessage.includes(phrase)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Add recommendation message to the response\n     */\n    addRecommendationMessage(responseMessages, context) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const messages = [];\n            try {\n                const recommendations = yield this.recommendationApi.getRecommendations({\n                    userId: this.userId,\n                    context: context,\n                    limit: 4\n                });\n                // Add recommendation message\n                if (recommendations.items.length > 0) {\n                    // Convert from Recommendation to Chat format\n                    const chatItems = this.convertRecommendationItemsToChatItems(recommendations.items);\n                    const recommendationMessage = this.createRecommendationMessage(chatItems);\n                    messages.push(recommendationMessage);\n                }\n                // If there are outfits, add outfit message\n                if (((_a = recommendations.outfits) === null || _a === void 0 ? void 0 : _a.length) > 0) {\n                    const outfitIntroMessage = this.createTextMessage('I also created a complete outfit for you:', MessageSender.ASSISTANT);\n                    messages.push(outfitIntroMessage);\n                    // Convert from Recommendation to Chat format\n                    const outfit = recommendations.outfits[0];\n                    const chatOutfit = this.convertRecommendationOutfitToChatOutfit(outfit);\n                    messages.push(this.createOutfitMessage(chatOutfit));\n                }\n                // Add all messages to the response if provided\n                if (responseMessages) {\n                    responseMessages.push(...messages);\n                }\n            }\n            catch (error) {\n                console.error('Error getting recommendations:', error);\n                const errorMessage = this.createTextMessage('Sorry, I had trouble getting recommendations. Please try again.', MessageSender.SYSTEM);\n                messages.push(errorMessage);\n                // Add error message to the response if provided\n                if (responseMessages) {\n                    responseMessages.push(errorMessage);\n                }\n            }\n            return messages;\n        });\n    }\n    /**\n     * Convert recommendation items to chat items\n     */\n    convertRecommendationItemsToChatItems(items) {\n        return items.map(item => {\n            var _a;\n            return ({\n                id: item.id,\n                name: item.name,\n                brand: item.brand,\n                category: item.category,\n                price: item.price,\n                salePrice: item.salePrice,\n                imageUrl: ((_a = item.imageUrls) === null || _a === void 0 ? void 0 : _a[0]) || '',\n                url: item.url,\n                matchScore: item.matchScore,\n                matchReasons: item.matchReasons\n            });\n        });\n    }\n    /**\n     * Convert recommendation outfit to chat outfit\n     */\n    convertRecommendationOutfitToChatOutfit(outfit) {\n        return {\n            id: outfit.id,\n            name: outfit.name,\n            occasion: outfit.occasion,\n            matchScore: outfit.matchScore,\n            matchReasons: outfit.matchReasons,\n            items: this.convertRecommendationItemsToChatItems(outfit.items)\n        };\n    }\n    /**\n     * Categorize user intent based on message text\n     */\n    categorizeIntent(text) {\n        const lowerText = text.toLowerCase();\n        // Handle the wedding dress case specially for the demo\n        if (lowerText.includes('wedding dress') ||\n            lowerText.includes('bridal') ||\n            (lowerText.includes('wedding') && lowerText.includes('dress'))) {\n            return 'wedding_dress';\n        }\n        if (lowerText.includes('recommend') ||\n            lowerText.includes('suggestion') ||\n            lowerText.includes('find') ||\n            lowerText.includes('show me')) {\n            return 'recommendation';\n        }\n        if (lowerText.includes('quiz') ||\n            lowerText.includes('style profile') ||\n            lowerText.includes('preferences')) {\n            return 'style_quiz';\n        }\n        if (lowerText.includes('try on') ||\n            lowerText.includes('virtual') ||\n            lowerText.includes('how does it look')) {\n            return 'virtual_try_on';\n        }\n        if (lowerText.includes('hello') ||\n            lowerText.includes('hi') ||\n            lowerText.includes('hey')) {\n            return 'greeting';\n        }\n        if (lowerText.includes('help') ||\n            lowerText.includes('what can you do') ||\n            lowerText.includes('how does this work')) {\n            return 'help';\n        }\n        return 'general';\n    }\n    /**\n     * Get a realistic Claude-like response for demo purposes\n     * These responses mock what the real API would return for specific queries\n     */\n    getDemoResponse(intent, query) {\n        // Special demo responses for specific query types\n        switch (intent) {\n            case 'wedding_dress':\n                return `I'd be happy to help you find the perfect wedding dress! Based on current trends and classic styles, here are some suggestions:\n\nFor a traditional look, A-line and ball gown silhouettes create a timeless, romantic appearance. If you prefer something more modern, consider a fitted mermaid or trumpet style that accentuates your curves.\n\nMaterial is important too - delicate lace creates a romantic feel, while silk or satin offers elegant simplicity. For spring/summer weddings, lighter fabrics like chiffon or organza are beautiful options.\n\nWould you like to see specific dress recommendations? I can show you some options across different styles and price points that might match what you're looking for.`;\n            case 'greeting':\n                // Use context-aware greeting\n                let greeting = `Hello! I'm your personal style assistant. I'm here to help you discover clothing that matches your unique style preferences. `;\n                if (Object.keys(this.userContext.stylePreferences).length > 0) {\n                    greeting += `Based on your style quiz results, I can provide tailored recommendations. `;\n                }\n                if (this.userContext.closetItems.length > 0) {\n                    greeting += `I can also suggest items that would coordinate well with the ${this.userContext.closetItems.length} items in your closet. `;\n                }\n                greeting += `I can recommend outfits, help you find specific items, provide style advice, or even let you virtually try on clothes. What kind of fashion help are you looking for today?`;\n                return greeting;\n            case 'help':\n                return `I'm your AI fashion assistant, and I can help you with:\n\n- Finding personalized clothing recommendations\n- Creating complete outfits for specific occasions\n- Virtually trying on garments with our try-on feature\n- Answering style questions and providing fashion advice\n- Helping you complete our style quiz to better understand your preferences\n\nYou can also use these special commands:\n- \"Show me dresses for wedding\"\n- \"Match this with my closet\"\n- \"Find under $50\"\n- \"Complete this outfit\"\n- \"What's trending in shoes\"\n\nJust let me know what you're looking for, and I'll guide you through the process!`;\n            default:\n                if (USE_CLAUDE_DEMO) {\n                    return `I'd be happy to help you with \"${query}\". This is a simulated Claude response in demo mode. In a real implementation with an API key, you would get a personalized response from Claude based on your specific query. Would you like to see some clothing recommendations related to this topic?`;\n                }\n                else {\n                    return ''; // Fall back to rule-based responses with empty string instead of null\n                }\n        }\n    }\n    /**\n     * Extract context from message text\n     */\n    extractContext(text) {\n        const lowerText = text.toLowerCase();\n        // Extract clothing categories\n        const categories = [\n            'tops', 'shirts', 't-shirts', 'blouses',\n            'bottoms', 'pants', 'jeans', 'shorts', 'skirts',\n            'dresses', 'gowns',\n            'outerwear', 'jackets', 'coats',\n            'shoes', 'sneakers', 'boots', 'heels',\n            'accessories'\n        ];\n        for (const category of categories) {\n            if (lowerText.includes(category)) {\n                return category;\n            }\n        }\n        // Extract occasions\n        const occasions = [\n            'casual', 'formal', 'business', 'work',\n            'party', 'date', 'wedding', 'weekend',\n            'vacation', 'summer', 'winter', 'spring', 'fall'\n        ];\n        for (const occasion of occasions) {\n            if (lowerText.includes(occasion)) {\n                return occasion;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Create a text message\n     */\n    createTextMessage(text, sender) {\n        return {\n            id: uuidv4(),\n            type: MessageType.TEXT,\n            sender,\n            text,\n            timestamp: new Date()\n        };\n    }\n    /**\n     * Create a recommendation message\n     */\n    createRecommendationMessage(items) {\n        return {\n            id: uuidv4(),\n            type: MessageType.RECOMMENDATION,\n            sender: MessageSender.ASSISTANT,\n            items,\n            timestamp: new Date()\n        };\n    }\n    /**\n     * Create an outfit message\n     */\n    createOutfitMessage(outfit) {\n        return {\n            id: uuidv4(),\n            type: MessageType.OUTFIT,\n            sender: MessageSender.ASSISTANT,\n            outfit,\n            timestamp: new Date()\n        };\n    }\n}\n","// src/services/analytics/analyticsService.ts\nimport { AnalyticsEventType, trackEvent } from '@utils/analytics';\n// Configure analytics provider\nlet analyticsInitialized = false;\n/**\n * Initialize analytics\n */\nexport const initializeAnalytics = () => {\n    if (analyticsInitialized)\n        return;\n    // Load analytics script\n    const script = document.createElement('script');\n    script.src = 'https://cdn.thestylist.ai/analytics.js';\n    script.async = true;\n    document.head.appendChild(script);\n    // Set initialized flag\n    analyticsInitialized = true;\n};\n/**\n * Track widget open event\n */\nexport const trackWidgetOpen = (userId) => {\n    trackEvent(AnalyticsEventType.WIDGET_OPEN, userId);\n};\n/**\n * Track widget close event\n */\nexport const trackWidgetClose = (userId) => {\n    trackEvent(AnalyticsEventType.WIDGET_CLOSE, userId);\n};\n/**\n * Track message sent event\n */\nexport const trackMessageSent = (userId, text) => {\n    trackEvent(AnalyticsEventType.MESSAGE_SENT, userId, { text });\n};\n/**\n * Track item view event\n */\nexport const trackItemView = (userId, itemId) => {\n    trackEvent(AnalyticsEventType.ITEM_VIEW, userId, { itemId });\n};\n/**\n * Track item feedback event\n */\nexport const trackItemFeedback = (userId, itemId, liked) => {\n    trackEvent(liked ? AnalyticsEventType.ITEM_LIKE : AnalyticsEventType.ITEM_DISLIKE, userId, { itemId });\n};\n/**\n * Track outfit save event\n */\nexport const trackOutfitSave = (userId, outfitId) => {\n    trackEvent(AnalyticsEventType.OUTFIT_SAVE, userId, { outfitId });\n};\n/**\n * Track style quiz events\n */\nexport const trackStyleQuizStart = (userId) => {\n    trackEvent(AnalyticsEventType.STYLE_QUIZ_START, userId);\n};\nexport const trackStyleQuizComplete = (userId) => {\n    trackEvent(AnalyticsEventType.STYLE_QUIZ_COMPLETE, userId);\n};\nexport const trackStyleQuizAbandon = (userId) => {\n    trackEvent(AnalyticsEventType.STYLE_QUIZ_ABANDON, userId);\n};\n/**\n * Track error events\n */\nexport const trackError = (userId, errorMessage, errorCode) => {\n    trackEvent(AnalyticsEventType.ERROR, userId, {\n        errorMessage,\n        errorCode\n    });\n};\n","/**\n * Offline Service\n *\n * Provides offline capabilities for the Stylist application including:\n * - Network status detection and monitoring\n * - Offline data storage and retrieval\n * - Data synchronization when connection is restored\n * - Offline mode UI state management\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { debugLog } from '../utils/debugMode';\n// Keys for offline storage\nconst STORAGE_KEYS = {\n    PENDING_REQUESTS: 'stylist_pending_requests',\n    OFFLINE_DATA: 'stylist_offline_data',\n    OFFLINE_MODE: 'stylist_offline_mode'\n};\n// Network status and event management\nlet isOnline = navigator.onLine;\nconst listeners = [];\n// Initialize offline data structure\nconst defaultOfflineData = {\n    recommendations: [],\n    userPreferences: null,\n    recentItems: [],\n    cachedProducts: {},\n    lastUpdated: Date.now()\n};\n/**\n * Initialize the offline service\n */\nexport const initOfflineService = () => {\n    debugLog('Initializing offline service');\n    // Set up network status event listeners\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    // Check if there are any pending requests to process\n    processPendingRequests();\n};\n/**\n * Clean up the offline service\n */\nexport const cleanupOfflineService = () => {\n    window.removeEventListener('online', handleOnline);\n    window.removeEventListener('offline', handleOffline);\n    listeners.length = 0;\n};\n/**\n * Handle coming back online\n */\nconst handleOnline = () => {\n    debugLog('Network connection restored');\n    isOnline = true;\n    // Notify all listeners\n    listeners.forEach(listener => listener(true));\n    // Process any pending requests\n    processPendingRequests();\n};\n/**\n * Handle going offline\n */\nconst handleOffline = () => {\n    debugLog('Network connection lost');\n    isOnline = false;\n    // Notify all listeners\n    listeners.forEach(listener => listener(false));\n};\n/**\n * Add a network status change listener\n * @param listener Function to call when network status changes\n * @returns Function to remove the listener\n */\nexport const addNetworkStatusListener = (listener) => {\n    listeners.push(listener);\n    // Immediately call with current status\n    listener(isOnline);\n    // Return a function to remove the listener\n    return () => {\n        const index = listeners.indexOf(listener);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n    };\n};\n/**\n * Check if the device is currently online\n * @returns Current online status\n */\nexport const getNetworkStatus = () => {\n    return isOnline;\n};\n/**\n * Save data for offline use\n * @param key The key in the offline data structure to update\n * @param data The data to save\n * @returns Promise that resolves when data is saved\n */\nexport const saveOfflineData = (key, data) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        // Get current offline data\n        const offlineData = yield getOfflineData();\n        // Update with new data\n        offlineData[key] = data;\n        offlineData.lastUpdated = Date.now();\n        // Save back to storage\n        localStorage.setItem(STORAGE_KEYS.OFFLINE_DATA, JSON.stringify(offlineData));\n        debugLog(`Saved offline data for key: ${key}`);\n    }\n    catch (error) {\n        console.error('Failed to save offline data:', error);\n    }\n});\n/**\n * Get all offline data\n * @returns The offline data\n */\nexport const getOfflineData = () => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const data = localStorage.getItem(STORAGE_KEYS.OFFLINE_DATA);\n        return data ? JSON.parse(data) : Object.assign({}, defaultOfflineData);\n    }\n    catch (error) {\n        console.error('Failed to get offline data:', error);\n        return Object.assign({}, defaultOfflineData);\n    }\n});\n/**\n * Queue a request to be processed when online\n * @param request The request to queue\n * @returns Promise that resolves with request ID\n */\nexport const queueRequest = (url, method, body, headers, maxRetries = 5) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        // Create a new pending request\n        const id = `req_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n        const pendingRequest = {\n            id,\n            url,\n            method,\n            body,\n            headers,\n            timestamp: Date.now(),\n            retryCount: 0,\n            maxRetries\n        };\n        // Get current pending requests\n        const pendingRequests = yield getPendingRequests();\n        // Add to pending requests\n        pendingRequests.push(pendingRequest);\n        // Save back to storage\n        localStorage.setItem(STORAGE_KEYS.PENDING_REQUESTS, JSON.stringify(pendingRequests));\n        debugLog(`Queued request for later processing: ${method} ${url}`);\n        return id;\n    }\n    catch (error) {\n        console.error('Failed to queue request:', error);\n        throw error;\n    }\n});\n/**\n * Get all pending requests\n * @returns Array of pending requests\n */\nexport const getPendingRequests = () => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const data = localStorage.getItem(STORAGE_KEYS.PENDING_REQUESTS);\n        return data ? JSON.parse(data) : [];\n    }\n    catch (error) {\n        console.error('Failed to get pending requests:', error);\n        return [];\n    }\n});\n/**\n * Process all pending requests\n * @returns Promise that resolves when all requests are processed\n */\nexport const processPendingRequests = () => __awaiter(void 0, void 0, void 0, function* () {\n    if (!isOnline) {\n        debugLog('Cannot process pending requests while offline');\n        return;\n    }\n    try {\n        const pendingRequests = yield getPendingRequests();\n        if (pendingRequests.length === 0) {\n            return;\n        }\n        debugLog(`Processing ${pendingRequests.length} pending requests`);\n        // Process each request\n        const results = yield Promise.allSettled(pendingRequests.map((request) => __awaiter(void 0, void 0, void 0, function* () {\n            try {\n                const response = yield fetch(request.url, {\n                    method: request.method,\n                    headers: request.headers,\n                    body: request.body ? JSON.stringify(request.body) : undefined,\n                });\n                if (!response.ok) {\n                    throw new Error(`Request failed with status ${response.status}`);\n                }\n                return request.id;\n            }\n            catch (error) {\n                // If max retries not reached, keep in queue with incremented retry count\n                if (request.retryCount < request.maxRetries) {\n                    request.retryCount++;\n                    return null; // null means keep in queue\n                }\n                // Otherwise, remove from queue\n                return request.id;\n            }\n        })));\n        // Filter out successful requests and those that exceeded max retries\n        const successfulRequestIds = results\n            .map((result, index) => result.status === 'fulfilled' && result.value !== null\n            ? result.value\n            : null)\n            .filter(Boolean);\n        // Update pending requests\n        const updatedPendingRequests = pendingRequests.filter(request => !successfulRequestIds.includes(request.id));\n        // Save back to storage\n        localStorage.setItem(STORAGE_KEYS.PENDING_REQUESTS, JSON.stringify(updatedPendingRequests));\n        debugLog(`Processed ${successfulRequestIds.length} pending requests successfully`);\n    }\n    catch (error) {\n        console.error('Failed to process pending requests:', error);\n    }\n});\n/**\n * Set the application's offline mode\n * @param enabled Whether offline mode should be enabled\n */\nexport const setOfflineMode = (enabled) => {\n    try {\n        localStorage.setItem(STORAGE_KEYS.OFFLINE_MODE, JSON.stringify(enabled));\n        debugLog(`Offline mode ${enabled ? 'enabled' : 'disabled'}`);\n    }\n    catch (error) {\n        console.error('Failed to set offline mode:', error);\n    }\n};\n/**\n * Check if offline mode is enabled\n * @returns Whether offline mode is enabled\n */\nexport const isOfflineModeEnabled = () => {\n    try {\n        const data = localStorage.getItem(STORAGE_KEYS.OFFLINE_MODE);\n        return data ? JSON.parse(data) : false;\n    }\n    catch (error) {\n        console.error('Failed to check offline mode:', error);\n        return false;\n    }\n};\n/**\n * Clear all offline data\n */\nexport const clearOfflineData = () => {\n    try {\n        localStorage.removeItem(STORAGE_KEYS.OFFLINE_DATA);\n        localStorage.removeItem(STORAGE_KEYS.PENDING_REQUESTS);\n        localStorage.removeItem(STORAGE_KEYS.OFFLINE_MODE);\n        debugLog('Cleared all offline data');\n    }\n    catch (error) {\n        console.error('Failed to clear offline data:', error);\n    }\n};\n// Create a fetch wrapper for offline-enabled API calls\nexport const offlineFetch = (url, options = {}, offlineOptions) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a, _b;\n    const { offlineable = true, timeout = 10000, offlineData = null } = offlineOptions || {};\n    // If we're online, try to fetch\n    if (isOnline) {\n        try {\n            // Create a timeout promise\n            const timeoutPromise = new Promise((_, reject) => {\n                setTimeout(() => reject(new Error('Request timed out')), timeout);\n            });\n            // Race between fetch and timeout\n            const response = yield Promise.race([\n                fetch(url, options),\n                timeoutPromise\n            ]);\n            // If fetch succeeded and this is an offlineable request, cache the data\n            if (response.ok && offlineable && ((_a = options.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === 'GET') {\n                try {\n                    const clonedResponse = response.clone();\n                    const data = yield clonedResponse.json();\n                    // Cache based on URL path segments\n                    const urlPath = new URL(url).pathname;\n                    const segments = urlPath.split('/').filter(Boolean);\n                    if (segments.length > 0) {\n                        // Determine which offline data category to use based on URL\n                        if (urlPath.includes('recommendations')) {\n                            yield saveOfflineData('recommendations', data);\n                        }\n                        else if (urlPath.includes('products')) {\n                            const offlineData = yield getOfflineData();\n                            const productId = segments[segments.length - 1];\n                            offlineData.cachedProducts[productId] = data;\n                            yield saveOfflineData('cachedProducts', offlineData.cachedProducts);\n                        }\n                    }\n                }\n                catch (error) {\n                    console.error('Failed to cache response:', error);\n                }\n            }\n            return response;\n        }\n        catch (error) {\n            console.error('Fetch failed:', error);\n            // If fetch failed and this is a write operation, queue it for later\n            if (offlineable && ((_b = options.method) === null || _b === void 0 ? void 0 : _b.toUpperCase()) !== 'GET') {\n                yield queueRequest(url, options.method || 'GET', options.body, options.headers);\n            }\n            // Fall through to offline handling\n        }\n    }\n    // If we're offline or fetch failed, handle offline\n    if (offlineable) {\n        const offlineResponse = yield handleOfflineRequest(url, options, offlineData);\n        if (offlineResponse) {\n            return offlineResponse;\n        }\n    }\n    // If we couldn't handle it offline, throw a network error\n    throw new Error('Network request failed and no offline data available');\n});\n/**\n * Handle a request while offline\n * @param url The request URL\n * @param options The request options\n * @param offlineData Optional offline data to use\n * @returns A Response object or null if the request can't be handled offline\n */\nconst handleOfflineRequest = (url, options, offlineData) => __awaiter(void 0, void 0, void 0, function* () {\n    var _c;\n    // If explicit offline data was provided, use that\n    if (offlineData !== null) {\n        return new Response(JSON.stringify(offlineData), {\n            status: 200,\n            headers: { 'Content-Type': 'application/json' }\n        });\n    }\n    // Otherwise, try to find cached data\n    const urlPath = new URL(url).pathname;\n    const data = yield getOfflineData();\n    // GET requests can be served from cache\n    if (((_c = options.method) === null || _c === void 0 ? void 0 : _c.toUpperCase()) === 'GET') {\n        if (urlPath.includes('recommendations')) {\n            return new Response(JSON.stringify(data.recommendations), {\n                status: 200,\n                headers: { 'Content-Type': 'application/json' }\n            });\n        }\n        else if (urlPath.includes('products')) {\n            const segments = urlPath.split('/').filter(Boolean);\n            const productId = segments[segments.length - 1];\n            if (data.cachedProducts[productId]) {\n                return new Response(JSON.stringify(data.cachedProducts[productId]), {\n                    status: 200,\n                    headers: { 'Content-Type': 'application/json' }\n                });\n            }\n        }\n    }\n    else {\n        // Non-GET requests are queued for later\n        yield queueRequest(url, options.method || 'GET', options.body, options.headers);\n        // Return a fake successful response\n        return new Response(JSON.stringify({ queued: true }), {\n            status: 202,\n            headers: { 'Content-Type': 'application/json' }\n        });\n    }\n    // If we couldn't handle it, return null\n    return null;\n});\n// Export a hook-friendly object\nexport const offlineService = {\n    initOfflineService,\n    cleanupOfflineService,\n    addNetworkStatusListener,\n    getNetworkStatus,\n    saveOfflineData,\n    getOfflineData,\n    queueRequest,\n    processPendingRequests,\n    setOfflineMode,\n    isOfflineModeEnabled,\n    clearOfflineData,\n    offlineFetch\n};\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n * Service to remove background using remove.bg API\n */\nimport { REMOVE_BG_API_KEY } from '@/utils/environment';\n/**\n * Remove background from an image using remove.bg API\n * @param imageFile Image file to remove background from\n * @param options Configuration options\n * @returns DataURL of the processed image\n */\nexport function removeBackgroundApi(imageFile, options = {}) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n        // Get API key from options or environment\n        const apiKey = options.apiKey || REMOVE_BG_API_KEY;\n        if (!apiKey) {\n            throw new Error('No API key provided for remove.bg');\n        }\n        // Create FormData for API request\n        const formData = new FormData();\n        formData.append('image_file', imageFile);\n        // Add options to request\n        if (options.size)\n            formData.append('size', options.size);\n        formData.append('crop', options.crop ? 'true' : 'false');\n        if (options.scale)\n            formData.append('scale', options.scale);\n        if (options.format)\n            formData.append('format', options.format);\n        // Send request to remove.bg API\n        const response = yield fetch('https://api.remove.bg/v1.0/removebg', {\n            method: 'POST',\n            headers: {\n                'X-Api-Key': apiKey\n            },\n            body: formData\n        });\n        // Handle API errors\n        if (!response.ok) {\n            let errorMessage = `Remove.bg API error (${response.status})`;\n            try {\n                const errorData = yield response.json();\n                errorMessage = `${errorMessage}: ${((_b = (_a = errorData.errors) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.title) || 'Unknown error'}`;\n            }\n            catch (e) {\n                // If JSON parsing fails, use status text\n                errorMessage = `${errorMessage}: ${response.statusText}`;\n            }\n            throw new Error(errorMessage);\n        }\n        // Get binary image data from response\n        const imageBlob = yield response.blob();\n        // Convert to data URL\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onloadend = () => resolve(reader.result);\n            reader.onerror = reject;\n            reader.readAsDataURL(imageBlob);\n        });\n    });\n}\n/**\n * Check if remove.bg API is available with current API key\n * @returns Boolean indicating if API is available\n */\nexport function isRemoveBgAvailable() {\n    return __awaiter(this, void 0, void 0, function* () {\n        const apiKey = REMOVE_BG_API_KEY;\n        if (!apiKey) {\n            return false;\n        }\n        try {\n            // Make a lightweight account API call to check key validity\n            const response = yield fetch('https://api.remove.bg/v1.0/account', {\n                method: 'GET',\n                headers: {\n                    'X-Api-Key': apiKey,\n                    'Accept': 'application/json'\n                }\n            });\n            return response.ok;\n        }\n        catch (error) {\n            console.error('Error checking remove.bg API availability:', error);\n            return false;\n        }\n    });\n}\n","/**\n * TensorFlow-based background removal service for virtual try-on\n * Fallback for when Remove.bg API is not available\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as bodyPix from '@tensorflow-models/body-pix';\nimport * as tf from '@tensorflow/tfjs';\nimport '@tensorflow/tfjs-backend-webgl';\nimport '@tensorflow/tfjs-backend-cpu';\n// Cache for the BodyPix model\nlet bodyPixModel = null;\n// Track if model is currently loading to prevent multiple simultaneous loads\nlet isModelLoading = false;\n// Queue of callbacks for concurrent model requests\nconst modelLoadQueue = [];\n// Cache for WebGL capabilities\nlet webGLCapabilitiesCache = null;\n/**\n * Check for WebGL capabilities and determine what fallbacks to use\n */\nexport function checkWebGLCapabilities() {\n    // Return cached result if available\n    if (webGLCapabilitiesCache) {\n        return webGLCapabilitiesCache;\n    }\n    const result = {\n        supported: false,\n        level: null,\n        extensions: [],\n        fullSupport: false,\n        fallbackOptions: {\n            useCPUBackend: false,\n            useSimpleSegmentation: false,\n            useReducedPrecision: false,\n            useProgressiveLoading: false\n        }\n    };\n    try {\n        // Try to create a canvas and get WebGL context\n        const canvas = document.createElement('canvas');\n        // Try to get WebGL2 context first\n        let gl = canvas.getContext('webgl2');\n        if (gl) {\n            result.supported = true;\n            result.level = 2;\n        }\n        else {\n            // Fall back to WebGL1\n            gl = (canvas.getContext('webgl', { failIfMajorPerformanceCaveat: false }) ||\n                canvas.getContext('experimental-webgl', { failIfMajorPerformanceCaveat: false }));\n            if (gl) {\n                result.supported = true;\n                result.level = 1;\n            }\n        }\n        // If WebGL is supported, check extensions and capabilities\n        if (result.supported && gl) {\n            // Get all available extensions\n            const extensions = gl.getSupportedExtensions() || [];\n            result.extensions = extensions;\n            // Check for specific extensions needed for TensorFlow.js\n            const requiredExtensions = [\n                'OES_texture_float',\n                'WEBGL_color_buffer_float',\n                'OES_element_index_uint',\n                'OES_vertex_array_object',\n                'WEBGL_draw_buffers'\n            ];\n            const supportedRequired = requiredExtensions.filter(ext => extensions.includes(ext));\n            // Check if we have full support - at least 3 of 5 required extensions\n            result.fullSupport = supportedRequired.length >= 3;\n            // Get WebGL info if available\n            try {\n                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');\n                if (debugInfo) {\n                    const vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);\n                    const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);\n                    console.log(`WebGL vendor: ${vendor}, renderer: ${renderer}`);\n                    // Check for software renderers which may be slower\n                    const rendererLower = renderer.toString().toLowerCase();\n                    if (rendererLower.includes('swiftshader') ||\n                        rendererLower.includes('software') ||\n                        rendererLower.includes('intel')) {\n                        // Software renderer detected - will need CPU fallback\n                        result.fallbackOptions.useCPUBackend = true;\n                    }\n                }\n            }\n            catch (debugError) {\n                console.warn('Unable to get WebGL debug info:', debugError);\n            }\n            // Test shader compilation if we have basic support\n            try {\n                // A simple test shader\n                const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n                if (vertexShader) {\n                    gl.shaderSource(vertexShader, `\n            attribute vec2 a_position;\n            void main() {\n              gl_Position = vec4(a_position, 0, 1);\n            }\n          `);\n                    gl.compileShader(vertexShader);\n                    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n                        // Shader compilation failed - might need more fallbacks\n                        result.fallbackOptions.useSimpleSegmentation = true;\n                        result.fallbackOptions.useReducedPrecision = true;\n                    }\n                    gl.deleteShader(vertexShader);\n                }\n            }\n            catch (shaderError) {\n                console.warn('WebGL shader test failed:', shaderError);\n                result.fallbackOptions.useSimpleSegmentation = true;\n            }\n            // Determine fallback options based on capabilities\n            if (!result.fullSupport) {\n                // If we're missing float textures, use reduced precision\n                result.fallbackOptions.useReducedPrecision =\n                    !extensions.includes('OES_texture_float');\n                // If we're missing color buffer, use simpler segmentation\n                result.fallbackOptions.useSimpleSegmentation =\n                    !extensions.includes('WEBGL_color_buffer_float');\n                // If WebGL1 with limited extensions, consider CPU backend\n                if (result.level === 1 && supportedRequired.length < 2) {\n                    result.fallbackOptions.useCPUBackend = true;\n                }\n                // Always use progressive loading for limited WebGL capabilities\n                result.fallbackOptions.useProgressiveLoading = true;\n            }\n        }\n        else {\n            // No WebGL support at all\n            result.fallbackOptions.useCPUBackend = true;\n            result.fallbackOptions.useSimpleSegmentation = true;\n            result.fallbackOptions.useReducedPrecision = true;\n            result.fallbackOptions.useProgressiveLoading = true;\n        }\n    }\n    catch (error) {\n        console.warn('Error checking WebGL capabilities:', error);\n        // In case of error, assume no support and use all fallbacks\n        result.supported = false;\n        result.fallbackOptions.useCPUBackend = true;\n        result.fallbackOptions.useSimpleSegmentation = true;\n        result.fallbackOptions.useReducedPrecision = true;\n        result.fallbackOptions.useProgressiveLoading = true;\n    }\n    // Cache the result\n    webGLCapabilitiesCache = result;\n    console.log('WebGL capabilities:', result);\n    return result;\n}\n;\n/**\n * Configure TensorFlow.js based on available WebGL capabilities\n */\nexport function configureTensorFlow() {\n    const webGLCaps = checkWebGLCapabilities();\n    try {\n        // Set the appropriate backend\n        if (webGLCaps.fallbackOptions.useCPUBackend) {\n            console.log('Using CPU backend for TensorFlow.js due to limited WebGL support');\n            tf.setBackend('cpu').catch(err => {\n                console.warn('Failed to set CPU backend:', err);\n            });\n        }\n        else {\n            console.log('Using WebGL backend for TensorFlow.js');\n            tf.setBackend('webgl').catch(err => {\n                console.warn('Failed to set WebGL backend, falling back to CPU:', err);\n                tf.setBackend('cpu').catch(innerErr => {\n                    console.warn('Failed to set CPU backend as fallback:', innerErr);\n                });\n            });\n        }\n        // Configure TensorFlow environment flags based on WebGL capabilities\n        if (webGLCaps.fullSupport) {\n            // Full WebGL support - use optimal settings\n            tf.env().set('WEBGL_FORCE_F16_TEXTURES', true);\n            tf.env().set('WEBGL_PACK', true);\n            tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);\n        }\n        else {\n            // Limited WebGL support - use more compatible settings\n            tf.env().set('WEBGL_FORCE_F16_TEXTURES', webGLCaps.fallbackOptions.useReducedPrecision);\n            tf.env().set('WEBGL_PACK', false); // Disable packing for better compatibility\n            tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', !webGLCaps.fallbackOptions.useReducedPrecision);\n            // Additional fallback settings\n            tf.env().set('WEBGL_USE_SHAPES_UNIFORMS', true);\n            tf.env().set('WEBGL_PACK_DEPTHWISECONV', false);\n        }\n        // Wait for backend initialization to be ready\n        tf.ready().then(() => {\n            console.log(`TensorFlow.js using ${tf.getBackend()} backend`);\n        }).catch(err => {\n            console.warn('Error initializing TensorFlow backend:', err);\n        });\n    }\n    catch (error) {\n        console.error('Error configuring TensorFlow:', error);\n    }\n}\n/**\n * Check if TensorFlow.js is supported in the current browser\n */\nexport function isTensorflowSupported() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            // Get WebGL capabilities\n            const webGLCaps = checkWebGLCapabilities();\n            // If WebGL is not supported at all and CPU fallback isn't possible,\n            // TensorFlow.js won't work\n            if (!webGLCaps.supported && !tf.findBackend('cpu')) {\n                return false;\n            }\n            // Configure TensorFlow based on capabilities\n            configureTensorFlow();\n            // Try to create a simple tensor to test if tf.js works\n            try {\n                const tensor = tf.tensor1d([1, 2, 3]);\n                tensor.dispose();\n                // Attempt to access backend\n                yield tf.ready();\n                const backend = tf.getBackend();\n                return !!backend; // If we have a backend, it's supported\n            }\n            catch (tensorError) {\n                console.warn('TensorFlow tensor creation failed:', tensorError);\n                return false;\n            }\n        }\n        catch (error) {\n            console.error('TensorFlow.js support check failed:', error);\n            return false;\n        }\n    });\n}\n/**\n * Preload the BodyPix model to speed up initial segmentation,\n * with optimization based on WebGL capabilities\n */\nexport function preloadBodyPixModel() {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            // If model is already loaded, return it\n            if (bodyPixModel) {\n                return bodyPixModel;\n            }\n            // If model is already loading, add to queue\n            if (isModelLoading) {\n                return new Promise((resolve, reject) => {\n                    modelLoadQueue.push({ resolve, reject });\n                });\n            }\n            isModelLoading = true;\n            console.log('Loading BodyPix model...');\n            // Configure TensorFlow based on WebGL capabilities\n            configureTensorFlow();\n            // Get WebGL capabilities\n            const webGLCaps = checkWebGLCapabilities();\n            // Create model config based on capabilities\n            const modelConfig = {\n                architecture: 'MobileNetV1',\n                outputStride: webGLCaps.fullSupport ? 16 : 32,\n                multiplier: webGLCaps.fullSupport ? 0.75 : 0.5,\n                quantBytes: webGLCaps.fallbackOptions.useReducedPrecision ? 1 : 2,\n                modelUrl: 'https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/float16/050/model-stride16.json' // Specify direct model URL to avoid 404\n            };\n            // If progressive loading is needed, load in stages\n            if (webGLCaps.fallbackOptions.useProgressiveLoading) {\n                console.log('Using progressive model loading due to limited WebGL capabilities');\n                // Wait for TensorFlow backend to be ready\n                yield tf.ready();\n                // Try loading with CPU backend if needed\n                if (webGLCaps.fallbackOptions.useCPUBackend) {\n                    try {\n                        yield tf.setBackend('cpu');\n                    }\n                    catch (backendError) {\n                        console.warn('Failed to set CPU backend:', backendError);\n                    }\n                }\n            }\n            // Load the model with the configured settings\n            try {\n                bodyPixModel = yield bodyPix.load(modelConfig);\n                console.log('BodyPix model loaded successfully');\n                // Process queue\n                while (modelLoadQueue.length > 0) {\n                    const { resolve } = modelLoadQueue.shift();\n                    resolve(bodyPixModel);\n                }\n                return bodyPixModel;\n            }\n            catch (modelError) {\n                console.error('Error loading BodyPix model:', modelError);\n                // Try with even more conservative settings if initial load failed\n                if (!webGLCaps.fallbackOptions.useReducedPrecision) {\n                    try {\n                        console.log('Retrying with more conservative model settings...');\n                        bodyPixModel = yield bodyPix.load({\n                            architecture: 'MobileNetV1',\n                            outputStride: 32,\n                            multiplier: 0.5,\n                            quantBytes: 1,\n                            modelUrl: 'https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/float16/050/model-stride16.json' // Specify direct model URL to avoid 404\n                        });\n                        console.log('BodyPix model loaded with fallback settings');\n                        // Process queue\n                        while (modelLoadQueue.length > 0) {\n                            const { resolve } = modelLoadQueue.shift();\n                            resolve(bodyPixModel);\n                        }\n                        return bodyPixModel;\n                    }\n                    catch (fallbackError) {\n                        console.error('Error loading BodyPix model with fallback settings:', fallbackError);\n                        // Try again with different model URL\n                        try {\n                            console.log('Trying alternative model URL');\n                            bodyPixModel = yield bodyPix.load({\n                                architecture: 'MobileNetV1',\n                                outputStride: 16,\n                                multiplier: 0.5,\n                                quantBytes: 1,\n                                modelUrl: 'https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/float16/050/model-stride8.json' // Try a different stride\n                            });\n                            console.log('BodyPix model loaded with alternative URL');\n                            // Process queue\n                            while (modelLoadQueue.length > 0) {\n                                const { resolve } = modelLoadQueue.shift();\n                                resolve(bodyPixModel);\n                            }\n                            return bodyPixModel;\n                        }\n                        catch (alternativeError) {\n                            console.error('Error loading BodyPix with alternative URL:', alternativeError);\n                            // Reject all queued promises\n                            while (modelLoadQueue.length > 0) {\n                                const { reject } = modelLoadQueue.shift();\n                                reject(alternativeError);\n                            }\n                            throw alternativeError;\n                        }\n                    }\n                }\n                // Reject all queued promises\n                while (modelLoadQueue.length > 0) {\n                    const { reject } = modelLoadQueue.shift();\n                    reject(modelError);\n                }\n                throw modelError;\n            }\n            finally {\n                isModelLoading = false;\n            }\n        }\n        catch (error) {\n            isModelLoading = false;\n            console.error('Error in preloadBodyPixModel:', error);\n            // Reset model state on error\n            bodyPixModel = null;\n            throw error;\n        }\n    });\n}\n/**\n * Helper function to segment a person in an image\n * Used by background removal process and tests\n */\nexport function segmentImage(imageElement, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Get WebGL capabilities to determine optimal settings\n        const webGLCaps = checkWebGLCapabilities();\n        // Load the BodyPix model if not already loaded\n        if (!bodyPixModel) {\n            try {\n                // This will configure TensorFlow.js based on WebGL capabilities\n                yield preloadBodyPixModel();\n            }\n            catch (modelError) {\n                console.warn('Error loading BodyPix model during segmentation:', modelError);\n                // If this is a WebGL-related error and Canvas 2D is available,\n                // we'll return a simplified segmentation for fallback\n                if (webGLCaps.fallbackOptions.useCPUBackend &&\n                    typeof document !== 'undefined' &&\n                    document.createElement('canvas').getContext('2d')) {\n                    console.log('Using Canvas API fallback for segmentation');\n                    return createSimplifiedSegmentation(imageElement);\n                }\n                throw new Error('Unable to load segmentation model');\n            }\n        }\n        if (!bodyPixModel) {\n            // If model still not available but Canvas 2D is, use canvas fallback\n            if (webGLCaps.fallbackOptions.useCPUBackend &&\n                typeof document !== 'undefined' &&\n                document.createElement('canvas').getContext('2d')) {\n                console.log('Using Canvas API fallback for segmentation');\n                return createSimplifiedSegmentation(imageElement);\n            }\n            throw new Error('Failed to load BodyPix model');\n        }\n        // Determine optimal resolution based on WebGL capabilities\n        let optimalResolution = 'high';\n        if (webGLCaps.fallbackOptions.useSimpleSegmentation) {\n            optimalResolution = 'low'; // Use low resolution for limited devices\n        }\n        else if (!webGLCaps.fullSupport) {\n            optimalResolution = 'medium'; // Use medium for partially supported devices\n        }\n        // If explicitly specified, use the requested resolution\n        const requestedResolution = options.internalResolution;\n        // Default options\n        const segmentationOptions = {\n            flipHorizontal: options.flipHorizontal || false,\n            internalResolution: requestedResolution || optimalResolution,\n            segmentationThreshold: options.threshold || 0.7\n        };\n        // Try progressively lower resolutions if needed\n        try {\n            // Segment the person with specified options\n            return yield bodyPixModel.segmentPerson(imageElement, segmentationOptions);\n        }\n        catch (highResError) {\n            console.warn('Primary segmentation failed:', highResError);\n            // Fallback progression if the first attempt fails\n            try {\n                // Try medium resolution if not already tried\n                if (segmentationOptions.internalResolution !== 'medium' &&\n                    segmentationOptions.internalResolution !== 'low') {\n                    console.log('Falling back to medium resolution segmentation');\n                    return yield bodyPixModel.segmentPerson(imageElement, Object.assign(Object.assign({}, segmentationOptions), { internalResolution: 'medium' }));\n                }\n                // If already at medium or below, try low\n                if (segmentationOptions.internalResolution !== 'low') {\n                    console.log('Falling back to low resolution segmentation');\n                    return yield bodyPixModel.segmentPerson(imageElement, Object.assign(Object.assign({}, segmentationOptions), { internalResolution: 'low' }));\n                }\n                // If all tensorflow.js approaches fail, fall back to Canvas API\n                throw new Error('All TensorFlow.js segmentation approaches failed');\n            }\n            catch (fallbackError) {\n                console.error('All segmentation fallbacks failed:', fallbackError);\n                // Check if this is a WebGL error and provide a clearer message\n                if (String(fallbackError).toLowerCase().includes('webgl') ||\n                    String(fallbackError).toLowerCase().includes('shader') ||\n                    String(fallbackError).toLowerCase().includes('compilation')) {\n                    console.log('WebGL error detected. Falling back to Canvas API');\n                    // Try the Canvas API fallback if WebGL is not supported\n                    return createSimplifiedSegmentation(imageElement);\n                }\n                throw fallbackError;\n            }\n        }\n    });\n}\n/**\n * Create a simplified segmentation using just the Canvas API\n * This is a fallback when TensorFlow.js/WebGL is not supported\n */\nfunction createSimplifiedSegmentation(imageElement) {\n    try {\n        // Create a canvas to process the image\n        const canvas = document.createElement('canvas');\n        canvas.width = imageElement.width;\n        canvas.height = imageElement.height;\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n            throw new Error('Could not get 2D context for Canvas API fallback');\n        }\n        // Draw the image to the canvas\n        ctx.drawImage(imageElement, 0, 0);\n        // Get the image data to create a simple segmentation mask\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        const data = imageData.data;\n        // Create a mask with the same dimensions\n        const maskData = new Uint8ClampedArray(canvas.width * canvas.height);\n        // Simple background segmentation based on color and position\n        // This is a very basic approach - in a real app you'd use a more sophisticated algorithm\n        const centerX = canvas.width / 2;\n        const centerY = canvas.height / 2;\n        for (let y = 0; y < canvas.height; y++) {\n            for (let x = 0; x < canvas.width; x++) {\n                // Calculate relative distance from center (as a percentage)\n                const distanceFromCenter = Math.sqrt(Math.pow((x - centerX) / centerX, 2) +\n                    Math.pow((y - centerY) / centerY, 2));\n                // Pixel index in the data array\n                const i = (y * canvas.width + x) * 4;\n                // Get RGB values\n                const r = data[i];\n                const g = data[i + 1];\n                const b = data[i + 2];\n                // Simple brightness calculation\n                const brightness = (r + g + b) / 3;\n                // Calculate distance from center to edge ratio (0 at center, 1 at corners)\n                const edgeRatio = Math.min(1, distanceFromCenter);\n                // Create a simple mask - likely foreground pixels are:\n                // 1. Near the center of the image (person usually centered)\n                // 2. Higher contrast/mid-brightness (not extreme white or black)\n                // This is obviously a gross simplification but works OK as fallback\n                const isForeground = edgeRatio < 0.7 && // Closer to center than edge\n                    brightness > 40 && // Not too dark (background often darker)\n                    brightness < 245; // Not too bright (background often white or bright)\n                // Set the mask value (1 for foreground, 0 for background)\n                maskData[y * canvas.width + x] = isForeground ? 1 : 0;\n            }\n        }\n        // Return a simplified segmentation result matching the BodyPix interface\n        // Use the same technique as before to avoid type errors\n        return {\n            width: canvas.width,\n            height: canvas.height,\n            data: maskData,\n            allPoses: [] // Add the required property\n        };\n    }\n    catch (error) {\n        console.error('Error in Canvas API fallback:', error);\n        // If even the fallback fails, return a blank segmentation\n        const blankMask = new Uint8ClampedArray(imageElement.width * imageElement.height);\n        // Central region is assumed to be person for a very basic fallback\n        const centerX = imageElement.width / 2;\n        const centerY = imageElement.height / 2;\n        const radius = Math.min(imageElement.width, imageElement.height) * 0.3;\n        for (let y = 0; y < imageElement.height; y++) {\n            for (let x = 0; x < imageElement.width; x++) {\n                // Simple circular mask in the center\n                const dist = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));\n                if (dist < radius) {\n                    blankMask[y * imageElement.width + x] = 1;\n                }\n            }\n        }\n        // Create a blank segmentation result with the required properties\n        // First cast to unknown to avoid type checking, then to the expected type\n        return {\n            width: imageElement.width,\n            height: imageElement.height,\n            data: blankMask,\n            allPoses: []\n        };\n    }\n}\n/**\n * Remove the background from an image using TensorFlow BodyPix\n * @param imageSource - Image file or URL to process\n * @param options - Configuration options\n * @returns URL to the processed image with background removed\n */\nexport function removeBackground(imageSource, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            // Load the BodyPix model if not already loaded\n            if (!bodyPixModel) {\n                try {\n                    yield preloadBodyPixModel();\n                }\n                catch (modelError) {\n                    console.warn('BodyPix model failed to load, falling back to original image:', modelError);\n                    if (typeof imageSource === 'string') {\n                        return imageSource;\n                    }\n                    else {\n                        return URL.createObjectURL(imageSource);\n                    }\n                }\n            }\n            if (!bodyPixModel) {\n                throw new Error('Failed to load BodyPix model');\n            }\n            // Create an image element from the source\n            const imageElement = yield createImageElement(imageSource);\n            // Try with different internal resolution options if needed\n            let segmentation;\n            try {\n                // Use bodyPix to segment the person with primary settings\n                segmentation = yield bodyPixModel.segmentPerson(imageElement, Object.assign({ flipHorizontal: false, internalResolution: 'high', segmentationThreshold: options.threshold || 0.7 }, (options.bodyPixOptions || {})));\n            }\n            catch (segmentationError) {\n                console.warn('High resolution segmentation failed, trying medium resolution:', segmentationError);\n                // Try with lower resolution\n                try {\n                    segmentation = yield bodyPixModel.segmentPerson(imageElement, Object.assign({ flipHorizontal: false, internalResolution: 'medium', segmentationThreshold: options.threshold || 0.7 }, (options.bodyPixOptions || {})));\n                }\n                catch (mediumError) {\n                    console.warn('Medium resolution segmentation failed, trying low resolution:', mediumError);\n                    // Last attempt with lowest resolution\n                    try {\n                        segmentation = yield bodyPixModel.segmentPerson(imageElement, Object.assign({ flipHorizontal: false, internalResolution: 'low', segmentationThreshold: options.threshold || 0.7 }, (options.bodyPixOptions || {})));\n                    }\n                    catch (lowError) {\n                        console.error('All segmentation attempts failed:', lowError);\n                        throw lowError;\n                    }\n                }\n            }\n            // Process the segmentation to extract key body parts\n            return processSegmentation(imageElement, segmentation, options.backgroundColor || 'transparent', options.foregroundColor);\n        }\n        catch (error) {\n            console.error('Error in TF background removal:', error);\n            // Check for specific WebGL errors\n            const errorMsg = String(error).toLowerCase();\n            if (errorMsg.includes('webgl') || errorMsg.includes('shader') || errorMsg.includes('compilation')) {\n                console.warn('WebGL/shader error detected. WebGL may not be fully supported on this device.');\n            }\n            // Return original image URL as fallback\n            if (typeof imageSource === 'string') {\n                return imageSource;\n            }\n            else {\n                return URL.createObjectURL(imageSource);\n            }\n        }\n    });\n}\n/**\n * Process segmentation data to create a masked image\n */\nfunction processSegmentation(imageElement, segmentation, backgroundColor, foregroundColor) {\n    // Create a canvas for the output\n    const canvas = document.createElement('canvas');\n    canvas.width = imageElement.width;\n    canvas.height = imageElement.height;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        throw new Error('Could not get canvas context');\n    }\n    // Draw the original image\n    ctx.drawImage(imageElement, 0, 0);\n    // Get image data\n    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const { data } = imageData;\n    // For each pixel\n    for (let i = 0; i < data.length; i += 4) {\n        // Get pixel position\n        const pixelIndex = i / 4;\n        const x = pixelIndex % canvas.width;\n        const y = Math.floor(pixelIndex / canvas.width);\n        // Check if this pixel is part of a person\n        if (!segmentation.data[pixelIndex]) {\n            if (backgroundColor === 'transparent') {\n                // Make pixel transparent\n                data[i + 3] = 0;\n            }\n            else {\n                // Set to background color\n                const bgColor = hexToRgb(backgroundColor);\n                data[i] = bgColor.r; // R\n                data[i + 1] = bgColor.g; // G\n                data[i + 2] = bgColor.b; // B\n                data[i + 3] = 255; // A\n            }\n        }\n        else if (foregroundColor) {\n            // If foreground color is provided, tint the person\n            const fgColor = hexToRgb(foregroundColor);\n            // Blend original with foreground color\n            data[i] = Math.round((data[i] + fgColor.r) / 2); // R\n            data[i + 1] = Math.round((data[i + 1] + fgColor.g) / 2); // G\n            data[i + 2] = Math.round((data[i + 2] + fgColor.b) / 2); // B\n        }\n    }\n    // Put the modified image data back\n    ctx.putImageData(imageData, 0, 0);\n    // Convert to data URL and return\n    return canvas.toDataURL('image/png');\n}\n/**\n * Extract body measurements from a segmented image\n * @param segmentation - BodyPix segmentation result\n * @param imageWidth - Width of the original image\n * @param imageHeight - Height of the original image\n */\nexport function extractBodyMeasurements(segmentation, imageWidth, imageHeight) {\n    // Initialize bounds\n    let minX = imageWidth;\n    let maxX = 0;\n    let minY = imageHeight;\n    let maxY = 0;\n    // Shoulders Y position\n    let shouldersY = 0;\n    let shouldersCount = 0;\n    // Waist tracking\n    let waistY = Math.floor(imageHeight * 0.5); // Approximate middle\n    let waistLeft = imageWidth;\n    let waistRight = 0;\n    // Hips tracking (lower third of body)\n    let hipsY = Math.floor(imageHeight * 0.7);\n    let hipsLeft = imageWidth;\n    let hipsRight = 0;\n    // Process the segmentation data\n    for (let y = 0; y < imageHeight; y++) {\n        for (let x = 0; x < imageWidth; x++) {\n            const index = y * imageWidth + x;\n            if (segmentation.data[index]) {\n                // Update bounds\n                minX = Math.min(minX, x);\n                maxX = Math.max(maxX, x);\n                minY = Math.min(minY, y);\n                maxY = Math.max(maxY, y);\n                // Check for shoulders (upper part)\n                if (y <= imageHeight * 0.3) {\n                    shouldersY += y;\n                    shouldersCount++;\n                }\n                // Check for waist points\n                if (Math.abs(y - waistY) < imageHeight * 0.05) {\n                    waistLeft = Math.min(waistLeft, x);\n                    waistRight = Math.max(waistRight, x);\n                }\n                // Check for hips points\n                if (Math.abs(y - hipsY) < imageHeight * 0.05) {\n                    hipsLeft = Math.min(hipsLeft, x);\n                    hipsRight = Math.max(hipsRight, x);\n                }\n            }\n        }\n    }\n    // Calculate measurements\n    const bodyWidth = maxX - minX;\n    const bodyHeight = maxY - minY;\n    const shouldersAvgY = shouldersCount > 0 ? shouldersY / shouldersCount : 0;\n    const waistWidth = waistRight - waistLeft;\n    const hipsWidth = hipsRight - hipsLeft;\n    // Return normalized measurements (as ratios of image dimensions)\n    return {\n        width: bodyWidth / imageWidth,\n        height: bodyHeight / imageHeight,\n        shouldersY: shouldersAvgY / imageHeight,\n        waistWidth: waistWidth / imageWidth,\n        hipsWidth: hipsWidth / imageWidth,\n        // Approximate sizing category based on proportions\n        approximateSize: calculateApproximateSize(waistWidth / hipsWidth, bodyWidth, bodyHeight),\n        // Body shape classification\n        bodyShape: classifyBodyShape(waistWidth / hipsWidth)\n    };\n}\n/**\n * Calculate approximate clothing size based on proportions\n */\nfunction calculateApproximateSize(waistToHipRatio, bodyWidth, bodyHeight) {\n    // Very simple approximation - would need calibration data for accuracy\n    if (bodyWidth < 100)\n        return 'XS';\n    if (bodyWidth < 150)\n        return 'S';\n    if (bodyWidth < 200)\n        return 'M';\n    if (bodyWidth < 250)\n        return 'L';\n    return 'XL';\n}\n/**\n * Classify body shape based on measurements\n * This is a very simplified version - a real implementation would be more nuanced\n */\nfunction classifyBodyShape(waistToHipRatio) {\n    if (waistToHipRatio < 0.75)\n        return 'hourglass';\n    if (waistToHipRatio < 0.85)\n        return 'pear';\n    if (waistToHipRatio > 0.95)\n        return 'apple';\n    return 'rectangle';\n}\n/**\n * Create an image element from a file or URL\n */\nfunction createImageElement(source) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            const img = new Image();\n            img.crossOrigin = 'anonymous';\n            img.onload = () => resolve(img);\n            img.onerror = (error) => reject(error);\n            if (typeof source === 'string') {\n                img.src = source;\n            }\n            else {\n                img.src = URL.createObjectURL(source);\n            }\n        });\n    });\n}\n/**\n * Convert hex color to RGB object\n */\nfunction hexToRgb(hex) {\n    // Default to black if invalid\n    if (!hex || hex === 'transparent') {\n        return { r: 0, g: 0, b: 0 };\n    }\n    // Remove # if present\n    hex = hex.replace(/^#/, '');\n    // Handle shorthand hex\n    if (hex.length === 3) {\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n    }\n    // Parse the hex values\n    const bigint = parseInt(hex, 16);\n    return {\n        r: (bigint >> 16) & 255,\n        g: (bigint >> 8) & 255,\n        b: bigint & 255\n    };\n}\n","// Background removal utility functions\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BackgroundRemovalMethod } from '@/types/tryOn';\nimport { removeBackgroundApi, isRemoveBgAvailable } from './removeBackgroundApi';\nimport { removeBackground as removeBackgroundTensorflow, isTensorflowSupported as isTfSupported, preloadBodyPixModel as preloadModel } from './tfBackgroundRemoval';\nimport { REMOVE_BG_API_KEY } from '@/utils/environment';\n/**\n * Remove background from an image using the specified method\n */\nexport const removeBackground = (imageData, options) => __awaiter(void 0, void 0, void 0, function* () {\n    let result;\n    try {\n        // Use the API key from options or environment\n        const apiKey = options.apiKey || REMOVE_BG_API_KEY;\n        switch (options.method) {\n            case BackgroundRemovalMethod.REMOVE_BG_API:\n                if (!apiKey) {\n                    throw new Error('API key is required for Remove.bg API');\n                }\n                // Check if the API key is valid\n                const isApiAvailable = yield isRemoveBgAvailable();\n                if (!isApiAvailable) {\n                    throw new Error('Remove.bg API is not available or key is invalid');\n                }\n                // File object required for API call\n                const imageFile = typeof imageData === 'string'\n                    ? yield dataUrlToFile(imageData, 'image.png')\n                    : imageData;\n                // Call the Remove.bg API\n                try {\n                    const resultUrl = yield removeBackgroundApi(imageFile, {\n                        apiKey: apiKey,\n                        size: mapQualityToSize(options.quality)\n                    });\n                    result = {\n                        success: true,\n                        imageUrl: resultUrl,\n                        method: BackgroundRemovalMethod.REMOVE_BG_API\n                    };\n                }\n                catch (apiError) {\n                    console.error('Remove.bg API error:', apiError);\n                    throw apiError;\n                }\n                break;\n            case BackgroundRemovalMethod.TENSORFLOW:\n                // Prepare image data\n                let imageDataUrl;\n                if (typeof imageData === 'string') {\n                    imageDataUrl = imageData;\n                }\n                else {\n                    // Convert File to data URL first\n                    imageDataUrl = yield fileToDataUrl(imageData);\n                }\n                // Apply image optimization if requested\n                if (options.optimizeOptions) {\n                    // Resize and optimize the image before processing\n                    const { width, height, quality } = options.optimizeOptions;\n                    const canvas = document.createElement('canvas');\n                    const ctx = canvas.getContext('2d');\n                    if (!ctx) {\n                        throw new Error('Could not get canvas context for image optimization');\n                    }\n                    // Load the image\n                    const img = new Image();\n                    img.src = imageDataUrl;\n                    yield new Promise((resolve) => {\n                        img.onload = () => resolve();\n                    });\n                    // Calculate dimensions while maintaining aspect ratio\n                    let targetWidth = width || img.width;\n                    let targetHeight = height || img.height;\n                    if (width && !height) {\n                        targetHeight = (img.height / img.width) * width;\n                    }\n                    else if (height && !width) {\n                        targetWidth = (img.width / img.height) * height;\n                    }\n                    // Set canvas dimensions\n                    canvas.width = targetWidth;\n                    canvas.height = targetHeight;\n                    // Draw image on canvas\n                    ctx.drawImage(img, 0, 0, targetWidth, targetHeight);\n                    // Convert to optimized data URL with quality setting\n                    const qualityValue = quality === 'low' ? 0.6 : quality === 'medium' ? 0.8 : 0.95;\n                    imageDataUrl = canvas.toDataURL('image/jpeg', qualityValue);\n                    console.log(`Optimized image from ${img.width}x${img.height} to ${targetWidth}x${targetHeight} with quality ${quality}`);\n                }\n                // Use TensorFlow to remove background with optimized image\n                const resultUrl = yield removeBackgroundTensorflow(imageDataUrl, {\n                    threshold: 0.7 // Adjust threshold for better results\n                });\n                result = {\n                    success: true,\n                    imageUrl: resultUrl,\n                    method: BackgroundRemovalMethod.TENSORFLOW\n                };\n                break;\n            case BackgroundRemovalMethod.MANUAL:\n                result = {\n                    success: false,\n                    error: 'Manual background removal not implemented',\n                    method: BackgroundRemovalMethod.MANUAL\n                };\n                break;\n            default:\n                result = {\n                    success: false,\n                    error: `Unknown removal method: ${options.method}`,\n                    method: options.method\n                };\n        }\n        // If primary method failed and fallback is enabled, try TensorFlow.js\n        if (!(result === null || result === void 0 ? void 0 : result.success) && options.fallbackToTensorflow && options.method !== BackgroundRemovalMethod.TENSORFLOW) {\n            console.log(`Falling back to TensorFlow.js background removal after ${options.method} failed`);\n            try {\n                // Check TensorFlow support first\n                const tfSupported = yield isTensorflowSupported();\n                if (!tfSupported) {\n                    throw new Error('TensorFlow.js not supported in this browser');\n                }\n                // Prepare image data\n                let imageDataUrl;\n                if (typeof imageData === 'string') {\n                    imageDataUrl = imageData;\n                }\n                else {\n                    // Convert File to data URL first\n                    imageDataUrl = yield fileToDataUrl(imageData);\n                }\n                // Always use optimization for fallback mode to ensure processing completes\n                // Use more aggressive optimization since this is a fallback\n                const optimizeOptions = options.optimizeOptions || {\n                    width: 600,\n                    height: 600,\n                    quality: 'low'\n                };\n                // Resize and optimize the image before processing\n                const { width, height, quality } = optimizeOptions;\n                const canvas = document.createElement('canvas');\n                const ctx = canvas.getContext('2d');\n                if (!ctx) {\n                    throw new Error('Could not get canvas context for image optimization');\n                }\n                // Load the image\n                const img = new Image();\n                img.src = imageDataUrl;\n                yield new Promise((resolve) => {\n                    img.onload = () => resolve();\n                });\n                // Calculate dimensions while maintaining aspect ratio\n                let targetWidth = width || img.width;\n                let targetHeight = height || img.height;\n                if (width && !height) {\n                    targetHeight = (img.height / img.width) * width;\n                }\n                else if (height && !width) {\n                    targetWidth = (img.width / img.height) * height;\n                }\n                // Set canvas dimensions\n                canvas.width = targetWidth;\n                canvas.height = targetHeight;\n                // Draw image on canvas\n                ctx.drawImage(img, 0, 0, targetWidth, targetHeight);\n                // Convert to optimized data URL with quality setting\n                const qualityValue = quality === 'low' ? 0.5 : quality === 'medium' ? 0.7 : 0.9;\n                imageDataUrl = canvas.toDataURL('image/jpeg', qualityValue);\n                console.log(`Fallback: Optimized image to ${targetWidth}x${targetHeight} with quality ${quality}`);\n                // Use TensorFlow to remove background with optimized image\n                const resultUrl = yield removeBackgroundTensorflow(imageDataUrl, {\n                    threshold: 0.65 // Slightly lower threshold for fallback to ensure we get a result\n                });\n                result = {\n                    success: true,\n                    imageUrl: resultUrl,\n                    method: BackgroundRemovalMethod.TENSORFLOW\n                };\n            }\n            catch (tfError) {\n                console.error('TensorFlow fallback error:', tfError);\n                // If fallback also fails, keep the original error\n            }\n        }\n        // Add body measurements if requested and operation succeeded\n        if (options.extractBodyMeasurements && (result === null || result === void 0 ? void 0 : result.success) && result.imageUrl) {\n            try {\n                // This will be implemented using the extractBodyMeasurements function\n                // For now, set a placeholder\n                result.bodyMeasurements = {\n                    approximateSize: 'M',\n                    bodyShape: 'rectangle'\n                };\n            }\n            catch (measureError) {\n                console.error('Error extracting body measurements:', measureError);\n            }\n        }\n        return result || {\n            success: false,\n            error: 'Background removal failed with all methods',\n            method: options.method\n        };\n    }\n    catch (error) {\n        console.error('Background removal error:', error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : String(error),\n            method: options.method\n        };\n    }\n});\n/**\n * Convert quality option to Remove.bg size parameter\n */\nconst mapQualityToSize = (quality) => {\n    switch (quality) {\n        case 'preview':\n            return 'preview';\n        case 'high':\n            return 'hd';\n        case 'full':\n            return 'medium';\n        default:\n            return 'auto';\n    }\n};\n/**\n * Helper function to convert File to data URL\n */\nconst fileToDataUrl = (file) => {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = (e) => {\n            var _a;\n            if ((_a = e.target) === null || _a === void 0 ? void 0 : _a.result) {\n                resolve(e.target.result);\n            }\n            else {\n                reject(new Error('Failed to convert file to data URL'));\n            }\n        };\n        reader.onerror = (error) => reject(error);\n        reader.readAsDataURL(file);\n    });\n};\n/**\n * Convert data URL to File object\n */\nconst dataUrlToFile = (dataUrl, filename) => {\n    return fetch(dataUrl)\n        .then(res => res.blob())\n        .then(blob => {\n        // Extract mime type from data URL\n        const mimeType = dataUrl.split(',')[0].split(':')[1].split(';')[0];\n        return new File([blob], filename, { type: mimeType });\n    });\n};\n/**\n * Check if the browser supports the WebGL backend for TensorFlow.js\n */\nexport const isTensorflowSupported = isTfSupported;\n/**\n * Preload the BodyPix model to reduce initial latency\n */\nexport const preloadBodyPixModel = preloadModel;\n","// Utilities for positioning images on canvas\nimport { GarmentType, BodyPosition } from '@/types/tryOn';\n/**\n * Calculate the center point of a rectangle\n */\nexport const calculateCenter = (rect) => {\n    return {\n        x: rect.x + rect.width / 2,\n        y: rect.y + rect.height / 2\n    };\n};\n/**\n * Calculate the positioning rectangle for a garment based on body position\n */\nexport const calculateGarmentPosition = (containerDimensions, garmentDimensions, bodyPosition, offset = { x: 0, y: 0 }) => {\n    // Default positioning is centered\n    let x = (containerDimensions.width - garmentDimensions.width) / 2;\n    let y = (containerDimensions.height - garmentDimensions.height) / 2;\n    // Adjust based on body position\n    switch (bodyPosition) {\n        case BodyPosition.UPPER_BODY:\n            y = containerDimensions.height * 0.25 - garmentDimensions.height / 2;\n            break;\n        case BodyPosition.LOWER_BODY:\n            y = containerDimensions.height * 0.65 - garmentDimensions.height / 2;\n            break;\n        case BodyPosition.FEET:\n            y = containerDimensions.height - garmentDimensions.height;\n            break;\n        case BodyPosition.HEAD:\n            y = 0;\n            break;\n        case BodyPosition.NECK:\n            y = containerDimensions.height * 0.15 - garmentDimensions.height / 2;\n            break;\n        case BodyPosition.WAIST:\n            y = containerDimensions.height * 0.5 - garmentDimensions.height / 2;\n            break;\n        case BodyPosition.HANDS:\n            // This depends on whether it's left or right hand\n            // We'll use offset for this\n            break;\n        case BodyPosition.FULL_BODY:\n            // Already centered\n            break;\n    }\n    // Apply offset\n    x += offset.x;\n    y += offset.y;\n    return {\n        x,\n        y,\n        width: garmentDimensions.width,\n        height: garmentDimensions.height\n    };\n};\n/**\n * Get default body position for a garment type\n */\nexport const getDefaultBodyPosition = (garmentType) => {\n    switch (garmentType) {\n        case GarmentType.TOP:\n            return BodyPosition.UPPER_BODY;\n        case GarmentType.BOTTOM:\n            return BodyPosition.LOWER_BODY;\n        case GarmentType.DRESS:\n            return BodyPosition.FULL_BODY;\n        case GarmentType.OUTERWEAR:\n            return BodyPosition.UPPER_BODY;\n        case GarmentType.SHOES:\n            return BodyPosition.FEET;\n        case GarmentType.ACCESSORY:\n            return BodyPosition.HEAD; // Default, should be specified\n        default:\n            return BodyPosition.FULL_BODY;\n    }\n};\n/**\n * Get default z-index for garment type (for layering)\n */\nexport const getDefaultZIndex = (garmentType) => {\n    switch (garmentType) {\n        case GarmentType.TOP:\n            return 10;\n        case GarmentType.BOTTOM:\n            return 5;\n        case GarmentType.DRESS:\n            return 10;\n        case GarmentType.OUTERWEAR:\n            return 15;\n        case GarmentType.SHOES:\n            return 5;\n        case GarmentType.ACCESSORY:\n            return 20;\n        default:\n            return 10;\n    }\n};\n/**\n * Get recommended scale for garment type\n */\nexport const getRecommendedScale = (garmentType, containerDimensions) => {\n    // These are approximate values and should be adjusted based on actual garment images\n    switch (garmentType) {\n        case GarmentType.TOP:\n            return containerDimensions.width * 0.7 / 600; // Assuming 600px is the \"standard\" width\n        case GarmentType.BOTTOM:\n            return containerDimensions.width * 0.6 / 500;\n        case GarmentType.DRESS:\n            return containerDimensions.width * 0.8 / 500;\n        case GarmentType.OUTERWEAR:\n            return containerDimensions.width * 0.75 / 600;\n        case GarmentType.SHOES:\n            return containerDimensions.width * 0.4 / 400;\n        case GarmentType.ACCESSORY:\n            return containerDimensions.width * 0.3 / 300;\n        default:\n            return 1.0;\n    }\n};\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","setupMockApiInterceptors","apiClient","originalRequestWithRetry","bind","method","url","data","config","this","shouldUseMockResponseForRequest","options","Object","assign","params","mockResponse","simulateNetworkDelay","error","includes","delay","Math","random","setTimeout","SyncContext","createContext","undefined","useSyncContext","context","useContext","Error","SyncProvider","children","syncService","network","userStore","isMounted","setIsMounted","useState","backgroundTasksStarted","useRef","backgroundTasksCompleted","maxSyncTimeout","useEffect","current","window","__STYLIST_BACKGROUND_INIT_COMPLETE","timer","user","isOnline","syncNow","clearTimeout","handleVisibilityChange","document","visibilityState","addEventListener","removeEventListener","syncState","state","isSlowConnection","__STYLIST_WIDGET_RENDER_COMPLETE","Provider","calculateAspectRatioDimensions","originalWidth","originalHeight","targetWidth","targetHeight","maxWidth","maxHeight","width","height","round","SYNC_LAST_TIMESTAMP","SYNC_QUEUE_KEY","SyncOperationType","useSyncService","setState","navigator","onLine","isSyncing","lastSyncTimestamp","Number","localStorage","getItem","pendingOperations","syncQueue","syncIntervalRef","baseURL","timeout","maxRetries","getAuthHeader","token","Authorization","createSyncApiClient","loadSyncQueue","useCallback","queueStr","JSON","parse","saveSyncQueue","queue","setItem","stringify","prev","filter","item","resolved","length","handleOnline","syncData","handleOffline","queueOperation","operation","userId","newItem","id","Date","now","toString","substring","timestamp","retryCount","updatedQueue","executeOperation","ADD_CLOSET_ITEM","addClosetItem","REMOVE_CLOSET_ITEM","removeClosetItem","itemId","UPDATE_CLOSET_ITEM","updateClosetItem","updates","TOGGLE_FAVORITE","toggleFavoriteItem","favorite","UPDATE_PREFERENCES","updatePreferences","SUBMIT_QUIZ","submitStyleQuiz","SAVE_OUTFIT","REMOVE_OUTFIT","ADD_LIKED_ITEM","ADD_DISLIKED_ITEM","REMOVE_LIKED_ITEM","REMOVE_DISLIKED_ITEM","resolveConflicts","localUser","serverUser","localTimestamp","lastActive","getTime","mergedUser","closetMap","Map","closet","forEach","set","localItem","serverItem","get","dateAdded","Array","from","values","likedItems","Set","feedback","dislikedItems","viewedItems","savedOutfits","localOutfit","some","outfit","every","push","lastInteraction","max","syncWithServer","getUserProfile","setUser","_a","pendingItems","index","findIndex","q","clearInterval","setInterval","toggleFavorite","preferences","submitQuiz","answers","saveOutfit","removeOutfit","outfitId","loadImage","img","Image","crossOrigin","onload","onerror","src","getImageDimensions","imageUrl","fileToDataUrl","file","reader","FileReader","target","readAsDataURL","isImageFile","type","startsWith","getFormattedFileSize","sizeInBytes","toFixed","feedbackSyncService","constructor","syncIntervalId","syncInterval","isInitialized","apiConfig","initialize","startSyncInterval","syncFeedback","stopSyncInterval","feedbackStore","getState","getPendingSyncItems","setIsSyncing","api","response","feedbackItems","success","syncedItemIds","markAsSynced","FEEDBACK_SYNCED","count","cleanup","drawImageToCanvas","ctx","image","rect","rotation","flipHorizontal","flipVertical","save","centerX","x","centerY","y","translate","rotate","PI","scaleX","scaleY","scale","drawImage","restore","drawImageToCanvasLowQuality","abs","optimizedRect","compositeImages","canvas","userImage","garments","getContext","clearRect","sortedGarments","sort","a","b","zIndex","garment","garmentImage","dimensions","scaledDimensions","offset","position","compositeImagesLowQuality","alpha","ctx2d","imageSmoothingQuality","scaleFactor","imageCache","has","keys","key","tempCanvas","createElement","tempCtx","canvasToImage","toDataURL","drawGuidelines","lineColor","lineWidth","strokeStyle","i","beginPath","moveTo","lineTo","stroke","ChatService","recommendationApi","userApi","conversationHistory","conversationContext","userContext","stylePreferences","closetItems","recentSearches","recentInteractions","specialCommands","claudeConfig","apiKey","baseUrl","modelName","fallbackMode","toLocaleDateString","initializeSpecialCommands","loadUserContext","generateTrendInsights","category","trendingItems","brands","map","brand","Boolean","uniqueBrands","colors","isArray","uniqueColors","insights","slice","join","pattern","handler","text","matches","_b","itemType","trim","toLowerCase","occasion","messages","createTextMessage","ASSISTANT","addRecommendationMessage","priceLimit","parseInt","recommendations","getRecommendations","includeOutfits","limit","outfits","chatOutfit","convertRecommendationOutfitToChatOutfit","createOutfitMessage","SYSTEM","_c","_d","_e","trending","items","trendInsights","chatItems","convertRecommendationItemsToChatItems","createRecommendationMessage","_f","searchQuery","deepSearch","processMessage","MESSAGE_SENT","trackMessageSent","shift","lastMessageTimestamp","responseMessages","userMessage","TEXT","sender","USER","specialCommandResponse","processSpecialCommands","intent","categorizeIntent","claudeResponse","callClaudeAPI","responseMessage","containsRecommendationIntent","additionalMessages","extractContext","demoResponse","getDemoResponse","acknowledgeMessage","quizMessage","tryOnMessage","greeting","lastMsgTime","greetingMessage","helpMessage","weddingMessage","weddingRecommendations","defaultMessage","processImageUpload","imageFile","uploadMessage","analysisDelay","analysisMessage","errorMessage","processURLInput","urlMessage","lookupDelay","productMessage","command","match","userProfile","savedContext","parsedContext","updateConversationContext","contextUpdates","stylePrefs","stylesContext","favoriteColors","stylePersona","preferredFit","closetSummary","feedbackContext","callDirectClaudeAPI","directError","apiUrl","fetch","headers","body","message","ok","json","model","role","content","max_tokens","statusText","assistantResponse","aiResponse","lowerAiResponse","lowerUserMessage","aiRecommendPhrases","userRecommendPhrases","phrase","recommendationMessage","outfitIntroMessage","name","price","salePrice","imageUrls","matchScore","matchReasons","lowerText","query","categories","occasions","RECOMMENDATION","OUTFIT","STORAGE_KEYS","listeners","defaultOfflineData","userPreferences","recentItems","cachedProducts","lastUpdated","listener","processPendingRequests","addNetworkStatusListener","indexOf","splice","getNetworkStatus","saveOfflineData","offlineData","getOfflineData","queueRequest","pendingRequest","pendingRequests","getPendingRequests","successfulRequestIds","allSettled","request","status","updatedPendingRequests","setOfflineMode","enabled","isOfflineModeEnabled","handleOfflineRequest","Response","urlPath","URL","pathname","toUpperCase","queued","segments","split","productId","offlineService","initOfflineService","cleanupOfflineService","clearOfflineData","removeItem","offlineFetch","offlineOptions","offlineable","timeoutPromise","_","race","clonedResponse","clone","offlineResponse","bodyPixModel","isModelLoading","modelLoadQueue","webGLCapabilitiesCache","checkWebGLCapabilities","supported","level","extensions","fullSupport","fallbackOptions","useCPUBackend","useSimpleSegmentation","useReducedPrecision","useProgressiveLoading","gl","failIfMajorPerformanceCaveat","getSupportedExtensions","supportedRequired","ext","debugInfo","getExtension","getParameter","UNMASKED_VENDOR_WEBGL","rendererLower","UNMASKED_RENDERER_WEBGL","debugError","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","deleteShader","shaderError","configureTensorFlow","webGLCaps","catch","err","innerErr","preloadBodyPixModel","modelConfig","architecture","outputStride","multiplier","quantBytes","modelUrl","backendError","modelError","fallbackError","alternativeError","removeBackground","imageSource","createObjectURL","imageElement","source","createImageElement","segmentation","segmentPerson","internalResolution","segmentationThreshold","threshold","bodyPixOptions","segmentationError","mediumError","lowError","backgroundColor","foregroundColor","imageData","getImageData","pixelIndex","floor","fgColor","hexToRgb","r","g","bgColor","putImageData","processSegmentation","errorMsg","String","hex","replace","bigint","REMOVE_BG_API","isApiAvailable","isRemoveBgAvailable","dataUrlToFile","resultUrl","formData","FormData","append","size","crop","format","errorData","errors","title","imageBlob","blob","onloadend","removeBackgroundApi","mapQualityToSize","quality","apiError","TENSORFLOW","imageDataUrl","optimizeOptions","qualityValue","MANUAL","fallbackToTensorflow","tfError","extractBodyMeasurements","bodyMeasurements","approximateSize","bodyShape","measureError","dataUrl","filename","res","mimeType","File","dispose","tensorError","getDefaultBodyPosition","garmentType","TOP","UPPER_BODY","BOTTOM","LOWER_BODY","DRESS","FULL_BODY","OUTERWEAR","SHOES","FEET","ACCESSORY","HEAD","getDefaultZIndex"],"sourceRoot":""}