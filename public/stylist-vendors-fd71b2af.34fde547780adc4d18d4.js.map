{"version":3,"file":"stylist-vendors-fd71b2af.34fde547780adc4d18d4.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/setdiff1d_async.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/scatter_nd_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/selu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/selu_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/scalar.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/segment_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/search_sorted.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/separable_conv2d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/scatter_nd.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { TensorBuffer } from '../tensor';\nimport { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\n/**\n * Computes the difference between two lists of numbers.\n *\n * Given a Tensor `x` and a Tensor `y`, this operation returns a Tensor `out`\n * that represents all values that are in `x` but not in `y`. The returned\n * Tensor `out` is sorted in the same order that the numbers appear in `x`\n * (duplicates are preserved). This operation also returns a Tensor indices that\n * represents the position of each out element in `x`. In other words:\n *\n * `out[i] = x[idx[i]] for i in [0, 1, ..., out.length - 1]`\n *\n * ```js\n * const x = [1, 2, 3, 4, 5, 6];\n * const y = [1, 3, 5];\n *\n * const [out, indices] = await tf.setdiff1dAsync(x, y);\n * out.print(); // [2, 4, 6]\n * indices.print(); // [1, 3, 5]\n * ```\n *\n * @param x 1-D Tensor. Values to keep.\n * @param y 1-D Tensor. Must have the same type as x. Values to exclude in the\n *     output.\n * @returns Promise of Tensor tuple [out, indices].\n *  out: Tensor with the same type as x.\n *  indices: A Tensor of type int32.\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nasync function setdiff1dAsync_(x, y) {\n    const $x = convertToTensor(x, 'x', 'setdiff1d');\n    const $y = convertToTensor(y, 'y', 'setdiff1d');\n    util.assert($x.dtype === $y.dtype, () => `x and y should have the same dtype, but got x (${$x.dtype}) and y (${$y.dtype}).`);\n    util.assert($x.rank === 1, () => `x should be 1D tensor, but got x (${$x.shape}).`);\n    util.assert($y.rank === 1, () => `y should be 1D tensor, but got y (${$y.shape}).`);\n    const xVals = await $x.data();\n    const yVals = await $y.data();\n    const ySet = new Set(yVals);\n    let outputSize = 0;\n    for (let i = 0; i < xVals.length; i++) {\n        if (!ySet.has(xVals[i])) {\n            outputSize++;\n        }\n    }\n    const buffer = new TensorBuffer([outputSize], $x.dtype);\n    const indices = new TensorBuffer([outputSize], 'int32');\n    for (let i = 0, p = 0; i < xVals.length; i++) {\n        if (!ySet.has(xVals[i])) {\n            buffer.values[p] = xVals[i];\n            indices.values[p] = i;\n            p++;\n        }\n    }\n    return [buffer.toTensor(), indices.toTensor()];\n}\nexport const setdiff1dAsync = setdiff1dAsync_;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V0ZGlmZjFkX2FzeW5jLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc2V0ZGlmZjFkX2FzeW5jLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE9BQU8sRUFBUyxZQUFZLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDL0MsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBRW5ELE9BQU8sS0FBSyxJQUFJLE1BQU0sU0FBUyxDQUFDO0FBRWhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNEJHO0FBQ0gsS0FBSyxVQUFVLGVBQWUsQ0FDMUIsQ0FBb0IsRUFBRSxDQUFvQjtJQUM1QyxNQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUNoRCxNQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUVoRCxJQUFJLENBQUMsTUFBTSxDQUNQLEVBQUUsQ0FBQyxLQUFLLEtBQUssRUFBRSxDQUFDLEtBQUssRUFDckIsR0FBRyxFQUFFLENBQUMsa0RBQ0YsRUFBRSxDQUFDLEtBQUssWUFBWSxFQUFFLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQztJQUUxQyxJQUFJLENBQUMsTUFBTSxDQUNQLEVBQUUsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLHFDQUFxQyxFQUFFLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQztJQUU1RSxJQUFJLENBQUMsTUFBTSxDQUNQLEVBQUUsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLHFDQUFxQyxFQUFFLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQztJQUU1RSxNQUFNLEtBQUssR0FBRyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUM5QixNQUFNLEtBQUssR0FBRyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUM5QixNQUFNLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUU1QixJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7SUFDbkIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDdkIsVUFBVSxFQUFFLENBQUM7U0FDZDtLQUNGO0lBRUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQyxVQUFVLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN4RCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQzVDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ3ZCLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzVCLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3RCLENBQUMsRUFBRSxDQUFDO1NBQ0w7S0FDRjtJQUNELE9BQU8sQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLEVBQUUsT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7QUFDakQsQ0FBQztBQUNELE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBRyxlQUFlLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5pbXBvcnQge1RlbnNvciwgVGVuc29yQnVmZmVyfSBmcm9tICcuLi90ZW5zb3InO1xuaW1wb3J0IHtjb252ZXJ0VG9UZW5zb3J9IGZyb20gJy4uL3RlbnNvcl91dGlsX2Vudic7XG5pbXBvcnQge1RlbnNvckxpa2V9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gbGlzdHMgb2YgbnVtYmVycy5cbiAqXG4gKiBHaXZlbiBhIFRlbnNvciBgeGAgYW5kIGEgVGVuc29yIGB5YCwgdGhpcyBvcGVyYXRpb24gcmV0dXJucyBhIFRlbnNvciBgb3V0YFxuICogdGhhdCByZXByZXNlbnRzIGFsbCB2YWx1ZXMgdGhhdCBhcmUgaW4gYHhgIGJ1dCBub3QgaW4gYHlgLiBUaGUgcmV0dXJuZWRcbiAqIFRlbnNvciBgb3V0YCBpcyBzb3J0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGUgbnVtYmVycyBhcHBlYXIgaW4gYHhgXG4gKiAoZHVwbGljYXRlcyBhcmUgcHJlc2VydmVkKS4gVGhpcyBvcGVyYXRpb24gYWxzbyByZXR1cm5zIGEgVGVuc29yIGluZGljZXMgdGhhdFxuICogcmVwcmVzZW50cyB0aGUgcG9zaXRpb24gb2YgZWFjaCBvdXQgZWxlbWVudCBpbiBgeGAuIEluIG90aGVyIHdvcmRzOlxuICpcbiAqIGBvdXRbaV0gPSB4W2lkeFtpXV0gZm9yIGkgaW4gWzAsIDEsIC4uLiwgb3V0Lmxlbmd0aCAtIDFdYFxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCB4ID0gWzEsIDIsIDMsIDQsIDUsIDZdO1xuICogY29uc3QgeSA9IFsxLCAzLCA1XTtcbiAqXG4gKiBjb25zdCBbb3V0LCBpbmRpY2VzXSA9IGF3YWl0IHRmLnNldGRpZmYxZEFzeW5jKHgsIHkpO1xuICogb3V0LnByaW50KCk7IC8vIFsyLCA0LCA2XVxuICogaW5kaWNlcy5wcmludCgpOyAvLyBbMSwgMywgNV1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB4IDEtRCBUZW5zb3IuIFZhbHVlcyB0byBrZWVwLlxuICogQHBhcmFtIHkgMS1EIFRlbnNvci4gTXVzdCBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgeC4gVmFsdWVzIHRvIGV4Y2x1ZGUgaW4gdGhlXG4gKiAgICAgb3V0cHV0LlxuICogQHJldHVybnMgUHJvbWlzZSBvZiBUZW5zb3IgdHVwbGUgW291dCwgaW5kaWNlc10uXG4gKiAgb3V0OiBUZW5zb3Igd2l0aCB0aGUgc2FtZSB0eXBlIGFzIHguXG4gKiAgaW5kaWNlczogQSBUZW5zb3Igb2YgdHlwZSBpbnQzMi5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdUcmFuc2Zvcm1hdGlvbnMnfVxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRkaWZmMWRBc3luY18oXG4gICAgeDogVGVuc29yfFRlbnNvckxpa2UsIHk6IFRlbnNvcnxUZW5zb3JMaWtlKTogUHJvbWlzZTxbVGVuc29yLCBUZW5zb3JdPiB7XG4gIGNvbnN0ICR4ID0gY29udmVydFRvVGVuc29yKHgsICd4JywgJ3NldGRpZmYxZCcpO1xuICBjb25zdCAkeSA9IGNvbnZlcnRUb1RlbnNvcih5LCAneScsICdzZXRkaWZmMWQnKTtcblxuICB1dGlsLmFzc2VydChcbiAgICAgICR4LmR0eXBlID09PSAkeS5kdHlwZSxcbiAgICAgICgpID0+IGB4IGFuZCB5IHNob3VsZCBoYXZlIHRoZSBzYW1lIGR0eXBlLCBidXQgZ290IHggKCR7XG4gICAgICAgICAgJHguZHR5cGV9KSBhbmQgeSAoJHskeS5kdHlwZX0pLmApO1xuXG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgJHgucmFuayA9PT0gMSwgKCkgPT4gYHggc2hvdWxkIGJlIDFEIHRlbnNvciwgYnV0IGdvdCB4ICgkeyR4LnNoYXBlfSkuYCk7XG5cbiAgdXRpbC5hc3NlcnQoXG4gICAgICAkeS5yYW5rID09PSAxLCAoKSA9PiBgeSBzaG91bGQgYmUgMUQgdGVuc29yLCBidXQgZ290IHkgKCR7JHkuc2hhcGV9KS5gKTtcblxuICBjb25zdCB4VmFscyA9IGF3YWl0ICR4LmRhdGEoKTtcbiAgY29uc3QgeVZhbHMgPSBhd2FpdCAkeS5kYXRhKCk7XG4gIGNvbnN0IHlTZXQgPSBuZXcgU2V0KHlWYWxzKTtcblxuICBsZXQgb3V0cHV0U2l6ZSA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeFZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXlTZXQuaGFzKHhWYWxzW2ldKSkge1xuICAgICAgb3V0cHV0U2l6ZSsrO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBUZW5zb3JCdWZmZXIoW291dHB1dFNpemVdLCAkeC5kdHlwZSk7XG4gIGNvbnN0IGluZGljZXMgPSBuZXcgVGVuc29yQnVmZmVyKFtvdXRwdXRTaXplXSwgJ2ludDMyJyk7XG4gIGZvciAobGV0IGkgPSAwLCBwID0gMDsgaSA8IHhWYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCF5U2V0Lmhhcyh4VmFsc1tpXSkpIHtcbiAgICAgIGJ1ZmZlci52YWx1ZXNbcF0gPSB4VmFsc1tpXTtcbiAgICAgIGluZGljZXMudmFsdWVzW3BdID0gaTtcbiAgICAgIHArKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtidWZmZXIudG9UZW5zb3IoKSwgaW5kaWNlcy50b1RlbnNvcigpXTtcbn1cbmV4cG9ydCBjb25zdCBzZXRkaWZmMWRBc3luYyA9IHNldGRpZmYxZEFzeW5jXztcbiJdfQ==","import { computeStrides, sizeFromShape } from '../util';\n/**\n * Check whether updates.shape = indices.shape[:batchDim] +\n * shape[sliceDim:]\n *\n * @param x The input tensor.\n */\nexport function validateUpdateShape(shape, indices, updates) {\n    const sliceDim = (indices.rank > 1) ? indices.shape[indices.rank - 1] : 1;\n    const batchDim = (indices.rank > 1) ? indices.rank - 1 : 1;\n    const shapeError = 'Must have updates.shape = indices.shape[:batchDim] + ' +\n        `shape[sliceDim:], got updates.shape: ${updates.shape}` +\n        `, indices.shape: ${indices.shape}, shape: ${shape}` +\n        `, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;\n    if (updates.rank < batchDim) {\n        throw new Error(shapeError + ` update.rank < ${batchDim}. `);\n    }\n    if (shape.length < sliceDim + (updates.rank - batchDim)) {\n        throw new Error(shapeError +\n            ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);\n    }\n    if (updates.rank !== batchDim + shape.length - sliceDim) {\n        throw new Error(shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);\n    }\n    for (let d = 0; d < batchDim; ++d) {\n        if (updates.shape[d] !== indices.shape[d]) {\n            throw new Error(shapeError +\n                ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${indices.shape[d]}).`);\n        }\n    }\n    for (let d = 0; d < updates.rank - batchDim; ++d) {\n        if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {\n            throw new Error(shapeError +\n                ` updates.shape[${d + batchDim}] (${updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${shape[d + batchDim]})`);\n        }\n    }\n}\n/**\n * Validate scatter nd inputs.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n */\nexport function validateInput(updates, indices, shape) {\n    if (indices.rank < 1) {\n        throw new Error('tf.scatterND() expects the indices to be rank 1 or higher,' +\n            ` but the rank was ${indices.rank}.`);\n    }\n    if (updates.rank < 1) {\n        throw new Error('tf.scatterND() expects the updates to be rank 1 or higher,' +\n            ` but the rank was ${updates.rank}.`);\n    }\n    if (indices.dtype !== 'int32') {\n        throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${indices.dtype}`);\n    }\n    if (shape.length < 1) {\n        throw new Error(`Output rank must be greater or equal to 1, but got shape: ${shape}`);\n    }\n    if (shape.length === 0) {\n        if (indices.size === 0) {\n            throw new Error(`Indices specified for empty output. indices shape: ${indices.shape}`);\n        }\n        if (updates.size === 0) {\n            throw new Error(`Updates specified for empty output. updates shape: ${updates.shape}`);\n        }\n    }\n    validateUpdateShape(shape, indices, updates);\n}\n/**\n * Calculate the shape information for the output.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n *\n * @returns ScatterShapeInfo\n */\nexport function calculateShapes(updates, indices, shape) {\n    // Calculate the number of dimensions in indices\n    const indicesRank = indices.shape.length;\n    const sliceRank = (indicesRank > 1) ? indices.shape[indicesRank - 1] : 1;\n    // Calculate the number of elements that make up each slice of our updated\n    // tensor. This allows us to work with flattened tensors and copy over whole\n    // slices at a time.\n    const totalNd = shape.length;\n    let sliceSize = 1;\n    for (let i = sliceRank; i < totalNd; ++i) {\n        sliceSize *= shape[i];\n    }\n    const safeSliceDim = (sliceRank < 1) ? 1 : sliceRank;\n    const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;\n    const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];\n    const outputSize = sizeFromShape(shape);\n    return { sliceRank, numUpdates, sliceSize, strides, outputSize };\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhdHRlcl9uZF91dGlsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc2NhdHRlcl9uZF91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWtCQSxPQUFPLEVBQUMsY0FBYyxFQUFFLGFBQWEsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUV0RDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxtQkFBbUIsQ0FDL0IsS0FBZSxFQUFFLE9BQWUsRUFBRSxPQUFlO0lBQ25ELE1BQU0sUUFBUSxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUUsTUFBTSxRQUFRLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRTNELE1BQU0sVUFBVSxHQUFHLHVEQUF1RDtRQUN0RSx3Q0FBd0MsT0FBTyxDQUFDLEtBQUssRUFBRTtRQUN2RCxvQkFBb0IsT0FBTyxDQUFDLEtBQUssWUFBWSxLQUFLLEVBQUU7UUFDcEQsZUFBZSxRQUFRLG1CQUFtQixRQUFRLEdBQUcsQ0FBQztJQUUxRCxJQUFJLE9BQU8sQ0FBQyxJQUFJLEdBQUcsUUFBUSxFQUFFO1FBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsVUFBVSxHQUFHLGtCQUFrQixRQUFRLElBQUksQ0FBQyxDQUFDO0tBQzlEO0lBQ0QsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLFFBQVEsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsUUFBUSxDQUFDLEVBQUU7UUFDdkQsTUFBTSxJQUFJLEtBQUssQ0FDWCxVQUFVO1lB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cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5pbXBvcnQgeyBUZW5zb3JJbmZvIH0gZnJvbSAnLi4vdGVuc29yX2luZm8nO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5pbXBvcnQge2NvbXB1dGVTdHJpZGVzLCBzaXplRnJvbVNoYXBlfSBmcm9tICcuLi91dGlsJztcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHVwZGF0ZXMuc2hhcGUgPSBpbmRpY2VzLnNoYXBlWzpiYXRjaERpbV0gK1xuICogc2hhcGVbc2xpY2VEaW06XVxuICpcbiAqIEBwYXJhbSB4IFRoZSBpbnB1dCB0ZW5zb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVVwZGF0ZVNoYXBlKFxuICAgIHNoYXBlOiBudW1iZXJbXSwgaW5kaWNlczogVGVuc29yLCB1cGRhdGVzOiBUZW5zb3IpIHtcbiAgY29uc3Qgc2xpY2VEaW0gPSAoaW5kaWNlcy5yYW5rID4gMSkgPyBpbmRpY2VzLnNoYXBlW2luZGljZXMucmFuayAtIDFdIDogMTtcbiAgY29uc3QgYmF0Y2hEaW0gPSAoaW5kaWNlcy5yYW5rID4gMSkgPyBpbmRpY2VzLnJhbmsgLSAxIDogMTtcblxuICBjb25zdCBzaGFwZUVycm9yID0gJ011c3QgaGF2ZSB1cGRhdGVzLnNoYXBlID0gaW5kaWNlcy5zaGFwZVs6YmF0Y2hEaW1dICsgJyArXG4gICAgICBgc2hhcGVbc2xpY2VEaW06XSwgZ290IHVwZGF0ZXMuc2hhcGU6ICR7dXBkYXRlcy5zaGFwZX1gICtcbiAgICAgIGAsIGluZGljZXMuc2hhcGU6ICR7aW5kaWNlcy5zaGFwZX0sIHNoYXBlOiAke3NoYXBlfWAgK1xuICAgICAgYCwgc2xpY2VEaW06ICR7c2xpY2VEaW19LCBhbmQgYmF0Y2hEaW06ICR7YmF0Y2hEaW19LmA7XG5cbiAgaWYgKHVwZGF0ZXMucmFuayA8IGJhdGNoRGltKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHNoYXBlRXJyb3IgKyBgIHVwZGF0ZS5yYW5rIDwgJHtiYXRjaERpbX0uIGApO1xuICB9XG4gIGlmIChzaGFwZS5sZW5ndGggPCBzbGljZURpbSArICh1cGRhdGVzLnJhbmsgLSBiYXRjaERpbSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIHNoYXBlRXJyb3IgK1xuICAgICAgICBgIE91dHB1dCBzaGFwZSBsZW5ndGggPCAke3NsaWNlRGltICsgKHVwZGF0ZXMucmFuayAtIGJhdGNoRGltKX1gKTtcbiAgfVxuICBpZiAodXBkYXRlcy5yYW5rICE9PSBiYXRjaERpbSArIHNoYXBlLmxlbmd0aCAtIHNsaWNlRGltKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBzaGFwZUVycm9yICsgYCB1cGRhdGUucmFuayAhPSAke2JhdGNoRGltICsgc2hhcGUubGVuZ3RoIC0gc2xpY2VEaW19YCk7XG4gIH1cbiAgZm9yIChsZXQgZCA9IDA7IGQgPCBiYXRjaERpbTsgKytkKSB7XG4gICAgaWYgKHVwZGF0ZXMuc2hhcGVbZF0gIT09IGluZGljZXMuc2hhcGVbZF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBzaGFwZUVycm9yICtcbiAgICAgICAgICBgIHVwZGF0ZXMuc2hhcGVbJHtkfV0gKCR7dXBkYXRlcy5zaGFwZVtkXX0pICE9IGluZGljZXMuc2hhcGVbJHtkfV0gKCR7XG4gICAgICAgICAgICAgIGluZGljZXMuc2hhcGVbZF19KS5gKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgZCA9IDA7IGQgPCB1cGRhdGVzLnJhbmsgLSBiYXRjaERpbTsgKytkKSB7XG4gICAgaWYgKHVwZGF0ZXMuc2hhcGVbZCArIGJhdGNoRGltXSAhPT0gc2hhcGVbZCArIHNsaWNlRGltXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIHNoYXBlRXJyb3IgK1xuICAgICAgICAgIGAgdXBkYXRlcy5zaGFwZVske2QgKyBiYXRjaERpbX1dICgke1xuICAgICAgICAgICAgICB1cGRhdGVzLnNoYXBlW2QgKyBiYXRjaERpbV19KSAhPSBzaGFwZVske2QgKyBiYXRjaERpbX1dICgke1xuICAgICAgICAgICAgICBzaGFwZVtkICsgYmF0Y2hEaW1dfSlgKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY2F0dGVyU2hhcGVJbmZvIHtcbiAgc2xpY2VSYW5rOiBudW1iZXI7XG4gIG51bVVwZGF0ZXM6IG51bWJlcjtcbiAgc2xpY2VTaXplOiBudW1iZXI7XG4gIHN0cmlkZXM6IG51bWJlcltdO1xuICBvdXRwdXRTaXplOiBudW1iZXI7XG59XG4vKipcbiAqIFZhbGlkYXRlIHNjYXR0ZXIgbmQgaW5wdXRzLlxuICpcbiAqIEBwYXJhbSB1cGRhdGUgVGhlIHRlbnNvciBjb250YWlucyB0aGUgdXBkYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSBpbmRpY2VzIFRoZSB0ZW5zb3IgY29udGFpbnMgdGhlIGluZGljZXMgZm9yIHRoZSB1cGRhdGUgdmFsdWVzLlxuICogQHBhcmFtIHNoYXBlIFRoZSBzaGFwZSBvZiB0aGUgb3V0cHV0IHRlbnNvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlSW5wdXQoXG4gICAgdXBkYXRlczogVGVuc29yLCBpbmRpY2VzOiBUZW5zb3IsIHNoYXBlOiBudW1iZXJbXSkge1xuICBpZiAoaW5kaWNlcy5yYW5rIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3RmLnNjYXR0ZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwnICtcbiAgICAgICAgYCBidXQgdGhlIHJhbmsgd2FzICR7aW5kaWNlcy5yYW5rfS5gKTtcbiAgfVxuICBpZiAodXBkYXRlcy5yYW5rIDwgMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ3RmLnNjYXR0ZXJORCgpIGV4cGVjdHMgdGhlIHVwZGF0ZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwnICtcbiAgICAgICAgYCBidXQgdGhlIHJhbmsgd2FzICR7dXBkYXRlcy5yYW5rfS5gKTtcbiAgfVxuICBpZiAoaW5kaWNlcy5kdHlwZSAhPT0gJ2ludDMyJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGR0eXBlIG9mICdpbmRpY2VzJyBzaG91bGQgYmUgaW50MzIsIGJ1dCBnb3QgZHR5cGU6ICR7XG4gICAgICAgIGluZGljZXMuZHR5cGV9YCk7XG4gIH1cbiAgaWYgKHNoYXBlLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBPdXRwdXQgcmFuayBtdXN0IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMSwgYnV0IGdvdCBzaGFwZTogJHtzaGFwZX1gKTtcbiAgfVxuXG4gIGlmIChzaGFwZS5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaW5kaWNlcy5zaXplID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluZGljZXMgc3BlY2lmaWVkIGZvciBlbXB0eSBvdXRwdXQuIGluZGljZXMgc2hhcGU6ICR7XG4gICAgICAgICAgaW5kaWNlcy5zaGFwZX1gKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVcGRhdGVzIHNwZWNpZmllZCBmb3IgZW1wdHkgb3V0cHV0LiB1cGRhdGVzIHNoYXBlOiAke1xuICAgICAgICAgIHVwZGF0ZXMuc2hhcGV9YCk7XG4gICAgfVxuICB9XG5cbiAgdmFsaWRhdGVVcGRhdGVTaGFwZShzaGFwZSwgaW5kaWNlcywgdXBkYXRlcyk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzaGFwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0gdXBkYXRlIFRoZSB0ZW5zb3IgY29udGFpbnMgdGhlIHVwZGF0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0gaW5kaWNlcyBUaGUgdGVuc29yIGNvbnRhaW5zIHRoZSBpbmRpY2VzIGZvciB0aGUgdXBkYXRlIHZhbHVlcy5cbiAqIEBwYXJhbSBzaGFwZSBUaGUgc2hhcGUgb2YgdGhlIG91dHB1dCB0ZW5zb3IuXG4gKlxuICogQHJldHVybnMgU2NhdHRlclNoYXBlSW5mb1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlU2hhcGVzKFxuICAgIHVwZGF0ZXM6IFRlbnNvckluZm8sIGluZGljZXM6IFRlbnNvckluZm8sXG4gICAgc2hhcGU6IG51bWJlcltdKTogU2NhdHRlclNoYXBlSW5mbyB7XG4gIC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMgaW4gaW5kaWNlc1xuICBjb25zdCBpbmRpY2VzUmFuayA9IGluZGljZXMuc2hhcGUubGVuZ3RoO1xuICBjb25zdCBzbGljZVJhbmsgPSAoaW5kaWNlc1JhbmsgPiAxKSA/IGluZGljZXMuc2hhcGVbaW5kaWNlc1JhbmsgLSAxXSA6IDE7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdGhhdCBtYWtlIHVwIGVhY2ggc2xpY2Ugb2Ygb3VyIHVwZGF0ZWRcbiAgLy8gdGVuc29yLiBUaGlzIGFsbG93cyB1cyB0byB3b3JrIHdpdGggZmxhdHRlbmVkIHRlbnNvcnMgYW5kIGNvcHkgb3ZlciB3aG9sZVxuICAvLyBzbGljZXMgYXQgYSB0aW1lLlxuICBjb25zdCB0b3RhbE5kID0gc2hhcGUubGVuZ3RoO1xuXG4gIGxldCBzbGljZVNpemUgPSAxO1xuICBmb3IgKGxldCBpID0gc2xpY2VSYW5rOyBpIDwgdG90YWxOZDsgKytpKSB7XG4gICAgc2xpY2VTaXplICo9IHNoYXBlW2ldO1xuICB9XG5cbiAgY29uc3Qgc2FmZVNsaWNlRGltID0gKHNsaWNlUmFuayA8IDEpID8gMSA6IHNsaWNlUmFuaztcbiAgY29uc3QgbnVtVXBkYXRlcyA9IHNpemVGcm9tU2hhcGUoaW5kaWNlcy5zaGFwZSkgLyBzYWZlU2xpY2VEaW07XG5cbiAgY29uc3Qgc3RyaWRlcyA9IFsuLi5jb21wdXRlU3RyaWRlcyhzaGFwZS5zbGljZSgwLCBzbGljZVJhbmspKSwgMV07XG4gIGNvbnN0IG91dHB1dFNpemUgPSBzaXplRnJvbVNoYXBlKHNoYXBlKTtcbiAgcmV0dXJuIHtzbGljZVJhbmssIG51bVVwZGF0ZXMsIHNsaWNlU2l6ZSwgc3RyaWRlcywgb3V0cHV0U2l6ZX07XG59XG4iXX0=","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { Selu } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Computes scaled exponential linear element-wise.\n *\n * `x < 0 ? scale * alpha * (exp(x) - 1) : scale * x`\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n *\n * x.selu().print();  // or tf.selu(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction selu_(x) {\n    const $x = convertToTensor(x, 'x', 'selu');\n    const inputs = { x: $x };\n    return ENGINE.runKernel(Selu, inputs);\n}\nexport const selu = /* @__PURE__ */ op({ selu_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL3NlbHUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNqQyxPQUFPLEVBQUMsSUFBSSxFQUFhLE1BQU0saUJBQWlCLENBQUM7QUFHakQsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBR25ELE9BQU8sRUFBQyxFQUFFLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFFL0I7Ozs7Ozs7Ozs7Ozs7R0FhRztBQUNILFNBQVMsS0FBSyxDQUFtQixDQUFlO0lBQzlDLE1BQU0sRUFBRSxHQUFHLGVBQWUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBRTNDLE1BQU0sTUFBTSxHQUFlLEVBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBQyxDQUFDO0lBRW5DLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsTUFBbUMsQ0FBQyxDQUFDO0FBQ3JFLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxJQUFJLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFDLEtBQUssRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi9lbmdpbmUnO1xuaW1wb3J0IHtTZWx1LCBTZWx1SW5wdXRzfSBmcm9tICcuLi9rZXJuZWxfbmFtZXMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5pbXBvcnQge05hbWVkVGVuc29yTWFwfSBmcm9tICcuLi90ZW5zb3JfdHlwZXMnO1xuaW1wb3J0IHtjb252ZXJ0VG9UZW5zb3J9IGZyb20gJy4uL3RlbnNvcl91dGlsX2Vudic7XG5pbXBvcnQge1RlbnNvckxpa2V9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtvcH0gZnJvbSAnLi9vcGVyYXRpb24nO1xuXG4vKipcbiAqIENvbXB1dGVzIHNjYWxlZCBleHBvbmVudGlhbCBsaW5lYXIgZWxlbWVudC13aXNlLlxuICpcbiAqIGB4IDwgMCA/IHNjYWxlICogYWxwaGEgKiAoZXhwKHgpIC0gMSkgOiBzY2FsZSAqIHhgXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHggPSB0Zi50ZW5zb3IxZChbLTEsIDIsIC0zLCA0XSk7XG4gKlxuICogeC5zZWx1KCkucHJpbnQoKTsgIC8vIG9yIHRmLnNlbHUoeClcbiAqIGBgYFxuICogQHBhcmFtIHggVGhlIGlucHV0IHRlbnNvci5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJ31cbiAqL1xuZnVuY3Rpb24gc2VsdV88VCBleHRlbmRzIFRlbnNvcj4oeDogVHxUZW5zb3JMaWtlKTogVCB7XG4gIGNvbnN0ICR4ID0gY29udmVydFRvVGVuc29yKHgsICd4JywgJ3NlbHUnKTtcblxuICBjb25zdCBpbnB1dHM6IFNlbHVJbnB1dHMgPSB7eDogJHh9O1xuXG4gIHJldHVybiBFTkdJTkUucnVuS2VybmVsKFNlbHUsIGlucHV0cyBhcyB1bmtub3duIGFzIE5hbWVkVGVuc29yTWFwKTtcbn1cblxuZXhwb3J0IGNvbnN0IHNlbHUgPSAvKiBAX19QVVJFX18gKi8gb3Aoe3NlbHVffSk7XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport const SELU_SCALEALPHA = 1.7580993408473768599402175208123;\nexport const SELU_SCALE = 1.0507009873554804934193349852946;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsdV91dGlsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc2VsdV91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxpQ0FBaUMsQ0FBQztBQUNqRSxNQUFNLENBQUMsTUFBTSxVQUFVLEdBQUcsaUNBQWlDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmV4cG9ydCBjb25zdCBTRUxVX1NDQUxFQUxQSEEgPSAxLjc1ODA5OTM0MDg0NzM3Njg1OTk0MDIxNzUyMDgxMjM7XG5leHBvcnQgY29uc3QgU0VMVV9TQ0FMRSA9IDEuMDUwNzAwOTg3MzU1NDgwNDkzNDE5MzM0OTg1Mjk0NjtcbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { isTypedArray } from '../util';\nimport { makeTensor } from './tensor_ops_util';\n/**\n * Creates rank-0 `tf.Tensor` (scalar) with the provided value and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.scalar` as it makes the code more readable.\n *\n * ```js\n * tf.scalar(3.14).print();\n * ```\n *\n * @param value The value of the scalar.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function scalar(value, dtype) {\n    if (((isTypedArray(value) && dtype !== 'string') || Array.isArray(value)) &&\n        dtype !== 'complex64') {\n        throw new Error('Error creating a new Scalar: value must be a primitive ' +\n            '(number|boolean|string)');\n    }\n    if (dtype === 'string' && isTypedArray(value) &&\n        !(value instanceof Uint8Array)) {\n        throw new Error('When making a scalar from encoded string, ' +\n            'the value must be `Uint8Array`.');\n    }\n    const shape = [];\n    const inferredShape = [];\n    return makeTensor(value, shape, inferredShape, dtype);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhbGFyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc2NhbGFyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUlILE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDckMsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBRTdDOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBQ0gsTUFBTSxVQUFVLE1BQU0sQ0FDbEIsS0FBdUMsRUFBRSxLQUFnQjtJQUMzRCxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxLQUFLLFFBQVEsQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckUsS0FBSyxLQUFLLFdBQVcsRUFBRTtRQUN6QixNQUFNLElBQUksS0FBSyxDQUNYLHlEQUF5RDtZQUN6RCx5QkFBeUIsQ0FBQyxDQUFDO0tBQ2hDO0lBQ0QsSUFBSSxLQUFLLEtBQUssUUFBUSxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUM7UUFDekMsQ0FBQyxDQUFDLEtBQUssWUFBWSxVQUFVLENBQUMsRUFBRTtRQUNsQyxNQUFNLElBQUksS0FBSyxDQUNYLDRDQUE0QztZQUM1QyxpQ0FBaUMsQ0FBQyxDQUFDO0tBQ3hDO0lBQ0QsTUFBTSxLQUFLLEdBQWEsRUFBRSxDQUFDO0lBQzNCLE1BQU0sYUFBYSxHQUFhLEVBQUUsQ0FBQztJQUNuQyxPQUFPLFVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLGFBQWEsRUFBRSxLQUFLLENBQVcsQ0FBQztBQUNsRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge1NjYWxhcn0gZnJvbSAnLi4vdGVuc29yJztcbmltcG9ydCB7RGF0YVR5cGV9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7aXNUeXBlZEFycmF5fSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7bWFrZVRlbnNvcn0gZnJvbSAnLi90ZW5zb3Jfb3BzX3V0aWwnO1xuXG4vKipcbiAqIENyZWF0ZXMgcmFuay0wIGB0Zi5UZW5zb3JgIChzY2FsYXIpIHdpdGggdGhlIHByb3ZpZGVkIHZhbHVlIGFuZCBkdHlwZS5cbiAqXG4gKiBUaGUgc2FtZSBmdW5jdGlvbmFsaXR5IGNhbiBiZSBhY2hpZXZlZCB3aXRoIGB0Zi50ZW5zb3JgLCBidXQgaW4gZ2VuZXJhbFxuICogd2UgcmVjb21tZW5kIHVzaW5nIGB0Zi5zY2FsYXJgIGFzIGl0IG1ha2VzIHRoZSBjb2RlIG1vcmUgcmVhZGFibGUuXG4gKlxuICogYGBganNcbiAqIHRmLnNjYWxhcigzLjE0KS5wcmludCgpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgc2NhbGFyLlxuICogQHBhcmFtIGR0eXBlIFRoZSBkYXRhIHR5cGUuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NhbGFyKFxuICAgIHZhbHVlOiBudW1iZXJ8Ym9vbGVhbnxzdHJpbmd8VWludDhBcnJheSwgZHR5cGU/OiBEYXRhVHlwZSk6IFNjYWxhciB7XG4gIGlmICgoKGlzVHlwZWRBcnJheSh2YWx1ZSkgJiYgZHR5cGUgIT09ICdzdHJpbmcnKSB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkgJiZcbiAgICAgIGR0eXBlICE9PSAnY29tcGxleDY0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Vycm9yIGNyZWF0aW5nIGEgbmV3IFNjYWxhcjogdmFsdWUgbXVzdCBiZSBhIHByaW1pdGl2ZSAnICtcbiAgICAgICAgJyhudW1iZXJ8Ym9vbGVhbnxzdHJpbmcpJyk7XG4gIH1cbiAgaWYgKGR0eXBlID09PSAnc3RyaW5nJyAmJiBpc1R5cGVkQXJyYXkodmFsdWUpICYmXG4gICAgICAhKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdXaGVuIG1ha2luZyBhIHNjYWxhciBmcm9tIGVuY29kZWQgc3RyaW5nLCAnICtcbiAgICAgICAgJ3RoZSB2YWx1ZSBtdXN0IGJlIGBVaW50OEFycmF5YC4nKTtcbiAgfVxuICBjb25zdCBzaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgaW5mZXJyZWRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgcmV0dXJuIG1ha2VUZW5zb3IodmFsdWUsIHNoYXBlLCBpbmZlcnJlZFNoYXBlLCBkdHlwZSkgYXMgU2NhbGFyO1xufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { nearestDivisor } from '../util';\nimport { PARALLELIZE_THRESHOLD } from './reduce_util';\nexport function segOpComputeOptimalWindowSize(inSize, numSegments) {\n    let done = false;\n    let res;\n    if (inSize <= PARALLELIZE_THRESHOLD) {\n        res = inSize;\n        done = true;\n    }\n    else {\n        res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));\n    }\n    while (!done) {\n        if (res > numSegments || res === inSize) {\n            done = true;\n        }\n        else {\n            res = nearestDivisor(inSize, res + 1);\n        }\n    }\n    return res;\n}\nexport function computeOutShape(aShape, axis, numSegments) {\n    const outShape = [];\n    const rank = aShape.length;\n    for (let dim = 0; dim < rank; dim++) {\n        if (dim !== axis) {\n            outShape.push(aShape[dim]);\n        }\n        else {\n            outShape.push(numSegments);\n        }\n    }\n    return outShape;\n}\nexport function collectGatherOpShapeInfo(x, indices, axis, batchDims) {\n    const indicesRank = indices.shape.length;\n    const xRank = x.shape.length;\n    if (batchDims !== 0) {\n        if (batchDims < -indicesRank || batchDims > indicesRank) {\n            throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${indicesRank}], but got ${batchDims}`);\n        }\n    }\n    if (batchDims < 0) {\n        batchDims += indicesRank;\n    }\n    if (batchDims > xRank) {\n        throw new Error(`batchDims (${batchDims}) must be less than rank(x) (\n    ${xRank}).`);\n    }\n    if (axis < batchDims) {\n        throw new Error(`batchDims (${batchDims}) must be less than or equal to axis (${axis}).`);\n    }\n    for (let i = 0; i < batchDims; ++i) {\n        if (x.shape[i] !== indices.shape[i]) {\n            throw new Error(`x.shape[${i}]: ${x.shape[i]} should be equal to indices.shape[${i}]: ${indices.shape[i]}.`);\n        }\n    }\n    const dimSize = x.shape[axis];\n    const outputShape = [];\n    let batchSize = 1;\n    let outerSize = 1;\n    let sliceSize = 1;\n    for (let i = 0; i < batchDims; ++i) {\n        outputShape.push(x.shape[i]);\n        batchSize *= x.shape[i];\n    }\n    for (let i = batchDims; i < axis; i++) {\n        outputShape.push(x.shape[i]);\n        outerSize *= x.shape[i];\n    }\n    for (let i = batchDims; i < indicesRank; i++) {\n        outputShape.push(indices.shape[i]);\n    }\n    for (let i = axis + 1; i < xRank; i++) {\n        outputShape.push(x.shape[i]);\n        sliceSize *= x.shape[i];\n    }\n    return { batchSize, sliceSize, outerSize, dimSize, outputShape };\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VnbWVudF91dGlsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvc2VnbWVudF91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUdILE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFFdkMsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sZUFBZSxDQUFDO0FBU3BELE1BQU0sVUFBVSw2QkFBNkIsQ0FDekMsTUFBYyxFQUFFLFdBQW1CO0lBQ3JDLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQztJQUNqQixJQUFJLEdBQUcsQ0FBQztJQUVSLElBQUksTUFBTSxJQUFJLHFCQUFxQixFQUFFO1FBQ25DLEdBQUcsR0FBRyxNQUFNLENBQUM7UUFDYixJQUFJLEdBQUcsSUFBSSxDQUFDO0tBQ2I7U0FBTTtRQUNMLEdBQUcsR0FBRyxjQUFjLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDN0Q7SUFFRCxPQUFPLENBQUMsSUFBSSxFQUFFO1FBQ1osSUFBSSxHQUFHLEdBQUcsV0FBVyxJQUFJLEdBQUcsS0FBSyxNQUFNLEVBQUU7WUFDdkMsSUFBSSxHQUFHLElBQUksQ0FBQztTQUNiO2FBQU07WUFDTCxHQUFHLEdBQUcsY0FBYyxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDdkM7S0FDRjtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQUVELE1BQU0sVUFBVSxlQUFlLENBQzNCLE1BQWdCLEVBQUUsSUFBWSxFQUFFLFdBQW1CO0lBQ3JELE1BQU0sUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUNwQixNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQzNCLEtBQUssSUFBSSxH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QUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNwQztJQUVELEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3JDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdCLFNBQVMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3pCO0lBRUQsT0FBTyxFQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUMsQ0FBQztBQUNqRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQgeyBUZW5zb3JJbmZvIH0gZnJvbSAnLi4vdGVuc29yX2luZm8nO1xuaW1wb3J0IHtuZWFyZXN0RGl2aXNvcn0gZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCB7UEFSQUxMRUxJWkVfVEhSRVNIT0xEfSBmcm9tICcuL3JlZHVjZV91dGlsJztcblxuZXhwb3J0IGludGVyZmFjZSBTZWdPcEluZm8ge1xuICB3aW5kb3dTaXplOiBudW1iZXI7XG4gIGJhdGNoU2l6ZTogbnVtYmVyO1xuICBpblNpemU6IG51bWJlcjtcbiAgbnVtU2VnbWVudHM6IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlZ09wQ29tcHV0ZU9wdGltYWxXaW5kb3dTaXplKFxuICAgIGluU2l6ZTogbnVtYmVyLCBudW1TZWdtZW50czogbnVtYmVyKTogbnVtYmVyIHtcbiAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgbGV0IHJlcztcblxuICBpZiAoaW5TaXplIDw9IFBBUkFMTEVMSVpFX1RIUkVTSE9MRCkge1xuICAgIHJlcyA9IGluU2l6ZTtcbiAgICBkb25lID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXMgPSBuZWFyZXN0RGl2aXNvcihpblNpemUsIE1hdGguZmxvb3IoTWF0aC5zcXJ0KGluU2l6ZSkpKTtcbiAgfVxuXG4gIHdoaWxlICghZG9uZSkge1xuICAgIGlmIChyZXMgPiBudW1TZWdtZW50cyB8fCByZXMgPT09IGluU2l6ZSkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IG5lYXJlc3REaXZpc29yKGluU2l6ZSwgcmVzICsgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlT3V0U2hhcGUoXG4gICAgYVNoYXBlOiBudW1iZXJbXSwgYXhpczogbnVtYmVyLCBudW1TZWdtZW50czogbnVtYmVyKTogbnVtYmVyW10ge1xuICBjb25zdCBvdXRTaGFwZSA9IFtdO1xuICBjb25zdCByYW5rID0gYVNoYXBlLmxlbmd0aDtcbiAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgcmFuazsgZGltKyspIHtcbiAgICBpZiAoZGltICE9PSBheGlzKSB7XG4gICAgICBvdXRTaGFwZS5wdXNoKGFTaGFwZVtkaW1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0U2hhcGUucHVzaChudW1TZWdtZW50cyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRTaGFwZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHYXRoZXJPcFNoYXBlSW5mbyB7XG4gIGJhdGNoU2l6ZTogbnVtYmVyO1xuICBzbGljZVNpemU6IG51bWJlcjtcbiAgb3V0ZXJTaXplOiBudW1iZXI7XG4gIGRpbVNpemU6IG51bWJlcjtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdEdhdGhlck9wU2hhcGVJbmZvKFxuICAgIHg6IFRlbnNvckluZm8sIGluZGljZXM6IFRlbnNvckluZm8sIGF4aXM6IG51bWJlcixcbiAgICBiYXRjaERpbXM6IG51bWJlcik6IEdhdGhlck9wU2hhcGVJbmZvIHtcbiAgY29uc3QgaW5kaWNlc1JhbmsgPSBpbmRpY2VzLnNoYXBlLmxlbmd0aDtcbiAgY29uc3QgeFJhbmsgPSB4LnNoYXBlLmxlbmd0aDtcblxuICBpZiAoYmF0Y2hEaW1zICE9PSAwKSB7XG4gICAgaWYgKGJhdGNoRGltcyA8IC1pbmRpY2VzUmFuayB8fCBiYXRjaERpbXMgPiBpbmRpY2VzUmFuaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3QgYmF0Y2hEaW1zIGluIHRoZSByYW5nZSBvZiBbLSR7aW5kaWNlc1Jhbmt9LCAke1xuICAgICAgICAgIGluZGljZXNSYW5rfV0sIGJ1dCBnb3QgJHtiYXRjaERpbXN9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGJhdGNoRGltcyA8IDApIHtcbiAgICBiYXRjaERpbXMgKz0gaW5kaWNlc1Jhbms7XG4gIH1cblxuICBpZiAoYmF0Y2hEaW1zID4geFJhbmspIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGJhdGNoRGltcyAoJHtiYXRjaERpbXN9KSBtdXN0IGJlIGxlc3MgdGhhbiByYW5rKHgpIChcbiAgICAke3hSYW5rfSkuYCk7XG4gIH1cblxuICBpZiAoYXhpcyA8IGJhdGNoRGltcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgYmF0Y2hEaW1zICgke1xuICAgICAgICBiYXRjaERpbXN9KSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBheGlzICgke2F4aXN9KS5gKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hEaW1zOyArK2kpIHtcbiAgICBpZiAoeC5zaGFwZVtpXSAhPT0gaW5kaWNlcy5zaGFwZVtpXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGB4LnNoYXBlWyR7aX1dOiAke3guc2hhcGVbaV19IHNob3VsZCBiZSBlcXVhbCB0byBpbmRpY2VzLnNoYXBlWyR7XG4gICAgICAgICAgICAgIGl9XTogJHtpbmRpY2VzLnNoYXBlW2ldfS5gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGltU2l6ZSA9IHguc2hhcGVbYXhpc107XG5cbiAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gW107XG4gIGxldCBiYXRjaFNpemUgPSAxO1xuICBsZXQgb3V0ZXJTaXplID0gMTtcbiAgbGV0IHNsaWNlU2l6ZSA9IDE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaERpbXM7ICsraSkge1xuICAgIG91dHB1dFNoYXBlLnB1c2goeC5zaGFwZVtpXSk7XG4gICAgYmF0Y2hTaXplICo9IHguc2hhcGVbaV07XG4gIH1cblxuICBmb3IgKGxldCBpID0gYmF0Y2hEaW1zOyBpIDwgYXhpczsgaSsrKSB7XG4gICAgb3V0cHV0U2hhcGUucHVzaCh4LnNoYXBlW2ldKTtcbiAgICBvdXRlclNpemUgKj0geC5zaGFwZVtpXTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSBiYXRjaERpbXM7IGkgPCBpbmRpY2VzUmFuazsgaSsrKSB7XG4gICAgb3V0cHV0U2hhcGUucHVzaChpbmRpY2VzLnNoYXBlW2ldKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSBheGlzICsgMTsgaSA8IHhSYW5rOyBpKyspIHtcbiAgICBvdXRwdXRTaGFwZS5wdXNoKHguc2hhcGVbaV0pO1xuICAgIHNsaWNlU2l6ZSAqPSB4LnNoYXBlW2ldO1xuICB9XG5cbiAgcmV0dXJuIHtiYXRjaFNpemUsIHNsaWNlU2l6ZSwgb3V0ZXJTaXplLCBkaW1TaXplLCBvdXRwdXRTaGFwZX07XG59XG4iXX0=","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { SearchSorted } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { sizeFromShape } from '../util_base';\nimport { op } from './operation';\nimport { reshape } from './reshape';\nconst INT32_MAX = 2147483648;\n/**\n * Searches for where a value would go in a sorted sequence.\n *\n * This is not a method for checking containment (like javascript in).\n *\n * The typical use case for this operation is \"binning\", \"bucketing\", or\n * \"discretizing\". The values are assigned to bucket-indices based on the edges\n * listed in 'sortedSequence'. This operation returns the bucket-index for each\n * value.\n *\n * The side argument controls which index is returned if a value lands exactly\n * on an edge.\n *\n * The axis is not settable for this operation. It always operates on the\n * innermost dimension (axis=-1). The operation will accept any number of outer\n * dimensions.\n *\n * Note: This operation assumes that 'sortedSequence' is sorted along the\n * innermost axis, maybe using 'sort(..., axis=-1)'. If the sequence is not\n * sorted no error is raised and the content of the returned tensor is not well\n * defined.\n *\n * ```js\n * const edges = tf.tensor1d([-1, 3.3, 9.1, 10.0]);\n * let values = tf.tensor1d([0.0, 4.1, 12.0]);\n * const result1 = tf.searchSorted(edges, values, 'left');\n * result1.print(); // [1, 2, 4]\n *\n * const seq = tf.tensor1d([0, 3, 9, 10, 10]);\n * values = tf.tensor1d([0, 4, 10]);\n * const result2 = tf.searchSorted(seq, values, 'left');\n * result2.print(); // [0, 2, 3]\n * const result3 = tf.searchSorted(seq, values, 'right');\n * result3.print(); // [1, 2, 5]\n *\n * const sortedSequence = tf.tensor2d([[0., 3., 8., 9., 10.],\n *                                     [1., 2., 3., 4., 5.]]);\n * values = tf.tensor2d([[9.8, 2.1, 4.3],\n *                       [0.1, 6.6, 4.5, ]]);\n * const result4 = tf.searchSorted(sortedSequence, values, 'left');\n * result4.print(); // [[4, 1, 2], [0, 5, 4]]\n * ```\n * @param sortedSequence: N-D. Sorted sequence.\n * @param values: N-D. Search values.\n * @param side: 'left'|'right'. Defaults to 'left'. 'left' corresponds to lower\n *     bound and 'right' to upper bound.\n * @return An N-D int32 tensor the size of values containing the result of\n *     applying either lower bound or upper bound (depending on side) to each\n *     value. The result is not a global index to the entire Tensor, but the\n *     index in the last dimension.\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\nfunction searchSorted_(sortedSequence, values, side = 'left') {\n    const $sortedSequence = convertToTensor(sortedSequence, 'sortedSequence', 'searchSorted');\n    const $values = convertToTensor(values, 'values', 'searchSorted');\n    const sequenceSize = $sortedSequence.shape[$sortedSequence.shape.length - 1];\n    const valuesSize = $values.shape[$values.shape.length - 1];\n    const $sortedSequence2D = reshape($sortedSequence, [-1, sequenceSize]);\n    const $values2D = reshape($values, [-1, valuesSize]);\n    if ($sortedSequence2D.rank < 2) {\n        throw new Error(`Sorted input argument must be at least 2-dimensional`);\n    }\n    if ($sortedSequence2D.shape[0] !== $values2D.shape[0]) {\n        throw new Error(`Leading dimension of 'sortedSequence' and 'values' must match.`);\n    }\n    if (sizeFromShape($values2D.shape) >= INT32_MAX) {\n        throw new Error(`values tensor size must less than ${INT32_MAX}`);\n    }\n    if ($sortedSequence2D.shape[1] >= INT32_MAX) {\n        throw new Error(`trailing dim_size must less than ${INT32_MAX} for int32 output type, was ${$sortedSequence2D.shape[1]}`);\n    }\n    const inputs = {\n        sortedSequence: $sortedSequence2D,\n        values: $values2D,\n    };\n    const attrs = { side };\n    return ENGINE.runKernel(SearchSorted, inputs, attrs);\n}\nexport const searchSorted = /* @__PURE__ */ op({ searchSorted_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoX3NvcnRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL3NlYXJjaF9zb3J0ZWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNqQyxPQUFPLEVBQUMsWUFBWSxFQUF3QyxNQUFNLGlCQUFpQixDQUFDO0FBRXBGLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUVuRCxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBQzNDLE9BQU8sRUFBQyxFQUFFLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFDL0IsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUVsQyxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUM7QUFDN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1ERztBQUNILFNBQVMsYUFBYSxDQUNsQixjQUFpQyxFQUFFLE1BQXlCLEVBQzVELE9BQXVCLE1BQU07SUFDL0IsTUFBTSxlQUFlLEdBQ2pCLGVBQWUsQ0FBQyxjQUFjLEVBQUUsZ0JBQWdCLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDdEUsTUFBTSxPQUFPLEdBQUcsZUFBZSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFFbEUsTUFBTSxZQUFZLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM3RSxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzNELE1BQU0saUJBQWlCLEdBQUcsT0FBTyxDQUFDLGVBQWUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDdkUsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFFckQsSUFBSSxpQkFBaUIsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFO1FBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsc0RBQXNELENBQUMsQ0FBQztLQUN6RTtJQUNELElBQUksaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDckQsTUFBTSxJQUFJLEtBQUssQ0FDWCxnRUFBZ0UsQ0FBQyxDQUFDO0tBQ3ZFO0lBQ0QsSUFBSSxhQUFhLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLFNBQVMsRUFBRTtRQUMvQyxNQUFNLElBQUksS0FBSyxDQUFDLHFDQUFxQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0tBQ25FO0lBQ0QsSUFBSSxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksU0FBUyxFQUFFO1FBQzNDLE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQ1osU0FBUywrQkFBK0IsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUMzRTtJQUVELE1BQU0sTUFBTSxHQUF1QjtRQUNqQyxjQUFjLEVBQUUsaUJBQWlCO1FBQ2pDLE1BQU0sRUFBRSxTQUFTO0tBQ2xCLENBQUM7SUFDRixNQUFNLEtBQUssR0FBc0IsRUFBQyxJQUFJLEVBQUMsQ0FBQztJQUV4QyxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsWUFBWSxFQUFFLE1BQVksRUFBRSxLQUFXLENBQUMsQ0FBQztBQUNuRSxDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0sWUFBWSxHQUFHLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBQyxhQUFhLEVBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0VOR0lORX0gZnJvbSAnLi4vZW5naW5lJztcbmltcG9ydCB7U2VhcmNoU29ydGVkLCBTZWFyY2hTb3J0ZWRBdHRycywgU2VhcmNoU29ydGVkSW5wdXRzfSBmcm9tICcuLi9rZXJuZWxfbmFtZXMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5pbXBvcnQge2NvbnZlcnRUb1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yX3V0aWxfZW52JztcbmltcG9ydCB7VGVuc29yTGlrZX0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtzaXplRnJvbVNoYXBlfSBmcm9tICcuLi91dGlsX2Jhc2UnO1xuaW1wb3J0IHtvcH0gZnJvbSAnLi9vcGVyYXRpb24nO1xuaW1wb3J0IHtyZXNoYXBlfSBmcm9tICcuL3Jlc2hhcGUnO1xuXG5jb25zdCBJTlQzMl9NQVggPSAyMTQ3NDgzNjQ4O1xuLyoqXG4gKiBTZWFyY2hlcyBmb3Igd2hlcmUgYSB2YWx1ZSB3b3VsZCBnbyBpbiBhIHNvcnRlZCBzZXF1ZW5jZS5cbiAqXG4gKiBUaGlzIGlzIG5vdCBhIG1ldGhvZCBmb3IgY2hlY2tpbmcgY29udGFpbm1lbnQgKGxpa2UgamF2YXNjcmlwdCBpbikuXG4gKlxuICogVGhlIHR5cGljYWwgdXNlIGNhc2UgZm9yIHRoaXMgb3BlcmF0aW9uIGlzIFwiYmlubmluZ1wiLCBcImJ1Y2tldGluZ1wiLCBvclxuICogXCJkaXNjcmV0aXppbmdcIi4gVGhlIHZhbHVlcyBhcmUgYXNzaWduZWQgdG8gYnVja2V0LWluZGljZXMgYmFzZWQgb24gdGhlIGVkZ2VzXG4gKiBsaXN0ZWQgaW4gJ3NvcnRlZFNlcXVlbmNlJy4gVGhpcyBvcGVyYXRpb24gcmV0dXJucyB0aGUgYnVja2V0LWluZGV4IGZvciBlYWNoXG4gKiB2YWx1ZS5cbiAqXG4gKiBUaGUgc2lkZSBhcmd1bWVudCBjb250cm9scyB3aGljaCBpbmRleCBpcyByZXR1cm5lZCBpZiBhIHZhbHVlIGxhbmRzIGV4YWN0bHlcbiAqIG9uIGFuIGVkZ2UuXG4gKlxuICogVGhlIGF4aXMgaXMgbm90IHNldHRhYmxlIGZvciB0aGlzIG9wZXJhdGlvbi4gSXQgYWx3YXlzIG9wZXJhdGVzIG9uIHRoZVxuICogaW5uZXJtb3N0IGRpbWVuc2lvbiAoYXhpcz0tMSkuIFRoZSBvcGVyYXRpb24gd2lsbCBhY2NlcHQgYW55IG51bWJlciBvZiBvdXRlclxuICogZGltZW5zaW9ucy5cbiAqXG4gKiBOb3RlOiBUaGlzIG9wZXJhdGlvbiBhc3N1bWVzIHRoYXQgJ3NvcnRlZFNlcXVlbmNlJyBpcyBzb3J0ZWQgYWxvbmcgdGhlXG4gKiBpbm5lcm1vc3QgYXhpcywgbWF5YmUgdXNpbmcgJ3NvcnQoLi4uLCBheGlzPS0xKScuIElmIHRoZSBzZXF1ZW5jZSBpcyBub3RcbiAqIHNvcnRlZCBubyBlcnJvciBpcyByYWlzZWQgYW5kIHRoZSBjb250ZW50IG9mIHRoZSByZXR1cm5lZCB0ZW5zb3IgaXMgbm90IHdlbGxcbiAqIGRlZmluZWQuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGVkZ2VzID0gdGYudGVuc29yMWQoWy0xLCAzLjMsIDkuMSwgMTAuMF0pO1xuICogbGV0IHZhbHVlcyA9IHRmLnRlbnNvcjFkKFswLjAsIDQuMSwgMTIuMF0pO1xuICogY29uc3QgcmVzdWx0MSA9IHRmLnNlYXJjaFNvcnRlZChlZGdlcywgdmFsdWVzLCAnbGVmdCcpO1xuICogcmVzdWx0MS5wcmludCgpOyAvLyBbMSwgMiwgNF1cbiAqXG4gKiBjb25zdCBzZXEgPSB0Zi50ZW5zb3IxZChbMCwgMywgOSwgMTAsIDEwXSk7XG4gKiB2YWx1ZXMgPSB0Zi50ZW5zb3IxZChbMCwgNCwgMTBdKTtcbiAqIGNvbnN0IHJlc3VsdDIgPSB0Zi5zZWFyY2hTb3J0ZWQoc2VxLCB2YWx1ZXMsICdsZWZ0Jyk7XG4gKiByZXN1bHQyLnByaW50KCk7IC8vIFswLCAyLCAzXVxuICogY29uc3QgcmVzdWx0MyA9IHRmLnNlYXJjaFNvcnRlZChzZXEsIHZhbHVlcywgJ3JpZ2h0Jyk7XG4gKiByZXN1bHQzLnByaW50KCk7IC8vIFsxLCAyLCA1XVxuICpcbiAqIGNvbnN0IHNvcnRlZFNlcXVlbmNlID0gdGYudGVuc29yMmQoW1swLiwgMy4sIDguLCA5LiwgMTAuXSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsxLiwgMi4sIDMuLCA0LiwgNS5dXSk7XG4gKiB2YWx1ZXMgPSB0Zi50ZW5zb3IyZChbWzkuOCwgMi4xLCA0LjNdLFxuICogICAgICAgICAgICAgICAgICAgICAgIFswLjEsIDYuNiwgNC41LCBdXSk7XG4gKiBjb25zdCByZXN1bHQ0ID0gdGYuc2VhcmNoU29ydGVkKHNvcnRlZFNlcXVlbmNlLCB2YWx1ZXMsICdsZWZ0Jyk7XG4gKiByZXN1bHQ0LnByaW50KCk7IC8vIFtbNCwgMSwgMl0sIFswLCA1LCA0XV1cbiAqIGBgYFxuICogQHBhcmFtIHNvcnRlZFNlcXVlbmNlOiBOLUQuIFNvcnRlZCBzZXF1ZW5jZS5cbiAqIEBwYXJhbSB2YWx1ZXM6IE4tRC4gU2VhcmNoIHZhbHVlcy5cbiAqIEBwYXJhbSBzaWRlOiAnbGVmdCd8J3JpZ2h0Jy4gRGVmYXVsdHMgdG8gJ2xlZnQnLiAnbGVmdCcgY29ycmVzcG9uZHMgdG8gbG93ZXJcbiAqICAgICBib3VuZCBhbmQgJ3JpZ2h0JyB0byB1cHBlciBib3VuZC5cbiAqIEByZXR1cm4gQW4gTi1EIGludDMyIHRlbnNvciB0aGUgc2l6ZSBvZiB2YWx1ZXMgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mXG4gKiAgICAgYXBwbHlpbmcgZWl0aGVyIGxvd2VyIGJvdW5kIG9yIHVwcGVyIGJvdW5kIChkZXBlbmRpbmcgb24gc2lkZSkgdG8gZWFjaFxuICogICAgIHZhbHVlLiBUaGUgcmVzdWx0IGlzIG5vdCBhIGdsb2JhbCBpbmRleCB0byB0aGUgZW50aXJlIFRlbnNvciwgYnV0IHRoZVxuICogICAgIGluZGV4IGluIHRoZSBsYXN0IGRpbWVuc2lvbi5cbiAqIEBkb2Mge2hlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0V2YWx1YXRpb24nfVxuICovXG5mdW5jdGlvbiBzZWFyY2hTb3J0ZWRfKFxuICAgIHNvcnRlZFNlcXVlbmNlOiBUZW5zb3J8VGVuc29yTGlrZSwgdmFsdWVzOiBUZW5zb3J8VGVuc29yTGlrZSxcbiAgICBzaWRlOiAnbGVmdCd8J3JpZ2h0JyA9ICdsZWZ0Jyk6IFRlbnNvciB7XG4gIGNvbnN0ICRzb3J0ZWRTZXF1ZW5jZSA9XG4gICAgICBjb252ZXJ0VG9UZW5zb3Ioc29ydGVkU2VxdWVuY2UsICdzb3J0ZWRTZXF1ZW5jZScsICdzZWFyY2hTb3J0ZWQnKTtcbiAgY29uc3QgJHZhbHVlcyA9IGNvbnZlcnRUb1RlbnNvcih2YWx1ZXMsICd2YWx1ZXMnLCAnc2VhcmNoU29ydGVkJyk7XG5cbiAgY29uc3Qgc2VxdWVuY2VTaXplID0gJHNvcnRlZFNlcXVlbmNlLnNoYXBlWyRzb3J0ZWRTZXF1ZW5jZS5zaGFwZS5sZW5ndGggLSAxXTtcbiAgY29uc3QgdmFsdWVzU2l6ZSA9ICR2YWx1ZXMuc2hhcGVbJHZhbHVlcy5zaGFwZS5sZW5ndGggLSAxXTtcbiAgY29uc3QgJHNvcnRlZFNlcXVlbmNlMkQgPSByZXNoYXBlKCRzb3J0ZWRTZXF1ZW5jZSwgWy0xLCBzZXF1ZW5jZVNpemVdKTtcbiAgY29uc3QgJHZhbHVlczJEID0gcmVzaGFwZSgkdmFsdWVzLCBbLTEsIHZhbHVlc1NpemVdKTtcblxuICBpZiAoJHNvcnRlZFNlcXVlbmNlMkQucmFuayA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFNvcnRlZCBpbnB1dCBhcmd1bWVudCBtdXN0IGJlIGF0IGxlYXN0IDItZGltZW5zaW9uYWxgKTtcbiAgfVxuICBpZiAoJHNvcnRlZFNlcXVlbmNlMkQuc2hhcGVbMF0gIT09ICR2YWx1ZXMyRC5zaGFwZVswXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYExlYWRpbmcgZGltZW5zaW9uIG9mICdzb3J0ZWRTZXF1ZW5jZScgYW5kICd2YWx1ZXMnIG11c3QgbWF0Y2guYCk7XG4gIH1cbiAgaWYgKHNpemVGcm9tU2hhcGUoJHZhbHVlczJELnNoYXBlKSA+PSBJTlQzMl9NQVgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbHVlcyB0ZW5zb3Igc2l6ZSBtdXN0IGxlc3MgdGhhbiAke0lOVDMyX01BWH1gKTtcbiAgfVxuICBpZiAoJHNvcnRlZFNlcXVlbmNlMkQuc2hhcGVbMV0gPj0gSU5UMzJfTUFYKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB0cmFpbGluZyBkaW1fc2l6ZSBtdXN0IGxlc3MgdGhhbiAke1xuICAgICAgICBJTlQzMl9NQVh9IGZvciBpbnQzMiBvdXRwdXQgdHlwZSwgd2FzICR7JHNvcnRlZFNlcXVlbmNlMkQuc2hhcGVbMV19YCk7XG4gIH1cblxuICBjb25zdCBpbnB1dHM6IFNlYXJjaFNvcnRlZElucHV0cyA9IHtcbiAgICBzb3J0ZWRTZXF1ZW5jZTogJHNvcnRlZFNlcXVlbmNlMkQsXG4gICAgdmFsdWVzOiAkdmFsdWVzMkQsXG4gIH07XG4gIGNvbnN0IGF0dHJzOiBTZWFyY2hTb3J0ZWRBdHRycyA9IHtzaWRlfTtcblxuICByZXR1cm4gRU5HSU5FLnJ1bktlcm5lbChTZWFyY2hTb3J0ZWQsIGlucHV0cyBhcyB7fSwgYXR0cnMgYXMge30pO1xufVxuXG5leHBvcnQgY29uc3Qgc2VhcmNoU29ydGVkID0gLyogQF9fUFVSRV9fICovIG9wKHtzZWFyY2hTb3J0ZWRffSk7XG4iXX0=","import { convertToTensor } from '../tensor_util_env';\nimport * as util from '../util';\nimport { conv2d } from './conv2d';\nimport { depthwiseConv2d } from './depthwise_conv2d';\nimport { op } from './operation';\nimport { reshape } from './reshape';\n/**\n * 2-D convolution with separable filters.\n *\n * Performs a depthwise convolution that acts separately on channels followed\n * by a pointwise convolution that mixes channels. Note that this is\n * separability between dimensions [1, 2] and 3, not spatial separability\n * between dimensions 1 and 2.\n *\n * See\n * [https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d](\n *     https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d)\n * for more details.\n *\n * @param x The input tensor, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n * assumed.\n * @param depthwiseFilter The depthwise filter tensor, rank 4, of shape\n *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`. This is\n *     the filter used in the first step.\n * @param pointwiseFilter The pointwise filter tensor, rank 4, of shape\n *     `[1, 1, inChannels * channelMultiplier, outChannels]`. This is\n *     the filter used in the second step.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`. If strides is a single number, then `strideHeight ==\n * strideWidth`.\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels]. Only \"NHWC\" is currently supported.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction separableConv2d_(x, depthwiseFilter, pointwiseFilter, strides, pad, dilation = [1, 1], dataFormat = 'NHWC') {\n    const $x = convertToTensor(x, 'x', 'separableConv2d');\n    const $depthwiseFilter = convertToTensor(depthwiseFilter, 'depthwiseFilter', 'separableConv2d');\n    const $pointwiseFilter = convertToTensor(pointwiseFilter, 'pointwiseFilter', 'separableConv2d');\n    let x4D = $x;\n    let reshapedTo4D = false;\n    if ($x.rank === 3) {\n        reshapedTo4D = true;\n        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n    }\n    if (dataFormat === 'NCHW') {\n        throw new Error('separableConv2d currently does not support dataFormat NCHW; only ' +\n            'NHWC is supported');\n    }\n    util.assert(x4D.rank === 4, () => `Error in separableConv2d: input must be rank 4, but got ` +\n        `rank ${x4D.rank}.`);\n    util.assert($depthwiseFilter.rank === 4, () => `Error in separableConv2d: depthwise filter must be rank 4, but ` +\n        `got rank ${$depthwiseFilter.rank}.`);\n    util.assert($pointwiseFilter.rank === 4, () => `Error in separableConv2d: pointwise filter must be rank 4, but ` +\n        `got rank ${$depthwiseFilter.rank}.`);\n    util.assert($pointwiseFilter.shape[0] === 1, () => `Error in separableConv2d: the first dimension of pointwise filter ` +\n        ` must be 1, but got ${$pointwiseFilter.shape[0]}.`);\n    util.assert($pointwiseFilter.shape[1] === 1, () => `Error in separableConv2d: the second dimension of pointwise ` +\n        `filter must be 1, but got ${$pointwiseFilter.shape[1]}.`);\n    const inChannels = $depthwiseFilter.shape[2];\n    const channelMultiplier = $depthwiseFilter.shape[3];\n    util.assert($pointwiseFilter.shape[2] === inChannels * channelMultiplier, () => `Error in separableConv2d: the third dimension of pointwise filter ` +\n        `must be ${inChannels * channelMultiplier}, ` +\n        `but got ${$pointwiseFilter.shape[2]}.`);\n    const depthwise = depthwiseConv2d(x4D, $depthwiseFilter, strides, pad, dataFormat, dilation);\n    const pointwiseStride = 1;\n    const res = conv2d(depthwise, $pointwiseFilter, pointwiseStride, 'valid', dataFormat);\n    if (reshapedTo4D) {\n        return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);\n    }\n    return res;\n}\nexport const separableConv2d = /* @__PURE__ */ op({ separableConv2d_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VwYXJhYmxlX2NvbnYyZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL3NlcGFyYWJsZV9jb252MmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUJBLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUVuRCxPQUFPLEtBQUssSUFBSSxNQUFNLFNBQVMsQ0FBQztBQUVoQyxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQ2hDLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUNuRCxPQUFPLEVBQUMsRUFBRSxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBQy9CLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFFbEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNENHO0FBQ0gsU0FBUyxnQkFBZ0IsQ0FDckIsQ0FBZSxFQUFFLGVBQW9DLEVBQ3JELGVBQW9DLEVBQUUsT0FBZ0MsRUFDdEUsR0FBbUIsRUFBRSxXQUFvQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFDL0QsYUFBNEIsTUFBTTtJQUNwQyxNQUFNLEVBQUUsR0FBRyxlQUFlLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3RELE1BQU0sZ0JBQWdCLEdBQ2xCLGVBQWUsQ0FBQyxlQUFlLEVBQUUsaUJBQWlCLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztJQUMzRSxNQUFNLGdCQUFnQixHQUNsQixlQUFlLENBQUMsZUFBZSxFQUFFLGlCQUFpQixFQUFFLGlCQUFpQixDQUFDLENBQUM7SUFFM0UsSUFBSSxHQUFHLEdBQUcsRUFBYyxDQUFDO0lBQ3pCLElBQUksWUFBWSxHQUFHLEtBQUssQ0FBQztJQUN6QixJQUFJLEVBQUUsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ2pC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IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmltcG9ydCB7VGVuc29yM0QsIFRlbnNvcjREfSBmcm9tICcuLi90ZW5zb3InO1xuaW1wb3J0IHtjb252ZXJ0VG9UZW5zb3J9IGZyb20gJy4uL3RlbnNvcl91dGlsX2Vudic7XG5pbXBvcnQge1RlbnNvckxpa2V9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCB7Y29udjJkfSBmcm9tICcuL2NvbnYyZCc7XG5pbXBvcnQge2RlcHRod2lzZUNvbnYyZH0gZnJvbSAnLi9kZXB0aHdpc2VfY29udjJkJztcbmltcG9ydCB7b3B9IGZyb20gJy4vb3BlcmF0aW9uJztcbmltcG9ydCB7cmVzaGFwZX0gZnJvbSAnLi9yZXNoYXBlJztcblxuLyoqXG4gKiAyLUQgY29udm9sdXRpb24gd2l0aCBzZXBhcmFibGUgZmlsdGVycy5cbiAqXG4gKiBQZXJmb3JtcyBhIGRlcHRod2lzZSBjb252b2x1dGlvbiB0aGF0IGFjdHMgc2VwYXJhdGVseSBvbiBjaGFubmVscyBmb2xsb3dlZFxuICogYnkgYSBwb2ludHdpc2UgY29udm9sdXRpb24gdGhhdCBtaXhlcyBjaGFubmVscy4gTm90ZSB0aGF0IHRoaXMgaXNcbiAqIHNlcGFyYWJpbGl0eSBiZXR3ZWVuIGRpbWVuc2lvbnMgWzEsIDJdIGFuZCAzLCBub3Qgc3BhdGlhbCBzZXBhcmFiaWxpdHlcbiAqIGJldHdlZW4gZGltZW5zaW9ucyAxIGFuZCAyLlxuICpcbiAqIFNlZVxuICogW2h0dHBzOi8vd3d3LnRlbnNvcmZsb3cub3JnL2FwaV9kb2NzL3B5dGhvbi90Zi9ubi9zZXBhcmFibGVfY29udjJkXShcbiAqICAgICBodHRwczovL3d3dy50ZW5zb3JmbG93Lm9yZy9hcGlfZG9jcy9weXRob24vdGYvbm4vc2VwYXJhYmxlX2NvbnYyZClcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHBhcmFtIHggVGhlIGlucHV0IHRlbnNvciwgb2YgcmFuayA0IG9yIHJhbmsgMywgb2Ygc2hhcGVcbiAqICAgICBgW2JhdGNoLCBoZWlnaHQsIHdpZHRoLCBpbkNoYW5uZWxzXWAuIElmIHJhbmsgMywgYmF0Y2ggb2YgMSBpc1xuICogYXNzdW1lZC5cbiAqIEBwYXJhbSBkZXB0aHdpc2VGaWx0ZXIgVGhlIGRlcHRod2lzZSBmaWx0ZXIgdGVuc29yLCByYW5rIDQsIG9mIHNoYXBlXG4gKiAgICAgYFtmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBpbkNoYW5uZWxzLCBjaGFubmVsTXVsdGlwbGllcl1gLiBUaGlzIGlzXG4gKiAgICAgdGhlIGZpbHRlciB1c2VkIGluIHRoZSBmaXJzdCBzdGVwLlxuICogQHBhcmFtIHBvaW50d2lzZUZpbHRlciBUaGUgcG9pbnR3aXNlIGZpbHRlciB0ZW5zb3IsIHJhbmsgNCwgb2Ygc2hhcGVcbiAqICAgICBgWzEsIDEsIGluQ2hhbm5lbHMgKiBjaGFubmVsTXVsdGlwbGllciwgb3V0Q2hhbm5lbHNdYC4gVGhpcyBpc1xuICogICAgIHRoZSBmaWx0ZXIgdXNlZCBpbiB0aGUgc2Vjb25kIHN0ZXAuXG4gKiBAcGFyYW0gc3RyaWRlcyBUaGUgc3RyaWRlcyBvZiB0aGUgY29udm9sdXRpb246IGBbc3RyaWRlSGVpZ2h0LFxuICogc3RyaWRlV2lkdGhdYC4gSWYgc3RyaWRlcyBpcyBhIHNpbmdsZSBudW1iZXIsIHRoZW4gYHN0cmlkZUhlaWdodCA9PVxuICogc3RyaWRlV2lkdGhgLlxuICogQHBhcmFtIHBhZCBUaGUgdHlwZSBvZiBwYWRkaW5nIGFsZ29yaXRobS5cbiAqICAgLSBgc2FtZWAgYW5kIHN0cmlkZSAxOiBvdXRwdXQgd2lsbCBiZSBvZiBzYW1lIHNpemUgYXMgaW5wdXQsXG4gKiAgICAgICByZWdhcmRsZXNzIG9mIGZpbHRlciBzaXplLlxuICogICAtIGB2YWxpZGA6IG91dHB1dCB3aWxsIGJlIHNtYWxsZXIgdGhhbiBpbnB1dCBpZiBmaWx0ZXIgaXMgbGFyZ2VyXG4gKiAgICAgICB0aGFuIDF4MS5cbiAqICAgLSBGb3IgbW9yZSBpbmZvLCBzZWUgdGhpcyBndWlkZTpcbiAqICAgICBbaHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL25uL2NvbnZvbHV0aW9uXShcbiAqICAgICAgICAgIGh0dHBzOi8vd3d3LnRlbnNvcmZsb3cub3JnL2FwaV9kb2NzL3B5dGhvbi90Zi9ubi9jb252b2x1dGlvbilcbiAqIEBwYXJhbSBkaWxhdGlvbnMgVGhlIGRpbGF0aW9uIHJhdGVzOiBgW2RpbGF0aW9uSGVpZ2h0LCBkaWxhdGlvbldpZHRoXWBcbiAqICAgICBpbiB3aGljaCB3ZSBzYW1wbGUgaW5wdXQgdmFsdWVzIGFjcm9zcyB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBkaW1lbnNpb25zXG4gKiAgICAgaW4gYXRyb3VzIGNvbnZvbHV0aW9uLiBEZWZhdWx0cyB0byBgWzEsIDFdYC4gSWYgYHJhdGVgIGlzIGEgc2luZ2xlXG4gKiAgICAgbnVtYmVyLCB0aGVuIGBkaWxhdGlvbkhlaWdodCA9PSBkaWxhdGlvbldpZHRoYC4gSWYgaXQgaXMgZ3JlYXRlciB0aGFuXG4gKiAgICAgMSwgdGhlbiBhbGwgdmFsdWVzIG9mIGBzdHJpZGVzYCBtdXN0IGJlIDEuXG4gKiBAcGFyYW0gZGF0YUZvcm1hdDogQW4gb3B0aW9uYWwgc3RyaW5nIGZyb206IFwiTkhXQ1wiLCBcIk5DSFdcIi4gRGVmYXVsdHMgdG9cbiAqICAgICBcIk5IV0NcIi4gU3BlY2lmeSB0aGUgZGF0YSBmb3JtYXQgb2YgdGhlIGlucHV0IGFuZCBvdXRwdXQgZGF0YS4gV2l0aCB0aGVcbiAqICAgICBkZWZhdWx0IGZvcm1hdCBcIk5IV0NcIiwgdGhlIGRhdGEgaXMgc3RvcmVkIGluIHRoZSBvcmRlciBvZjogW2JhdGNoLFxuICogICAgIGhlaWdodCwgd2lkdGgsIGNoYW5uZWxzXS4gT25seSBcIk5IV0NcIiBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uJ31cbiAqL1xuZnVuY3Rpb24gc2VwYXJhYmxlQ29udjJkXzxUIGV4dGVuZHMgVGVuc29yM0R8VGVuc29yNEQ+KFxuICAgIHg6IFR8VGVuc29yTGlrZSwgZGVwdGh3aXNlRmlsdGVyOiBUZW5zb3I0RHxUZW5zb3JMaWtlLFxuICAgIHBvaW50d2lzZUZpbHRlcjogVGVuc29yNER8VGVuc29yTGlrZSwgc3RyaWRlczogW251bWJlciwgbnVtYmVyXXxudW1iZXIsXG4gICAgcGFkOiAndmFsaWQnfCdzYW1lJywgZGlsYXRpb246IFtudW1iZXIsIG51bWJlcl18bnVtYmVyID0gWzEsIDFdLFxuICAgIGRhdGFGb3JtYXQ6ICdOSFdDJ3wnTkNIVycgPSAnTkhXQycpOiBUIHtcbiAgY29uc3QgJHggPSBjb252ZXJ0VG9UZW5zb3IoeCwgJ3gnLCAnc2VwYXJhYmxlQ29udjJkJyk7XG4gIGNvbnN0ICRkZXB0aHdpc2VGaWx0ZXIgPVxuICAgICAgY29udmVydFRvVGVuc29yKGRlcHRod2lzZUZpbHRlciwgJ2RlcHRod2lzZUZpbHRlcicsICdzZXBhcmFibGVDb252MmQnKTtcbiAgY29uc3QgJHBvaW50d2lzZUZpbHRlciA9XG4gICAgICBjb252ZXJ0VG9UZW5zb3IocG9pbnR3aXNlRmlsdGVyLCAncG9pbnR3aXNlRmlsdGVyJywgJ3NlcGFyYWJsZUNvbnYyZCcpO1xuXG4gIGxldCB4NEQgPSAkeCBhcyBUZW5zb3I0RDtcbiAgbGV0IHJlc2hhcGVkVG80RCA9IGZhbHNlO1xuICBpZiAoJHgucmFuayA9PT0gMykge1xuICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgeDREID0gcmVzaGFwZSgkeCwgWzEsICR4LnNoYXBlWzBdLCAkeC5zaGFwZVsxXSwgJHguc2hhcGVbMl1dKTtcbiAgfVxuXG4gIGlmIChkYXRhRm9ybWF0ID09PSAnTkNIVycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzZXBhcmFibGVDb252MmQgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgZGF0YUZvcm1hdCBOQ0hXOyBvbmx5ICcgK1xuICAgICAgICAnTkhXQyBpcyBzdXBwb3J0ZWQnKTtcbiAgfVxuXG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgeDRELnJhbmsgPT09IDQsXG4gICAgICAoKSA9PiBgRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBgICtcbiAgICAgICAgICBgcmFuayAke3g0RC5yYW5rfS5gKTtcbiAgdXRpbC5hc3NlcnQoXG4gICAgICAkZGVwdGh3aXNlRmlsdGVyLnJhbmsgPT09IDQsXG4gICAgICAoKSA9PiBgRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiBkZXB0aHdpc2UgZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgYCArXG4gICAgICAgICAgYGdvdCByYW5rICR7JGRlcHRod2lzZUZpbHRlci5yYW5rfS5gKTtcbiAgdXRpbC5hc3NlcnQoXG4gICAgICAkcG9pbnR3aXNlRmlsdGVyLnJhbmsgPT09IDQsXG4gICAgICAoKSA9PiBgRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiBwb2ludHdpc2UgZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgYCArXG4gICAgICAgICAgYGdvdCByYW5rICR7JGRlcHRod2lzZUZpbHRlci5yYW5rfS5gKTtcbiAgdXRpbC5hc3NlcnQoXG4gICAgICAkcG9pbnR3aXNlRmlsdGVyLnNoYXBlWzBdID09PSAxLFxuICAgICAgKCkgPT5cbiAgICAgICAgICBgRXJyb3IgaW4gc2VwYXJhYmxlQ29udjJkOiB0aGUgZmlyc3QgZGltZW5zaW9uIG9mIHBvaW50d2lzZSBmaWx0ZXIgYCArXG4gICAgICAgICAgYCBtdXN0IGJlIDEsIGJ1dCBnb3QgJHskcG9pbnR3aXNlRmlsdGVyLnNoYXBlWzBdfS5gKTtcbiAgdXRpbC5hc3NlcnQoXG4gICAgICAkcG9pbnR3aXNlRmlsdGVyLnNoYXBlWzFdID09PSAxLFxuICAgICAgKCkgPT4gYEVycm9yIGluIHNlcGFyYWJsZUNvbnYyZDogdGhlIHNlY29uZCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGAgK1xuICAgICAgICAgIGBmaWx0ZXIgbXVzdCBiZSAxLCBidXQgZ290ICR7JHBvaW50d2lzZUZpbHRlci5zaGFwZVsxXX0uYCk7XG5cbiAgY29uc3QgaW5DaGFubmVscyA9ICRkZXB0aHdpc2VGaWx0ZXIuc2hhcGVbMl07XG4gIGNvbnN0IGNoYW5uZWxNdWx0aXBsaWVyID0gJGRlcHRod2lzZUZpbHRlci5zaGFwZVszXTtcbiAgdXRpbC5hc3NlcnQoXG4gICAgICAkcG9pbnR3aXNlRmlsdGVyLnNoYXBlWzJdID09PSBpbkNoYW5uZWxzICogY2hhbm5lbE11bHRpcGxpZXIsXG4gICAgICAoKSA9PlxuICAgICAgICAgIGBFcnJvciBpbiBzZXBhcmFibGVDb252MmQ6IHRoZSB0aGlyZCBkaW1lbnNpb24gb2YgcG9pbnR3aXNlIGZpbHRlciBgICtcbiAgICAgICAgICBgbXVzdCBiZSAke2luQ2hhbm5lbHMgKiBjaGFubmVsTXVsdGlwbGllcn0sIGAgK1xuICAgICAgICAgIGBidXQgZ290ICR7JHBvaW50d2lzZUZpbHRlci5zaGFwZVsyXX0uYCk7XG5cbiAgY29uc3QgZGVwdGh3aXNlID0gZGVwdGh3aXNlQ29udjJkKFxuICAgICAgeDRELCAkZGVwdGh3aXNlRmlsdGVyLCBzdHJpZGVzLCBwYWQsIGRhdGFGb3JtYXQsIGRpbGF0aW9uKTtcbiAgY29uc3QgcG9pbnR3aXNlU3RyaWRlID0gMTtcbiAgY29uc3QgcmVzID1cbiAgICAgIGNvbnYyZChkZXB0aHdpc2UsICRwb2ludHdpc2VGaWx0ZXIsIHBvaW50d2lzZVN0cmlkZSwgJ3ZhbGlkJywgZGF0YUZvcm1hdCk7XG5cbiAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgIHJldHVybiByZXNoYXBlKHJlcywgW3Jlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM11dKSBhcyBUO1xuICB9XG4gIHJldHVybiByZXMgYXMgVDtcbn1cblxuZXhwb3J0IGNvbnN0IHNlcGFyYWJsZUNvbnYyZCA9IC8qIEBfX1BVUkVfXyAqLyBvcCh7c2VwYXJhYmxlQ29udjJkX30pO1xuIl19","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { ScatterNd } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { assertNonNegativeIntegerDimensions } from '../util_base';\nimport { op } from './operation';\nimport * as scatter_nd_util from './scatter_nd_util';\n/**\n * Creates a new tensor by applying sparse updates to individual\n * values or slices within a zero tensor of the given shape tensor according to\n * indices. This operator is the inverse of the `tf.gatherND` operator which\n * extracts values or slices from a given tensor.\n *\n * ```js\n * const indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');\n * const updates = tf.tensor1d([9, 10, 11, 12]);\n * const shape = [8];\n * tf.scatterND(indices, updates, shape).print() //[0, 11, 0, 10, 9, 0, 0, 12]\n * ```\n *\n * @param indices The tensor contains the indices into the output tensor.\n * @param updates The tensor contains the value for the indices.\n * @param shape: The shape of the output tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\n */\nfunction scatterND_(indices, updates, shape) {\n    assertNonNegativeIntegerDimensions(shape);\n    const $indices = convertToTensor(indices, 'indices', 'scatterND', 'int32');\n    const $updates = convertToTensor(updates, 'updates', 'scatterND');\n    scatter_nd_util.validateInput($updates, $indices, shape);\n    const inputs = { indices: $indices, updates: $updates };\n    const attrs = { shape };\n    // tslint:disable-next-line: no-unnecessary-type-assertion\n    return ENGINE.runKernel(ScatterNd, inputs, attrs);\n}\nexport const scatterND = /* @__PURE__ */ op({ scatterND_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhdHRlcl9uZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL3NjYXR0ZXJfbmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNqQyxPQUFPLEVBQUMsU0FBUyxFQUFrQyxNQUFNLGlCQUFpQixDQUFDO0FBSTNFLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUVuRCxPQUFPLEVBQUMsa0NBQWtDLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFFaEUsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUMvQixPQUFPLEtBQUssZUFBZSxNQUFNLG1CQUFtQixDQUFDO0FBRXJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQkc7QUFDSCxTQUFTLFVBQVUsQ0FDZixPQUEwQixFQUFFLE9BQTBCLEVBQ3RELEtBQWtCO0lBQ3BCLGtDQUFrQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFDLE1BQU0sUUFBUSxHQUFHLGVBQWUsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUMzRSxNQUFNLFFBQVEsR0FBRyxlQUFlLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUNsRSxlQUFlLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFFekQsTUFBTSxNQUFNLEdBQW9CLEVBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFDLENBQUM7SUFDdkUsTUFBTSxLQUFLLEdBQW1CLEVBQUMsS0FBSyxFQUFDLENBQUM7SUFFdEMsMERBQTBEO0lBQzFELE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FDWixTQUFTLEVBQUUsTUFBbUMsRUFDOUMsS0FBZ0MsQ0FBYyxDQUFDO0FBQzVELENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxTQUFTLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFDLFVBQVUsRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi9lbmdpbmUnO1xuaW1wb3J0IHtTY2F0dGVyTmQsIFNjYXR0ZXJOZEF0dHJzLCBTY2F0dGVyTmRJbnB1dHN9IGZyb20gJy4uL2tlcm5lbF9uYW1lcyc7XG5pbXBvcnQge05hbWVkQXR0ck1hcH0gZnJvbSAnLi4va2VybmVsX3JlZ2lzdHJ5JztcbmltcG9ydCB7VGVuc29yfSBmcm9tICcuLi90ZW5zb3InO1xuaW1wb3J0IHtOYW1lZFRlbnNvck1hcH0gZnJvbSAnLi4vdGVuc29yX3R5cGVzJztcbmltcG9ydCB7Y29udmVydFRvVGVuc29yfSBmcm9tICcuLi90ZW5zb3JfdXRpbF9lbnYnO1xuaW1wb3J0IHtSYW5rLCBTaGFwZU1hcCwgVGVuc29yTGlrZX0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHthc3NlcnROb25OZWdhdGl2ZUludGVnZXJEaW1lbnNpb25zfSBmcm9tICcuLi91dGlsX2Jhc2UnO1xuXG5pbXBvcnQge29wfSBmcm9tICcuL29wZXJhdGlvbic7XG5pbXBvcnQgKiBhcyBzY2F0dGVyX25kX3V0aWwgZnJvbSAnLi9zY2F0dGVyX25kX3V0aWwnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdGVuc29yIGJ5IGFwcGx5aW5nIHNwYXJzZSB1cGRhdGVzIHRvIGluZGl2aWR1YWxcbiAqIHZhbHVlcyBvciBzbGljZXMgd2l0aGluIGEgemVybyB0ZW5zb3Igb2YgdGhlIGdpdmVuIHNoYXBlIHRlbnNvciBhY2NvcmRpbmcgdG9cbiAqIGluZGljZXMuIFRoaXMgb3BlcmF0b3IgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGB0Zi5nYXRoZXJORGAgb3BlcmF0b3Igd2hpY2hcbiAqIGV4dHJhY3RzIHZhbHVlcyBvciBzbGljZXMgZnJvbSBhIGdpdmVuIHRlbnNvci5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgaW5kaWNlcyA9IHRmLnRlbnNvcjJkKFs0LCAzLCAxLCA3XSwgWzQsIDFdLCAnaW50MzInKTtcbiAqIGNvbnN0IHVwZGF0ZXMgPSB0Zi50ZW5zb3IxZChbOSwgMTAsIDExLCAxMl0pO1xuICogY29uc3Qgc2hhcGUgPSBbOF07XG4gKiB0Zi5zY2F0dGVyTkQoaW5kaWNlcywgdXBkYXRlcywgc2hhcGUpLnByaW50KCkgLy9bMCwgMTEsIDAsIDEwLCA5LCAwLCAwLCAxMl1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBpbmRpY2VzIFRoZSB0ZW5zb3IgY29udGFpbnMgdGhlIGluZGljZXMgaW50byB0aGUgb3V0cHV0IHRlbnNvci5cbiAqIEBwYXJhbSB1cGRhdGVzIFRoZSB0ZW5zb3IgY29udGFpbnMgdGhlIHZhbHVlIGZvciB0aGUgaW5kaWNlcy5cbiAqIEBwYXJhbSBzaGFwZTogVGhlIHNoYXBlIG9mIHRoZSBvdXRwdXQgdGVuc29yLlxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1NsaWNpbmcgYW5kIEpvaW5pbmcnfVxuICovXG5mdW5jdGlvbiBzY2F0dGVyTkRfPFIgZXh0ZW5kcyBSYW5rPihcbiAgICBpbmRpY2VzOiBUZW5zb3J8VGVuc29yTGlrZSwgdXBkYXRlczogVGVuc29yfFRlbnNvckxpa2UsXG4gICAgc2hhcGU6IFNoYXBlTWFwW1JdKTogVGVuc29yPFI+IHtcbiAgYXNzZXJ0Tm9uTmVnYXRpdmVJbnRlZ2VyRGltZW5zaW9ucyhzaGFwZSk7XG4gIGNvbnN0ICRpbmRpY2VzID0gY29udmVydFRvVGVuc29yKGluZGljZXMsICdpbmRpY2VzJywgJ3NjYXR0ZXJORCcsICdpbnQzMicpO1xuICBjb25zdCAkdXBkYXRlcyA9IGNvbnZlcnRUb1RlbnNvcih1cGRhdGVzLCAndXBkYXRlcycsICdzY2F0dGVyTkQnKTtcbiAgc2NhdHRlcl9uZF91dGlsLnZhbGlkYXRlSW5wdXQoJHVwZGF0ZXMsICRpbmRpY2VzLCBzaGFwZSk7XG5cbiAgY29uc3QgaW5wdXRzOiBTY2F0dGVyTmRJbnB1dHMgPSB7aW5kaWNlczogJGluZGljZXMsIHVwZGF0ZXM6ICR1cGRhdGVzfTtcbiAgY29uc3QgYXR0cnM6IFNjYXR0ZXJOZEF0dHJzID0ge3NoYXBlfTtcblxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gIHJldHVybiBFTkdJTkUucnVuS2VybmVsKFxuICAgICAgICAgICAgIFNjYXR0ZXJOZCwgaW5wdXRzIGFzIHVua25vd24gYXMgTmFtZWRUZW5zb3JNYXAsXG4gICAgICAgICAgICAgYXR0cnMgYXMgdW5rbm93biBhcyBOYW1lZEF0dHJNYXApIGFzIFRlbnNvcjxSPjtcbn1cblxuZXhwb3J0IGNvbnN0IHNjYXR0ZXJORCA9IC8qIEBfX1BVUkVfXyAqLyBvcCh7c2NhdHRlck5EX30pO1xuIl19"],"names":["setdiff1dAsync","async","x","y","$x","$y","dtype","rank","shape","xVals","data","yVals","ySet","Set","outputSize","i","length","has","buffer","indices","p","values","toTensor","validateUpdateShape","updates","sliceDim","batchDim","shapeError","Error","d","validateInput","size","calculateShapes","indicesRank","sliceRank","totalNd","sliceSize","safeSliceDim","numUpdates","strides","slice","selu","op","selu_","inputs","runKernel","SELU_SCALEALPHA","SELU_SCALE","scalar","value","isTypedArray","Array","isArray","Uint8Array","segOpComputeOptimalWindowSize","inSize","numSegments","res","done","Math","floor","sqrt","computeOutShape","aShape","axis","outShape","dim","push","collectGatherOpShapeInfo","batchDims","xRank","dimSize","outputShape","batchSize","outerSize","INT32_MAX","searchSorted","searchSorted_","sortedSequence","side","$sortedSequence","$values","sequenceSize","valuesSize","$sortedSequence2D","$values2D","attrs","separableConv2d","separableConv2d_","depthwiseFilter","pointwiseFilter","pad","dilation","dataFormat","$depthwiseFilter","$pointwiseFilter","x4D","reshapedTo4D","inChannels","channelMultiplier","depthwise","scatterND","scatterND_","$indices","$updates"],"sourceRoot":""}