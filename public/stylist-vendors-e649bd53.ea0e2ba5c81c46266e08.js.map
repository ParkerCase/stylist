{"version":3,"file":"stylist-vendors-e649bd53.ea0e2ba5c81c46266e08.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/backends/non_max_suppression_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/backends/non_max_suppression_impl.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/backends/backend.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/backends/complex_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/backends/einsum_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/backends/backend_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/backends/where_impl.js"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Inserts a value into a sorted array. This method allows duplicate, meaning it\n * allows inserting duplicate value, in which case, the element will be inserted\n * at the lowest index of the value.\n * @param arr The array to modify.\n * @param element The element to insert.\n * @param comparator Optional. If no comparator is specified, elements are\n * compared using array_util.defaultComparator, which is suitable for Strings\n * and Numbers in ascending arrays. If the array contains multiple instances of\n * the target value, the left-most instance will be returned. To provide a\n * comparator, it should take 2 arguments to compare and return a negative,\n * zero, or a positive number.\n */\nexport function binaryInsert(arr, element, comparator) {\n    const index = binarySearch(arr, element, comparator);\n    const insertionPoint = index < 0 ? -(index + 1) : index;\n    arr.splice(insertionPoint, 0, element);\n}\n/**\n * Searches the array for the target using binary search, returns the index\n * of the found element, or position to insert if element not found. If no\n * comparator is specified, elements are compared using array_\n * util.defaultComparator, which is suitable for Strings and Numbers in\n * ascending arrays. If the array contains multiple instances of the target\n * value, the left-most instance will be returned.\n * @param arr The array to be searched in.\n * @param target The target to be searched for.\n * @param comparator Should take 2 arguments to compare and return a negative,\n *    zero, or a positive number.\n * @return Lowest index of the target value if found, otherwise the insertion\n *    point where the target should be inserted, in the form of\n *    (-insertionPoint - 1).\n */\nexport function binarySearch(arr, target, comparator) {\n    return binarySearch_(arr, target, comparator || defaultComparator);\n}\n/**\n * Compares its two arguments for order.\n * @param a The first element to be compared.\n * @param b The second element to be compared.\n * @return A negative number, zero, or a positive number as the first\n *     argument is less than, equal to, or greater than the second.\n */\nfunction defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n}\nfunction binarySearch_(arr, target, comparator) {\n    let left = 0;\n    let right = arr.length;\n    let middle = 0;\n    let found = false;\n    while (left < right) {\n        middle = left + ((right - left) >>> 1);\n        const compareResult = comparator(target, arr[middle]);\n        if (compareResult > 0) {\n            left = middle + 1;\n        }\n        else {\n            right = middle;\n            // If compareResult is 0, the value is found. We record it is found,\n            // and then keep looking because there may be duplicate.\n            found = !compareResult;\n        }\n    }\n    return found ? left : -left - 1;\n}\n//# sourceMappingURL=non_max_suppression_util.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { binaryInsert } from './non_max_suppression_util';\nexport function nonMaxSuppressionV3Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold) {\n    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0 /* softNmsSigma */);\n}\nexport function nonMaxSuppressionV4Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, padToMaxOutputSize) {\n    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, 0 /* softNmsSigma */, false /* returnScoresTensor */, padToMaxOutputSize /* padToMaxOutputSize */, true\n    /* returnValidOutputs */ );\n}\nexport function nonMaxSuppressionV5Impl(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma) {\n    return nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, true /* returnScoresTensor */);\n}\nfunction nonMaxSuppressionImpl_(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma, returnScoresTensor = false, padToMaxOutputSize = false, returnValidOutputs = false) {\n    // The list is sorted in ascending order, so that we can always pop the\n    // candidate with the largest score in O(1) time.\n    const candidates = [];\n    for (let i = 0; i < scores.length; i++) {\n        if (scores[i] > scoreThreshold) {\n            candidates.push({ score: scores[i], boxIndex: i, suppressBeginIndex: 0 });\n        }\n    }\n    candidates.sort(ascendingComparator);\n    // If softNmsSigma is 0, the outcome of this algorithm is exactly same as\n    // before.\n    const scale = softNmsSigma > 0 ? (-0.5 / softNmsSigma) : 0.0;\n    const selectedIndices = [];\n    const selectedScores = [];\n    while (selectedIndices.length < maxOutputSize && candidates.length > 0) {\n        const candidate = candidates.pop();\n        const { score: originalScore, boxIndex, suppressBeginIndex } = candidate;\n        if (originalScore < scoreThreshold) {\n            break;\n        }\n        // Overlapping boxes are likely to have similar scores, therefore we\n        // iterate through the previously selected boxes backwards in order to\n        // see if candidate's score should be suppressed. We use\n        // suppressBeginIndex to track and ensure a candidate can be suppressed\n        // by a selected box no more than once. Also, if the overlap exceeds\n        // iouThreshold, we simply ignore the candidate.\n        let ignoreCandidate = false;\n        for (let j = selectedIndices.length - 1; j >= suppressBeginIndex; --j) {\n            const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j]);\n            if (iou >= iouThreshold) {\n                ignoreCandidate = true;\n                break;\n            }\n            candidate.score =\n                candidate.score * suppressWeight(iouThreshold, scale, iou);\n            if (candidate.score <= scoreThreshold) {\n                break;\n            }\n        }\n        // At this point, if `candidate.score` has not dropped below\n        // `scoreThreshold`, then we know that we went through all of the\n        // previous selections and can safely update `suppressBeginIndex` to the\n        // end of the selected array. Then we can re-insert the candidate with\n        // the updated score and suppressBeginIndex back in the candidate list.\n        // If on the other hand, `candidate.score` has dropped below the score\n        // threshold, we will not add it back to the candidates list.\n        candidate.suppressBeginIndex = selectedIndices.length;\n        if (!ignoreCandidate) {\n            // Candidate has passed all the tests, and is not suppressed, so\n            // select the candidate.\n            if (candidate.score === originalScore) {\n                selectedIndices.push(boxIndex);\n                selectedScores.push(candidate.score);\n            }\n            else if (candidate.score > scoreThreshold) {\n                // Candidate's score is suppressed but is still high enough to be\n                // considered, so add back to the candidates list.\n                binaryInsert(candidates, candidate, ascendingComparator);\n            }\n        }\n    }\n    // NonMaxSuppressionV4 feature: padding output to maxOutputSize.\n    const validOutputs = selectedIndices.length;\n    const elemsToPad = maxOutputSize - validOutputs;\n    if (padToMaxOutputSize && elemsToPad > 0) {\n        selectedIndices.push(...new Array(elemsToPad).fill(0));\n        selectedScores.push(...new Array(elemsToPad).fill(0.0));\n    }\n    const result = { selectedIndices };\n    if (returnScoresTensor) {\n        result['selectedScores'] = selectedScores;\n    }\n    if (returnValidOutputs) {\n        result['validOutputs'] = validOutputs;\n    }\n    return result;\n}\nfunction intersectionOverUnion(boxes, i, j) {\n    const iCoord = boxes.subarray(i * 4, i * 4 + 4);\n    const jCoord = boxes.subarray(j * 4, j * 4 + 4);\n    const yminI = Math.min(iCoord[0], iCoord[2]);\n    const xminI = Math.min(iCoord[1], iCoord[3]);\n    const ymaxI = Math.max(iCoord[0], iCoord[2]);\n    const xmaxI = Math.max(iCoord[1], iCoord[3]);\n    const yminJ = Math.min(jCoord[0], jCoord[2]);\n    const xminJ = Math.min(jCoord[1], jCoord[3]);\n    const ymaxJ = Math.max(jCoord[0], jCoord[2]);\n    const xmaxJ = Math.max(jCoord[1], jCoord[3]);\n    const areaI = (ymaxI - yminI) * (xmaxI - xminI);\n    const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);\n    if (areaI <= 0 || areaJ <= 0) {\n        return 0.0;\n    }\n    const intersectionYmin = Math.max(yminI, yminJ);\n    const intersectionXmin = Math.max(xminI, xminJ);\n    const intersectionYmax = Math.min(ymaxI, ymaxJ);\n    const intersectionXmax = Math.min(xmaxI, xmaxJ);\n    const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) *\n        Math.max(intersectionXmax - intersectionXmin, 0.0);\n    return intersectionArea / (areaI + areaJ - intersectionArea);\n}\n// A Gaussian penalty function, this method always returns values in [0, 1].\n// The weight is a function of similarity, the more overlap two boxes are, the\n// smaller the weight is, meaning highly overlapping boxe will be significantly\n// penalized. On the other hand, a non-overlapping box will not be penalized.\nfunction suppressWeight(iouThreshold, scale, iou) {\n    const weight = Math.exp(scale * iou * iou);\n    return iou <= iouThreshold ? weight : 0.0;\n}\nfunction ascendingComparator(c1, c2) {\n    // For objects with same scores, we make the object with the larger index go\n    // first. In an array that pops from the end, this means that the object with\n    // the smaller index will be popped first. This ensures the same output as\n    // the TensorFlow python version.\n    return (c1.score - c2.score) ||\n        ((c1.score === c2.score) && (c2.boxIndex - c1.boxIndex));\n}\n//# sourceMappingURL=non_max_suppression_impl.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\n/** Convenient class for storing tensor-related data. */\nexport class DataStorage {\n    constructor(backend, dataMover) {\n        this.backend = backend;\n        this.dataMover = dataMover;\n        this.data = new WeakMap();\n        this.dataIdsCount = 0;\n    }\n    get(dataId) {\n        if (!this.data.has(dataId)) {\n            this.dataMover.moveData(this.backend, dataId);\n        }\n        return this.data.get(dataId);\n    }\n    set(dataId, value) {\n        this.dataIdsCount++;\n        this.data.set(dataId, value);\n    }\n    has(dataId) {\n        return this.data.has(dataId);\n    }\n    delete(dataId) {\n        this.dataIdsCount--;\n        return this.data.delete(dataId);\n    }\n    numDataIds() {\n        return this.dataIdsCount;\n    }\n}\n/**\n * The interface that defines the kernels that should be implemented when\n * adding a new backend. New backends don't need to implement every one of the\n * methods, this can be done gradually (throw an error for unimplemented\n * methods).\n */\nexport class KernelBackend {\n    refCount(dataId) {\n        return notYetImplemented('refCount');\n    }\n    incRef(dataId) {\n        return notYetImplemented('incRef');\n    }\n    timerAvailable() {\n        return true;\n    }\n    time(f) {\n        return notYetImplemented('time');\n    }\n    read(dataId) {\n        return notYetImplemented('read');\n    }\n    readSync(dataId) {\n        return notYetImplemented('readSync');\n    }\n    numDataIds() {\n        return notYetImplemented('numDataIds');\n    }\n    disposeData(dataId, force) {\n        return notYetImplemented('disposeData');\n    }\n    write(values, shape, dtype) {\n        return notYetImplemented('write');\n    }\n    move(dataId, values, shape, dtype, refCount) {\n        return notYetImplemented('move');\n    }\n    memory() {\n        return notYetImplemented('memory');\n    }\n    /** Returns the highest precision for floats in bits (e.g. 16 or 32) */\n    floatPrecision() {\n        return notYetImplemented('floatPrecision');\n    }\n    /** Returns the smallest representable number.  */\n    epsilon() {\n        return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n    }\n    dispose() {\n        return notYetImplemented('dispose');\n    }\n}\nfunction notYetImplemented(kernelName) {\n    throw new Error(`'${kernelName}' not yet implemented or not found in the registry. ` +\n        `This kernel may not be supported by the tfjs backend you have chosen`);\n}\n//# sourceMappingURL=backend.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Merges real and imaginary Float32Arrays into a single complex Float32Array.\n *\n * The memory layout is interleaved as follows:\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n * complex: [r0, i0, r1, i1, r2, i2]\n *\n * This is the inverse of splitRealAndImagArrays.\n *\n * @param real The real values of the complex tensor values.\n * @param imag The imag values of the complex tensor values.\n * @returns A complex tensor as a Float32Array with merged values.\n */\nexport function mergeRealAndImagArrays(real, imag) {\n    if (real.length !== imag.length) {\n        throw new Error(`Cannot merge real and imag arrays of different lengths. real:` +\n            `${real.length}, imag: ${imag.length}.`);\n    }\n    const result = new Float32Array(real.length * 2);\n    for (let i = 0; i < result.length; i += 2) {\n        result[i] = real[i / 2];\n        result[i + 1] = imag[i / 2];\n    }\n    return result;\n}\n/**\n * Splits a complex Float32Array into real and imag parts.\n *\n * The memory layout is interleaved as follows:\n * complex: [r0, i0, r1, i1, r2, i2]\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n *\n * This is the inverse of mergeRealAndImagArrays.\n *\n * @param complex The complex tensor values.\n * @returns An object with real and imag Float32Array components of the complex\n *     tensor.\n */\nexport function splitRealAndImagArrays(complex) {\n    const real = new Float32Array(complex.length / 2);\n    const imag = new Float32Array(complex.length / 2);\n    for (let i = 0; i < complex.length; i += 2) {\n        real[i / 2] = complex[i];\n        imag[i / 2] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Extracts even indexed complex values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithEvenIndex(complex) {\n    const len = Math.ceil(complex.length / 4);\n    const real = new Float32Array(len);\n    const imag = new Float32Array(len);\n    for (let i = 0; i < complex.length; i += 4) {\n        real[Math.floor(i / 4)] = complex[i];\n        imag[Math.floor(i / 4)] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Extracts odd indexed comple values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithOddIndex(complex) {\n    const len = Math.floor(complex.length / 4);\n    const real = new Float32Array(len);\n    const imag = new Float32Array(len);\n    for (let i = 2; i < complex.length; i += 4) {\n        real[Math.floor(i / 4)] = complex[i];\n        imag[Math.floor(i / 4)] = complex[i + 1];\n    }\n    return { real, imag };\n}\n/**\n * Get the map representing a complex value in the given array.\n * @param complex The complex tensor values.\n * @param index An index of the target complex value.\n */\nexport function getComplexWithIndex(complex, index) {\n    const real = complex[index * 2];\n    const imag = complex[index * 2 + 1];\n    return { real, imag };\n}\n/**\n * Insert a given complex value into the TypedArray.\n * @param data The array in which the complex value is inserted.\n * @param c The complex value to be inserted.\n * @param index An index of the target complex value.\n */\nexport function assignToTypedArray(data, real, imag, index) {\n    data[index * 2] = real;\n    data[index * 2 + 1] = imag;\n}\n/**\n * Make the list of exponent terms used by FFT.\n */\nexport function exponents(n, inverse) {\n    const real = new Float32Array(n / 2);\n    const imag = new Float32Array(n / 2);\n    for (let i = 0; i < Math.ceil(n / 2); i++) {\n        const x = (inverse ? 2 : -2) * Math.PI * (i / n);\n        real[i] = Math.cos(x);\n        imag[i] = Math.sin(x);\n    }\n    return { real, imag };\n}\n/**\n * Make the exponent term used by FFT.\n */\nexport function exponent(k, n, inverse) {\n    const x = (inverse ? 2 : -2) * Math.PI * (k / n);\n    const real = Math.cos(x);\n    const imag = Math.sin(x);\n    return { real, imag };\n}\n//# sourceMappingURL=complex_util.js.map","/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from '../util_base';\nconst ARROW = '->';\nconst ARROW_REGEX = /->/g;\nconst COMMA = ',';\nconst ELLIPSIS = '...';\n/**\n * Parse an equation for einsum.\n *\n * @param equation The einsum equation (e.g., \"ij,jk->ik\").\n * @param numTensors Number of tensors provided along with `equation`. Used to\n *   check matching number of input tensors.\n * @returns An object consisting of the following fields:\n *   - allDims: all dimension names as strings.\n *   - summedDims: a list of all dimensions being summed over, as indices to\n *     the elements of `allDims`.\n *   - idDims: indices of the dimensions in each input tensor, as indices to\n *     the elements of `allDims.\n */\nexport function decodeEinsumEquation(equation, numTensors) {\n    equation = equation.replace(/\\s/g, ''); // Remove witespace in equation.\n    const numArrows = (equation.length - equation.replace(ARROW_REGEX, '').length) /\n        ARROW.length;\n    if (numArrows < 1) {\n        throw new Error('Equations without an arrow are not supported.');\n    }\n    else if (numArrows > 1) {\n        throw new Error(`Equation must contain exactly one arrow (\"${ARROW}\").`);\n    }\n    const [inputString, outputString] = equation.split(ARROW);\n    assert(inputString.indexOf(ELLIPSIS) === -1, () => `The ellipsis notation (\"${ELLIPSIS}\") is not supported yet.`);\n    const inputTerms = inputString.split(COMMA);\n    const numInputs = inputTerms.length;\n    if (numTensors !== numInputs) {\n        throw new Error(`Expected ${numInputs} input tensors, received ${numTensors}`);\n    }\n    if (numInputs > 2) {\n        throw new Error('Support for more than 2 input tensors is not implemented yet.');\n    }\n    const allDims = [];\n    for (let i = 0; i < outputString.length; ++i) {\n        const dimName = outputString[i];\n        if (!inputTerms.some(inputTerm => inputTerm.indexOf(dimName) !== -1)) {\n            throw new Error(`Output subscripts contain the label ${dimName} ` +\n                `not present in the input subscripts.`);\n        }\n        if (allDims.indexOf(dimName) === -1) {\n            allDims.push(dimName);\n        }\n    }\n    for (let i = 0; i < inputString.length; ++i) {\n        const dimName = inputString[i];\n        if (allDims.indexOf(dimName) === -1 && dimName !== COMMA) {\n            allDims.push(dimName);\n        }\n    }\n    const idDims = new Array(inputTerms.length);\n    for (let i = 0; i < numInputs; ++i) {\n        if (new Set(inputTerms[i].split('')).size !== inputTerms[i].length) {\n            throw new Error(`Found duplicate axes in input component ${inputTerms[i]}. ` +\n                `Support for duplicate axes in input is not implemented yet.`);\n        }\n        idDims[i] = [];\n        for (let j = 0; j < inputTerms[i].length; ++j) {\n            idDims[i].push(allDims.indexOf(inputTerms[i][j]));\n        }\n    }\n    const numDims = allDims.length; // Number of unique dimensions.\n    const numOutDims = outputString.length; // Number of output dimensions.\n    const summedDims = []; // Dimensions being summed over.\n    for (let i = numOutDims; i < numDims; ++i) {\n        summedDims.push(i);\n    }\n    return { allDims, summedDims, idDims };\n}\n/**\n * Get the permutation for a given input tensor.\n *\n * @param nDims Total number of dimension of all tensors involved in the einsum\n *   operation.\n * @param idDims Dimension indices involve in the tensor in question.\n * @returns An object consisting of the following fields:\n *   - permutationIndices: Indices to permute the axes of the tensor with.\n *   - expandDims: Indices to the dimension that need to be expanded from the\n *     tensor after permutation.\n */\nexport function getEinsumPermutation(nDims, idDims) {\n    let permutationIndices = new Array(nDims);\n    permutationIndices.fill(-1);\n    for (let i = 0; i < idDims.length; ++i) {\n        permutationIndices[idDims[i]] = i;\n    }\n    const expandDims = [];\n    for (let i = 0; i < nDims; ++i) {\n        if (permutationIndices[i] === -1) {\n            expandDims.push(i);\n        }\n    }\n    permutationIndices = permutationIndices.filter(d => d !== -1);\n    return { permutationIndices, expandDims };\n}\n/**\n * Checks that the dimension sizes from different input tensors match the\n * equation.\n */\nexport function checkEinsumDimSizes(nDims, idDims, tensors) {\n    const dimSizes = new Array(nDims);\n    for (let i = 0; i < tensors.length; ++i) {\n        const shape = tensors[i].shape;\n        for (let j = 0; j < idDims[i].length; ++j) {\n            if (dimSizes[idDims[i][j]] === undefined) {\n                dimSizes[idDims[i][j]] = shape[j];\n            }\n            else {\n                assert(dimSizes[idDims[i][j]] === shape[j], () => `Expected dimension ${dimSizes[idDims[i][j]]} at axis ${j} ` +\n                    `of input shaped ${JSON.stringify(shape)}, ` +\n                    `but got dimension ${shape[j]}`);\n            }\n        }\n    }\n}\n/**\n * Gets path of computation for einsum.\n *\n * @param summedDims indices to the dimensions being summed over.\n * @param idDims A look up table for the dimensions present in each input\n *     tensor. Each consituent array contains indices for the dimensions in the\n *     corresponding input tensor.\n *\n * @return A map with two fields:\n *   - path: The path of computation, with each element indicating the dimension\n *     being summed over after the element-wise multiplication in that step.\n *   - steps: With the same length as `path`. Each element contains the indices\n *     to the input tensors being used for element-wise multiplication in the\n *     corresponding step.\n */\nexport function getEinsumComputePath(summedDims, idDims) {\n    const path = summedDims;\n    const steps = [];\n    let nSteps = 0;\n    if (summedDims.length === 0) {\n        // Einsum that involes no summing: e.g., transpose and outer product.\n        path.push(-1);\n    }\n    nSteps = summedDims.length + 1;\n    for (let i = 0; i < nSteps; ++i) {\n        steps.push([]);\n    }\n    const computedTermIndices = [];\n    for (let i = 0; i < path.length; ++i) {\n        const summedDim = path[i];\n        const termIndices = findTermsWithDim(idDims, summedDim);\n        for (const termIndex of termIndices) {\n            if (computedTermIndices.indexOf(termIndex) === -1) {\n                steps[i].push(termIndex);\n                computedTermIndices.push(termIndex);\n            }\n        }\n    }\n    return { path, steps };\n}\n/** Determines if an axes permutation is the identity permutation. */\nexport function isIdentityPermutation(perm) {\n    return perm.every((dim, index) => dim === index);\n}\nfunction findTermsWithDim(idDims, dim) {\n    const termIndices = [];\n    for (let i = 0; i < idDims.length; ++i) {\n        if (idDims[i].length === 0 || idDims[i].indexOf(dim) !== -1 || dim === -1) {\n            termIndices.push(i);\n        }\n    }\n    return termIndices;\n}\n//# sourceMappingURL=einsum_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { decodeString, encodeString } from '../util';\n// Utilities needed by backend consumers of tf-core.\nexport * from '../ops/axis_util';\nexport * from '../ops/broadcast_util';\nexport * from '../ops/concat_util';\nexport * from '../ops/conv_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/reduce_util';\nimport * as slice_util from '../ops/slice_util';\nexport { slice_util };\nexport { upcastType } from '../types';\nexport * from '../ops/rotate_util';\nexport * from '../ops/array_ops_util';\nexport * from '../ops/gather_nd_util';\nexport * from '../ops/scatter_nd_util';\nexport * from '../ops/selu_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/erf_util';\nexport * from '../log';\nexport * from '../backends/complex_util';\nexport * from '../backends/einsum_util';\nexport * from '../ops/split_util';\nimport * as segment_util from '../ops/segment_util';\nexport { segment_util };\nexport function fromUint8ToStringArray(vals) {\n    try {\n        // Decode the bytes into string.\n        return vals.map(val => decodeString(val));\n    }\n    catch (err) {\n        throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${err}`);\n    }\n}\nexport function fromStringArrayToUint8(strings) {\n    return strings.map(s => encodeString(s));\n}\n//# sourceMappingURL=backend_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/** An implementation of the Where kernel shared between cpu and webgl */\nimport { buffer } from '../ops/buffer';\nexport function whereImpl(condShape, condVals) {\n    const indices = [];\n    for (let i = 0; i < condVals.length; i++) {\n        if (condVals[i]) {\n            indices.push(i);\n        }\n    }\n    const inBuffer = buffer(condShape, 'int32');\n    const out = buffer([indices.length, condShape.length], 'int32');\n    for (let i = 0; i < indices.length; i++) {\n        const loc = inBuffer.indexToLoc(indices[i]);\n        const offset = i * condShape.length;\n        out.values.set(loc, offset);\n    }\n    return out.toTensor();\n}\n//# sourceMappingURL=where_impl.js.map"],"names":["binaryInsert","arr","element","comparator","index","target","left","right","length","middle","found","compareResult","binarySearch_","defaultComparator","binarySearch","insertionPoint","splice","a","b","nonMaxSuppressionV3Impl","boxes","scores","maxOutputSize","iouThreshold","scoreThreshold","nonMaxSuppressionImpl_","nonMaxSuppressionV4Impl","padToMaxOutputSize","nonMaxSuppressionV5Impl","softNmsSigma","returnScoresTensor","returnValidOutputs","candidates","i","push","score","boxIndex","suppressBeginIndex","sort","ascendingComparator","scale","selectedIndices","selectedScores","candidate","pop","originalScore","ignoreCandidate","j","iou","intersectionOverUnion","suppressWeight","validOutputs","elemsToPad","Array","fill","result","iCoord","subarray","jCoord","yminI","Math","min","xminI","ymaxI","max","xmaxI","yminJ","xminJ","ymaxJ","xmaxJ","areaI","areaJ","intersectionYmin","intersectionXmin","intersectionYmax","intersectionXmax","intersectionArea","weight","exp","c1","c2","DataStorage","constructor","backend","dataMover","this","data","WeakMap","dataIdsCount","get","dataId","has","moveData","set","value","delete","numDataIds","KernelBackend","refCount","notYetImplemented","incRef","timerAvailable","time","f","read","readSync","disposeData","force","write","values","shape","dtype","move","memory","floatPrecision","epsilon","dispose","kernelName","Error","mergeRealAndImagArrays","real","imag","Float32Array","splitRealAndImagArrays","complex","complexWithEvenIndex","len","ceil","floor","complexWithOddIndex","getComplexWithIndex","assignToTypedArray","exponents","n","inverse","x","PI","cos","sin","exponent","k","ARROW","ARROW_REGEX","COMMA","ELLIPSIS","decodeEinsumEquation","equation","numTensors","numArrows","replace","inputString","outputString","split","indexOf","inputTerms","numInputs","allDims","dimName","some","inputTerm","idDims","Set","size","numDims","summedDims","getEinsumPermutation","nDims","permutationIndices","expandDims","filter","d","checkEinsumDimSizes","tensors","dimSizes","undefined","JSON","stringify","getEinsumComputePath","path","steps","nSteps","computedTermIndices","termIndices","findTermsWithDim","termIndex","isIdentityPermutation","perm","every","dim","fromUint8ToStringArray","vals","map","val","decodeString","err","fromStringArrayToUint8","strings","s","encodeString","whereImpl","condShape","condVals","indices","inBuffer","out","loc","indexToLoc","offset","toTensor"],"sourceRoot":""}