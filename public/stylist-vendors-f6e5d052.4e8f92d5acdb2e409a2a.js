"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[8266],{7175:function(t,n,r){r.d(n,{r:function(){return e}});const e="3.6.0"},45119:function(t,n,r){function e(t){let n=t.length,r=0,e=0;for(;n>0;)e=Math.random()*n|0,n--,r=t[n],t[n]=t[e],t[e]=r}function i(t,n){if(t.length!==n.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${t.length}Second array length was ${n.length}`);let r,e,i=t.length,s=0;for(;i>0;)s=Math.random()*i|0,i--,r=t[i],e=n[i],t[i]=t[s],n[i]=n[s],t[s]=r,n[s]=e}function s(t,n,r){return Math.max(t,Math.min(n,r))}function u(t){return t%2===0?t:t+1}function o(t){let n=0;for(let r=0;r<t.length;r++)n+=t[r];return n}function a(t,n){const r=Math.random();return n*r+(1-r)*t}function l(t,n){let r=0;for(let e=0;e<t.length;e++){const i=Number(t[e])-Number(n[e]);r+=i*i}return r}function c(t,n){if(!t)throw new Error("string"===typeof n?n:n())}function h(t,n,r=""){c(y(t,n),(()=>r+` Shapes ${t} and ${n} must match`))}function f(t){c(null!=t,(()=>"The input to the tensor constructor must be a non-null value."))}function p(t,n=[],r=!1){if(null==n&&(n=[]),Array.isArray(t)||I(t)&&!r)for(let e=0;e<t.length;++e)p(t[e],n,r);else n.push(t);return n}function m(t){if(0===t.length)return 1;let n=t[0];for(let r=1;r<t.length;r++)n*=t[r];return n}function d(t){return 0===t.length}function y(t,n){if(t===n)return!0;if(null==t||null==n)return!1;if(t.length!==n.length)return!1;for(let r=0;r<t.length;r++)if(t[r]!==n[r])return!1;return!0}function w(t){return t%1===0}function g(t){if(null!=Math.tanh)return Math.tanh(t);if(t===1/0)return 1;if(t===-1/0)return-1;{const n=Math.exp(2*t);return(n-1)/(n+1)}}function x(t){const n=Math.ceil(Math.sqrt(t));return[n,Math.ceil(t/n)]}function b(t){const n=new Uint32Array(t);for(let r=0;r<t;++r)n[r]=r;return e(n),n}function v(t,n){return n<=t.length?t:t+" ".repeat(n-t.length)}function A(t,n=t=>0,r){return new Promise(((e,i)=>{let s=0;const u=()=>{if(t())return void e();s++;const o=n(s);null!=r&&s>=r?i():setTimeout(u,o)};u()}))}function E(t,n){let r=1,e=-1;for(let s=0;s<t.length;++s)if(t[s]>=0)r*=t[s];else if(-1===t[s]){if(-1!==e)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${e} and dim ${s}`);e=s}else if(t[s]<0)throw Error(`Shapes can not be < 0. Found ${t[s]} at dim ${s}`);if(-1===e){if(n>0&&n!==r)throw Error(`Size(${n}) must match the product of shape ${t}`);return t}if(0===r)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(n%r!==0)throw Error(`The implicit shape can't be a fractional number. Got ${n} / ${r}`);const i=t.slice();return i[e]=n/r,i}function R(t,n){const r=n.length;return c((t=null==t?n.map(((t,n)=>n)):[].concat(t)).every((t=>t>=-r&&t<r)),(()=>`All values in axis param must be in range [-${r}, ${r}) but got axis ${t}`)),c(t.every((t=>w(t))),(()=>`All values in axis param must be integers but got axis ${t}`)),t.map((t=>t<0?r+t:t))}function S(t,n){const r=[],e=[],i=null!=n&&Array.isArray(n)&&0===n.length,s=null==n||i?null:R(n,t).sort();let u=0;for(let o=0;o<t.length;++o){if(null!=s){if(s[u]===o&&1!==t[o])throw new Error(`Can't squeeze axis ${o} since its dim '${t[o]}' is not 1`);(null==s[u]||s[u]>o)&&1===t[o]&&(r.push(t[o]),e.push(o)),s[u]<=o&&u++}1!==t[o]&&(r.push(t[o]),e.push(o))}return{newShape:r,keptDims:e}}function z(t,n){let r=null;if(null==t||"float32"===t)r=new Float32Array(n);else if("int32"===t)r=new Int32Array(n);else{if("bool"!==t)throw new Error(`Unknown data type ${t}`);r=new Uint8Array(n)}return r}function T(t,n){let r=null;if(null==t||"float32"===t)r=new Float32Array(n);else if("int32"===t)r=new Int32Array(n);else if("bool"===t)r=new Uint8Array(n);else{if("string"!==t)throw new Error(`Unknown data type ${t}`);r=new Array(n)}return r}function $(t,n){for(let r=0;r<t.length;r++){const e=t[r];if(isNaN(e)||!isFinite(e))throw Error(`A tensor of type ${n} being uploaded contains ${e}.`)}}function F(t){return"bool"===t||"complex64"===t||"float32"===t||"int32"===t||"string"===t}function C(t,n){return"complex64"!==n&&(("float32"!==n||"complex64"===t)&&(("int32"!==n||"float32"===t||"complex64"===t)&&("bool"!==n||"bool"!==t)))}function I(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array}function k(t){if("float32"===t||"int32"===t)return 4;if("complex64"===t)return 8;if("bool"===t)return 1;throw new Error(`Unknown dtype ${t}`)}function N(t){if(null==t)return 0;let n=0;return t.forEach((t=>n+=t.length)),n}function M(t){return"string"===typeof t||t instanceof String}function L(t){return"boolean"===typeof t}function _(t){return"number"===typeof t}function q(t){return Array.isArray(t)?q(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array?"int32":_(t)?"float32":M(t)?"string":L(t)?"bool":"float32"}function U(t){return!!(t&&t.constructor&&t.call&&t.apply)}function P(t,n){for(let r=n;r<t;++r)if(t%r===0)return r;return t}function B(t){const n=t.length;if(n<2)return[];const r=new Array(n-1);r[n-2]=t[n-1];for(let e=n-3;e>=0;--e)r[e]=r[e+1]*t[e+1];return r}function O(t,n,r,e=!1){const i=new Array;if(1===n.length){const s=n[0]*(e?2:1);for(let n=0;n<s;n++)i[n]=r[t+n]}else{const s=n[0],u=n.slice(1),o=u.reduce(((t,n)=>t*n))*(e?2:1);for(let n=0;n<s;n++)i[n]=O(t+n*o,u,r,e)}return i}function D(t,n,r=!1){if(0===t.length)return n[0];const e=t.reduce(((t,n)=>t*n))*(r?2:1);if(0===e)return[];if(e!==n.length)throw new Error(`[${t}] does not match the input size ${n.length}${r?" for a complex tensor":""}.`);return O(0,t,n,r)}function j(t,n){const r=K(t,n);for(let e=0;e<r.length;e++)r[e]=1;return r}function K(t,n){if(null==n||"float32"===n||"complex64"===n)return new Float32Array(t);if("int32"===n)return new Int32Array(t);if("bool"===n)return new Uint8Array(t);throw new Error(`Unknown data type ${n}`)}function H(t,n){const r=t.reduce(((t,n)=>t*n),1);if(null==n||"float32"===n)return D(t,new Float32Array(r));if("int32"===n)return D(t,new Int32Array(r));if("bool"===n)return D(t,new Uint8Array(r));throw new Error(`Unknown data type ${n}`)}function X(t){t.forEach((n=>{c(Number.isInteger(n)&&n>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`))}))}function Z(t,n,r){if(0===n)return 0;if(1===n)return t[0];let e=t[t.length-1];for(let i=0;i<t.length-1;++i)e+=r[i]*t[i];return e}function G(t,n,r){if(0===n)return[];if(1===n)return[t];const e=new Array(n);for(let i=0;i<e.length-1;++i)e[i]=Math.floor(t/r[i]),t-=e[i]*r[i];return e[e.length-1]=t,e}function Q(t){return t&&t.then&&"function"===typeof t.then}r.d(n,{Ab:function(){return T},BE:function(){return C},Bq:function(){return p},E6:function(){return w},Et:function(){return _},FZ:function(){return j},HO:function(){return f},Kg:function(){return M},Lm:function(){return L},O3:function(){return h},P8:function(){return b},SA:function(){return X},SL:function(){return N},Sf:function(){return d},Tn:function(){return U},Ty:function(){return K},Ur:function(){return B},X$:function(){return q},XT:function(){return E},Y6:function(){return R},Ze:function(){return m},_k:function(){return G},_q:function(){return A},a0:function(){return i},av:function(){return v},c7:function(){return H},ce:function(){return z},cz:function(){return o},eV:function(){return u},gS:function(){return x},gx:function(){return S},iu:function(){return I},jv:function(){return k},k4:function(){return e},lK:function(){return P},nd:function(){return $},oO:function(){return l},qE:function(){return s},r1:function(){return y},sX:function(){return Z},so:function(){return a},vA:function(){return c},xn:function(){return F},yL:function(){return Q},ym:function(){return g},yw:function(){return D}})},52046:function(t,n,r){var e,i,s,u,o;r.d(n,{Tu:function(){return l},ch:function(){return c},rg:function(){return e}}),function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(e||(e={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(i||(i={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(s||(s={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(u||(u={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(o||(o={}));const a={float32:u,int32:i,bool:s,complex64:o};function l(t,n){if("string"===t||"string"===n){if("string"===t&&"string"===n)return"string";throw new Error(`Can not upcast ${t} with ${n}`)}return a[t][n]}function c(t){return l(t,"int32")}},72633:function(t,n,r){r.d(n,{B:function(){return h}});var e=r(99696),i=r(85316),s=r(81409),u=r(98544),o=r(5340),a=r(83335),l=r(25727),c=r(37930);o.Q,c.S,e.K,i.a,l.P,u.o,s.F;const h={sgd:a.L.sgd,momentum:a.L.momentum,adadelta:a.L.adadelta,adagrad:a.L.adagrad,rmsprop:a.L.rmsprop,adamax:a.L.adamax,adam:a.L.adam}},84510:function(t,n,r){r.d(n,{iS:function(){return _}});var e,i=r(9495),s=r(7391);function u(t,n,r=new Map,e=new Set){if(null==t)return null;if(e.has(t))throw new Error("Circular references are not supported.");if(r.has(t))return r.get(t);const i=n(t);if(i.recurse&&null!==i.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse){if(c(t)){const i=Array.isArray(t)?[]:{};e.add(t);for(const s in t){const o=u(t[s],n,r,e);i[s]=o}return e.delete(t),i}throw new Error(`Can't recurse into non-iterable type: ${t}`)}return r.set(t,i.value),i.value}function o(t,n=l){return a(t,n)}function a(t,n,r=new Set){const e=t[0];if(r.has(e))throw new Error("Circular references are not supported.");const i=n(t);if(i.recurse&&null!==i.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse){if(c(e)){const i=Array.isArray(e)?[]:{};r.add(e);for(const s in e){const e=a(t.map((t=>t[s])),n,r);i[s]=e}return r.delete(e),i}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return i.value}function l(t){return null===t?null:c(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}function c(t){return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"===typeof t&&!(t instanceof i.Tensor))}function h(t){return u(t,f)}function f(t){return t instanceof i.Tensor?{value:t.clone(),recurse:!1}:c(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}class p{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,n){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=n}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const n of t)this.push(n)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const n=this.wrap(this.begin+t),r=this.get(n);return this.set(n,this.pop()),r}}class m extends p{constructor(){super(m.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,n=new Array(t),r=this.length();for(let e=0;e<r;e++)n[e]=this.get(this.wrap(this.begin+e));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}}function d(t){return new x(t)}function y(t,n){return new C(t,n)}m.INITIAL_CAPACITY=32;class w{async toArray(){const t=[];let n=await this.next();for(;!n.done;)t.push(n.value),n=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),n=[];let r=await t.next();for(;!r.done;)n.push(r.value),r=await t.next();return n}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let n=await this.next(),r=t(n.value);for(;!n.done&&r;)n=await this.next(),r=t(n.value)}handleErrors(t){return new z(this,t)}filter(t){return new R(this,t)}map(t){return new S(this,t)}mapAsync(t){return new T(this,t)}serialMapAsync(t){return new T(this,t).serial()}flatmap(t){return new F(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile((t=>!0===t))}rowMajorBatch(t,n=!0){return new E(this,t,n)}columnMajorBatch(t,n=!0,r=l){return this.rowMajorBatch(t,n).map((t=>o(t,r)))}concatenate(t,n){return new C(new g([this,t]),n)}take(t){return t<0||null==t?this:new A(this,t)}skip(t){return t<0||null==t?this:new v(this,t)}prefetch(t){return new I(this,t)}shuffle(t,n){return new k(this,t,n)}serial(){return new b(this)}}class g extends w{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:h(t),done:!1}}}class x extends w{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}}class b extends w{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class v extends w{constructor(t,n){super(),this.upstream=t,this.maxCount=n,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;i.dispose(t.value)}return this.upstream.next()}}class A extends w{constructor(t,n){super(),this.upstream=t,this.maxCount=n,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class E extends w{constructor(t,n,r=!0){super(),this.upstream=t,this.batchSize=n,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const n=await this.upstream.next();if(n.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(n.value)}return{value:t,done:!1}}}class R extends w{constructor(t,n){super(),this.upstream=t,this.predicate=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;i.dispose(t.value)}}}class S extends w{constructor(t,n){super(),this.upstream=t,this.transform=n}summary(){return`${this.upstream.summary()} -> Map`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const n=i.tensor_util.getTensorsInContainer(t.value),r=this.transform(t.value),e=i.tensor_util.getTensorsInContainer(r);for(const s of n)i.tensor_util.isTensorInList(s,e)||s.dispose();return{value:r,done:!1}}}class z extends w{constructor(t,n){super(),this.upstream=t,this.handler=n,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class T extends w{constructor(t,n){super(),this.upstream=t,this.transform=n}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const n=i.tensor_util.getTensorsInContainer(t.value),r=await this.transform(t.value),e=i.tensor_util.getTensorsInContainer(r);for(const s of n)i.tensor_util.isTensorInList(s,e)||s.dispose();return{value:r,done:!1}}}class $ extends w{constructor(){super(),this.outputQueue=new m,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class F extends ${constructor(t,n){super(),this.upstream=t,this.transform=n}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const t=await this.upstream.next();if(t.done)return!1;const n=i.tensor_util.getTensorsInContainer(t.value),r=this.transform(t.value),e=i.tensor_util.getTensorsInContainer(r);this.outputQueue.pushAll(r);for(const s of n)i.tensor_util.isTensorInList(s,e)||s.dispose();return!0}}class C extends w{constructor(t,n){super(),this.baseErrorHandler=n,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const n=await this.iterator.next();return n.done?(this.iterator=null,this.readFromChain(t)):n}}!function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(e||(e={}));class I extends w{constructor(t,n){super(),this.upstream=t,this.bufferSize=n,this.buffer=new p(n)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}class k extends I{constructor(t,n,r){super(t,n),this.upstream=t,this.windowSize=n,this.upstreamExhausted=!1,this.random=s.alea(r||i.util.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),n=await this.buffer.shuffleExcise(t);if(!n.done)return this.refill(),n;this.upstreamExhausted=!0}return{value:null,done:!0}}}class N{constructor(){this.size=null}batch(t,n=!0){const r=this;let e;return i.util.assert(t>0,(()=>`batchSize needs to be positive, but it is\n      ${t}`)),e=this.size===1/0||null==this.size?this.size:n?Math.ceil(this.size/t):Math.floor(this.size/t),M((async()=>(await r.iterator()).columnMajorBatch(t,n,L)),e)}concatenate(t){const n=this;let r;return r=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,M((async()=>(await n.iterator()).concatenate(await t.iterator())),r)}filter(t){const n=this;let r;return r=this.size===1/0?1/0:null,M((async()=>(await n.iterator()).filter((n=>i.tidy((()=>t(n)))))),r)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const n=this;return M((async()=>(await n.iterator()).map((n=>i.tidy((()=>t(n)))))),this.size)}mapAsync(t){const n=this;return M((async()=>(await n.iterator()).mapAsync(t)),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const n=this;return M((async()=>(await n.iterator()).prefetch(t)),this.size)}repeat(t){const n=this;let r;return r=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,M((async()=>y(d((async()=>({value:await n.iterator(),done:!1}))).take(t))),r)}skip(t){const n=this;let r;return r=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,M((async()=>(await n.iterator()).skip(t)),r)}shuffle(t,n,r=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const e=this,u=s.alea(n||i.util.now().toString());return M((async()=>{let n=u.int32();return r&&(n+=u.int32()),(await e.iterator()).shuffle(t,n.toString())}),this.size)}take(t){const n=this;let r;return r=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,M((async()=>(await n.iterator()).take(t)),r)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function M(t,n=null){return new class extends N{constructor(){super(...arguments),this.size=n}async iterator(){return t()}}}function L(t){if(null===t)return null;if(function(t){return null==t||null===(n=t)||"object"!==typeof n&&"function"!==typeof n||Array.isArray(t)||"object"===typeof t&&t instanceof i.Tensor||i.util.isTypedArray(t);var n}(t[0])){return{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof i.Tensor?i.stack(t):i.tensor(t)}(t),recurse:!1}}return{value:null,recurse:!0}}N.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");r(48287).hp;const _="3.6.0"},89783:function(t,n,r){r.r(n),r.d(n,{arraysEqual:function(){return i.r1},assert:function(){return i.vA},assertNonNegativeIntegerDimensions:function(){return i.SA},assertNonNull:function(){return i.HO},assertShapesMatch:function(){return i.O3},bytesFromStringArray:function(){return i.SL},bytesPerElement:function(){return i.jv},checkConversionForErrors:function(){return i.nd},clamp:function(){return i.qE},computeStrides:function(){return i.Ur},createScalarValue:function(){return s},createShuffledIndices:function(){return i.P8},decodeString:function(){return c},distSquared:function(){return i.oO},encodeString:function(){return l},fetch:function(){return a},flatten:function(){return i.Bq},getArrayFromDType:function(){return i.Ab},getTypedArrayFromDType:function(){return i.ce},hasEncodingLoss:function(){return i.BE},indexToLoc:function(){return i._k},inferDtype:function(){return i.X$},inferFromImplicitShape:function(){return i.XT},isBoolean:function(){return i.Lm},isFunction:function(){return i.Tn},isInt:function(){return i.E6},isNumber:function(){return i.Et},isPromise:function(){return i.yL},isScalarShape:function(){return i.Sf},isString:function(){return i.Kg},isTypedArray:function(){return i.iu},isValidDtype:function(){return i.xn},locToIndex:function(){return i.sX},makeOnesTypedArray:function(){return i.FZ},makeZerosNestedTypedArray:function(){return i.c7},makeZerosTypedArray:function(){return i.Ty},nearestDivisor:function(){return i.lK},nearestLargerEven:function(){return i.eV},now:function(){return o},parseAxisParam:function(){return i.Y6},randUniform:function(){return i.so},repeatedTry:function(){return i._q},rightPad:function(){return i.av},shuffle:function(){return i.k4},shuffleCombo:function(){return i.a0},sizeFromShape:function(){return i.Ze},sizeToSquarishShape:function(){return i.gS},squeezeShape:function(){return i.gx},sum:function(){return i.cz},tanh:function(){return i.ym},toNestedArray:function(){return i.yw},toTypedArray:function(){return u}});var e=r(46574),i=r(45119);function s(t,n){return"string"===n?l(t):u([t],n)}function u(t,n){if("string"===n)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=i.Bq(t)),(0,e._K)().getBool("DEBUG")&&i.nd(t,n),function(t,n){return t instanceof Float32Array&&"float32"===n||t instanceof Int32Array&&"int32"===n||t instanceof Uint8Array&&"bool"===n}(t,n))return t;if(null==n||"float32"===n||"complex64"===n)return new Float32Array(t);if("int32"===n)return new Int32Array(t);if("bool"===n){const n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)0!==Math.round(t[r])&&(n[r]=1);return n}throw new Error(`Unknown data type ${n}`)}function o(){return(0,e._K)().platform.now()}function a(t,n){return(0,e._K)().platform.fetch(t,n)}function l(t,n="utf-8"){return n=n||"utf-8",(0,e._K)().platform.encode(t,n)}function c(t,n="utf-8"){return n=n||"utf-8",(0,e._K)().platform.decode(t,n)}}}]);
//# sourceMappingURL=stylist-vendors-f6e5d052.4e8f92d5acdb2e409a2a.js.map