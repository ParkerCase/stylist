{"version":3,"file":"stylist-vendors-f69c3f2b.e2772057b2aba0a6ed51.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/engine/training_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/engine/training_tensors.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/engine/training_dataset.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { argMax, clone, dispose, mul, reshape, tensor1d, tidy } from '@tensorflow/tfjs-core';\nfunction standardizeSampleOrClassWeights(xWeight, outputNames, weightType) {\n    const numOutputs = outputNames.length;\n    if (xWeight == null || (Array.isArray(xWeight) && xWeight.length === 0)) {\n        return outputNames.map(name => null);\n    }\n    if (numOutputs === 1) {\n        if (Array.isArray(xWeight) && xWeight.length === 1) {\n            return xWeight;\n        }\n        else if (typeof xWeight === 'object' && outputNames[0] in xWeight) {\n            return [xWeight[outputNames[0]]];\n        }\n        else {\n            return [xWeight];\n        }\n    }\n    if (Array.isArray(xWeight)) {\n        if (xWeight.length !== numOutputs) {\n            throw new Error(`Provided ${weightType} is an array of ${xWeight.length} ` +\n                `element(s), but the model has ${numOutputs} outputs. ` +\n                `Make sure a set of weights is provided for each model output.`);\n        }\n        return xWeight;\n    }\n    else if (typeof xWeight === 'object' && Object.keys(xWeight).length > 0 &&\n        typeof xWeight[Object.keys(xWeight)[0]] ===\n            'object') {\n        const output = [];\n        outputNames.forEach(outputName => {\n            if (outputName in xWeight) {\n                output.push(xWeight[outputName]);\n            }\n            else {\n                output.push(null);\n            }\n        });\n        return output;\n    }\n    else {\n        throw new Error(`The model has multiple (${numOutputs}) outputs, ` +\n            `so ${weightType} must be either an array with ` +\n            `${numOutputs} elements or an object with ${outputNames} keys. ` +\n            `Provided ${weightType} not understood: ${JSON.stringify(xWeight)}`);\n    }\n}\n/**\n * Standardize class weighting objects.\n *\n * This function takes a single class-weighting object, an array of them,\n * or a map from output name to class-weighting object. It compares it to the\n * output name(s) of the model, base on which it outputs an array of\n * class-weighting objects of which the length matches the number of outputs.\n *\n * @param classWeight Input class-weighting object(s).\n * @param outputNames All output name(s) of the model.\n * @return An array of class-weighting objects. The length of the array matches\n *   the model's number of outputs.\n */\nexport function standardizeClassWeights(classWeight, outputNames) {\n    return standardizeSampleOrClassWeights(classWeight, outputNames, 'classWeight');\n}\nexport function standardizeSampleWeights(classWeight, outputNames) {\n    return standardizeSampleOrClassWeights(classWeight, outputNames, 'sampleWeight');\n}\n/**\n * Standardize by-sample and/or by-class weights for training.\n *\n * Note that this function operates on one model output at a time. For a model\n * with multiple outputs, you must call this function multiple times.\n *\n * @param y The target tensor that the by-sample and/or by-class weight is for.\n *     The values of y are assumed to encode the classes, either directly\n *     as an integer index, or as one-hot encoding.\n * @param sampleWeight By-sample weights.\n * @param classWeight By-class weights: an object mapping class indices\n *     (integers) to a weight (float) to apply to the model's loss for the\n *     samples from this class during training. This can be useful to tell the\n *     model to \"pay more attention\" to samples from an under-represented class.\n * @param sampleWeightMode The mode for the sample weights.\n * @return A Promise of weight tensor, of which the size of the first dimension\n *     matches that of `y`.\n */\nexport async function standardizeWeights(y, sampleWeight, classWeight, sampleWeightMode) {\n    if (sampleWeight != null || sampleWeightMode != null) {\n        // TODO(cais): Once 'temporal' mode is implemented, document it in the doc\n        // string.\n        throw new Error('Support sampleWeight is not implemented yet');\n    }\n    if (classWeight != null) {\n        // Apply class weights per sample.\n        const yClasses = tidy(() => {\n            if (y.shape.length === 1) {\n                // Assume class indices.\n                return clone(y);\n            }\n            else if (y.shape.length === 2) {\n                if (y.shape[1] > 1) {\n                    // Assume one-hot encoding of classes.\n                    const axis = 1;\n                    return argMax(y, axis);\n                }\n                else if (y.shape[1] === 1) {\n                    // Class index.\n                    return reshape(y, [y.shape[0]]);\n                }\n                else {\n                    throw new Error(`Encountered unexpected last-dimension size (${y.shape[1]}) ` +\n                        `during handling of class weights. The size is expected to be ` +\n                        `>= 1.`);\n                }\n            }\n            else {\n                throw new Error(`Unexpected rank of target (y) tensor (${y.rank}) during ` +\n                    `handling of class weights. The rank is expected to be 1 or 2.`);\n            }\n        });\n        const yClassIndices = Array.from(await yClasses.data());\n        dispose(yClasses);\n        const classSampleWeight = [];\n        yClassIndices.forEach(classIndex => {\n            if (classWeight[classIndex] == null) {\n                throw new Error(`classWeight must contain all classes in the training data. ` +\n                    `The class ${classIndex} exists in the data but not in ` +\n                    `classWeight`);\n            }\n            else {\n                classSampleWeight.push(classWeight[classIndex]);\n            }\n        });\n        return tensor1d(classSampleWeight, 'float32');\n    }\n    else {\n        return null;\n    }\n}\n/**\n * Apply per-sample weights on the loss values from a number of samples.\n *\n * @param losses Loss tensor of shape `[batchSize]`.\n * @param sampleWeights Per-sample weight tensor of shape `[batchSize]`.\n * @returns Tensor of the same shape as`losses`.\n */\nexport function computeWeightedLoss(losses, sampleWeights) {\n    return mul(losses, sampleWeights);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhaW5pbmdfdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvZW5naW5lL3RyYWluaW5nX3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQW9CLFFBQVEsRUFBRSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQXVCN0csU0FBUywrQkFBK0IsQ0FDcEMsT0FBaUQsRUFBRSxXQUFxQixFQUN4RSxVQUF3QztJQUMxQyxNQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDO0lBQ3RDLElBQUksT0FBTyxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsRUFBRTtRQUN2RSxPQUFPLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN0QztJQUNELElBQUksVUFBVSxLQUFLLENBQUMsRUFBRTtRQUNwQixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDbEQsT0FBTyxPQUFPLENBQUM7U0FDaEI7YUFBTSxJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksT0FBTyxFQUFFO1lBQ25FLE9BQU8sQ0FBRSxPQUEwQixDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEQ7YUFBTTtZQUNMLE9BQU8sQ0FBQyxPQUFzQixDQUFDLENBQUM7U0FDakM7S0FDRjtJQUNELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENB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dXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YXJnTWF4LCBjbG9uZSwgZGlzcG9zZSwgbXVsLCByZXNoYXBlLCBUZW5zb3IsIFRlbnNvcjFELCB0ZW5zb3IxZCwgdGlkeX0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuLyoqXG4gKiBGb3IgbXVsdGktY2xhc3MgY2xhc3NpZmljYXRpb24gcHJvYmxlbXMsIHRoaXMgb2JqZWN0IGlzIGRlc2lnbmVkIHRvIHN0b3JlIGFcbiAqIG1hcHBpbmcgZnJvbSBjbGFzcyBpbmRleCB0byB0aGUgXCJ3ZWlnaHRcIiBvZiB0aGUgY2xhc3MsIHdoZXJlIGhpZ2hlciB3ZWlnaHRlZFxuICogY2xhc3NlcyBoYXZlIGxhcmdlciBpbXBhY3Qgb24gbG9zcywgYWNjdXJhY3ksIGFuZCBvdGhlciBtZXRyaWNzLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyBpbiB3aGljaCB5b3Ugd2FudCB0aGUgbW9kZWwgdG8gXCJwYXkgbW9yZSBhdHRlbnRpb25cIlxuICogdG8gZXhhbXBsZXMgZnJvbSBhbiB1bmRlci1yZXByZXNlbnRlZCBjbGFzcywgZS5nLiwgaW4gdW5iYWxhbmNlZCBkYXRhc2V0cy5cbiAqL1xuZXhwb3J0IHR5cGUgQ2xhc3NXZWlnaHQgPSB7XG4gIFtjbGFzc0luZGV4OiBudW1iZXJdOiBudW1iZXJcbn07XG5cbi8qKlxuICogQ2xhc3Mgd2VpZ2h0aW5nIGZvciBhIG1vZGVsIHdpdGggbXVsdGlwbGUgb3V0cHV0cy5cbiAqXG4gKiBUaGlzIG9iamVjdCBtYXBzIGVhY2ggb3V0cHV0IG5hbWUgdG8gYSBjbGFzcy13ZWlnaHRpbmcgb2JqZWN0LlxuICovXG5leHBvcnQgdHlwZSBDbGFzc1dlaWdodE1hcCA9IHtcbiAgW291dHB1dE5hbWU6IHN0cmluZ106IENsYXNzV2VpZ2h0XG59O1xuXG5mdW5jdGlvbiBzdGFuZGFyZGl6ZVNhbXBsZU9yQ2xhc3NXZWlnaHRzKFxuICAgIHhXZWlnaHQ6IENsYXNzV2VpZ2h0fENsYXNzV2VpZ2h0W118Q2xhc3NXZWlnaHRNYXAsIG91dHB1dE5hbWVzOiBzdHJpbmdbXSxcbiAgICB3ZWlnaHRUeXBlOiAnc2FtcGxlV2VpZ2h0J3wnY2xhc3NXZWlnaHQnKTogQ2xhc3NXZWlnaHRbXSB7XG4gIGNvbnN0IG51bU91dHB1dHMgPSBvdXRwdXROYW1lcy5sZW5ndGg7XG4gIGlmICh4V2VpZ2h0ID09IG51bGwgfHwgKEFycmF5LmlzQXJyYXkoeFdlaWdodCkgJiYgeFdlaWdodC5sZW5ndGggPT09IDApKSB7XG4gICAgcmV0dXJuIG91dHB1dE5hbWVzLm1hcChuYW1lID0+IG51bGwpO1xuICB9XG4gIGlmIChudW1PdXRwdXRzID09PSAxKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeFdlaWdodCkgJiYgeFdlaWdodC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB4V2VpZ2h0O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHhXZWlnaHQgPT09ICdvYmplY3QnICYmIG91dHB1dE5hbWVzWzBdIGluIHhXZWlnaHQpIHtcbiAgICAgIHJldHVybiBbKHhXZWlnaHQgYXMgQ2xhc3NXZWlnaHRNYXApW291dHB1dE5hbWVzWzBdXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbeFdlaWdodCBhcyBDbGFzc1dlaWdodF07XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHhXZWlnaHQpKSB7XG4gICAgaWYgKHhXZWlnaHQubGVuZ3RoICE9PSBudW1PdXRwdXRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFByb3ZpZGVkICR7d2VpZ2h0VHlwZX0gaXMgYW4gYXJyYXkgb2YgJHt4V2VpZ2h0Lmxlbmd0aH0gYCArXG4gICAgICAgICAgYGVsZW1lbnQocyksIGJ1dCB0aGUgbW9kZWwgaGFzICR7bnVtT3V0cHV0c30gb3V0cHV0cy4gYCArXG4gICAgICAgICAgYE1ha2Ugc3VyZSBhIHNldCBvZiB3ZWlnaHRzIGlzIHByb3ZpZGVkIGZvciBlYWNoIG1vZGVsIG91dHB1dC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHhXZWlnaHQ7XG4gIH0gZWxzZSBpZiAoXG4gICAgICB0eXBlb2YgeFdlaWdodCA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoeFdlaWdodCkubGVuZ3RoID4gMCAmJlxuICAgICAgdHlwZW9mICh4V2VpZ2h0IGFzIENsYXNzV2VpZ2h0TWFwKVtPYmplY3Qua2V5cyh4V2VpZ2h0KVswXV0gPT09XG4gICAgICAgICAgJ29iamVjdCcpIHtcbiAgICBjb25zdCBvdXRwdXQ6IENsYXNzV2VpZ2h0W10gPSBbXTtcbiAgICBvdXRwdXROYW1lcy5mb3JFYWNoKG91dHB1dE5hbWUgPT4ge1xuICAgICAgaWYgKG91dHB1dE5hbWUgaW4geFdlaWdodCkge1xuICAgICAgICBvdXRwdXQucHVzaCgoeFdlaWdodCBhcyBDbGFzc1dlaWdodE1hcClbb3V0cHV0TmFtZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUgbW9kZWwgaGFzIG11bHRpcGxlICgke251bU91dHB1dHN9KSBvdXRwdXRzLCBgICtcbiAgICAgICAgYHNvICR7d2VpZ2h0VHlwZX0gbXVzdCBiZSBlaXRoZXIgYW4gYXJyYXkgd2l0aCBgICtcbiAgICAgICAgYCR7bnVtT3V0cHV0c30gZWxlbWVudHMgb3IgYW4gb2JqZWN0IHdpdGggJHtvdXRwdXROYW1lc30ga2V5cy4gYCArXG4gICAgICAgIGBQcm92aWRlZCAke3dlaWdodFR5cGV9IG5vdCB1bmRlcnN0b29kOiAke0pTT04uc3RyaW5naWZ5KHhXZWlnaHQpfWApO1xuICB9XG59XG5cbi8qKlxuICogU3RhbmRhcmRpemUgY2xhc3Mgd2VpZ2h0aW5nIG9iamVjdHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhIHNpbmdsZSBjbGFzcy13ZWlnaHRpbmcgb2JqZWN0LCBhbiBhcnJheSBvZiB0aGVtLFxuICogb3IgYSBtYXAgZnJvbSBvdXRwdXQgbmFtZSB0byBjbGFzcy13ZWlnaHRpbmcgb2JqZWN0LiBJdCBjb21wYXJlcyBpdCB0byB0aGVcbiAqIG91dHB1dCBuYW1lKHMpIG9mIHRoZSBtb2RlbCwgYmFzZSBvbiB3aGljaCBpdCBvdXRwdXRzIGFuIGFycmF5IG9mXG4gKiBjbGFzcy13ZWlnaHRpbmcgb2JqZWN0cyBvZiB3aGljaCB0aGUgbGVuZ3RoIG1hdGNoZXMgdGhlIG51bWJlciBvZiBvdXRwdXRzLlxuICpcbiAqIEBwYXJhbSBjbGFzc1dlaWdodCBJbnB1dCBjbGFzcy13ZWlnaHRpbmcgb2JqZWN0KHMpLlxuICogQHBhcmFtIG91dHB1dE5hbWVzIEFsbCBvdXRwdXQgbmFtZShzKSBvZiB0aGUgbW9kZWwuXG4gKiBAcmV0dXJuIEFuIGFycmF5IG9mIGNsYXNzLXdlaWdodGluZyBvYmplY3RzLiBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBtYXRjaGVzXG4gKiAgIHRoZSBtb2RlbCdzIG51bWJlciBvZiBvdXRwdXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhbmRhcmRpemVDbGFzc1dlaWdodHMoXG4gICAgY2xhc3NXZWlnaHQ6IENsYXNzV2VpZ2h0fENsYXNzV2VpZ2h0W118Q2xhc3NXZWlnaHRNYXAsXG4gICAgb3V0cHV0TmFtZXM6IHN0cmluZ1tdKTogQ2xhc3NXZWlnaHRbXSB7XG4gIHJldHVybiBzdGFuZGFyZGl6ZVNhbXBsZU9yQ2xhc3NXZWlnaHRzKFxuICAgICAgY2xhc3NXZWlnaHQsIG91dHB1dE5hbWVzLCAnY2xhc3NXZWlnaHQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YW5kYXJkaXplU2FtcGxlV2VpZ2h0cyhcbiAgICBjbGFzc1dlaWdodDogQ2xhc3NXZWlnaHR8Q2xhc3NXZWlnaHRbXXxDbGFzc1dlaWdodE1hcCxcbiAgICBvdXRwdXROYW1lczogc3RyaW5nW10pOiBDbGFzc1dlaWdodFtdIHtcbiAgcmV0dXJuIHN0YW5kYXJkaXplU2FtcGxlT3JDbGFzc1dlaWdodHMoXG4gICAgICBjbGFzc1dlaWdodCwgb3V0cHV0TmFtZXMsICdzYW1wbGVXZWlnaHQnKTtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZGl6ZSBieS1zYW1wbGUgYW5kL29yIGJ5LWNsYXNzIHdlaWdodHMgZm9yIHRyYWluaW5nLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG9wZXJhdGVzIG9uIG9uZSBtb2RlbCBvdXRwdXQgYXQgYSB0aW1lLiBGb3IgYSBtb2RlbFxuICogd2l0aCBtdWx0aXBsZSBvdXRwdXRzLCB5b3UgbXVzdCBjYWxsIHRoaXMgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMuXG4gKlxuICogQHBhcmFtIHkgVGhlIHRhcmdldCB0ZW5zb3IgdGhhdCB0aGUgYnktc2FtcGxlIGFuZC9vciBieS1jbGFzcyB3ZWlnaHQgaXMgZm9yLlxuICogICAgIFRoZSB2YWx1ZXMgb2YgeSBhcmUgYXNzdW1lZCB0byBlbmNvZGUgdGhlIGNsYXNzZXMsIGVpdGhlciBkaXJlY3RseVxuICogICAgIGFzIGFuIGludGVnZXIgaW5kZXgsIG9yIGFzIG9uZS1ob3QgZW5jb2RpbmcuXG4gKiBAcGFyYW0gc2FtcGxlV2VpZ2h0IEJ5LXNhbXBsZSB3ZWlnaHRzLlxuICogQHBhcmFtIGNsYXNzV2VpZ2h0IEJ5LWNsYXNzIHdlaWdodHM6IGFuIG9iamVjdCBtYXBwaW5nIGNsYXNzIGluZGljZXNcbiAqICAgICAoaW50ZWdlcnMpIHRvIGEgd2VpZ2h0IChmbG9hdCkgdG8gYXBwbHkgdG8gdGhlIG1vZGVsJ3MgbG9zcyBmb3IgdGhlXG4gKiAgICAgc2FtcGxlcyBmcm9tIHRoaXMgY2xhc3MgZHVyaW5nIHRyYWluaW5nLiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gdGVsbCB0aGVcbiAqICAgICBtb2RlbCB0byBcInBheSBtb3JlIGF0dGVudGlvblwiIHRvIHNhbXBsZXMgZnJvbSBhbiB1bmRlci1yZXByZXNlbnRlZCBjbGFzcy5cbiAqIEBwYXJhbSBzYW1wbGVXZWlnaHRNb2RlIFRoZSBtb2RlIGZvciB0aGUgc2FtcGxlIHdlaWdodHMuXG4gKiBAcmV0dXJuIEEgUHJvbWlzZSBvZiB3ZWlnaHQgdGVuc29yLCBvZiB3aGljaCB0aGUgc2l6ZSBvZiB0aGUgZmlyc3QgZGltZW5zaW9uXG4gKiAgICAgbWF0Y2hlcyB0aGF0IG9mIGB5YC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YW5kYXJkaXplV2VpZ2h0cyhcbiAgICB5OiBUZW5zb3IsIHNhbXBsZVdlaWdodD86IFRlbnNvciwgY2xhc3NXZWlnaHQ/OiBDbGFzc1dlaWdodCxcbiAgICBzYW1wbGVXZWlnaHRNb2RlPzogJ3RlbXBvcmFsJyk6IFByb21pc2U8VGVuc29yPiB7XG4gIGlmIChzYW1wbGVXZWlnaHQgIT0gbnVsbCB8fCBzYW1wbGVXZWlnaHRNb2RlICE9IG51bGwpIHtcbiAgICAvLyBUT0RPKGNhaXMpOiBPbmNlICd0ZW1wb3JhbCcgbW9kZSBpcyBpbXBsZW1lbnRlZCwgZG9jdW1lbnQgaXQgaW4gdGhlIGRvY1xuICAgIC8vIHN0cmluZy5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgc2FtcGxlV2VpZ2h0IGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgfVxuXG4gIGlmIChjbGFzc1dlaWdodCAhPSBudWxsKSB7XG4gICAgLy8gQXBwbHkgY2xhc3Mgd2VpZ2h0cyBwZXIgc2FtcGxlLlxuICAgIGNvbnN0IHlDbGFzc2VzOiBUZW5zb3IxRCA9IHRpZHkoKCkgPT4ge1xuICAgICAgaWYgKHkuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIEFzc3VtZSBjbGFzcyBpbmRpY2VzLlxuICAgICAgICByZXR1cm4gY2xvbmUoeSkgYXMgVGVuc29yMUQ7XG4gICAgICB9IGVsc2UgaWYgKHkuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGlmICh5LnNoYXBlWzFdID4gMSkge1xuICAgICAgICAgIC8vIEFzc3VtZSBvbmUtaG90IGVuY29kaW5nIG9mIGNsYXNzZXMuXG4gICAgICAgICAgY29uc3QgYXhpcyA9IDE7XG4gICAgICAgICAgcmV0dXJuIGFyZ01heCh5LCBheGlzKTtcbiAgICAgICAgfSBlbHNlIGlmICh5LnNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgICAgLy8gQ2xhc3MgaW5kZXguXG4gICAgICAgICAgcmV0dXJuIHJlc2hhcGUoeSwgW3kuc2hhcGVbMF1dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBFbmNvdW50ZXJlZCB1bmV4cGVjdGVkIGxhc3QtZGltZW5zaW9uIHNpemUgKCR7eS5zaGFwZVsxXX0pIGAgK1xuICAgICAgICAgICAgICBgZHVyaW5nIGhhbmRsaW5nIG9mIGNsYXNzIHdlaWdodHMuIFRoZSBzaXplIGlzIGV4cGVjdGVkIHRvIGJlIGAgK1xuICAgICAgICAgICAgICBgPj0gMS5gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFVuZXhwZWN0ZWQgcmFuayBvZiB0YXJnZXQgKHkpIHRlbnNvciAoJHt5LnJhbmt9KSBkdXJpbmcgYCArXG4gICAgICAgICAgICBgaGFuZGxpbmcgb2YgY2xhc3Mgd2VpZ2h0cy4gVGhlIHJhbmsgaXMgZXhwZWN0ZWQgdG8gYmUgMSBvciAyLmApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeUNsYXNzSW5kaWNlcyA9IEFycmF5LmZyb20oYXdhaXQgeUNsYXNzZXMuZGF0YSgpKTtcbiAgICBkaXNwb3NlKHlDbGFzc2VzKTtcbiAgICBjb25zdCBjbGFzc1NhbXBsZVdlaWdodDogbnVtYmVyW10gPSBbXTtcbiAgICB5Q2xhc3NJbmRpY2VzLmZvckVhY2goY2xhc3NJbmRleCA9PiB7XG4gICAgICBpZiAoY2xhc3NXZWlnaHRbY2xhc3NJbmRleF0gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgY2xhc3NXZWlnaHQgbXVzdCBjb250YWluIGFsbCBjbGFzc2VzIGluIHRoZSB0cmFpbmluZyBkYXRhLiBgICtcbiAgICAgICAgICAgIGBUaGUgY2xhc3MgJHtjbGFzc0luZGV4fSBleGlzdHMgaW4gdGhlIGRhdGEgYnV0IG5vdCBpbiBgICtcbiAgICAgICAgICAgIGBjbGFzc1dlaWdodGApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3NTYW1wbGVXZWlnaHQucHVzaChjbGFzc1dlaWdodFtjbGFzc0luZGV4XSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGVuc29yMWQoY2xhc3NTYW1wbGVXZWlnaHQsICdmbG9hdDMyJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBcHBseSBwZXItc2FtcGxlIHdlaWdodHMgb24gdGhlIGxvc3MgdmFsdWVzIGZyb20gYSBudW1iZXIgb2Ygc2FtcGxlcy5cbiAqXG4gKiBAcGFyYW0gbG9zc2VzIExvc3MgdGVuc29yIG9mIHNoYXBlIGBbYmF0Y2hTaXplXWAuXG4gKiBAcGFyYW0gc2FtcGxlV2VpZ2h0cyBQZXItc2FtcGxlIHdlaWdodCB0ZW5zb3Igb2Ygc2hhcGUgYFtiYXRjaFNpemVdYC5cbiAqIEByZXR1cm5zIFRlbnNvciBvZiB0aGUgc2FtZSBzaGFwZSBhc2Bsb3NzZXNgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVdlaWdodGVkTG9zcyhsb3NzZXM6IFRlbnNvciwgc2FtcGxlV2VpZ2h0czogVGVuc29yKSB7XG4gIHJldHVybiBtdWwobG9zc2VzLCBzYW1wbGVXZWlnaHRzKTtcbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Interfaces and methods for training models using tf.Tensor objects.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { Tensor } from '@tensorflow/tfjs-core';\nimport { expandDims, gather, sliceAlongFirstAxis } from '../backend/tfjs_backend';\nexport function checkBatchSize(batchSize) {\n    tfc.util.assert(batchSize > 0 && Number.isInteger(batchSize), () => `batchSize is required to be a positive integer, but got ${batchSize}`);\n}\n/**\n * Slice a Tensor or an Array of Tensors, by start and stop indices.\n *\n * Porting Note: The `_slice_arrays` function in PyKeras is covered by this\n *   function and `sliceArraysByIndices()` together.\n *\n * @param arrays: the input.\n * @param start: the starting index (inclusive).\n * @param stop: the stopping index (exclusive).\n * @returns The result of the slicing. If `arrays` is an `Array` of\n *   `tf.Tensor`s, the slicing will be applied to all elements of the `Array`\n *   in the same way.\n */\nexport function sliceArrays(arrays, start, stop) {\n    if (arrays == null) {\n        return [null];\n    }\n    else if (Array.isArray(arrays)) {\n        return arrays.map(array => sliceAlongFirstAxis(array, start, stop - start));\n    }\n    else { // Tensor.\n        return sliceAlongFirstAxis(arrays, start, stop - start);\n    }\n}\n/**\n * Slice a Tensor or an Array of Tensors, by random-order indices.\n *\n * Porting Note: The `_slice_arrays` function in PyKeras is covered by this\n *   function and `sliceArrays()` together.\n *\n * @param arrays The input `tf.Tensor` or `Array` of `tf.Tensor`s to slice.\n *   If an `Array` of `tf.Tensor`s, all `tf.Tensor`s will be sliced in the\n *   same fashion.\n * @param indices The indices to use for slicing along the first (batch)\n *   dimension.\n * @returns Result(s) of the slicing.\n */\nexport function sliceArraysByIndices(arrays, indices) {\n    return tfc.tidy(() => {\n        if (arrays == null) {\n            return null;\n        }\n        else if (Array.isArray(arrays)) {\n            return arrays.map(array => sliceArraysByIndices(array, indices));\n        }\n        else {\n            // TODO(cais): indices should be a pre-constructed Tensor1D to avoid\n            //   tensor1d() calls.\n            return gather(arrays, indices.dtype === 'int32' ? indices : tfc.cast(indices, 'int32'));\n        }\n    });\n}\n/**\n * Returns a list of batch indices (tuples of indices).\n * @param size: Integer, total size of the data to slice into batches.\n * @param batchSize: Integer, batch size.\n * @returns An Array of [batchStart, batchEnd] tuples. batchStart is\n *   inclusive; batchEnd is exclusive. I.e., each batch consists of indices x\n *   that satisfy batchStart <= x < batchEnd.\n */\nexport function makeBatches(size, batchSize) {\n    const output = [];\n    let batchStart = 0;\n    let batchEnd = null;\n    while (batchStart < size) {\n        batchEnd = batchStart + batchSize;\n        if (batchEnd >= size) {\n            batchEnd = size;\n        }\n        output.push([batchStart, batchEnd]);\n        batchStart = batchEnd;\n    }\n    return output;\n}\n/**\n * Ensure tensors all have a rank of at least 2.\n *\n * If a tensor has a rank of 1, it is dimension-expanded to rank 2.\n * If any tensor has a rank of 0 (i.e., is a scalar), an error will be thrown.\n */\nexport function ensureTensorsRank2OrHigher(tensors) {\n    const outs = [];\n    if (tensors instanceof Tensor) {\n        tensors = [tensors];\n    }\n    // Make Tensors at least 2D.\n    for (let i = 0; i < tensors.length; ++i) {\n        const tensor = tensors[i];\n        if (tensor.rank === 1) {\n            outs.push(expandDims(tensor, 1));\n        }\n        else if (tensor.rank === 0) {\n            throw new Error('Expected tensor to be at least 1D, but received a 0D tensor ' +\n                '(scalar).');\n        }\n        else {\n            outs.push(tensor);\n        }\n    }\n    return outs;\n}\n/**\n * Compare a set of tensors with a reference (old) set, discard the ones\n * in the new set that are not present in the reference set.\n *\n * This method is used for memory clenaup during calls such as\n * LayersModel.fit().\n *\n * @param tensors New set which may contain Tensors not present in\n *   `refTensors`.\n * @param refTensors Reference Tensor set.\n */\n// TODO(cais, kangyizhang): Deduplicate with tfjs-data.\nexport function disposeNewTensors(tensors, refTensors) {\n    if (tensors == null) {\n        return;\n    }\n    const oldTensorIds = [];\n    if (refTensors instanceof Tensor) {\n        oldTensorIds.push(refTensors.id);\n    }\n    else if (Array.isArray(refTensors)) {\n        refTensors.forEach(t => oldTensorIds.push(t.id));\n    }\n    else if (refTensors != null) {\n        // `oldTensors` is a map from string name to Tensor.\n        for (const name in refTensors) {\n            const oldTensor = refTensors[name];\n            oldTensorIds.push(oldTensor.id);\n        }\n    }\n    const tensorsToDispose = [];\n    if (tensors instanceof Tensor) {\n        if (oldTensorIds.indexOf(tensors.id) === -1) {\n            tensorsToDispose.push(tensors);\n        }\n    }\n    else if (Array.isArray(tensors)) {\n        tensors.forEach(t => {\n            if (oldTensorIds.indexOf(t.id) === -1) {\n                tensorsToDispose.push(t);\n            }\n        });\n    }\n    else if (tensors != null) {\n        // `oldTensors` is a map from string name to Tensor.\n        for (const name in tensors) {\n            const tensor = tensors[name];\n            if (oldTensorIds.indexOf(tensor.id) === -1) {\n                tensorsToDispose.push(tensor);\n            }\n        }\n    }\n    tensorsToDispose.forEach(t => {\n        if (!t.isDisposed) {\n            t.dispose();\n        }\n    });\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhaW5pbmdfdGVuc29ycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9lbmdpbmUvdHJhaW5pbmdfdGVuc29ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOztHQUVHO0FBRUgsT0FBTyxLQUFLLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsTUFBTSxFQUFXLE1BQU0sdUJBQXVCLENBQUM7QUFDdkQsT0FBTyxFQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsbUJBQW1CLEVBQUMsTUFBTSx5QkFBeUIsQ0FBQztBQTZJaEYsTUFBTSxVQUFVLGNBQWMsQ0FBQyxTQUFpQjtJQUM5QyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FDWCxTQUFTLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQzVDLEdBQUcsRUFBRSxDQUFDLDJEQUNGLFNBQVMsRUFBRSxDQUFDLENBQUM7QUFDdkIsQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQ3ZCLE1BQXVCLEVBQUUsS0FBYSxFQUFFLElBQVk7SUFDdEQsSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO1FBQ2xCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNmO1NBQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQ2hDLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLG1CQUFtQixDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7S0FDN0U7U0FBTSxFQUFHLFVBQVU7UUFDbEIsT0FBTyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQztLQUN6RDtB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QyxDQUFDLEVBQUU7Z0JBQzFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUMvQjtTQUNGO0tBQ0Y7SUFFRCxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDM0IsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUU7WUFDakIsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQ2I7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIEludGVyZmFjZXMgYW5kIG1ldGhvZHMgZm9yIHRyYWluaW5nIG1vZGVscyB1c2luZyB0Zi5UZW5zb3Igb2JqZWN0cy5cbiAqL1xuXG5pbXBvcnQgKiBhcyB0ZmMgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7VGVuc29yLCBUZW5zb3IxRH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7ZXhwYW5kRGltcywgZ2F0aGVyLCBzbGljZUFsb25nRmlyc3RBeGlzfSBmcm9tICcuLi9iYWNrZW5kL3RmanNfYmFja2VuZCc7XG5pbXBvcnQge0Jhc2VDYWxsYmFjaywgQ3VzdG9tQ2FsbGJhY2tBcmdzLCBNb2RlbExvZ2dpbmdWZXJib3NpdHksIFlpZWxkRXZlcnlPcHRpb25zfSBmcm9tICcuLi9iYXNlX2NhbGxiYWNrcyc7XG5pbXBvcnQge0NsYXNzV2VpZ2h0LCBDbGFzc1dlaWdodE1hcH0gZnJvbSAnLi90cmFpbmluZ191dGlscyc7XG5cbi8qKlxuICogSW50ZXJmYWNlIGNvbmZpZ3VyYXRpb24gbW9kZWwgdHJhaW5pbmcgYmFzZWQgb24gZGF0YSBhcyBgdGYuVGVuc29yYHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZWxGaXRBcmdzIHtcbiAgLyoqXG4gICAqIE51bWJlciBvZiBzYW1wbGVzIHBlciBncmFkaWVudCB1cGRhdGUuIElmIHVuc3BlY2lmaWVkLCBpdFxuICAgKiB3aWxsIGRlZmF1bHQgdG8gMzIuXG4gICAqL1xuICBiYXRjaFNpemU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEludGVnZXIgbnVtYmVyIG9mIHRpbWVzIHRvIGl0ZXJhdGUgb3ZlciB0aGUgdHJhaW5pbmcgZGF0YSBhcnJheXMuXG4gICAqL1xuICBlcG9jaHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFZlcmJvc2l0eSBsZXZlbC5cbiAgICpcbiAgICogRXhwZWN0ZWQgdG8gYmUgMCwgMSwgb3IgMi4gRGVmYXVsdDogMS5cbiAgICpcbiAgICogMCAtIE5vIHByaW50ZWQgbWVzc2FnZSBkdXJpbmcgZml0KCkgY2FsbC5cbiAgICogMSAtIEluIE5vZGUuanMgKHRmanMtbm9kZSksIHByaW50cyB0aGUgcHJvZ3Jlc3MgYmFyLCB0b2dldGhlciB3aXRoXG4gICAqICAgICByZWFsLXRpbWUgdXBkYXRlcyBvZiBsb3NzIGFuZCBtZXRyaWMgdmFsdWVzIGFuZCB0cmFpbmluZyBzcGVlZC5cbiAgICogICAgIEluIHRoZSBicm93c2VyOiBubyBhY3Rpb24uIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gICAqIDIgLSBOb3QgaW1wbGVtZW50ZWQgeWV0LlxuICAgKi9cbiAgdmVyYm9zZT86IE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eSB8IDI7XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgY2FsbGJhY2tzIHRvIGJlIGNhbGxlZCBkdXJpbmcgdHJhaW5pbmcuXG4gICAqIENhbiBoYXZlIG9uZSBvciBtb3JlIG9mIHRoZSBmb2xsb3dpbmcgY2FsbGJhY2tzOlxuICAgKiAgIC0gYG9uVHJhaW5CZWdpbihsb2dzKWA6IGNhbGxlZCB3aGVuIHRyYWluaW5nIHN0YXJ0cy5cbiAgICogICAtIGBvblRyYWluRW5kKGxvZ3MpYDogY2FsbGVkIHdoZW4gdHJhaW5pbmcgZW5kcy5cbiAgICogICAtIGBvbkVwb2NoQmVnaW4oZXBvY2gsIGxvZ3MpYDogY2FsbGVkIGF0IHRoZSBzdGFydCBvZiBldmVyeSBlcG9jaC5cbiAgICogICAtIGBvbkVwb2NoRW5kKGVwb2NoLCBsb2dzKWA6IGNhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IGVwb2NoLlxuICAgKiAgIC0gYG9uQmF0Y2hCZWdpbihiYXRjaCwgbG9ncylgOiBjYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIGV2ZXJ5IGJhdGNoLlxuICAgKiAgIC0gYG9uQmF0Y2hFbmQoYmF0Y2gsIGxvZ3MpYDogY2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgYmF0Y2guXG4gICAqICAgLSBgb25ZaWVsZChlcG9jaCwgYmF0Y2gsIGxvZ3MpYDogY2FsbGVkIGV2ZXJ5IGB5aWVsZEV2ZXJ5YCBtaWxsaXNlY29uZHNcbiAgICogICAgICB3aXRoIHRoZSBjdXJyZW50IGVwb2NoLCBiYXRjaCBhbmQgbG9ncy4gVGhlIGxvZ3MgYXJlIHRoZSBzYW1lXG4gICAqICAgICAgYXMgaW4gYG9uQmF0Y2hFbmQoKWAuIE5vdGUgdGhhdCBgb25ZaWVsZGAgY2FuIHNraXAgYmF0Y2hlcyBvclxuICAgKiAgICAgIGVwb2Nocy4gU2VlIGFsc28gZG9jcyBmb3IgYHlpZWxkRXZlcnlgIGJlbG93LlxuICAgKi9cbiAgY2FsbGJhY2tzPzogQmFzZUNhbGxiYWNrW118Q3VzdG9tQ2FsbGJhY2tBcmdzfEN1c3RvbUNhbGxiYWNrQXJnc1tdO1xuXG4gIC8qKlxuICAgKiBGbG9hdCBiZXR3ZWVuIDAgYW5kIDE6IGZyYWN0aW9uIG9mIHRoZSB0cmFpbmluZyBkYXRhXG4gICAqIHRvIGJlIHVzZWQgYXMgdmFsaWRhdGlvbiBkYXRhLiBUaGUgbW9kZWwgd2lsbCBzZXQgYXBhcnQgdGhpcyBmcmFjdGlvbiBvZlxuICAgKiB0aGUgdHJhaW5pbmcgZGF0YSwgd2lsbCBub3QgdHJhaW4gb24gaXQsIGFuZCB3aWxsIGV2YWx1YXRlIHRoZSBsb3NzIGFuZFxuICAgKiBhbnkgbW9kZWwgbWV0cmljcyBvbiB0aGlzIGRhdGEgYXQgdGhlIGVuZCBvZiBlYWNoIGVwb2NoLlxuICAgKiBUaGUgdmFsaWRhdGlvbiBkYXRhIGlzIHNlbGVjdGVkIGZyb20gdGhlIGxhc3Qgc2FtcGxlcyBpbiB0aGUgYHhgIGFuZCBgeWBcbiAgICogZGF0YSBwcm92aWRlZCwgYmVmb3JlIHNodWZmbGluZy5cbiAgICovXG4gIHZhbGlkYXRpb25TcGxpdD86IG51bWJlcjtcblxuICAvKipcbiAgICogRGF0YSBvbiB3aGljaCB0byBldmFsdWF0ZSB0aGUgbG9zcyBhbmQgYW55IG1vZGVsXG4gICAqIG1ldHJpY3MgYXQgdGhlIGVuZCBvZiBlYWNoIGVwb2NoLiBUaGUgbW9kZWwgd2lsbCBub3QgYmUgdHJhaW5lZCBvbiB0aGlzXG4gICAqIGRhdGEuIFRoaXMgY291bGQgYmUgYSB0dXBsZSBbeFZhbCwgeVZhbF0gb3IgYSB0dXBsZSBbeFZhbCwgeVZhbCxcbiAgICogdmFsU2FtcGxlV2VpZ2h0c10uIFRoZSBtb2RlbCB3aWxsIG5vdCBiZSB0cmFpbmVkIG9uIHRoaXMgZGF0YS5cbiAgICogYHZhbGlkYXRpb25EYXRhYCB3aWxsIG92ZXJyaWRlIGB2YWxpZGF0aW9uU3BsaXRgLlxuICAgKi9cbiAgdmFsaWRhdGlvbkRhdGE/OiBbXG4gICAgVGVuc29yfFRlbnNvcltdLCBUZW5zb3J8VGVuc29yW11cbiAgXXxbVGVuc29yIHwgVGVuc29yW10sIFRlbnNvcnxUZW5zb3JbXSwgVGVuc29yfFRlbnNvcltdXTtcblxuICAvKipcbiAgICogV2hldGhlciB0byBzaHVmZmxlIHRoZSB0cmFpbmluZyBkYXRhIGJlZm9yZSBlYWNoIGVwb2NoLiBIYXNcbiAgICogbm8gZWZmZWN0IHdoZW4gYHN0ZXBzUGVyRXBvY2hgIGlzIG5vdCBgbnVsbGAuXG4gICAqL1xuICBzaHVmZmxlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogT3B0aW9uYWwgb2JqZWN0IG1hcHBpbmcgY2xhc3MgaW5kaWNlcyAoaW50ZWdlcnMpIHRvXG4gICAqIGEgd2VpZ2h0IChmbG9hdCkgdG8gYXBwbHkgdG8gdGhlIG1vZGVsJ3MgbG9zcyBmb3IgdGhlIHNhbXBsZXMgZnJvbSB0aGlzXG4gICAqIGNsYXNzIGR1cmluZyB0cmFpbmluZy4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIHRlbGwgdGhlIG1vZGVsIHRvIFwicGF5IG1vcmVcbiAgICogYXR0ZW50aW9uXCIgdG8gc2FtcGxlcyBmcm9tIGFuIHVuZGVyLXJlcHJlc2VudGVkIGNsYXNzLlxuICAgKlxuICAgKiBJZiB0aGUgbW9kZWwgaGFzIG11bHRpcGxlIG91dHB1dHMsIGEgY2xhc3Mgd2VpZ2h0IGNhbiBiZSBzcGVjaWZpZWQgZm9yXG4gICAqIGVhY2ggb2YgdGhlIG91dHB1dHMgYnkgc2V0dGluZyB0aGlzIGZpZWxkIGFuIGFycmF5IG9mIHdlaWdodCBvYmplY3RcbiAgICogb3IgYW4gb2JqZWN0IHRoYXQgbWFwcyBtb2RlbCBvdXRwdXQgbmFtZXMgKGUuZy4sIGBtb2RlbC5vdXRwdXROYW1lc1swXWApXG4gICAqIHRvIHdlaWdodCBvYmplY3RzLlxuICAgKi9cbiAgY2xhc3NXZWlnaHQ/OiBDbGFzc1dlaWdodHxDbGFzc1dlaWdodFtdfENsYXNzV2VpZ2h0TWFwO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBhcnJheSBvZiB0aGUgc2FtZSBsZW5ndGggYXMgeCwgY29udGFpbmluZ1xuICAgKiB3ZWlnaHRzIHRvIGFwcGx5IHRvIHRoZSBtb2RlbCdzIGxvc3MgZm9yIGVhY2ggc2FtcGxlLiBJbiB0aGUgY2FzZSBvZlxuICAgKiB0ZW1wb3JhbCBkYXRhLCB5b3UgY2FuIHBhc3MgYSAyRCBhcnJheSB3aXRoIHNoYXBlIChzYW1wbGVzLFxuICAgKiBzZXF1ZW5jZUxlbmd0aCksIHRvIGFwcGx5IGEgZGlmZmVyZW50IHdlaWdodCB0byBldmVyeSB0aW1lc3RlcCBvZiBldmVyeVxuICAgKiBzYW1wbGUuIEluIHRoaXMgY2FzZSB5b3Ugc2hvdWxkIG1ha2Ugc3VyZSB0byBzcGVjaWZ5XG4gICAqIHNhbXBsZVdlaWdodE1vZGU9XCJ0ZW1wb3JhbFwiIGluIGNvbXBpbGUoKS5cbiAgICovXG4gIHNhbXBsZVdlaWdodD86IFRlbnNvcjtcblxuICAvKipcbiAgICogRXBvY2ggYXQgd2hpY2ggdG8gc3RhcnQgdHJhaW5pbmcgKHVzZWZ1bCBmb3IgcmVzdW1pbmcgYSBwcmV2aW91cyB0cmFpbmluZ1xuICAgKiBydW4pLiBXaGVuIHRoaXMgaXMgdXNlZCwgYGVwb2Noc2AgaXMgdGhlIGluZGV4IG9mIHRoZSBcImZpbmFsIGVwb2NoXCIuXG4gICAqIFRoZSBtb2RlbCBpcyBub3QgdHJhaW5lZCBmb3IgYSBudW1iZXIgb2YgaXRlcmF0aW9ucyBnaXZlbiBieSBgZXBvY2hzYCxcbiAgICogYnV0IG1lcmVseSB1bnRpbCB0aGUgZXBvY2ggb2YgaW5kZXggYGVwb2Noc2AgaXMgcmVhY2hlZC5cbiAgICovXG4gIGluaXRpYWxFcG9jaD86IG51bWJlcjtcblxuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIHN0ZXBzIChiYXRjaGVzIG9mIHNhbXBsZXMpIGJlZm9yZVxuICAgKiBkZWNsYXJpbmcgb25lIGVwb2NoIGZpbmlzaGVkIGFuZCBzdGFydGluZyB0aGUgbmV4dCBlcG9jaC4gV2hlbiB0cmFpbmluZ1xuICAgKiB3aXRoIElucHV0IFRlbnNvcnMgc3VjaCBhcyBUZW5zb3JGbG93IGRhdGEgdGVuc29ycywgdGhlIGRlZmF1bHQgYG51bGxgIGlzXG4gICAqIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIHNhbXBsZXMgaW4geW91ciBkYXRhc2V0IGRpdmlkZWQgYnkgdGhlXG4gICAqIGJhdGNoIHNpemUsIG9yIDEgaWYgdGhhdCBjYW5ub3QgYmUgZGV0ZXJtaW5lZC5cbiAgICovXG4gIHN0ZXBzUGVyRXBvY2g/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgaWYgYHN0ZXBzUGVyRXBvY2hgIGlzIHNwZWNpZmllZC4gVG90YWwgbnVtYmVyIG9mIHN0ZXBzXG4gICAqIChiYXRjaGVzIG9mIHNhbXBsZXMpIHRvIHZhbGlkYXRlIGJlZm9yZSBzdG9wcGluZy5cbiAgICovXG4gIHZhbGlkYXRpb25TdGVwcz86IG51bWJlcjtcblxuICAvKipcbiAgICogQ29uZmlndXJlcyB0aGUgZnJlcXVlbmN5IG9mIHlpZWxkaW5nIHRoZSBtYWluIHRocmVhZCB0byBvdGhlciB0YXNrcy5cbiAgICpcbiAgICogSW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQsIHlpZWxkaW5nIHRoZSBtYWluIHRocmVhZCBjYW4gaW1wcm92ZSB0aGVcbiAgICogcmVzcG9uc2l2ZW5lc3Mgb2YgdGhlIHBhZ2UgZHVyaW5nIHRyYWluaW5nLiBJbiB0aGUgTm9kZS5qcyBlbnZpcm9ubWVudCxcbiAgICogaXQgY2FuIGVuc3VyZSB0YXNrcyBxdWV1ZWQgaW4gdGhlIGV2ZW50IGxvb3AgY2FuIGJlIGhhbmRsZWQgaW4gYSB0aW1lbHlcbiAgICogbWFubmVyLlxuICAgKlxuICAgKiBUaGUgdmFsdWUgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKiAgIC0gYCdhdXRvJ2A6IFRoZSB5aWVsZGluZyBoYXBwZW5zIGF0IGEgY2VydGFpbiBmcmFtZSByYXRlIChjdXJyZW50bHkgc2V0XG4gICAqICAgICAgICAgICAgICAgYXQgMTI1bXMpLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlxuICAgKiAgIC0gYCdiYXRjaCdgOiB5aWVsZCBldmVyeSBiYXRjaC5cbiAgICogICAtIGAnZXBvY2gnYDogeWllbGQgZXZlcnkgZXBvY2guXG4gICAqICAgLSBhbnkgYG51bWJlcmA6IHlpZWxkIGV2ZXJ5IGBudW1iZXJgIG1pbGxpc2Vjb25kcy5cbiAgICogICAtIGAnbmV2ZXInYDogbmV2ZXIgeWllbGQuICh5aWVsZGluZyBjYW4gc3RpbGwgaGFwcGVuIHRocm91Z2ggYGF3YWl0XG4gICAqICAgICAgbmV4dEZyYW1lKClgIGNhbGxzIGluIGN1c3RvbSBjYWxsYmFja3MuKVxuICAgKi9cbiAgeWllbGRFdmVyeT86IFlpZWxkRXZlcnlPcHRpb25zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tCYXRjaFNpemUoYmF0Y2hTaXplOiBudW1iZXIpIHtcbiAgdGZjLnV0aWwuYXNzZXJ0KFxuICAgICAgYmF0Y2hTaXplID4gMCAmJiBOdW1iZXIuaXNJbnRlZ2VyKGJhdGNoU2l6ZSksXG4gICAgICAoKSA9PiBgYmF0Y2hTaXplIGlzIHJlcXVpcmVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCAke1xuICAgICAgICAgIGJhdGNoU2l6ZX1gKTtcbn1cblxuLyoqXG4gKiBTbGljZSBhIFRlbnNvciBvciBhbiBBcnJheSBvZiBUZW5zb3JzLCBieSBzdGFydCBhbmQgc3RvcCBpbmRpY2VzLlxuICpcbiAqIFBvcnRpbmcgTm90ZTogVGhlIGBfc2xpY2VfYXJyYXlzYCBmdW5jdGlvbiBpbiBQeUtlcmFzIGlzIGNvdmVyZWQgYnkgdGhpc1xuICogICBmdW5jdGlvbiBhbmQgYHNsaWNlQXJyYXlzQnlJbmRpY2VzKClgIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSBhcnJheXM6IHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBzdGFydDogdGhlIHN0YXJ0aW5nIGluZGV4IChpbmNsdXNpdmUpLlxuICogQHBhcmFtIHN0b3A6IHRoZSBzdG9wcGluZyBpbmRleCAoZXhjbHVzaXZlKS5cbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIHNsaWNpbmcuIElmIGBhcnJheXNgIGlzIGFuIGBBcnJheWAgb2ZcbiAqICAgYHRmLlRlbnNvcmBzLCB0aGUgc2xpY2luZyB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIGVsZW1lbnRzIG9mIHRoZSBgQXJyYXlgXG4gKiAgIGluIHRoZSBzYW1lIHdheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlQXJyYXlzKFxuICAgIGFycmF5czogVGVuc29yfFRlbnNvcltdLCBzdGFydDogbnVtYmVyLCBzdG9wOiBudW1iZXIpOiBUZW5zb3J8VGVuc29yW10ge1xuICBpZiAoYXJyYXlzID09IG51bGwpIHtcbiAgICByZXR1cm4gW251bGxdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlzKSkge1xuICAgIHJldHVybiBhcnJheXMubWFwKGFycmF5ID0+IHNsaWNlQWxvbmdGaXJzdEF4aXMoYXJyYXksIHN0YXJ0LCBzdG9wIC0gc3RhcnQpKTtcbiAgfSBlbHNlIHsgIC8vIFRlbnNvci5cbiAgICByZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhhcnJheXMsIHN0YXJ0LCBzdG9wIC0gc3RhcnQpO1xuICB9XG59XG5cbi8qKlxuICogU2xpY2UgYSBUZW5zb3Igb3IgYW4gQXJyYXkgb2YgVGVuc29ycywgYnkgcmFuZG9tLW9yZGVyIGluZGljZXMuXG4gKlxuICogUG9ydGluZyBOb3RlOiBUaGUgYF9zbGljZV9hcnJheXNgIGZ1bmN0aW9uIGluIFB5S2VyYXMgaXMgY292ZXJlZCBieSB0aGlzXG4gKiAgIGZ1bmN0aW9uIGFuZCBgc2xpY2VBcnJheXMoKWAgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIGFycmF5cyBUaGUgaW5wdXQgYHRmLlRlbnNvcmAgb3IgYEFycmF5YCBvZiBgdGYuVGVuc29yYHMgdG8gc2xpY2UuXG4gKiAgIElmIGFuIGBBcnJheWAgb2YgYHRmLlRlbnNvcmBzLCBhbGwgYHRmLlRlbnNvcmBzIHdpbGwgYmUgc2xpY2VkIGluIHRoZVxuICogICBzYW1lIGZhc2hpb24uXG4gKiBAcGFyYW0gaW5kaWNlcyBUaGUgaW5kaWNlcyB0byB1c2UgZm9yIHNsaWNpbmcgYWxvbmcgdGhlIGZpcnN0IChiYXRjaClcbiAqICAgZGltZW5zaW9uLlxuICogQHJldHVybnMgUmVzdWx0KHMpIG9mIHRoZSBzbGljaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2VBcnJheXNCeUluZGljZXMoXG4gICAgYXJyYXlzOiBUZW5zb3J8VGVuc29yW10sIGluZGljZXM6IFRlbnNvcjFEKTogVGVuc29yfFRlbnNvcltdIHtcbiAgcmV0dXJuIHRmYy50aWR5KCgpID0+IHtcbiAgICBpZiAoYXJyYXlzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheXMpKSB7XG4gICAgICByZXR1cm4gYXJyYXlzLm1hcChcbiAgICAgICAgICBhcnJheSA9PiAoc2xpY2VBcnJheXNCeUluZGljZXMoYXJyYXksIGluZGljZXMpIGFzIFRlbnNvcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPKGNhaXMpOiBpbmRpY2VzIHNob3VsZCBiZSBhIHByZS1jb25zdHJ1Y3RlZCBUZW5zb3IxRCB0byBhdm9pZFxuICAgICAgLy8gICB0ZW5zb3IxZCgpIGNhbGxzLlxuICAgICAgcmV0dXJuIGdhdGhlcihcbiAgICAgICAgICBhcnJheXMsXG4gICAgICAgICAgaW5kaWNlcy5kdHlwZSA9PT0gJ2ludDMyJyA/IGluZGljZXMgOiB0ZmMuY2FzdChpbmRpY2VzLCAnaW50MzInKSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBiYXRjaCBpbmRpY2VzICh0dXBsZXMgb2YgaW5kaWNlcykuXG4gKiBAcGFyYW0gc2l6ZTogSW50ZWdlciwgdG90YWwgc2l6ZSBvZiB0aGUgZGF0YSB0byBzbGljZSBpbnRvIGJhdGNoZXMuXG4gKiBAcGFyYW0gYmF0Y2hTaXplOiBJbnRlZ2VyLCBiYXRjaCBzaXplLlxuICogQHJldHVybnMgQW4gQXJyYXkgb2YgW2JhdGNoU3RhcnQsIGJhdGNoRW5kXSB0dXBsZXMuIGJhdGNoU3RhcnQgaXNcbiAqICAgaW5jbHVzaXZlOyBiYXRjaEVuZCBpcyBleGNsdXNpdmUuIEkuZS4sIGVhY2ggYmF0Y2ggY29uc2lzdHMgb2YgaW5kaWNlcyB4XG4gKiAgIHRoYXQgc2F0aXNmeSBiYXRjaFN0YXJ0IDw9IHggPCBiYXRjaEVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VCYXRjaGVzKFxuICAgIHNpemU6IG51bWJlciwgYmF0Y2hTaXplOiBudW1iZXIpOiBBcnJheTxbbnVtYmVyLCBudW1iZXJdPiB7XG4gIGNvbnN0IG91dHB1dDogQXJyYXk8W251bWJlciwgbnVtYmVyXT4gPSBbXTtcbiAgbGV0IGJhdGNoU3RhcnQgPSAwO1xuICBsZXQgYmF0Y2hFbmQ6IG51bWJlciA9IG51bGw7XG4gIHdoaWxlIChiYXRjaFN0YXJ0IDwgc2l6ZSkge1xuICAgIGJhdGNoRW5kID0gYmF0Y2hTdGFydCArIGJhdGNoU2l6ZTtcbiAgICBpZiAoYmF0Y2hFbmQgPj0gc2l6ZSkge1xuICAgICAgYmF0Y2hFbmQgPSBzaXplO1xuICAgIH1cbiAgICBvdXRwdXQucHVzaChbYmF0Y2hTdGFydCwgYmF0Y2hFbmRdKTtcbiAgICBiYXRjaFN0YXJ0ID0gYmF0Y2hFbmQ7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGVuc29ycyBhbGwgaGF2ZSBhIHJhbmsgb2YgYXQgbGVhc3QgMi5cbiAqXG4gKiBJZiBhIHRlbnNvciBoYXMgYSByYW5rIG9mIDEsIGl0IGlzIGRpbWVuc2lvbi1leHBhbmRlZCB0byByYW5rIDIuXG4gKiBJZiBhbnkgdGVuc29yIGhhcyBhIHJhbmsgb2YgMCAoaS5lLiwgaXMgYSBzY2FsYXIpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVRlbnNvcnNSYW5rMk9ySGlnaGVyKHRlbnNvcnM6IFRlbnNvcnxUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgY29uc3Qgb3V0czogVGVuc29yW10gPSBbXTtcbiAgaWYgKHRlbnNvcnMgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICB0ZW5zb3JzID0gW3RlbnNvcnNdO1xuICB9XG5cbiAgLy8gTWFrZSBUZW5zb3JzIGF0IGxlYXN0IDJELlxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbnNvcnMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCB0ZW5zb3IgPSB0ZW5zb3JzW2ldO1xuICAgIGlmICh0ZW5zb3IucmFuayA9PT0gMSkge1xuICAgICAgb3V0cy5wdXNoKGV4cGFuZERpbXModGVuc29yLCAxKSk7XG4gICAgfSBlbHNlIGlmICh0ZW5zb3IucmFuayA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdFeHBlY3RlZCB0ZW5zb3IgdG8gYmUgYXQgbGVhc3QgMUQsIGJ1dCByZWNlaXZlZCBhIDBEIHRlbnNvciAnICtcbiAgICAgICAgICAnKHNjYWxhcikuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHMucHVzaCh0ZW5zb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cztcbn1cblxuLyoqXG4gKiBDb21wYXJlIGEgc2V0IG9mIHRlbnNvcnMgd2l0aCBhIHJlZmVyZW5jZSAob2xkKSBzZXQsIGRpc2NhcmQgdGhlIG9uZXNcbiAqIGluIHRoZSBuZXcgc2V0IHRoYXQgYXJlIG5vdCBwcmVzZW50IGluIHRoZSByZWZlcmVuY2Ugc2V0LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIG1lbW9yeSBjbGVuYXVwIGR1cmluZyBjYWxscyBzdWNoIGFzXG4gKiBMYXllcnNNb2RlbC5maXQoKS5cbiAqXG4gKiBAcGFyYW0gdGVuc29ycyBOZXcgc2V0IHdoaWNoIG1heSBjb250YWluIFRlbnNvcnMgbm90IHByZXNlbnQgaW5cbiAqICAgYHJlZlRlbnNvcnNgLlxuICogQHBhcmFtIHJlZlRlbnNvcnMgUmVmZXJlbmNlIFRlbnNvciBzZXQuXG4gKi9cbi8vIFRPRE8oY2Fpcywga2FuZ3lpemhhbmcpOiBEZWR1cGxpY2F0ZSB3aXRoIHRmanMtZGF0YS5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlTmV3VGVuc29ycyhcbiAgICB0ZW5zb3JzOiBUZW5zb3J8VGVuc29yW118e1tpbnB1dE5hbWU6IHN0cmluZ106IFRlbnNvcn0sXG4gICAgcmVmVGVuc29yczogVGVuc29yfFRlbnNvcltdfHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9KTogdm9pZCB7XG4gIGlmICh0ZW5zb3JzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb2xkVGVuc29ySWRzOiBudW1iZXJbXSA9IFtdO1xuICBpZiAocmVmVGVuc29ycyBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgIG9sZFRlbnNvcklkcy5wdXNoKHJlZlRlbnNvcnMuaWQpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVmVGVuc29ycykpIHtcbiAgICByZWZUZW5zb3JzLmZvckVhY2godCA9PiBvbGRUZW5zb3JJZHMucHVzaCh0LmlkKSk7XG4gIH0gZWxzZSBpZiAocmVmVGVuc29ycyAhPSBudWxsKSB7XG4gICAgLy8gYG9sZFRlbnNvcnNgIGlzIGEgbWFwIGZyb20gc3RyaW5nIG5hbWUgdG8gVGVuc29yLlxuICAgIGZvciAoY29uc3QgbmFtZSBpbiByZWZUZW5zb3JzKSB7XG4gICAgICBjb25zdCBvbGRUZW5zb3IgPSByZWZUZW5zb3JzW25hbWVdO1xuICAgICAgb2xkVGVuc29ySWRzLnB1c2gob2xkVGVuc29yLmlkKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB0ZW5zb3JzVG9EaXNwb3NlOiBUZW5zb3JbXSA9IFtdO1xuICBpZiAodGVuc29ycyBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgIGlmIChvbGRUZW5zb3JJZHMuaW5kZXhPZih0ZW5zb3JzLmlkKSA9PT0gLTEpIHtcbiAgICAgIHRlbnNvcnNUb0Rpc3Bvc2UucHVzaCh0ZW5zb3JzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0ZW5zb3JzKSkge1xuICAgIHRlbnNvcnMuZm9yRWFjaCh0ID0+IHtcbiAgICAgIGlmIChvbGRUZW5zb3JJZHMuaW5kZXhPZih0LmlkKSA9PT0gLTEpIHtcbiAgICAgICAgdGVuc29yc1RvRGlzcG9zZS5wdXNoKHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRlbnNvcnMgIT0gbnVsbCkge1xuICAgIC8vIGBvbGRUZW5zb3JzYCBpcyBhIG1hcCBmcm9tIHN0cmluZyBuYW1lIHRvIFRlbnNvci5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGVuc29ycykge1xuICAgICAgY29uc3QgdGVuc29yID0gdGVuc29yc1tuYW1lXTtcbiAgICAgIGlmIChvbGRUZW5zb3JJZHMuaW5kZXhPZih0ZW5zb3IuaWQpID09PSAtMSkge1xuICAgICAgICB0ZW5zb3JzVG9EaXNwb3NlLnB1c2godGVuc29yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0ZW5zb3JzVG9EaXNwb3NlLmZvckVhY2godCA9PiB7XG4gICAgaWYgKCF0LmlzRGlzcG9zZWQpIHtcbiAgICAgIHQuZGlzcG9zZSgpO1xuICAgIH1cbiAgfSk7XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Interfaces and methods for training models using TensorFlow.js datasets.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { scalar } from '@tensorflow/tfjs-core';\nimport { configureCallbacks, standardizeCallbacks } from '../base_callbacks';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { disposeTensorsInLogs } from '../logs';\nimport { singletonOrArray, toList } from '../utils/generic_utils';\nimport { standardizeClassWeights, standardizeWeights } from './training_utils';\n// Default batch size used during tensor-based validation.\nconst DEFAULT_VALIDATION_BATCH_SIZE = 32;\n/**\n * Standardize the output of a dataset iterator for use by\n * LayersModel.fitDataset().\n *\n * @param model: A `tf.LayersModel` object.\n * @param iteratorOut The output of a dataset iterator. It is required to be\n *   an object of the form `{xs: TensorOrArrayOrMap, ys:\n * TensorOrArrayOrMap}`, where `TensorOrArrayOrMap` is a single `tf.Tensor`,\n * a `tf.Tensor[]`, or a flat map from string names to `tf.Tensor`s.\n * @returns A flat array of `tf.Tensor` objects: the input `tf.Tensor`s\n *   followed by the target `tf.Tensor`s.  When `tf.Tensor`s are provided\n *   as a map, the order in the resulting array is taken from the `inputNames`\n *   and `outputNames` of the model.\n */\nfunction standardizeDataIteratorOutput(\n// Type `model` as `any` here to avoid circular dependency w/\n// training.ts.\n// tslint:disable-next-line:no-any\nmodel, iteratorOut) {\n    let xs;\n    let ys;\n    const iteratorOutObj = iteratorOut;\n    xs = iteratorOutObj['xs'];\n    ys = iteratorOutObj['ys'];\n    tfc.util.assert(xs != null && ys != null, () => 'A Dataset iterator for fitDataset() is expected to generate ' +\n        'objects of the form `{xs: xVal, ys: yVal}`, where the two ' +\n        'values may be `tf.Tensor`, an array of Tensors, or a map of ' +\n        'string to Tensor.  The provided Dataset instead generates ' +\n        `${iteratorOut}`);\n    const flattenedXs = flattenTensorOrArrayOrMap('input', model.inputNames, xs);\n    const flattenedYs = flattenTensorOrArrayOrMap('output', model.outputNames, ys);\n    const batchSize = flattenedXs[0].shape[0];\n    tfc.util.assert(flattenedXs.length === model.inputs.length, () => `LayersModel has ${model.inputs.length} inputs, but the dataset ` +\n        `provides ${flattenedXs.length} inputs.  (Expected input keys: ` +\n        `${JSON.stringify(model.inputNames)})`);\n    tfc.util.assert(flattenedYs.length === model.outputs.length, () => `LayersModel has ${model.outputs.length} outputs, but the dataset ` +\n        `provides ${flattenedYs.length} outputs.  (Expected output keys: ` +\n        `${JSON.stringify(model.outputNames)})`);\n    for (let xIndex = 0; xIndex < flattenedXs.length; xIndex++) {\n        tfc.util.assert(flattenedXs[xIndex].shape[0] === batchSize, () => `Batch size mismatch: input ` +\n            `${model.inputNames[xIndex]} has ${flattenedXs[xIndex].shape[0]}; ` +\n            `expected  ${batchSize} based on input ${model.inputNames[0]}.`);\n    }\n    for (let yIndex = 0; yIndex < flattenedYs.length; yIndex++) {\n        tfc.util.assert(flattenedYs[yIndex].shape[0] === batchSize, () => `Batch size mismatch: output ` +\n            `${model.outputNames[yIndex]} has ${flattenedYs[yIndex].shape[0]}; ` +\n            `expected  ${batchSize} based on input ${model.inputNames[0]}.`);\n    }\n    return { xs: flattenedXs, ys: flattenedYs };\n}\nfunction flattenTensorOrArrayOrMap(inputOrOutput, names, values) {\n    if (values instanceof tfc.Tensor) {\n        return [values];\n    }\n    else if (Array.isArray(values)) {\n        tfc.util.assert(values.length === names.length, () => `Received an array of ${values.length} Tensors, but expected ${names.length} to match the ${inputOrOutput} keys ${names}.`);\n        return values;\n    }\n    else {\n        const result = [];\n        // Check that all the required keys are available.\n        for (const name of names) {\n            if (values[name] == null) {\n                throw new ValueError(`The feature data generated by the dataset lacks the required ` +\n                    `${inputOrOutput} key '${name}'.`);\n            }\n            result.push(values[name]);\n        }\n        return result;\n    }\n}\nfunction standardizeTensorValidationData(data) {\n    if (data.length === 3) {\n        throw new NotImplementedError('Validation with sample weights is not implemented yet.');\n    }\n    return { xs: data[0], ys: data[1] };\n}\nexport async function fitDataset(\n// Type `model` as `any` here to avoid circular dependency w/\n// training.ts.\n// tslint:disable-next-line:no-any\nmodel, dataset, args) {\n    const hasBatchesPerEpoch = args.batchesPerEpoch != null;\n    tfc.util.assert(model.optimizer != null, () => 'You must compile a model before training/testing. Use ' +\n        'LayersModel.compile(modelCompileConfig).');\n    tfc.util.assert(args != null, () => `For fitDataset(), the 2nd argument (config) is required, ` +\n        `but it is not provided in this call.`);\n    tfc.util.assert(args.epochs != null && args.epochs > 0 && Number.isInteger(args.epochs), () => `For fitDataset(), config.epochs is expected to be a positive ` +\n        `integer, but got ${args.epochs}`);\n    tfc.util.assert(!hasBatchesPerEpoch ||\n        (args.batchesPerEpoch > 0 && Number.isInteger(args.batchesPerEpoch)), () => `For fitDataset(), config.batchesPerEpoch is expected to be a ` +\n        `positive integer if specified, but got ${args.batchesPerEpoch}`);\n    tfc.util.assert(\n    // tslint:disable-next-line:no-any\n    args['validationSplit'] == null, () => '`validationSplit` is not supported by `fitDataset()`. ' +\n        'Use validationData instead.');\n    if (model.isTraining) {\n        throw new Error('Cannot start training because another fit() call is ongoing.');\n    }\n    model.isTraining = true;\n    try {\n        const doValidation = args.validationData != null;\n        let valXs;\n        let valYs;\n        if (doValidation) {\n            if (isDatasetObject(args.validationData)) {\n                tfc.util.assert(args.validationBatches == null ||\n                    (args.validationBatches > 0 &&\n                        Number.isInteger(args.validationBatches)), () => `For fitDataset() with dataset-based validation, ` +\n                    `config.validationBatches is expected not to be provided, ` +\n                    `or to be a positive integer, ` +\n                    `but got ${args.validationBatches}`);\n            }\n            else {\n                const validationData = standardizeTensorValidationData(args.validationData);\n                valXs = validationData.xs;\n                valYs = validationData.ys;\n            }\n        }\n        const trainFunction = model.makeTrainFunction();\n        const outLabels = model.getDedupedMetricsNames();\n        let callbackMetrics;\n        if (doValidation) {\n            callbackMetrics =\n                outLabels.slice().concat(outLabels.map(n => 'val_' + n));\n        }\n        else {\n            callbackMetrics = outLabels.slice();\n        }\n        const callbacks = standardizeCallbacks(args.callbacks, args.yieldEvery);\n        const verbose = args.verbose == null ? 1 : args.verbose;\n        const { callbackList, history } = configureCallbacks(callbacks, verbose, args.epochs, null, null, getStepsPerEpoch(dataset, args), null, // Batch size determined by the dataset itself.\n        doValidation, callbackMetrics);\n        callbackList.setModel(model);\n        model.history = history;\n        await callbackList.onTrainBegin();\n        model.stopTraining_ = false;\n        let epoch = args.initialEpoch == null ? 0 : args.initialEpoch;\n        let dataIterator = await dataset.iterator();\n        while (epoch < args.epochs) {\n            const epochLogs = {};\n            await callbackList.onEpochBegin(epoch);\n            let stepsDone = 0;\n            let batchIndex = 0;\n            if (!hasBatchesPerEpoch) {\n                dataIterator = await dataset.iterator();\n            }\n            while (hasBatchesPerEpoch ? stepsDone < args.batchesPerEpoch : true) {\n                const iteratorOut = await dataIterator.next();\n                // If `batchesPerEpoch` is specified, the dataset should not be\n                // exhausted until all epoches are done.\n                if (hasBatchesPerEpoch && iteratorOut.done) {\n                    console.warn('You provided `batchesPerEpoch` as ' +\n                        `${args.batchesPerEpoch}, ` +\n                        'but your dataset iterator ran out of data after ' +\n                        `${stepsDone} batches; ` +\n                        'interrupting training. Make sure that your ' +\n                        'dataset can generate at least `batchesPerEpoch * epochs` ' +\n                        'batches (in this case, ' +\n                        `${args.batchesPerEpoch * args.epochs} batches). ` +\n                        'You may need to use the repeat() function when building ' +\n                        'your dataset.');\n                    break;\n                }\n                if (iteratorOut.value != null) {\n                    const { xs, ys } = standardizeDataIteratorOutput(model, iteratorOut.value);\n                    const batchLogs = {};\n                    batchLogs['batch'] = batchIndex;\n                    batchLogs['size'] = xs[0].shape[0];\n                    await callbackList.onBatchBegin(batchIndex, batchLogs);\n                    const sampleWeights = [];\n                    if (args.classWeight != null) {\n                        const standardClassWeights = standardizeClassWeights(args.classWeight, model.outputNames);\n                        for (let i = 0; i < standardClassWeights.length; ++i) {\n                            sampleWeights.push(await standardizeWeights(ys[i], null, standardClassWeights[i]));\n                        }\n                    }\n                    // Train on batch.\n                    const ins = xs.concat(ys).concat(sampleWeights);\n                    const outs = trainFunction(ins);\n                    tfc.dispose(ins);\n                    for (let i = 0; i < outLabels.length; ++i) {\n                        const label = outLabels[i];\n                        const out = outs[i];\n                        batchLogs[label] = out;\n                        tfc.keep(out);\n                    }\n                    await callbackList.onBatchEnd(batchIndex, batchLogs);\n                    disposeTensorsInLogs(batchLogs);\n                    batchIndex++;\n                    stepsDone++;\n                }\n                if (hasBatchesPerEpoch ? stepsDone >= args.batchesPerEpoch :\n                    iteratorOut.done) {\n                    // Epoch finished. Perform validation.\n                    if (doValidation) {\n                        let valOuts;\n                        if (isDatasetObject(args.validationData)) {\n                            valOuts = toList(await model.evaluateDataset(args.validationData, { batches: args.validationBatches }));\n                        }\n                        else {\n                            valOuts = toList(model.evaluate(valXs, valYs, {\n                                batchSize: args.validationBatchSize == null ?\n                                    DEFAULT_VALIDATION_BATCH_SIZE :\n                                    args.validationBatchSize,\n                                verbose: 0\n                            }));\n                        }\n                        for (let i = 0; i < model.metricsNames.length; ++i) {\n                            epochLogs[`val_${model.metricsNames[i]}`] = valOuts[i];\n                        }\n                    }\n                    // Call `break` to exit one epoch lopp after validation is done. If\n                    // config.batchesPerEpoch is specified, an epoch while loop will\n                    // stop when `stepsDone >= config.batchesPerEpoch`. When\n                    // config.batchesPerEpoch is not provided, the following `break` is\n                    // required to exit the while lopp after dataset is exhausted.\n                    break;\n                }\n                if (model.stopTraining_) {\n                    break;\n                }\n            }\n            await callbackList.onEpochEnd(epoch, epochLogs);\n            epoch++;\n            if (model.stopTraining_) {\n                break;\n            }\n        }\n        await callbackList.onTrainEnd();\n        await model.history.syncData();\n        return model.history;\n    }\n    finally {\n        model.isTraining = false;\n    }\n}\n/** Helper function that determines number of steps (batches) per epoch. */\nfunction getStepsPerEpoch(dataset, args) {\n    // Attempt to determine # of batches in an epoch.\n    let stepsPerEpoch = null;\n    if (args.batchesPerEpoch != null) {\n        stepsPerEpoch = args.batchesPerEpoch;\n    }\n    else if (Number.isFinite(dataset.size)) {\n        stepsPerEpoch = dataset.size;\n    }\n    return stepsPerEpoch;\n}\n// Check if provided object is a Dataset object by checking its .iterator\n// element.\nfunction isDatasetObject(dataset) {\n    return (typeof dataset.iterator === 'function');\n}\n// Check if provided object is a LazyIterator object by checking it's .next\n// element.\nfunction isLazyIteratorObject(iterator) {\n    return (typeof iterator.next === 'function');\n}\nexport async function evaluateDataset(\n// Type `model` as `any` here to avoid circular dependency w/\n// training.ts.\n// tslint:disable-next-line:no-any\nmodel, dataset, args) {\n    args = args || {};\n    const hasBatches = args.batches != null;\n    const f = model.testFunction;\n    let outs = [];\n    if (args.verbose > 0) {\n        throw new NotImplementedError('Verbose mode is not implemented yet.');\n    }\n    tfc.util.assert(!hasBatches || (args.batches > 0 && Number.isInteger(args.batches)), () => 'Test loop expects `batches` to be a positive integer, but ' +\n        `received ${JSON.stringify(args.batches)}`);\n    const dataIterator = isLazyIteratorObject(dataset) ?\n        dataset :\n        await dataset.iterator();\n    // Keeps track of number of examples used in this evaluation.\n    let numExamples = 0;\n    let batch = 0;\n    while (hasBatches ? batch < args.batches : true) {\n        const iteratorOut = await dataIterator.next();\n        outs = tfc.tidy(() => {\n            if (iteratorOut.value) {\n                // TODO(cais): Once real dataset is available, use\n                //   `map(x => standardizeDataIteratorOutput(model, x).map(f)`.\n                const { xs, ys } = standardizeDataIteratorOutput(model, iteratorOut.value);\n                const xsAndYs = xs.concat(ys);\n                const batchOuts = tfc.tidy(() => f(xsAndYs));\n                tfc.dispose(xsAndYs);\n                if (batch === 0) {\n                    for (let i = 0; i < batchOuts.length; ++i) {\n                        outs.push(scalar(0));\n                    }\n                }\n                const batchSize = xsAndYs[0].shape[0];\n                for (let i = 0; i < batchOuts.length; ++i) {\n                    const batchOut = batchOuts[i];\n                    const oldScalar = outs[i];\n                    outs[i] =\n                        tfc.tidy(() => tfc.add(outs[i], tfc.mul(batchSize, batchOut)));\n                    if (batch > 0) {\n                        tfc.dispose(oldScalar);\n                    }\n                }\n                tfc.dispose(batchOuts);\n                numExamples += batchSize;\n                ++batch;\n            }\n            return outs;\n        });\n        if (iteratorOut.done) {\n            if (hasBatches) {\n                console.warn('Your dataset iterator ran out of data during evaluateDataset(). ' +\n                    'Interrupting evalution. Make sure that your ' +\n                    'dataset can generate at least `batches` ' +\n                    `batches (in this case, ${args.batches} batches). ` +\n                    'You may need to use the repeat() function when building ' +\n                    'your dataset.');\n            }\n            break;\n        }\n    }\n    for (let i = 0; i < outs.length; ++i) {\n        const oldScalar = outs[i];\n        outs[i] = tfc.div(outs[i], numExamples);\n        tfc.dispose(oldScalar);\n    }\n    return singletonOrArray(outs);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhaW5pbmdfZGF0YXNldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9lbmdpbmUvdHJhaW5pbmdfZGF0YXNldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOztHQUVHO0FBRUgsT0FBTyxLQUFLLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDN0MsT0FBTyxFQUFlLGtCQUFrQixFQUFzRCxvQkFBb0IsRUFBb0IsTUFBTSxtQkFBbUIsQ0FBQztBQUNoSyxPQUFPLEVBQUMsbUJBQW1CLEVBQUUsVUFBVSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQzFELE9BQU8sRUFBQyxvQkFBb0IsRUFBaUIsTUFBTSxTQUFTLENBQUM7QUFFN0QsT0FBTyxFQUFDLGdCQUFnQixFQUFFLE1BQU0sRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBR2hFLE9BQU8sRUFBOEIsdUJBQXVCLEVBQUUsa0JBQWtCLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQWlLMUcsMERBQTBEO0FBQzFELE1BQU0sNkJBQTZCLEdBQUcsRUFBRSxDQUFDO0FBRXpDOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxTQUFTLDZCQUE2QjtBQUNsQyw2REFBNkQ7QUFDN0QsZUFBZTtBQUNmLGtDQUFrQztBQUNsQyxLQUFVLEVBQUUsV0FBZTtJQUM3QixJQUFJLEVBQXNCLENBQUM7SUFDM0IsSUFBSSxFQUFzQixDQUFDO0lBRTNCLE1BQU0sY0FBYyxHQUFHLFdBQWdDLENBQUM7SUFDeEQsRUFBRSxHQUFHLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQixFQUFFLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFCLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUNYLEVBQUUsSUFBSSxJQUFJLElBQUksRUFBRSxJQUFJ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YixHQUFHLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO3FCQUN4QjtpQkFDRjtnQkFDRCxHQUFHLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUN2QixXQUFXLElBQUksU0FBUyxDQUFDO2dCQUV6QixFQUFFLEtBQUssQ0FBQzthQUNUO1lBQ0QsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksV0FBVyxDQUFDLElBQUksRUFBRTtZQUNwQixJQUFJLFVBQVUsRUFBRTtnQkFDZCxPQUFPLENBQUMsSUFBSSxDQUNSLGtFQUFrRTtvQkFDbEUsOENBQThDO29CQUM5QywwQ0FBMEM7b0JBQzFDLDBCQUEwQixJQUFJLENBQUMsT0FBTyxhQUFhO29CQUNuRCwwREFBMEQ7b0JBQzFELGVBQWUsQ0FBQyxDQUFDO2FBQ3RCO1lBQ0QsTUFBTTtTQUNQO0tBQ0Y7SUFFRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRTtRQUNwQyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ3hDLEdBQUcsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDeEI7SUFFRCxPQUFPLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2hDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIEludGVyZmFjZXMgYW5kIG1ldGhvZHMgZm9yIHRyYWluaW5nIG1vZGVscyB1c2luZyBUZW5zb3JGbG93LmpzIGRhdGFzZXRzLlxuICovXG5cbmltcG9ydCAqIGFzIHRmYyBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtzY2FsYXJ9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge0Jhc2VDYWxsYmFjaywgY29uZmlndXJlQ2FsbGJhY2tzLCBDdXN0b21DYWxsYmFja0FyZ3MsIEhpc3RvcnksIE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eSwgc3RhbmRhcmRpemVDYWxsYmFja3MsIFlpZWxkRXZlcnlPcHRpb25zfSBmcm9tICcuLi9iYXNlX2NhbGxiYWNrcyc7XG5pbXBvcnQge05vdEltcGxlbWVudGVkRXJyb3IsIFZhbHVlRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2Rpc3Bvc2VUZW5zb3JzSW5Mb2dzLCBVbnJlc29sdmVkTG9nc30gZnJvbSAnLi4vbG9ncyc7XG5pbXBvcnQge1RlbnNvck9yQXJyYXlPck1hcH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtzaW5nbGV0b25PckFycmF5LCB0b0xpc3R9IGZyb20gJy4uL3V0aWxzL2dlbmVyaWNfdXRpbHMnO1xuXG5pbXBvcnQge0RhdGFzZXQsIExhenlJdGVyYXRvcn0gZnJvbSAnLi9kYXRhc2V0X3N0dWInO1xuaW1wb3J0IHtDbGFzc1dlaWdodCwgQ2xhc3NXZWlnaHRNYXAsIHN0YW5kYXJkaXplQ2xhc3NXZWlnaHRzLCBzdGFuZGFyZGl6ZVdlaWdodHN9IGZyb20gJy4vdHJhaW5pbmdfdXRpbHMnO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgY29uZmlndXJpbmcgbW9kZWwgdHJhaW5pbmcgYmFzZWQgb24gYSBkYXRhc2V0IG9iamVjdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb2RlbEZpdERhdGFzZXRBcmdzPFQ+IHtcbiAgLyoqXG4gICAqIChPcHRpb25hbCkgVG90YWwgbnVtYmVyIG9mIHN0ZXBzIChiYXRjaGVzIG9mIHNhbXBsZXMpIGJlZm9yZVxuICAgKiBkZWNsYXJpbmcgb25lIGVwb2NoIGZpbmlzaGVkIGFuZCBzdGFydGluZyB0aGUgbmV4dCBlcG9jaC4gSXQgc2hvdWxkXG4gICAqIHR5cGljYWxseSBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHNhbXBsZXMgb2YgeW91ciBkYXRhc2V0IGRpdmlkZWQgYnlcbiAgICogdGhlIGJhdGNoIHNpemUsIHNvIHRoYXQgYGZpdERhdGFzZXRgKCkgY2FsbCBjYW4gdXRpbGl6ZSB0aGUgZW50aXJlIGRhdGFzZXQuXG4gICAqIElmIGl0IGlzIG5vdCBwcm92aWRlZCwgdXNlIGBkb25lYCByZXR1cm4gdmFsdWUgaW4gYGl0ZXJhdG9yLm5leHQoKWAgYXNcbiAgICogc2lnbmFsIHRvIGZpbmlzaCBhbiBlcG9jaC5cbiAgICovXG4gIGJhdGNoZXNQZXJFcG9jaD86IG51bWJlcjtcblxuICAvKipcbiAgICogSW50ZWdlciBudW1iZXIgb2YgdGltZXMgdG8gaXRlcmF0ZSBvdmVyIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgKi9cbiAgZXBvY2hzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFZlcmJvc2l0eSBsZXZlbC5cbiAgICpcbiAgICogRXhwZWN0ZWQgdG8gYmUgMCwgMSwgb3IgMi4gRGVmYXVsdDogMS5cbiAgICpcbiAgICogMCAtIE5vIHByaW50ZWQgbWVzc2FnZSBkdXJpbmcgZml0KCkgY2FsbC5cbiAgICogMSAtIEluIE5vZGUuanMgKHRmanMtbm9kZSksIHByaW50cyB0aGUgcHJvZ3Jlc3MgYmFyLCB0b2dldGhlciB3aXRoXG4gICAqICAgICByZWFsLXRpbWUgdXBkYXRlcyBvZiBsb3NzIGFuZCBtZXRyaWMgdmFsdWVzIGFuZCB0cmFpbmluZyBzcGVlZC5cbiAgICogICAgIEluIHRoZSBicm93c2VyOiBubyBhY3Rpb24uIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gICAqIDIgLSBOb3QgaW1wbGVtZW50ZWQgeWV0LlxuICAgKi9cbiAgdmVyYm9zZT86IE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eTtcblxuICAvKipcbiAgICogTGlzdCBvZiBjYWxsYmFja3MgdG8gYmUgY2FsbGVkIGR1cmluZyB0cmFpbmluZy5cbiAgICogQ2FuIGhhdmUgb25lIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyBjYWxsYmFja3M6XG4gICAqICAgLSBgb25UcmFpbkJlZ2luKGxvZ3MpYDogY2FsbGVkIHdoZW4gdHJhaW5pbmcgc3RhcnRzLlxuICAgKiAgIC0gYG9uVHJhaW5FbmQobG9ncylgOiBjYWxsZWQgd2hlbiB0cmFpbmluZyBlbmRzLlxuICAgKiAgIC0gYG9uRXBvY2hCZWdpbihlcG9jaCwgbG9ncylgOiBjYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIGV2ZXJ5IGVwb2NoLlxuICAgKiAgIC0gYG9uRXBvY2hFbmQoZXBvY2gsIGxvZ3MpYDogY2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgZXBvY2guXG4gICAqICAgLSBgb25CYXRjaEJlZ2luKGJhdGNoLCBsb2dzKWA6IGNhbGxlZCBhdCB0aGUgc3RhcnQgb2YgZXZlcnkgYmF0Y2guXG4gICAqICAgLSBgb25CYXRjaEVuZChiYXRjaCwgbG9ncylgOiBjYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSBiYXRjaC5cbiAgICogICAtIGBvbllpZWxkKGVwb2NoLCBiYXRjaCwgbG9ncylgOiBjYWxsZWQgZXZlcnkgYHlpZWxkRXZlcnlgIG1pbGxpc2Vjb25kc1xuICAgKiAgICAgIHdpdGggdGhlIGN1cnJlbnQgZXBvY2gsIGJhdGNoIGFuZCBsb2dzLiBUaGUgbG9ncyBhcmUgdGhlIHNhbWVcbiAgICogICAgICBhcyBpbiBgb25CYXRjaEVuZCgpYC4gTm90ZSB0aGF0IGBvbllpZWxkYCBjYW4gc2tpcCBiYXRjaGVzIG9yXG4gICAqICAgICAgZXBvY2hzLiBTZWUgYWxzbyBkb2NzIGZvciBgeWllbGRFdmVyeWAgYmVsb3cuXG4gICAqL1xuICBjYWxsYmFja3M/OiBCYXNlQ2FsbGJhY2tbXXxDdXN0b21DYWxsYmFja0FyZ3N8Q3VzdG9tQ2FsbGJhY2tBcmdzW107XG5cbiAgLyoqXG4gICAqIERhdGEgb24gd2hpY2ggdG8gZXZhbHVhdGUgdGhlIGxvc3MgYW5kIGFueSBtb2RlbFxuICAgKiBtZXRyaWNzIGF0IHRoZSBlbmQgb2YgZWFjaCBlcG9jaC4gVGhlIG1vZGVsIHdpbGwgbm90IGJlIHRyYWluZWQgb24gdGhpc1xuICAgKiBkYXRhLiBUaGlzIGNvdWxkIGJlIGFueSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiAgIC0gQW4gYXJyYXkgYFt4VmFsLCB5VmFsXWAsIHdoZXJlIHRoZSB0d28gdmFsdWVzIG1heSBiZSBgdGYuVGVuc29yYCxcbiAgICogICAgIGFuIGFycmF5IG9mIFRlbnNvcnMsIG9yIGEgbWFwIG9mIHN0cmluZyB0byBUZW5zb3IuXG4gICAqICAgLSBTaW1pbGFybHksIGFuIGFycmF5IGAgW3hWYWwsIHlWYWwsIHZhbFNhbXBsZVdlaWdodHNdYFxuICAgKiAgICAgKG5vdCBpbXBsZW1lbnRlZCB5ZXQpLlxuICAgKiAgIC0gYSBgRGF0YXNldGAgb2JqZWN0IHdpdGggZWxlbWVudHMgb2YgdGhlIGZvcm0gYHt4czogeFZhbCwgeXM6IHlWYWx9YCxcbiAgICogICAgIHdoZXJlIGB4c2AgYW5kIGB5c2AgYXJlIHRoZSBmZWF0dXJlIGFuZCBsYWJlbCB0ZW5zb3JzLCByZXNwZWN0aXZlbHkuXG4gICAqXG4gICAqIElmIGB2YWxpZGF0aW9uRGF0YWAgaXMgYW4gQXJyYXkgb2YgVGVuc29yIG9iamVjdHMsIGVhY2ggYHRmLlRlbnNvcmAgd2lsbCBiZVxuICAgKiBzbGljZWQgaW50byBiYXRjaGVzIGR1cmluZyB2YWxpZGF0aW9uLCB1c2luZyB0aGUgcGFyYW1ldGVyXG4gICAqIGB2YWxpZGF0aW9uQmF0Y2hTaXplYCAod2hpY2ggZGVmYXVsdHMgdG8gMzIpLiBUaGUgZW50aXJldHkgb2YgdGhlXG4gICAqIGB0Zi5UZW5zb3JgIG9iamVjdHMgd2lsbCBiZSB1c2VkIGluIHRoZSB2YWxpZGF0aW9uLlxuICAgKlxuICAgKiBJZiBgdmFsaWRhdGlvbkRhdGFgIGlzIGEgZGF0YXNldCBvYmplY3QsIGFuZCB0aGUgYHZhbGlkYXRpb25CYXRjaGVzYFxuICAgKiBwYXJhbWV0ZXIgaXMgc3BlY2lmaWVkLCB0aGUgdmFsaWRhdGlvbiB3aWxsIHVzZSBgdmFsaWRhdGlvbkJhdGNoZXNgIGJhdGNoZXNcbiAgICogZHJhd24gZnJvbSB0aGUgZGF0YXNldCBvYmplY3QuIElmIGB2YWxpZGF0aW9uQmF0Y2hlc2AgcGFyYW1ldGVyIGlzIG5vdFxuICAgKiBzcGVjaWZpZWQsIHRoZSB2YWxpZGF0aW9uIHdpbGwgc3RvcCB3aGVuIHRoZSBkYXRhc2V0IGlzIGV4aGF1c3RlZC5cbiAgICpcbiAgICogVGhlIG1vZGVsIHdpbGwgbm90IGJlIHRyYWluZWQgb24gdGhpcyBkYXRhLlxuICAgKi9cbiAgdmFsaWRhdGlvbkRhdGE/OiBbXG4gICAgVGVuc29yT3JBcnJheU9yTWFwLCBUZW5zb3JPckFycmF5T3JNYXBcbiAgXXxbVGVuc29yT3JBcnJheU9yTWFwLCBUZW5zb3JPckFycmF5T3JNYXAsIFRlbnNvck9yQXJyYXlPck1hcF18RGF0YXNldDxUPjtcblxuICAvKipcbiAgICogT3B0aW9uYWwgYmF0Y2ggc2l6ZSBmb3IgdmFsaWRhdGlvbi5cbiAgICpcbiAgICogVXNlZCBvbmx5IGlmIGB2YWxpZGF0aW9uRGF0YWAgaXMgYW4gYXJyYXkgb2YgYHRmLlRlbnNvcmAgb2JqZWN0cywgaS5lLiwgbm90XG4gICAqIGEgZGF0YXNldCBvYmplY3QuXG4gICAqXG4gICAqIElmIG5vdCBzcGVjaWZpZWQsIGl0cyB2YWx1ZSBkZWZhdWx0cyB0byAzMi5cbiAgICovXG4gIHZhbGlkYXRpb25CYXRjaFNpemU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIChPcHRpb25hbCkgT25seSByZWxldmFudCBpZiBgdmFsaWRhdGlvbkRhdGFgIGlzIHNwZWNpZmllZCBhbmQgaXMgYSBkYXRhc2V0XG4gICAqIG9iamVjdC5cbiAgICpcbiAgICogVG90YWwgbnVtYmVyIG9mIGJhdGNoZXMgb2Ygc2FtcGxlcyB0byBkcmF3IGZyb20gYHZhbGlkYXRpb25EYXRhYCBmb3JcbiAgICogdmFsaWRhdGlvbiBwdXJwb3NlIGJlZm9yZSBzdG9wcGluZyBhdCB0aGUgZW5kIG9mIGV2ZXJ5IGVwb2NoLiBJZiBub3RcbiAgICogc3BlY2lmaWVkLCBgZXZhbHVhdGVEYXRhc2V0YCB3aWxsIHVzZSBgaXRlcmF0b3IubmV4dCgpLmRvbmVgIGFzIHNpZ25hbCB0b1xuICAgKiBzdG9wIHZhbGlkYXRpb24uXG4gICAqL1xuICB2YWxpZGF0aW9uQmF0Y2hlcz86IG51bWJlcjtcblxuICAvKipcbiAgICogQ29uZmlndXJlcyB0aGUgZnJlcXVlbmN5IG9mIHlpZWxkaW5nIHRoZSBtYWluIHRocmVhZCB0byBvdGhlciB0YXNrcy5cbiAgICpcbiAgICogSW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQsIHlpZWxkaW5nIHRoZSBtYWluIHRocmVhZCBjYW4gaW1wcm92ZSB0aGVcbiAgICogcmVzcG9uc2l2ZW5lc3Mgb2YgdGhlIHBhZ2UgZHVyaW5nIHRyYWluaW5nLiBJbiB0aGUgTm9kZS5qcyBlbnZpcm9ubWVudCxcbiAgICogaXQgY2FuIGVuc3VyZSB0YXNrcyBxdWV1ZWQgaW4gdGhlIGV2ZW50IGxvb3AgY2FuIGJlIGhhbmRsZWQgaW4gYSB0aW1lbHlcbiAgICogbWFubmVyLlxuICAgKlxuICAgKiBUaGUgdmFsdWUgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKiAgIC0gYCdhdXRvJ2A6IFRoZSB5aWVsZGluZyBoYXBwZW5zIGF0IGEgY2VydGFpbiBmcmFtZSByYXRlIChjdXJyZW50bHkgc2V0XG4gICAqICAgICAgICAgICAgICAgYXQgMTI1bXMpLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlxuICAgKiAgIC0gYCdiYXRjaCdgOiB5aWVsZCBldmVyeSBiYXRjaC5cbiAgICogICAtIGAnZXBvY2gnYDogeWllbGQgZXZlcnkgZXBvY2guXG4gICAqICAgLSBhIGBudW1iZXJgOiBXaWxsIHlpZWxkIGV2ZXJ5IGBudW1iZXJgIG1pbGxpc2Vjb25kcy5cbiAgICogICAtIGAnbmV2ZXInYDogbmV2ZXIgeWllbGQuIChCdXQgeWllbGRpbmcgY2FuIHN0aWxsIGhhcHBlbiB0aHJvdWdoIGBhd2FpdFxuICAgKiAgICAgIG5leHRGcmFtZSgpYCBjYWxscyBpbiBjdXN0b20gY2FsbGJhY2tzLilcbiAgICovXG4gIHlpZWxkRXZlcnk/OiBZaWVsZEV2ZXJ5T3B0aW9ucztcblxuICAvKipcbiAgICogRXBvY2ggYXQgd2hpY2ggdG8gc3RhcnQgdHJhaW5pbmcgKHVzZWZ1bCBmb3IgcmVzdW1pbmcgYSBwcmV2aW91cyB0cmFpbmluZ1xuICAgKiBydW4pLiBXaGVuIHRoaXMgaXMgdXNlZCwgYGVwb2Noc2AgaXMgdGhlIGluZGV4IG9mIHRoZSBcImZpbmFsIGVwb2NoXCIuXG4gICAqIFRoZSBtb2RlbCBpcyBub3QgdHJhaW5lZCBmb3IgYSBudW1iZXIgb2YgaXRlcmF0aW9ucyBnaXZlbiBieSBgZXBvY2hzYCxcbiAgICogYnV0IG1lcmVseSB1bnRpbCB0aGUgZXBvY2ggb2YgaW5kZXggYGVwb2Noc2AgaXMgcmVhY2hlZC5cbiAgICovXG4gIGluaXRpYWxFcG9jaD86IG51bWJlcjtcblxuICAvKipcbiAgICogT3B0aW9uYWwgb2JqZWN0IG1hcHBpbmcgY2xhc3MgaW5kaWNlcyAoaW50ZWdlcnMpIHRvXG4gICAqIGEgd2VpZ2h0IChmbG9hdCkgdG8gYXBwbHkgdG8gdGhlIG1vZGVsJ3MgbG9zcyBmb3IgdGhlIHNhbXBsZXMgZnJvbSB0aGlzXG4gICAqIGNsYXNzIGR1cmluZyB0cmFpbmluZy4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIHRlbGwgdGhlIG1vZGVsIHRvIFwicGF5IG1vcmVcbiAgICogYXR0ZW50aW9uXCIgdG8gc2FtcGxlcyBmcm9tIGFuIHVuZGVyLXJlcHJlc2VudGVkIGNsYXNzLlxuICAgKlxuICAgKiBJZiB0aGUgbW9kZWwgaGFzIG11bHRpcGxlIG91dHB1dHMsIGEgY2xhc3Mgd2VpZ2h0IGNhbiBiZSBzcGVjaWZpZWQgZm9yXG4gICAqIGVhY2ggb2YgdGhlIG91dHB1dHMgYnkgc2V0dGluZyB0aGlzIGZpZWxkIGFuIGFycmF5IG9mIHdlaWdodCBvYmplY3RcbiAgICogb3IgYW4gb2JqZWN0IHRoYXQgbWFwcyBtb2RlbCBvdXRwdXQgbmFtZXMgKGUuZy4sIGBtb2RlbC5vdXRwdXROYW1lc1swXWApXG4gICAqIHRvIHdlaWdodCBvYmplY3RzLlxuICAgKi9cbiAgY2xhc3NXZWlnaHQ/OiBDbGFzc1dlaWdodHxDbGFzc1dlaWdodFtdfENsYXNzV2VpZ2h0TWFwO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpdERhdGFzZXRFbGVtZW50IHtcbiAgeHM6IFRlbnNvck9yQXJyYXlPck1hcDtcbiAgeXM6IFRlbnNvck9yQXJyYXlPck1hcDtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGNvbmZpZ3VyaW5nIG1vZGVsIGV2YWx1YXRpb24gYmFzZWQgb24gYSBkYXRhc2V0IG9iamVjdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb2RlbEV2YWx1YXRlRGF0YXNldEFyZ3Mge1xuICAvKipcbiAgICogTnVtYmVyIG9mIGJhdGNoZXMgdG8gZHJhdyBmcm9tIHRoZSBkYXRhc2V0IG9iamVjdCBiZWZvcmUgZW5kaW5nIHRoZVxuICAgKiBldmFsdWF0aW9uLlxuICAgKi9cbiAgYmF0Y2hlcz86IG51bWJlcjtcblxuICAvKipcbiAgICogVmVyYm9zaXR5IG1vZGUuXG4gICAqL1xuICB2ZXJib3NlPzogTW9kZWxMb2dnaW5nVmVyYm9zaXR5O1xufVxuXG4vLyBEZWZhdWx0IGJhdGNoIHNpemUgdXNlZCBkdXJpbmcgdGVuc29yLWJhc2VkIHZhbGlkYXRpb24uXG5jb25zdCBERUZBVUxUX1ZBTElEQVRJT05fQkFUQ0hfU0laRSA9IDMyO1xuXG4vKipcbiAqIFN0YW5kYXJkaXplIHRoZSBvdXRwdXQgb2YgYSBkYXRhc2V0IGl0ZXJhdG9yIGZvciB1c2UgYnlcbiAqIExheWVyc01vZGVsLmZpdERhdGFzZXQoKS5cbiAqXG4gKiBAcGFyYW0gbW9kZWw6IEEgYHRmLkxheWVyc01vZGVsYCBvYmplY3QuXG4gKiBAcGFyYW0gaXRlcmF0b3JPdXQgVGhlIG91dHB1dCBvZiBhIGRhdGFzZXQgaXRlcmF0b3IuIEl0IGlzIHJlcXVpcmVkIHRvIGJlXG4gKiAgIGFuIG9iamVjdCBvZiB0aGUgZm9ybSBge3hzOiBUZW5zb3JPckFycmF5T3JNYXAsIHlzOlxuICogVGVuc29yT3JBcnJheU9yTWFwfWAsIHdoZXJlIGBUZW5zb3JPckFycmF5T3JNYXBgIGlzIGEgc2luZ2xlIGB0Zi5UZW5zb3JgLFxuICogYSBgdGYuVGVuc29yW11gLCBvciBhIGZsYXQgbWFwIGZyb20gc3RyaW5nIG5hbWVzIHRvIGB0Zi5UZW5zb3Jgcy5cbiAqIEByZXR1cm5zIEEgZmxhdCBhcnJheSBvZiBgdGYuVGVuc29yYCBvYmplY3RzOiB0aGUgaW5wdXQgYHRmLlRlbnNvcmBzXG4gKiAgIGZvbGxvd2VkIGJ5IHRoZSB0YXJnZXQgYHRmLlRlbnNvcmBzLiAgV2hlbiBgdGYuVGVuc29yYHMgYXJlIHByb3ZpZGVkXG4gKiAgIGFzIGEgbWFwLCB0aGUgb3JkZXIgaW4gdGhlIHJlc3VsdGluZyBhcnJheSBpcyB0YWtlbiBmcm9tIHRoZSBgaW5wdXROYW1lc2BcbiAqICAgYW5kIGBvdXRwdXROYW1lc2Agb2YgdGhlIG1vZGVsLlxuICovXG5mdW5jdGlvbiBzdGFuZGFyZGl6ZURhdGFJdGVyYXRvck91dHB1dChcbiAgICAvLyBUeXBlIGBtb2RlbGAgYXMgYGFueWAgaGVyZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IHcvXG4gICAgLy8gdHJhaW5pbmcudHMuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIG1vZGVsOiBhbnksIGl0ZXJhdG9yT3V0OiB7fSk6IHt4czogdGZjLlRlbnNvcltdLCB5czogdGZjLlRlbnNvcltdfSB7XG4gIGxldCB4czogVGVuc29yT3JBcnJheU9yTWFwO1xuICBsZXQgeXM6IFRlbnNvck9yQXJyYXlPck1hcDtcblxuICBjb25zdCBpdGVyYXRvck91dE9iaiA9IGl0ZXJhdG9yT3V0IGFzIEZpdERhdGFzZXRFbGVtZW50O1xuICB4cyA9IGl0ZXJhdG9yT3V0T2JqWyd4cyddO1xuICB5cyA9IGl0ZXJhdG9yT3V0T2JqWyd5cyddO1xuICB0ZmMudXRpbC5hc3NlcnQoXG4gICAgICB4cyAhPSBudWxsICYmIHlzICE9IG51bGwsXG4gICAgICAoKSA9PiAnQSBEYXRhc2V0IGl0ZXJhdG9yIGZvciBmaXREYXRhc2V0KCkgaXMgZXhwZWN0ZWQgdG8gZ2VuZXJhdGUgJyArXG4gICAgICAgICAgJ29iamVjdHMgb2YgdGhlIGZvcm0gYHt4czogeFZhbCwgeXM6IHlWYWx9YCwgd2hlcmUgdGhlIHR3byAnICtcbiAgICAgICAgICAndmFsdWVzIG1heSBiZSBgdGYuVGVuc29yYCwgYW4gYXJyYXkgb2YgVGVuc29ycywgb3IgYSBtYXAgb2YgJyArXG4gICAgICAgICAgJ3N0cmluZyB0byBUZW5zb3IuICBUaGUgcHJvdmlkZWQgRGF0YXNldCBpbnN0ZWFkIGdlbmVyYXRlcyAnICtcbiAgICAgICAgICBgJHtpdGVyYXRvck91dH1gKTtcblxuICBjb25zdCBmbGF0dGVuZWRYczogdGZjLlRlbnNvcltdID1cbiAgICAgIGZsYXR0ZW5UZW5zb3JPckFycmF5T3JNYXAoJ2lucHV0JywgbW9kZWwuaW5wdXROYW1lcywgeHMpO1xuICBjb25zdCBmbGF0dGVuZWRZczogdGZjLlRlbnNvcltdID1cbiAgICAgIGZsYXR0ZW5UZW5zb3JPckFycmF5T3JNYXAoJ291dHB1dCcsIG1vZGVsLm91dHB1dE5hbWVzLCB5cyk7XG5cbiAgY29uc3QgYmF0Y2hTaXplOiBudW1iZXIgPSBmbGF0dGVuZWRYc1swXS5zaGFwZVswXTtcblxuICB0ZmMudXRpbC5hc3NlcnQoXG4gICAgICBmbGF0dGVuZWRYcy5sZW5ndGggPT09IG1vZGVsLmlucHV0cy5sZW5ndGgsXG4gICAgICAoKSA9PiBgTGF5ZXJzTW9kZWwgaGFzICR7bW9kZWwuaW5wdXRzLmxlbmd0aH0gaW5wdXRzLCBidXQgdGhlIGRhdGFzZXQgYCArXG4gICAgICAgICAgYHByb3ZpZGVzICR7ZmxhdHRlbmVkWHMubGVuZ3RofSBpbnB1dHMuICAoRXhwZWN0ZWQgaW5wdXQga2V5czogYCArXG4gICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkobW9kZWwuaW5wdXROYW1lcyl9KWApO1xuXG4gIHRmYy51dGlsLmFzc2VydChcbiAgICAgIGZsYXR0ZW5lZFlzLmxlbmd0aCA9PT0gbW9kZWwub3V0cHV0cy5sZW5ndGgsXG4gICAgICAoKSA9PlxuICAgICAgICAgIGBMYXllcnNNb2RlbCBoYXMgJHttb2RlbC5vdXRwdXRzLmxlbmd0aH0gb3V0cHV0cywgYnV0IHRoZSBkYXRhc2V0IGAgK1xuICAgICAgICAgIGBwcm92aWRlcyAke2ZsYXR0ZW5lZFlzLmxlbmd0aH0gb3V0cHV0cy4gIChFeHBlY3RlZCBvdXRwdXQga2V5czogYCArXG4gICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkobW9kZWwub3V0cHV0TmFtZXMpfSlgKTtcblxuICBmb3IgKGxldCB4SW5kZXggPSAwOyB4SW5kZXggPCBmbGF0dGVuZWRYcy5sZW5ndGg7IHhJbmRleCsrKSB7XG4gICAgdGZjLnV0aWwuYXNzZXJ0KFxuICAgICAgICBmbGF0dGVuZWRYc1t4SW5kZXhdLnNoYXBlWzBdID09PSBiYXRjaFNpemUsXG4gICAgICAgICgpID0+IGBCYXRjaCBzaXplIG1pc21hdGNoOiBpbnB1dCBgICtcbiAgICAgICAgICAgIGAke21vZGVsLmlucHV0TmFtZXNbeEluZGV4XX0gaGFzICR7XG4gICAgICAgICAgICAgICAgICBmbGF0dGVuZWRYc1t4SW5kZXhdLnNoYXBlWzBdfTsgYCArXG4gICAgICAgICAgICBgZXhwZWN0ZWQgICR7YmF0Y2hTaXplfSBiYXNlZCBvbiBpbnB1dCAke21vZGVsLmlucHV0TmFtZXNbMF19LmApO1xuICB9XG5cbiAgZm9yIChsZXQgeUluZGV4ID0gMDsgeUluZGV4IDwgZmxhdHRlbmVkWXMubGVuZ3RoOyB5SW5kZXgrKykge1xuICAgIHRmYy51dGlsLmFzc2VydChcbiAgICAgICAgZmxhdHRlbmVkWXNbeUluZGV4XS5zaGFwZVswXSA9PT0gYmF0Y2hTaXplLFxuICAgICAgICAoKSA9PiBgQmF0Y2ggc2l6ZSBtaXNtYXRjaDogb3V0cHV0IGAgK1xuICAgICAgICAgICAgYCR7bW9kZWwub3V0cHV0TmFtZXNbeUluZGV4XX0gaGFzICR7XG4gICAgICAgICAgICAgICAgICBmbGF0dGVuZWRZc1t5SW5kZXhdLnNoYXBlWzBdfTsgYCArXG4gICAgICAgICAgICBgZXhwZWN0ZWQgICR7YmF0Y2hTaXplfSBiYXNlZCBvbiBpbnB1dCAke21vZGVsLmlucHV0TmFtZXNbMF19LmApO1xuICB9XG5cbiAgcmV0dXJuIHt4czogZmxhdHRlbmVkWHMsIHlzOiBmbGF0dGVuZWRZc307XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5UZW5zb3JPckFycmF5T3JNYXAoXG4gICAgaW5wdXRPck91dHB1dDogc3RyaW5nLCBuYW1lczogc3RyaW5nW10sIHZhbHVlczogVGVuc29yT3JBcnJheU9yTWFwKSB7XG4gIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiB0ZmMuVGVuc29yKSB7XG4gICAgcmV0dXJuIFt2YWx1ZXNdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgIHRmYy51dGlsLmFzc2VydChcbiAgICAgICAgdmFsdWVzLmxlbmd0aCA9PT0gbmFtZXMubGVuZ3RoLFxuICAgICAgICAoKSA9PiBgUmVjZWl2ZWQgYW4gYXJyYXkgb2YgJHt2YWx1ZXMubGVuZ3RofSBUZW5zb3JzLCBidXQgZXhwZWN0ZWQgJHtcbiAgICAgICAgICAgIG5hbWVzLmxlbmd0aH0gdG8gbWF0Y2ggdGhlICR7aW5wdXRPck91dHB1dH0ga2V5cyAke25hbWVzfS5gKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlc3VsdDogdGZjLlRlbnNvcltdID0gW107XG4gICAgLy8gQ2hlY2sgdGhhdCBhbGwgdGhlIHJlcXVpcmVkIGtleXMgYXJlIGF2YWlsYWJsZS5cbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgIGlmICh2YWx1ZXNbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBUaGUgZmVhdHVyZSBkYXRhIGdlbmVyYXRlZCBieSB0aGUgZGF0YXNldCBsYWNrcyB0aGUgcmVxdWlyZWQgYCArXG4gICAgICAgICAgICBgJHtpbnB1dE9yT3V0cHV0fSBrZXkgJyR7bmFtZX0nLmApO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWVzW25hbWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFuZGFyZGl6ZVRlbnNvclZhbGlkYXRpb25EYXRhPFQ+KFxuICAgIGRhdGE6XG4gICAgICAgIFtcbiAgICAgICAgICB0ZmMuVGVuc29yfHRmYy5UZW5zb3JbXSwgdGZjLlRlbnNvcnx0ZmMuVGVuc29yW11cbiAgICAgICAgXXxbdGZjLlRlbnNvciB8IHRmYy5UZW5zb3JbXSwgdGZjLlRlbnNvciB8IHRmYy5UZW5zb3JbXSxcbiAgICAgICAgICAgdGZjLlRlbnNvciB8IHRmYy5UZW5zb3JbXV0pOlxuICAgIHt4czogdGZjLlRlbnNvcnx0ZmMuVGVuc29yW10sIHlzOiB0ZmMuVGVuc29yfHRmYy5UZW5zb3JbXX0ge1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDMpIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgJ1ZhbGlkYXRpb24gd2l0aCBzYW1wbGUgd2VpZ2h0cyBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICB9XG4gIHJldHVybiB7eHM6IGRhdGFbMF0sIHlzOiBkYXRhWzFdfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZpdERhdGFzZXQ8VD4oXG4gICAgLy8gVHlwZSBgbW9kZWxgIGFzIGBhbnlgIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeSB3L1xuICAgIC8vIHRyYWluaW5nLnRzLlxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICBtb2RlbDogYW55LCBkYXRhc2V0OiBEYXRhc2V0PFQ+LFxuICAgIGFyZ3M6IE1vZGVsRml0RGF0YXNldEFyZ3M8VD4pOiBQcm9taXNlPEhpc3Rvcnk+IHtcbiAgY29uc3QgaGFzQmF0Y2hlc1BlckVwb2NoID0gYXJncy5iYXRjaGVzUGVyRXBvY2ggIT0gbnVsbDtcbiAgdGZjLnV0aWwuYXNzZXJ0KFxuICAgICAgbW9kZWwub3B0aW1pemVyICE9IG51bGwsXG4gICAgICAoKSA9PiAnWW91IG11c3QgY29tcGlsZSBhIG1vZGVsIGJlZm9yZSB0cmFpbmluZy90ZXN0aW5nLiBVc2UgJyArXG4gICAgICAgICAgJ0xheWVyc01vZGVsLmNvbXBpbGUobW9kZWxDb21waWxlQ29uZmlnKS4nKTtcblxuICB0ZmMudXRpbC5hc3NlcnQoXG4gICAgICBhcmdzICE9IG51bGwsXG4gICAgICAoKSA9PiBgRm9yIGZpdERhdGFzZXQoKSwgdGhlIDJuZCBhcmd1bWVudCAoY29uZmlnKSBpcyByZXF1aXJlZCwgYCArXG4gICAgICAgICAgYGJ1dCBpdCBpcyBub3QgcHJvdmlkZWQgaW4gdGhpcyBjYWxsLmApO1xuICB0ZmMudXRpbC5hc3NlcnQoXG4gICAgICBhcmdzLmVwb2NocyAhPSBudWxsICYmIGFyZ3MuZXBvY2hzID4gMCAmJiBOdW1iZXIuaXNJbnRlZ2VyKGFyZ3MuZXBvY2hzKSxcbiAgICAgICgpID0+IGBGb3IgZml0RGF0YXNldCgpLCBjb25maWcuZXBvY2hzIGlzIGV4cGVjdGVkIHRvIGJlIGEgcG9zaXRpdmUgYCArXG4gICAgICAgICAgYGludGVnZXIsIGJ1dCBnb3QgJHthcmdzLmVwb2Noc31gKTtcbiAgdGZjLnV0aWwuYXNzZXJ0KFxuICAgICAgIWhhc0JhdGNoZXNQZXJFcG9jaCB8fFxuICAgICAgICAgIChhcmdzLmJhdGNoZXNQZXJFcG9jaCA+IDAgJiYgTnVtYmVyLmlzSW50ZWdlcihhcmdzLmJhdGNoZXNQZXJFcG9jaCkpLFxuICAgICAgKCkgPT4gYEZvciBmaXREYXRhc2V0KCksIGNvbmZpZy5iYXRjaGVzUGVyRXBvY2ggaXMgZXhwZWN0ZWQgdG8gYmUgYSBgICtcbiAgICAgICAgICBgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQsIGJ1dCBnb3QgJHthcmdzLmJhdGNoZXNQZXJFcG9jaH1gKTtcbiAgdGZjLnV0aWwuYXNzZXJ0KFxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgKGFyZ3MgYXMgYW55KVsndmFsaWRhdGlvblNwbGl0J10gPT0gbnVsbCxcbiAgICAgICgpID0+ICdgdmFsaWRhdGlvblNwbGl0YCBpcyBub3Qgc3VwcG9ydGVkIGJ5IGBmaXREYXRhc2V0KClgLiAnICtcbiAgICAgICAgICAnVXNlIHZhbGlkYXRpb25EYXRhIGluc3RlYWQuJyk7XG5cbiAgaWYgKG1vZGVsLmlzVHJhaW5pbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDYW5ub3Qgc3RhcnQgdHJhaW5pbmcgYmVjYXVzZSBhbm90aGVyIGZpdCgpIGNhbGwgaXMgb25nb2luZy4nKTtcbiAgfVxuICBtb2RlbC5pc1RyYWluaW5nID0gdHJ1ZTtcblxuICB0cnkge1xuICAgIGNvbnN0IGRvVmFsaWRhdGlvbiA9IGFyZ3MudmFsaWRhdGlvbkRhdGEgIT0gbnVsbDtcbiAgICBsZXQgdmFsWHM6IHRmYy5UZW5zb3J8dGZjLlRlbnNvcltdO1xuICAgIGxldCB2YWxZczogdGZjLlRlbnNvcnx0ZmMuVGVuc29yW107XG4gICAgaWYgKGRvVmFsaWRhdGlvbikge1xuICAgICAgaWYgKGlzRGF0YXNldE9iamVjdChhcmdzLnZhbGlkYXRpb25EYXRhKSkge1xuICAgICAgICB0ZmMudXRpbC5hc3NlcnQoXG4gICAgICAgICAgICBhcmdzLnZhbGlkYXRpb25CYXRjaGVzID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAoYXJncy52YWxpZGF0aW9uQmF0Y2hlcyA+IDAgJiZcbiAgICAgICAgICAgICAgICAgTnVtYmVyLmlzSW50ZWdlcihhcmdzLnZhbGlkYXRpb25CYXRjaGVzKSksXG4gICAgICAgICAgICAoKSA9PiBgRm9yIGZpdERhdGFzZXQoKSB3aXRoIGRhdGFzZXQtYmFzZWQgdmFsaWRhdGlvbiwgYCArXG4gICAgICAgICAgICAgICAgYGNvbmZpZy52YWxpZGF0aW9uQmF0Y2hlcyBpcyBleHBlY3RlZCBub3QgdG8gYmUgcHJvdmlkZWQsIGAgK1xuICAgICAgICAgICAgICAgIGBvciB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGAgK1xuICAgICAgICAgICAgICAgIGBidXQgZ290ICR7YXJncy52YWxpZGF0aW9uQmF0Y2hlc31gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25EYXRhID0gc3RhbmRhcmRpemVUZW5zb3JWYWxpZGF0aW9uRGF0YShcbiAgICAgICAgICAgIGFyZ3MudmFsaWRhdGlvbkRhdGEgYXNcbiAgICAgICAgICAgICAgICAgICAgW3RmYy5UZW5zb3IgfCB0ZmMuVGVuc29yW10sIHRmYy5UZW5zb3IgfCB0ZmMuVGVuc29yW11dIHxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgdGZjLlRlbnNvciB8IHRmYy5UZW5zb3JbXSwgdGZjLlRlbnNvciB8IHRmYy5UZW5zb3JbXSxcbiAgICAgICAgICAgICAgdGZjLlRlbnNvciB8IHRmYy5UZW5zb3JbXVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIHZhbFhzID0gdmFsaWRhdGlvbkRhdGEueHM7XG4gICAgICAgIHZhbFlzID0gdmFsaWRhdGlvbkRhdGEueXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdHJhaW5GdW5jdGlvbiA9IG1vZGVsLm1ha2VUcmFpbkZ1bmN0aW9uKCk7XG4gICAgY29uc3Qgb3V0TGFiZWxzID0gbW9kZWwuZ2V0RGVkdXBlZE1ldHJpY3NOYW1lcygpIGFzIHN0cmluZ1tdO1xuXG4gICAgbGV0IGNhbGxiYWNrTWV0cmljczogc3RyaW5nW107XG4gICAgaWYgKGRvVmFsaWRhdGlvbikge1xuICAgICAgY2FsbGJhY2tNZXRyaWNzID1cbiAgICAgICAgICBvdXRMYWJlbHMuc2xpY2UoKS5jb25jYXQob3V0TGFiZWxzLm1hcChuID0+ICd2YWxfJyArIG4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2tNZXRyaWNzID0gb3V0TGFiZWxzLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgY2FsbGJhY2tzID0gc3RhbmRhcmRpemVDYWxsYmFja3MoYXJncy5jYWxsYmFja3MsIGFyZ3MueWllbGRFdmVyeSk7XG4gICAgY29uc3QgdmVyYm9zZSA9IGFyZ3MudmVyYm9zZSA9PSBudWxsID8gMSA6IGFyZ3MudmVyYm9zZTtcbiAgICBjb25zdCB7Y2FsbGJhY2tMaXN0LCBoaXN0b3J5fSA9IGNvbmZpZ3VyZUNhbGxiYWNrcyhcbiAgICAgICAgY2FsbGJhY2tzLCB2ZXJib3NlLCBhcmdzLmVwb2NocywgbnVsbCwgbnVsbCxcbiAgICAgICAgZ2V0U3RlcHNQZXJFcG9jaChkYXRhc2V0LCBhcmdzKSxcbiAgICAgICAgbnVsbCwgIC8vIEJhdGNoIHNpemUgZGV0ZXJtaW5lZCBieSB0aGUgZGF0YXNldCBpdHNlbGYuXG4gICAgICAgIGRvVmFsaWRhdGlvbiwgY2FsbGJhY2tNZXRyaWNzKTtcbiAgICBjYWxsYmFja0xpc3Quc2V0TW9kZWwobW9kZWwpO1xuICAgIG1vZGVsLmhpc3RvcnkgPSBoaXN0b3J5O1xuXG4gICAgYXdhaXQgY2FsbGJhY2tMaXN0Lm9uVHJhaW5CZWdpbigpO1xuICAgIG1vZGVsLnN0b3BUcmFpbmluZ18gPSBmYWxzZTtcbiAgICBsZXQgZXBvY2ggPSBhcmdzLmluaXRpYWxFcG9jaCA9PSBudWxsID8gMCA6IGFyZ3MuaW5pdGlhbEVwb2NoO1xuXG4gICAgbGV0IGRhdGFJdGVyYXRvciA9IGF3YWl0IGRhdGFzZXQuaXRlcmF0b3IoKTtcbiAgICB3aGlsZSAoZXBvY2ggPCBhcmdzLmVwb2Nocykge1xuICAgICAgY29uc3QgZXBvY2hMb2dzOiBVbnJlc29sdmVkTG9ncyA9IHt9O1xuICAgICAgYXdhaXQgY2FsbGJhY2tMaXN0Lm9uRXBvY2hCZWdpbihlcG9jaCk7XG4gICAgICBsZXQgc3RlcHNEb25lID0gMDtcbiAgICAgIGxldCBiYXRjaEluZGV4ID0gMDtcbiAgICAgIGlmICghaGFzQmF0Y2hlc1BlckVwb2NoKSB7XG4gICAgICAgIGRhdGFJdGVyYXRvciA9IGF3YWl0IGRhdGFzZXQuaXRlcmF0b3IoKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChoYXNCYXRjaGVzUGVyRXBvY2ggPyBzdGVwc0RvbmUgPCBhcmdzLmJhdGNoZXNQZXJFcG9jaCA6IHRydWUpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3JPdXQgPSBhd2FpdCBkYXRhSXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgIC8vIElmIGBiYXRjaGVzUGVyRXBvY2hgIGlzIHNwZWNpZmllZCwgdGhlIGRhdGFzZXQgc2hvdWxkIG5vdCBiZVxuICAgICAgICAvLyBleGhhdXN0ZWQgdW50aWwgYWxsIGVwb2NoZXMgYXJlIGRvbmUuXG4gICAgICAgIGlmIChoYXNCYXRjaGVzUGVyRXBvY2ggJiYgaXRlcmF0b3JPdXQuZG9uZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ1lvdSBwcm92aWRlZCBgYmF0Y2hlc1BlckVwb2NoYCBhcyAnICtcbiAgICAgICAgICAgICAgYCR7YXJncy5iYXRjaGVzUGVyRXBvY2h9LCBgICtcbiAgICAgICAgICAgICAgJ2J1dCB5b3VyIGRhdGFzZXQgaXRlcmF0b3IgcmFuIG91dCBvZiBkYXRhIGFmdGVyICcgK1xuICAgICAgICAgICAgICBgJHtzdGVwc0RvbmV9IGJhdGNoZXM7IGAgK1xuICAgICAgICAgICAgICAnaW50ZXJydXB0aW5nIHRyYWluaW5nLiBNYWtlIHN1cmUgdGhhdCB5b3VyICcgK1xuICAgICAgICAgICAgICAnZGF0YXNldCBjYW4gZ2VuZXJhdGUgYXQgbGVhc3QgYGJhdGNoZXNQZXJFcG9jaCAqIGVwb2Noc2AgJyArXG4gICAgICAgICAgICAgICdiYXRjaGVzIChpbiB0aGlzIGNhc2UsICcgK1xuICAgICAgICAgICAgICBgJHthcmdzLmJhdGNoZXNQZXJFcG9jaCAqIGFyZ3MuZXBvY2hzfSBiYXRjaGVzKS4gYCArXG4gICAgICAgICAgICAgICdZb3UgbWF5IG5lZWQgdG8gdXNlIHRoZSByZXBlYXQoKSBmdW5jdGlvbiB3aGVuIGJ1aWxkaW5nICcgK1xuICAgICAgICAgICAgICAneW91ciBkYXRhc2V0LicpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZXJhdG9yT3V0LnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCB7eHMsIHlzfSA9XG4gICAgICAgICAgICAgIHN0YW5kYXJkaXplRGF0YUl0ZXJhdG9yT3V0cHV0KG1vZGVsLCBpdGVyYXRvck91dC52YWx1ZSk7XG4gICAgICAgICAgY29uc3QgYmF0Y2hMb2dzOiBVbnJlc29sdmVkTG9ncyA9IHt9O1xuICAgICAgICAgIGJhdGNoTG9nc1snYmF0Y2gnXSA9IGJhdGNoSW5kZXg7XG4gICAgICAgICAgYmF0Y2hMb2dzWydzaXplJ10gPSB4c1swXS5zaGFwZVswXTtcblxuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrTGlzdC5vbkJhdGNoQmVnaW4oYmF0Y2hJbmRleCwgYmF0Y2hMb2dzKTtcblxuICAgICAgICAgIGNvbnN0IHNhbXBsZVdlaWdodHM6IHRmYy5UZW5zb3JbXSA9IFtdO1xuICAgICAgICAgIGlmIChhcmdzLmNsYXNzV2VpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YW5kYXJkQ2xhc3NXZWlnaHRzID1cbiAgICAgICAgICAgICAgICBzdGFuZGFyZGl6ZUNsYXNzV2VpZ2h0cyhhcmdzLmNsYXNzV2VpZ2h0LCBtb2RlbC5vdXRwdXROYW1lcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YW5kYXJkQ2xhc3NXZWlnaHRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHNhbXBsZVdlaWdodHMucHVzaChhd2FpdCBzdGFuZGFyZGl6ZVdlaWdodHMoXG4gICAgICAgICAgICAgICAgICB5c1tpXSwgbnVsbCwgc3RhbmRhcmRDbGFzc1dlaWdodHNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUcmFpbiBvbiBiYXRjaC5cbiAgICAgICAgICBjb25zdCBpbnMgPSB4cy5jb25jYXQoeXMpLmNvbmNhdChzYW1wbGVXZWlnaHRzKTtcbiAgICAgICAgICBjb25zdCBvdXRzID0gdHJhaW5GdW5jdGlvbihpbnMpO1xuICAgICAgICAgIHRmYy5kaXNwb3NlKGlucyk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gb3V0TGFiZWxzW2ldO1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gb3V0c1tpXTtcbiAgICAgICAgICAgIGJhdGNoTG9nc1tsYWJlbF0gPSBvdXQ7XG4gICAgICAgICAgICB0ZmMua2VlcChvdXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrTGlzdC5vbkJhdGNoRW5kKGJhdGNoSW5kZXgsIGJhdGNoTG9ncyk7XG4gICAgICAgICAgZGlzcG9zZVRlbnNvcnNJbkxvZ3MoYmF0Y2hMb2dzKTtcblxuICAgICAgICAgIGJhdGNoSW5kZXgrKztcbiAgICAgICAgICBzdGVwc0RvbmUrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNCYXRjaGVzUGVyRXBvY2ggPyBzdGVwc0RvbmUgPj0gYXJncy5iYXRjaGVzUGVyRXBvY2ggOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3JPdXQuZG9uZSkge1xuICAgICAgICAgIC8vIEVwb2NoIGZpbmlzaGVkLiBQZXJmb3JtIHZhbGlkYXRpb24uXG4gICAgICAgICAgaWYgKGRvVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgbGV0IHZhbE91dHM6IHRmYy5TY2FsYXJbXTtcbiAgICAgICAgICAgIGlmIChpc0RhdGFzZXRPYmplY3QoYXJncy52YWxpZGF0aW9uRGF0YSkpIHtcbiAgICAgICAgICAgICAgdmFsT3V0cyA9IHRvTGlzdChhd2FpdCBtb2RlbC5ldmFsdWF0ZURhdGFzZXQoXG4gICAgICAgICAgICAgICAgICBhcmdzLnZhbGlkYXRpb25EYXRhLCB7YmF0Y2hlczogYXJncy52YWxpZGF0aW9uQmF0Y2hlc30pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbE91dHMgPSB0b0xpc3QobW9kZWwuZXZhbHVhdGUodmFsWHMsIHZhbFlzLCB7XG4gICAgICAgICAgICAgICAgYmF0Y2hTaXplOiBhcmdzLnZhbGlkYXRpb25CYXRjaFNpemUgPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgIERFRkFVTFRfVkFMSURBVElPTl9CQVRDSF9TSVpFIDpcbiAgICAgICAgICAgICAgICAgICAgYXJncy52YWxpZGF0aW9uQmF0Y2hTaXplLFxuICAgICAgICAgICAgICAgIHZlcmJvc2U6IDBcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RlbC5tZXRyaWNzTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgZXBvY2hMb2dzW2B2YWxfJHttb2RlbC5tZXRyaWNzTmFtZXNbaV19YF0gPSB2YWxPdXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIGBicmVha2AgdG8gZXhpdCBvbmUgZXBvY2ggbG9wcCBhZnRlciB2YWxpZGF0aW9uIGlzIGRvbmUuIElmXG4gICAgICAgICAgLy8gY29uZmlnLmJhdGNoZXNQZXJFcG9jaCBpcyBzcGVjaWZpZWQsIGFuIGVwb2NoIHdoaWxlIGxvb3Agd2lsbFxuICAgICAgICAgIC8vIHN0b3Agd2hlbiBgc3RlcHNEb25lID49IGNvbmZpZy5iYXRjaGVzUGVyRXBvY2hgLiBXaGVuXG4gICAgICAgICAgLy8gY29uZmlnLmJhdGNoZXNQZXJFcG9jaCBpcyBub3QgcHJvdmlkZWQsIHRoZSBmb2xsb3dpbmcgYGJyZWFrYCBpc1xuICAgICAgICAgIC8vIHJlcXVpcmVkIHRvIGV4aXQgdGhlIHdoaWxlIGxvcHAgYWZ0ZXIgZGF0YXNldCBpcyBleGhhdXN0ZWQuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kZWwuc3RvcFRyYWluaW5nXykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FpdCBjYWxsYmFja0xpc3Qub25FcG9jaEVuZChlcG9jaCwgZXBvY2hMb2dzKTtcbiAgICAgIGVwb2NoKys7XG4gICAgICBpZiAobW9kZWwuc3RvcFRyYWluaW5nXykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgYXdhaXQgY2FsbGJhY2tMaXN0Lm9uVHJhaW5FbmQoKTtcbiAgICBhd2FpdCBtb2RlbC5oaXN0b3J5LnN5bmNEYXRhKCk7XG4gICAgcmV0dXJuIG1vZGVsLmhpc3Rvcnk7XG4gIH0gZmluYWxseSB7XG4gICAgbW9kZWwuaXNUcmFpbmluZyA9IGZhbHNlO1xuICB9XG59XG5cbi8qKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIG51bWJlciBvZiBzdGVwcyAoYmF0Y2hlcykgcGVyIGVwb2NoLiAqL1xuZnVuY3Rpb24gZ2V0U3RlcHNQZXJFcG9jaDxUPihcbiAgICBkYXRhc2V0OiBEYXRhc2V0PFQ+LCBhcmdzOiBNb2RlbEZpdERhdGFzZXRBcmdzPFQ+KTogbnVtYmVyIHtcbiAgLy8gQXR0ZW1wdCB0byBkZXRlcm1pbmUgIyBvZiBiYXRjaGVzIGluIGFuIGVwb2NoLlxuICBsZXQgc3RlcHNQZXJFcG9jaDogbnVtYmVyID0gbnVsbDtcbiAgaWYgKGFyZ3MuYmF0Y2hlc1BlckVwb2NoICE9IG51bGwpIHtcbiAgICBzdGVwc1BlckVwb2NoID0gYXJncy5iYXRjaGVzUGVyRXBvY2g7XG4gIH0gZWxzZSBpZiAoTnVtYmVyLmlzRmluaXRlKGRhdGFzZXQuc2l6ZSkpIHtcbiAgICBzdGVwc1BlckVwb2NoID0gZGF0YXNldC5zaXplO1xuICB9XG4gIHJldHVybiBzdGVwc1BlckVwb2NoO1xufVxuXG4vLyBDaGVjayBpZiBwcm92aWRlZCBvYmplY3QgaXMgYSBEYXRhc2V0IG9iamVjdCBieSBjaGVja2luZyBpdHMgLml0ZXJhdG9yXG4vLyBlbGVtZW50LlxuZnVuY3Rpb24gaXNEYXRhc2V0T2JqZWN0PFQ+KFxuICAgIGRhdGFzZXQ6XG4gICAgICAgIFtcbiAgICAgICAgICBUZW5zb3JPckFycmF5T3JNYXAsIFRlbnNvck9yQXJyYXlPck1hcFxuICAgICAgICBdfFtUZW5zb3JPckFycmF5T3JNYXAsIFRlbnNvck9yQXJyYXlPck1hcCwgVGVuc29yT3JBcnJheU9yTWFwXXxcbiAgICBEYXRhc2V0PFQ+KTogYm9vbGVhbiB7XG4gIHJldHVybiAodHlwZW9mIChkYXRhc2V0IGFzIERhdGFzZXQ8VD4pLml0ZXJhdG9yID09PSAnZnVuY3Rpb24nKTtcbn1cblxuLy8gQ2hlY2sgaWYgcHJvdmlkZWQgb2JqZWN0IGlzIGEgTGF6eUl0ZXJhdG9yIG9iamVjdCBieSBjaGVja2luZyBpdCdzIC5uZXh0XG4vLyBlbGVtZW50LlxuZnVuY3Rpb24gaXNMYXp5SXRlcmF0b3JPYmplY3Q8VD4oaXRlcmF0b3I6IERhdGFzZXQ8VD58XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYXp5SXRlcmF0b3I8VD4pOiBib29sZWFuIHtcbiAgcmV0dXJuICh0eXBlb2YgKGl0ZXJhdG9yIGFzIExhenlJdGVyYXRvcjxUPikubmV4dCA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBldmFsdWF0ZURhdGFzZXQ8VD4oXG4gICAgLy8gVHlwZSBgbW9kZWxgIGFzIGBhbnlgIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeSB3L1xuICAgIC8vIHRyYWluaW5nLnRzLlxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICBtb2RlbDogYW55LCBkYXRhc2V0OiBEYXRhc2V0PFQ+fExhenlJdGVyYXRvcjxUPixcbiAgICBhcmdzOiBNb2RlbEV2YWx1YXRlRGF0YXNldEFyZ3MpOiBQcm9taXNlPHRmYy5TY2FsYXJ8dGZjLlNjYWxhcltdPiB7XG4gIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICBjb25zdCBoYXNCYXRjaGVzID0gYXJncy5iYXRjaGVzICE9IG51bGw7XG4gIGNvbnN0IGYgPSBtb2RlbC50ZXN0RnVuY3Rpb247XG4gIGxldCBvdXRzOiB0ZmMuU2NhbGFyW10gPSBbXTtcbiAgaWYgKGFyZ3MudmVyYm9zZSA+IDApIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignVmVyYm9zZSBtb2RlIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gIH1cblxuICB0ZmMudXRpbC5hc3NlcnQoXG4gICAgICAhaGFzQmF0Y2hlcyB8fCAoYXJncy5iYXRjaGVzID4gMCAmJiBOdW1iZXIuaXNJbnRlZ2VyKGFyZ3MuYmF0Y2hlcykpLFxuICAgICAgKCkgPT4gJ1Rlc3QgbG9vcCBleHBlY3RzIGBiYXRjaGVzYCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCAnICtcbiAgICAgICAgICBgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShhcmdzLmJhdGNoZXMpfWApO1xuICBjb25zdCBkYXRhSXRlcmF0b3IgPSBpc0xhenlJdGVyYXRvck9iamVjdChkYXRhc2V0KSA/XG4gICAgICBkYXRhc2V0IGFzIExhenlJdGVyYXRvcjxUPjpcbiAgICAgIGF3YWl0IChkYXRhc2V0IGFzIERhdGFzZXQ8VD4pLml0ZXJhdG9yKCk7XG4gIC8vIEtlZXBzIHRyYWNrIG9mIG51bWJlciBvZiBleGFtcGxlcyB1c2VkIGluIHRoaXMgZXZhbHVhdGlvbi5cbiAgbGV0IG51bUV4YW1wbGVzID0gMDtcbiAgbGV0IGJhdGNoID0gMDtcblxuICB3aGlsZSAoaGFzQmF0Y2hlcyA/IGJhdGNoIDwgYXJncy5iYXRjaGVzIDogdHJ1ZSkge1xuICAgIGNvbnN0IGl0ZXJhdG9yT3V0ID0gYXdhaXQgZGF0YUl0ZXJhdG9yLm5leHQoKTtcbiAgICBvdXRzID0gdGZjLnRpZHkoKCkgPT4ge1xuICAgICAgaWYgKGl0ZXJhdG9yT3V0LnZhbHVlKSB7XG4gICAgICAgIC8vIFRPRE8oY2Fpcyk6IE9uY2UgcmVhbCBkYXRhc2V0IGlzIGF2YWlsYWJsZSwgdXNlXG4gICAgICAgIC8vICAgYG1hcCh4ID0+IHN0YW5kYXJkaXplRGF0YUl0ZXJhdG9yT3V0cHV0KG1vZGVsLCB4KS5tYXAoZilgLlxuICAgICAgICBjb25zdCB7eHMsIHlzfSA9XG4gICAgICAgICAgICBzdGFuZGFyZGl6ZURhdGFJdGVyYXRvck91dHB1dChtb2RlbCwgaXRlcmF0b3JPdXQudmFsdWUpO1xuICAgICAgICBjb25zdCB4c0FuZFlzID0geHMuY29uY2F0KHlzKTtcbiAgICAgICAgY29uc3QgYmF0Y2hPdXRzID0gdGZjLnRpZHkoKCkgPT4gZih4c0FuZFlzKSk7XG4gICAgICAgIHRmYy5kaXNwb3NlKHhzQW5kWXMpO1xuXG4gICAgICAgIGlmIChiYXRjaCA9PT0gMCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hPdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBvdXRzLnB1c2goc2NhbGFyKDApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiYXRjaFNpemUgPSB4c0FuZFlzWzBdLnNoYXBlWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoT3V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IGJhdGNoT3V0ID0gYmF0Y2hPdXRzW2ldO1xuICAgICAgICAgIGNvbnN0IG9sZFNjYWxhciA9IG91dHNbaV07XG4gICAgICAgICAgb3V0c1tpXSA9XG4gICAgICAgICAgICAgIHRmYy50aWR5KCgpID0+IHRmYy5hZGQob3V0c1tpXSwgdGZjLm11bChiYXRjaFNpemUsIGJhdGNoT3V0KSkpO1xuICAgICAgICAgIGlmIChiYXRjaCA+IDApIHtcbiAgICAgICAgICAgIHRmYy5kaXNwb3NlKG9sZFNjYWxhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRmYy5kaXNwb3NlKGJhdGNoT3V0cyk7XG4gICAgICAgIG51bUV4YW1wbGVzICs9IGJhdGNoU2l6ZTtcblxuICAgICAgICArK2JhdGNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHM7XG4gICAgfSk7XG5cbiAgICBpZiAoaXRlcmF0b3JPdXQuZG9uZSkge1xuICAgICAgaWYgKGhhc0JhdGNoZXMpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ1lvdXIgZGF0YXNldCBpdGVyYXRvciByYW4gb3V0IG9mIGRhdGEgZHVyaW5nIGV2YWx1YXRlRGF0YXNldCgpLiAnICtcbiAgICAgICAgICAgICdJbnRlcnJ1cHRpbmcgZXZhbHV0aW9uLiBNYWtlIHN1cmUgdGhhdCB5b3VyICcgK1xuICAgICAgICAgICAgJ2RhdGFzZXQgY2FuIGdlbmVyYXRlIGF0IGxlYXN0IGBiYXRjaGVzYCAnICtcbiAgICAgICAgICAgIGBiYXRjaGVzIChpbiB0aGlzIGNhc2UsICR7YXJncy5iYXRjaGVzfSBiYXRjaGVzKS4gYCArXG4gICAgICAgICAgICAnWW91IG1heSBuZWVkIHRvIHVzZSB0aGUgcmVwZWF0KCkgZnVuY3Rpb24gd2hlbiBidWlsZGluZyAnICtcbiAgICAgICAgICAgICd5b3VyIGRhdGFzZXQuJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBvbGRTY2FsYXIgPSBvdXRzW2ldO1xuICAgIG91dHNbaV0gPSB0ZmMuZGl2KG91dHNbaV0sIG51bUV4YW1wbGVzKTtcbiAgICB0ZmMuZGlzcG9zZShvbGRTY2FsYXIpO1xuICB9XG5cbiAgcmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkob3V0cyk7XG59XG4iXX0="],"names":["standardizeSampleOrClassWeights","xWeight","outputNames","weightType","numOutputs","length","Array","isArray","map","name","Error","Object","keys","output","forEach","outputName","push","JSON","stringify","standardizeClassWeights","classWeight","async","standardizeWeights","y","sampleWeight","sampleWeightMode","yClasses","tidy","shape","clone","axis","argMax","reshape","rank","yClassIndices","from","data","dispose","classSampleWeight","classIndex","tensor1d","computeWeightedLoss","losses","sampleWeights","mul","checkBatchSize","batchSize","Number","isInteger","sliceArrays","arrays","start","stop","array","sliceArraysByIndices","indices","dtype","makeBatches","size","batchStart","batchEnd","ensureTensorsRank2OrHigher","tensors","outs","Tensor","i","tensor","disposeNewTensors","refTensors","oldTensorIds","id","t","oldTensor","tensorsToDispose","indexOf","isDisposed","DEFAULT_VALIDATION_BATCH_SIZE","standardizeDataIteratorOutput","model","iteratorOut","xs","ys","iteratorOutObj","flattenedXs","flattenTensorOrArrayOrMap","inputNames","flattenedYs","inputs","outputs","xIndex","yIndex","inputOrOutput","names","values","result","fitDataset","dataset","args","hasBatchesPerEpoch","batchesPerEpoch","optimizer","epochs","isTraining","doValidation","validationData","valXs","valYs","isDatasetObject","validationBatches","standardizeTensorValidationData","trainFunction","makeTrainFunction","outLabels","getDedupedMetricsNames","callbackMetrics","slice","concat","n","callbacks","yieldEvery","verbose","callbackList","history","stepsPerEpoch","isFinite","getStepsPerEpoch","setModel","onTrainBegin","stopTraining_","epoch","initialEpoch","dataIterator","iterator","epochLogs","onEpochBegin","stepsDone","batchIndex","next","done","value","batchLogs","onBatchBegin","standardClassWeights","ins","label","out","onBatchEnd","valOuts","evaluateDataset","batches","evaluate","validationBatchSize","metricsNames","onEpochEnd","onTrainEnd","syncData","hasBatches","f","testFunction","numExamples","batch","xsAndYs","batchOuts","scalar","batchOut","oldScalar"],"sourceRoot":""}