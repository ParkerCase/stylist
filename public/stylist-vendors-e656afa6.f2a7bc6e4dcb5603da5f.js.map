{"version":3,"file":"stylist-vendors-e656afa6.f2a7bc6e4dcb5603da5f.js","mappings":"0YA2OO,MAAM,GAAyB,IAAAA,IAAG,CAAEC,aAnJ3C,UAAsB,EAAEC,EAAC,OAAEC,EAAM,QAAEC,EAAO,IAAEC,EAAG,WAAEC,EAAa,OAAM,UAAEC,EAAY,CAAC,EAAG,GAAE,gBAAEC,EAAe,KAAEC,EAAI,WAAEC,EAAa,SAAQ,uBAAEC,EAAsB,eAAEC,IAE5J,GADAF,EAAaA,GAAc,UACgC,KAAvD,QAAW,KAAOG,MAAMC,cAAeJ,GAAuB,CAG9D,KAA2B,SAAfJ,GAAuB,IAAM,4CAA4CA,iHAGrF,IAAIS,GAAS,OAAcb,EAAGC,EAAQC,EAASC,EAAKC,EAAYC,EAAWC,GAI3E,OAHY,MAARC,IACAM,GAAS,EAAAC,EAAA,GAAID,EAAQN,KAElB,QAAgBM,EAAQL,EAAYC,EAAwBC,EACvE,CACA,MAAMK,GAAK,QAAgBf,EAAG,IAAK,SAAU,WACvCgB,GAAU,QAAgBf,EAAQ,SAAU,SAAU,WAC5D,IAAIgB,EAAMF,EACNG,GAAe,EACH,IAAZH,EAAGI,OACHD,GAAe,EACfD,GAAM,EAAAG,EAAA,GAAQL,EAAI,CAAC,EAAGA,EAAGM,MAAM,GAAIN,EAAGM,MAAM,GAAIN,EAAGM,MAAM,MAE7D,KAAyB,IAAbJ,EAAIE,MAAY,IACxB,6DAAGF,EAAIE,UACX,KAA6B,IAAjBH,EAAQG,MAAY,IAC5B,8DAAGH,EAAQG,UACfG,EAAA,GAAoC,eAAgBnB,EAAKG,GACzD,MAAMiB,EAA+B,SAAfnB,EAAwBa,EAAII,MAAM,GAAKJ,EAAII,MAAM,GACvE,KAAYL,EAAQK,MAAM,KAAOE,GAAe,IAAM,oCAAoCA,wCAC5DP,EAAQK,MAAM,QAC5C,KAAYC,EAAA,GAAyCpB,EAASG,IAAY,IACtE,uEAAeH,oBAA0BG,OAC7C,MAAMmB,EAAWF,EAAA,GAA4BL,EAAII,MAAOL,EAAQK,MAAOnB,EAASG,EAAWF,EAAKG,GAChG,IAAImB,EAuBAC,EACJ,GAvBY,MAARnB,IACAkB,GAAQ,QAAgBlB,EAAM,OAAQ,iBACrCkB,IAAS,IAAAE,gBAAeF,EAAOV,GAOb,SAAfX,EACAwB,EAAeC,2BAA2BL,EAASM,SAAUL,EAAMJ,QAGnE,KAAYI,EAAMJ,MAAMU,QAAU,GAAG,IAEjC,2GAAQN,EAAMJ,MAAMU,YACxB,KAAmC,IAAvBN,EAAMJ,MAAMU,QAAgBN,EAAMJ,MAAM,KAAOG,EAASQ,aAC7C,IAAnBP,EAAMJ,MAAM,IAAU,IAAM,sCAAsCI,EAAMJ,gEAEpEG,EAASQ,mBAIK,MAA1BvB,EAAgC,CAGhC,MAAMwB,EAAaxB,EAAuBY,MAI1C,GAHA,KAAYY,EAAWF,QAAU,GAA2B,IAAtBE,EAAWF,QAAc,IAE3D,2HAAQE,EAAWF,YACG,IAAtBE,EAAWF,OAIX,KAA8B,IAAlBE,EAAW,IAAYA,EAAW,KAAOT,EAASQ,aAAa,IACvE,oDAAIC,4DACST,EAASQ,uBAEzB,GAA0B,IAAtBC,EAAWF,OAGhB,IACIH,EAAeC,2BAA2BI,EAAYT,EAASM,SACnE,CACA,MAAOI,GACH,MAAMC,EAAS,oDAAoDF,6DAE3DT,EAASM,aACjB,MAAMM,MAAMD,EAChB,CAEJT,GAA0B,QAAgBjB,EAAwB,gBAAiB,eACvF,CACA,MAAM4B,EAAO,CAACC,EAAIC,KACd,KAA2B,SAAfnC,GAAuB,IAAM,wDAAwDA,4CACjG,MAAOY,EAASC,EAAKuB,EAAGf,GAASc,EAC3BE,GAAe,QAAqBH,EAAIE,EAAGhC,GACjD,KAAYc,EAAA,GAA4BjB,IAAY,IAEhD,uHAAsDA,OAC1D,MAEMqC,EAAM,EAFC,OAAoBzB,EAAII,MAAOoB,EAAczB,EAASd,EAASC,IAC1D,OAAqBc,EAAKwB,EAAczB,EAAQK,MAAOnB,EAASC,IAElF,GAAa,MAATsB,EAAe,CACf,MAAMkB,GAAU,QAAqBlB,EAAOgB,GAC5CC,EAAIE,KAAKD,EACb,CACA,OAAOD,CAAG,EAERG,EAAS,CACX7C,EAAGiB,EACHhB,OAAQe,EACRT,KAAMkB,EACNhB,uBAAwBiB,GAEtBoB,EAAQ,CACV5C,UACAC,MACAC,aACAC,YACAC,kBACAE,aACAE,kBAIJ,GAAY,MAARH,EAAc,CACd,MAAMwC,GAAW,SAAW,CAAC9B,EAAKhB,EAAQ+C,KACtC,IAAIC,EAEJ,KAAOC,UAAU,MAAaL,EAAQC,GAMtC,OALAE,EAAK,CAAC/C,EAAQgB,EAAKgC,IACf/B,IAEA+B,GAAM,EAAA7B,EAAA,GAAQ6B,EAAK,CAACA,EAAI5B,MAAM,GAAI4B,EAAI5B,MAAM,GAAI4B,EAAI5B,MAAM,MAEvD,CAAE8B,MAAOF,EAAKG,SAAUf,EAAM,IAEzC,OAAOU,EAAS9B,EAAKD,EACzB,CACK,CACD,MAAMqC,GAAmB,SAAW,CAACpC,EAAKhB,EAAQM,EAAMyC,KACpD,IAAIC,EAAM,KAAOC,UAAU,MAAaL,EAAQC,GAMhD,OALAE,EAAK,CAAC/C,EAAQgB,EAAKgC,EAAK1C,IACpBW,IAEA+B,GAAM,EAAA7B,EAAA,GAAQ6B,EAAK,CAACA,EAAI5B,MAAM,GAAI4B,EAAI5B,MAAM,GAAI4B,EAAI5B,MAAM,MAEvD,CAAE8B,MAAOF,EAAKG,SAAUf,EAAM,IAEzC,OAAOgB,EAAiBpC,EAAKD,EAASS,EAC1C,CACJ,I,qCCtDO,MAAM6B,GAAkC,IAAAxD,IAAG,CAAEyD,sBAlGpD,UAA+B,EAAEvD,EAAC,OAAEC,EAAM,QAAEC,EAAO,IAAEC,EAAG,WAAEC,EAAa,OAAM,UAAEC,EAAY,CAAC,EAAG,GAAE,gBAAEC,EAAe,KAAEC,EAAI,WAAEC,EAAa,SAAQ,uBAAEC,EAAsB,eAAEC,IACrK,IAA2D,KAAvD,QAAW,KAAOC,MAAMC,cAAeJ,GAAuB,CAC9D,IAAIK,GAAS,OAAuBb,EAAGC,EAAQC,EAASC,EAAKC,EAAYC,EAAWC,GAIpF,OAHY,MAARC,IACAM,GAAS,EAAAC,EAAA,GAAID,EAAQN,KAElB,QAAgBM,EAAQL,EAAYC,EAAwBC,EACvE,CACA,MAAMK,GAAK,QAAgBf,EAAG,IAAK,kBAAmB,WAChDgB,GAAU,QAAgBf,EAAQ,SAAU,kBAAmB,WACrE,IAAIgB,EAAMF,EACNG,GAAe,EACH,IAAZH,EAAGI,OACHD,GAAe,EACfD,GAAM,EAAAG,EAAA,GAAQL,EAAI,CAAC,EAAGA,EAAGM,MAAM,GAAIN,EAAGM,MAAM,GAAIN,EAAGM,MAAM,MAE7D,KAAyB,IAAbJ,EAAIE,MAAY,IACxB,sEAAQF,EAAIE,UAChB,KAA6B,IAAjBH,EAAQG,MAAY,IAC5B,uEAAgBH,EAAQG,UAC5B,KAAYF,EAAII,MAAM,KAAOL,EAAQK,MAAM,IAAI,IAC3C,6DAAIJ,EAAII,MAAM,qDACJL,EAAQK,MAAM,QACX,MAAbhB,IACAA,EAAY,CAAC,EAAG,IAEpB,KAAYiB,EAAA,GAAyCpB,EAASG,IAAY,IACtE,sFAAqBH,oBAA0BG,OACnDiB,EAAA,GAAoC,wBAAyBnB,EAAKG,GAClE,MAAMkB,EAAWF,EAAA,GAA4BL,EAAII,MAAOL,EAAQK,MAAOnB,EAASG,EAAWF,EAAKG,GAAiB,GACjH,IAAImB,EAMAC,EALQ,MAARnB,IACAkB,GAAQ,QAAgBlB,EAAM,OAAQ,iBACrCkB,IAAS,IAAAE,gBAAeF,EAAOV,GAChCa,EAAeC,2BAA2BL,EAASM,SAAUL,EAAMJ,QAGzC,MAA1BZ,IACAiB,GAA0B,QAAgBjB,EAAwB,gBAAiB,0BAEvF,MAAM4B,EAAO,CAACC,EAAIC,KACd,KAAYjB,EAAA,GAA4BjB,IAAY,IAEhD,mHAAIA,OACR,MAAOW,EAASC,EAAKuB,EAAGjC,GAAQgC,EAC1BE,GAAe,QAAqBH,EAAIE,EAAGhC,GAC3CgD,GAAO,OAAmCvC,EAAII,MAAOoB,EAAczB,EAASd,EAASC,EAAKE,EAAWC,GACrGmD,GAAY,OAAoCxC,EAAKwB,EAAczB,EAAQK,MAAOnB,EAASC,EAAKE,EAAWC,GACjH,GAAY,MAARC,EAAc,CAEd,MAAO,CAACiD,EAAMC,GADE,QAAqBhC,EAAOgB,GAEhD,CACA,MAAO,CAACe,EAAMC,EAAU,EAEtBZ,EAAS,CACX7C,EAAGiB,EACHhB,OAAQe,EACRT,KAAMkB,EACNhB,uBAAwBiB,GAEtBoB,EAAQ,CACV5C,UACAC,MACAC,aACAC,YACAC,kBACAE,aACAE,kBAIJ,GAAY,MAARH,EAAc,CACd,MAAMwC,GAAW,SAAW,CAAC9B,EAAKhB,EAAQ+C,KAEtC,IAAIC,EAAM,KAAOC,UAAU,MAAsBL,EAAQC,GAMzD,OALAE,EAAK,CAAC/C,EAAQgB,EAAKgC,IACf/B,IAEA+B,GAAM,EAAA7B,EAAA,GAAQ6B,EAAK,CAACA,EAAI5B,MAAM,GAAI4B,EAAI5B,MAAM,GAAI4B,EAAI5B,MAAM,MAEvD,CAAE8B,MAAOF,EAAKG,SAAUf,EAAM,IAEzC,OAAOU,EAAS9B,EAAKD,EACzB,CACK,CACD,MAAMqC,GAAmB,SAAW,CAACpC,EAAKhB,EAAQM,EAAMyC,KAEpD,IAAIC,EAAM,KAAOC,UAAU,MAAsBL,EAAQC,GAMzD,OALAE,EAAK,CAAC/C,EAAQgB,EAAKgC,EAAK1C,IACpBW,IAEA+B,GAAM,EAAA7B,EAAA,GAAQ6B,EAAK,CAACA,EAAI5B,MAAM,GAAI4B,EAAI5B,MAAM,GAAI4B,EAAI5B,MAAM,MAEvD,CAAE8B,MAAOF,EAAKG,SAAUf,EAAM,IAEzC,OAAOgB,EAAiBpC,EAAKD,EAASS,EAC1C,CACJ,I,eC3BO,MAAMiC,GAAyB,IAAA5D,IAAG,CAAE6D,aAvG3C,UAAsB,EAAEC,EAAC,EAAEC,EAAC,WAAEC,GAAa,EAAK,WAAEC,GAAa,EAAK,KAAExD,EAAI,WAAEC,EAAa,SAAQ,uBAAEC,EAAsB,eAAEC,EAAiB,KACxI,IAA2D,KAAvD,QAAW,KAAOC,MAAMC,cAAeJ,GAAuB,CAC9D,IAAIK,GAAS,OAAc+C,EAAGC,EAAGC,EAAYC,GAI7C,OAHY,MAARxD,IACAM,GAAS,EAAAC,EAAA,GAAID,EAAQN,KAElB,QAAgBM,EAAQL,EAAYC,EAAwBC,EACvE,CACA,IAAIsD,GAAK,QAAgBJ,EAAG,IAAK,gBAC7BK,GAAK,QAAgBJ,EAAG,IAAK,iBAChCG,EAAIC,IAAM,IAAAtC,gBAAeqC,EAAIC,GAC9B,MAAMC,EAAcJ,EAAaE,EAAG3C,MAAM2C,EAAG7C,KAAO,GAAK6C,EAAG3C,MAAM2C,EAAG7C,KAAO,GACtEgD,EAAcJ,EAAaE,EAAG5C,MAAM4C,EAAG9C,KAAO,GAAK8C,EAAG5C,MAAM4C,EAAG9C,KAAO,GACtEiD,EAAcN,EAAaE,EAAG3C,MAAM2C,EAAG7C,KAAO,GAAK6C,EAAG3C,MAAM2C,EAAG7C,KAAO,GACtEkD,EAAcN,EAAaE,EAAG5C,MAAM4C,EAAG9C,KAAO,GAAK8C,EAAG5C,MAAM4C,EAAG9C,KAAO,GACtEmD,EAAaN,EAAG3C,MAAMkD,MAAM,GAAI,GAChCC,EAAaP,EAAG5C,MAAMkD,MAAM,GAAI,GAChCE,EAAY,KAAmBH,GAC/BI,EAAY,KAAmBF,GACrC,KAAYN,IAAgBC,GAAa,IAAM,wCAAwCD,WAChFC,6BAAuCH,EAAG3C,aAC1C4C,EAAG5C,wBAAwByC,oBACXC,kBACvB,MACMjC,EADoBF,EAAeC,2BAA2BmC,EAAG3C,MAAMkD,MAAM,GAAI,GAAIN,EAAG5C,MAAMkD,MAAM,GAAI,IAC3EI,OAAO,CAACP,EAAaC,IAClDO,EAAMd,GACR,EAAA1C,EAAA,GAAQ4C,EAAI,CAACS,EAAWP,EAAaE,KACrC,EAAAhD,EAAA,GAAQ4C,EAAI,CAACS,EAAWL,EAAaF,IACnCW,EAAMd,GACR,EAAA3C,EAAA,GAAQ6C,EAAI,CAACS,EAAWL,EAAaF,KACrC,EAAA/C,EAAA,GAAQ6C,EAAI,CAACS,EAAWP,EAAaE,IACzC,IAAI5C,EAMAC,EALQ,MAARnB,IACAkB,GAAQ,QAAgBlB,EAAM,OAAQ,iBACrCkB,IAAS,IAAAE,gBAAeF,EAAOuC,GAChCpC,EAAeC,2BAA2BC,EAAUL,EAAMJ,QAGhC,MAA1BZ,IACAiB,GAA0B,QAAgBjB,EAAwB,gBAAiB,iBAEvF,MAAM4B,EAAO,CAACC,EAAIC,KACd,MAAOqC,EAAKC,EAAKrC,EAAGf,GAASc,EAIvBE,GAAe,SAAqB,EAAArB,EAAA,GAAQkB,EAAIE,EAAEnB,OAAQmB,EAAGhC,GACnE,IAAIsE,EACAC,EAiBJ,GAhBKjB,GAAeC,GAIVD,GAAcC,GACpBe,GAAO,OAAcrC,EAAcoC,GAAK,GAAO,GAC/CE,GAAO,OAActC,EAAcmC,GAAK,GAAM,IAEzCd,IAAeC,GACpBe,GAAO,OAAcD,EAAKpC,GAAc,GAAO,GAC/CsC,GAAO,OAAcH,EAAKnC,GAAc,GAAO,KAG/CqC,GAAO,OAAcD,EAAKpC,GAAc,GAAM,GAC9CsC,GAAO,OAActC,EAAcmC,GAAK,GAAM,KAb9CE,GAAO,OAAcrC,EAAcoC,GAAK,GAAO,GAC/CE,GAAO,OAAcH,EAAKnC,GAAc,GAAM,IActC,MAARlC,EAAc,CAEd,MAAO,CAACuE,EAAMC,GADE,QAAqBtD,EAAOgB,GAEhD,CAEI,MAAO,CAACqC,EAAMC,EAClB,EAEElC,EAAS,CACXe,EAAGgB,EACHf,EAAGgB,EACHtE,KAAMkB,EACNhB,uBAAwBiB,GAEtBoB,EAAQ,CAAEgB,aAAYC,aAAYvD,aAAYE,kBAGpD,GAAY,MAARH,EAAc,CACd,MAAMwC,GAAW,SAAW,CAAC6B,EAAKC,EAAK7B,KACnC,MAAMC,EAEN,KAAOC,UAAU,KAAcL,EAAQC,GAEvC,OADAE,EAAK,CAAC4B,EAAKC,EAAK5B,IACT,CAAEE,OAAO,EAAA/B,EAAA,GAAQ6B,EAAKnB,GAAWsB,SAAUf,EAAM,IAE5D,OAAOU,EAAS6B,EAAKC,EACzB,CACK,CACD,MAAMxB,GAAmB,SAAW,CAACuB,EAAKC,EAAKpD,EAAOuB,KAClD,MAAMC,EAEN,KAAOC,UAAU,KAAcL,EAAQC,GAEvC,OADAE,EAAK,CAAC4B,EAAKC,EAAK5B,EAAKxB,IACd,CAAE0B,OAAO,EAAA/B,EAAA,GAAQ6B,EAAKnB,GAAWsB,SAAUf,EAAM,IAE5D,OAAOgB,EAAiBuB,EAAKC,EAAKpD,EACtC,CACJ,G,6FClGO,MAAMuD,GAAyB,E,SAAAlF,IAAG,CAAEmF,QAP3C,SAAiBjF,EAAGkF,EAASC,EAAO,EAAGC,EAAY,GAC/C,MAEMvC,EAAS,CAAE7C,GAFN,QAAgBA,EAAG,IAAK,UAEXkF,SADP,QAAgBA,EAAS,UAAW,SAAU,UAEzDpC,EAAQ,CAAEqC,OAAMC,aACtB,OAAO,KAAOlC,UAAU,MAAUL,EAAQC,EAC9C,G,6FCYO,MAAMuC,GAA2B,E,SAAAvF,IAAG,CAAEwF,UAN7C,SAAmBtF,EAAGkF,GAClB,MAAMK,GAAW,QAAgBL,EAAS,UAAW,WAAY,SAE3DrC,EAAS,CAAE2C,QADN,QAAgBxF,EAAG,IAAK,WAAY,qBAClBkF,QAASK,GACtC,OAAO,KAAOrC,UAAU,MAAUL,EACtC,G,6PCnCO,SAAS4C,EAAqBnD,EAAIE,EAAGhC,GACxC,GAAkB,MAAdA,GAAqC,WAAfA,EACtB,OAAO8B,EAEX,GAAmB,SAAf9B,EACA,OAAO,OAAI8B,GAAI,OAAKE,IAExB,MAAM,IAAIJ,MAAM,gDAAgD5B,KACpE,CAEO,SAASkF,EAAqBnF,EAAMkC,GACvC,IAAIQ,EAAMR,EACV,MAAMkD,EAAa,mBAAgCpF,EAAKc,MAAOoB,EAAapB,OAI5E,OAHIsE,EAAW5D,OAAS,IACpBkB,GAAM,OAAIA,EAAK0C,KAEZ,OAAQ1C,EAAK1C,EAAKc,MAC7B,CACO,SAASuE,EAAgB5F,EAAGQ,EAAYC,EAAwBC,GACnE,GAAmB,WAAfF,EACA,OAAOR,EAEN,GAAmB,SAAfQ,EACL,OAAO,OAAKR,GAEX,GAAmB,QAAfQ,EACL,OAAO,OAAIR,GAEV,GAAmB,UAAfQ,EACL,OAAO,OAAMR,GAEZ,GAAmB,UAAfQ,EACL,OAAO,OAAMR,EAAGS,GAEf,GAAmB,cAAfD,EACL,OAAO,OAAUR,EAAGU,GAEnB,GAAmB,YAAfF,EACL,OAAO,OAAQR,GAEnB,MAAM,IAAIoC,MAAM,4BAA4B5B,KAChD,CAEO,MAAMqF,EAAa,CAACjF,EAAeJ,MACjBI,EAAgB,IACE,WAAfJ,C,+FChErB,SAASsF,EAAmBC,EAAQb,GACvC,MAAMc,EAAaD,EAAO1E,MAAMU,OAC1BkE,EAAcf,EAAQ7D,MAAMU,OAClC,GAAIiE,EAAa,EACb,MAAM,IAAI5D,MACN,4EAAqB4D,MAE7B,GAAIC,EAAc,EACd,MAAM,IAAI7D,MACN,8EAAqB6D,MAE7B,GAAsB,UAAlBf,EAAQgB,MACR,MAAM,IAAI9D,MACN,yEAAsB8C,EAAQgB,UAEtC,GAAIhB,EAAQ7D,MAAM4E,EAAc,GAAKD,EACjC,MAAM,IAAI5D,MACN,iEAAG8C,EAAQ7D,MAAM4E,EAAc,UAAUD,KAEjD,GAAoC,KAAhC,QAAcD,EAAO1E,OACrB,MAAM,IAAIe,MACN,mEAAiB2D,EAAO1E,UAEhC,MAAM8E,EAAejB,EAAQ7D,MACvB+E,EAAYD,EAAaA,EAAapE,OAAS,GAGrD,IAAIsE,EAAU,EACd,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAapE,OAAS,IAAKuE,EAC3CD,GAAWF,EAAaG,GAE5B,MAAMC,EAAaR,EAAO1E,MACpBmF,EAAcL,EAAa5B,QACjCiC,EAAYC,MACZ,IAAIC,EAAY,EAChB,IAAK,IAAIJ,EAAIF,EAAWE,EAAIN,IAAcM,EACtCI,GAAaH,EAAWD,GACxBE,EAAY5D,KAAK2D,EAAWD,IAEhC,MAAMpG,EAAU,KAAI,QAAe6F,EAAO1E,OAAOsF,KAAIC,GAAUA,EAASF,IACpE,GAAGnC,MAAM,EAAG6B,GAChB,MAAO,CAACI,EAAaH,EAASK,EAAWxG,EAC7C,C","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/fused/conv2d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/fused/depthwise_conv2d.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/fused/mat_mul.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/gather.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/gather_nd.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/fused_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/ops/gather_nd_util.js"],"sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { customGrad } from '../../gradients';\nimport { FusedConv2D } from '../../kernel_names';\nimport { makeTypesMatch } from '../../tensor_util';\nimport { convertToTensor } from '../../tensor_util_env';\nimport * as util from '../../util';\nimport { add } from '../add';\nimport * as broadcast_util from '../broadcast_util';\nimport { conv2d as unfusedConv2d } from '../conv2d';\nimport { conv2DBackpropFilter } from '../conv2d_backprop_filter';\nimport { conv2DBackpropInput } from '../conv2d_backprop_input';\nimport * as conv_util from '../conv_util';\nimport { applyActivation, getFusedBiasGradient, getFusedDyActivation, shouldFuse } from '../fused_util';\nimport { op } from '../operation';\nimport { reshape } from '../reshape';\n/**\n * Computes a 2D convolution over the input x, optionally fused with adding a\n * bias and applying an activation.\n *\n * ```js\n * const inputDepth = 2;\n * const inShape = [2, 2, 2, inputDepth];\n * const outputDepth = 2;\n * const fSize = 1;\n * const pad = 0;\n * const strides = 1;\n *\n * const x = tf.tensor4d( [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n * 16], inShape);\n * const w = tf.tensor4d([-1, 1, -2, 0.5], [fSize, fSize, inputDepth,\n * outputDepth]);\n *\n * tf.fused.conv2d({ x, filter: w, strides, pad, dataFormat: 'NHWC',\n * dilations: [1, 1], bias: tf.scalar(5), activation: 'relu' }).print();\n * ```\n *\n * @param obj An object with the following properties:\n * @param x The input tensor, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n * assumed.\n * @param filter The filter, rank 4, of shape\n *     `[filterHeight, filterWidth, inDepth, outDepth]`.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`.\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid` output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels]. Only \"NHWC\" is currently supported.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in atrous convolution. Defaults to `[1, 1]`. If `dilations` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @param bias Tensor to be added to the result.\n * @param activation Name of activation kernel (defaults to `linear`) to be\n *     applied\n *      after biasAdd.\n * @param preluActivationWeights Tensor of prelu weights to be applied as part\n *     of a `prelu` activation, typically the same shape as `x`.\n * @param leakyreluAlpha Optional. Alpha to be applied as part of a `leakyrelu`\n *     activation.\n */\nfunction fusedConv2d_({ x, filter, strides, pad, dataFormat = 'NHWC', dilations = [1, 1], dimRoundingMode, bias, activation = 'linear', preluActivationWeights, leakyreluAlpha }) {\n    activation = activation || 'linear';\n    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {\n        // TODO: Transpose bias and preluActivationWeights properly for NCHW\n        // format before computation.\n        util.assert(dataFormat === 'NHWC', () => `Error in fused conv2d: got dataFormat of ${dataFormat} but ` +\n            `only NHWC is currently supported for the case of gradient depth ` +\n            `is 0 and the activation is not linear.`);\n        let result = unfusedConv2d(x, filter, strides, pad, dataFormat, dilations, dimRoundingMode);\n        if (bias != null) {\n            result = add(result, bias);\n        }\n        return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);\n    }\n    const $x = convertToTensor(x, 'x', 'conv2d', 'float32');\n    const $filter = convertToTensor(filter, 'filter', 'conv2d', 'float32');\n    let x4D = $x;\n    let reshapedTo4D = false;\n    if ($x.rank === 3) {\n        reshapedTo4D = true;\n        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n    }\n    util.assert(x4D.rank === 4, () => `Error in fused conv2d: input must be rank 4, but got rank ` +\n        `${x4D.rank}.`);\n    util.assert($filter.rank === 4, () => `Error in fused conv2d: filter must be rank 4, but got rank ` +\n        `${$filter.rank}.`);\n    conv_util.checkPadOnDimRoundingMode('fused conv2d', pad, dimRoundingMode);\n    const inputChannels = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];\n    util.assert($filter.shape[2] === inputChannels, () => `Error in conv2d: depth of input (${inputChannels}) must match ` +\n        `input depth for filter ${$filter.shape[2]}.`);\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in conv2D: Either strides or dilations must be 1. ' +\n        `Got strides ${strides} and dilations '${dilations}'`);\n    const convInfo = conv_util.computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad, dimRoundingMode);\n    let $bias;\n    if (bias != null) {\n        $bias = convertToTensor(bias, 'bias', 'fused conv2d');\n        [$bias] = makeTypesMatch($bias, $x);\n        // According to TensorFlow, the bias is supposed be a 1-D tensor or a\n        // scalar.\n        //\n        // 3-D or 4-D bias is not disabled for NHWC format, because they are\n        // currently being used in some cases. For examplem in our code base,\n        // https://github.com/tensorflow/tfjs/blob/b53bd47e880367ae57493f0ea628abaf08db2d5d/tfjs-core/src/ops/fused/fused_conv2d_test.ts#L1972.\n        if (dataFormat === 'NHWC') {\n            broadcast_util.assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);\n        }\n        else {\n            util.assert($bias.shape.length <= 1, () => `Error in fused conv2d: only supports scalar or 1-D Tensor ` +\n                `bias for NCHW format but got the bias of ` +\n                `rank-${$bias.shape.length}.`);\n            util.assert($bias.shape.length === 0 || $bias.shape[0] === convInfo.outChannels ||\n                $bias.shape[0] === 1, () => `Error in fused conv2d: bias shape (${$bias.shape}) is not ` +\n                `compatible with the number of output channels ` +\n                `(${convInfo.outChannels})`);\n        }\n    }\n    let $preluActivationWeights;\n    if (preluActivationWeights != null) {\n        // PReLU's activation weights could be a scalar, a 1-D tensor or a 3-D\n        // tensor.\n        const alphaShape = preluActivationWeights.shape;\n        util.assert(alphaShape.length <= 1 || alphaShape.length === 3, () => `Error in fused conv2d: only supports scalar, 1-D Tensor or ` +\n            `3-D Tensor PReLU activation weights but got a tensor of ` +\n            `rank-${alphaShape.length}.`);\n        if (alphaShape.length === 1) {\n            // Whether the data format is NCHW or NHWC, the 1-D PReLU activation\n            // weights tensor should be aligned with the output channels of conv2d\n            // result.\n            util.assert(alphaShape[0] === 1 || alphaShape[0] === convInfo.outChannels, () => `Error in fused conv2d: PReLU activation weights ` +\n                `(${alphaShape}) is not compatible with the number of output ` +\n                `channels (${convInfo.outChannels}).`);\n        }\n        else if (alphaShape.length === 3) {\n            // Whether the data format is NCHW or NHWC, the PReLU activation weights\n            // tensor should has the compatible shape with the result of conv2d.\n            try {\n                broadcast_util.assertAndGetBroadcastShape(alphaShape, convInfo.outShape);\n            }\n            catch (e) {\n                const errMsg = `Error in fused conv2d: PReLU activation weights (${alphaShape}) ` +\n                    `is not compatible with the output shape of the conv2d ` +\n                    `(${convInfo.outShape}).`;\n                throw Error(errMsg);\n            }\n        }\n        $preluActivationWeights = convertToTensor(preluActivationWeights, 'prelu weights', 'fused conv2d');\n    }\n    const grad = (dy, saved) => {\n        util.assert(dataFormat === 'NHWC', () => `Error in gradient of fused conv2D: got dataFormat of ${dataFormat} but only NHWC is currently supported.`);\n        const [$filter, x4D, y, $bias] = saved;\n        const dyActivation = getFusedDyActivation(dy, y, activation);\n        util.assert(conv_util.tupleValuesAreOne(dilations), () => 'Error in gradient of fused conv2D: ' +\n            `dilation rates greater than 1 ` +\n            `are not yet supported in gradients. Got dilations '${dilations}'`);\n        const xDer = conv2DBackpropInput(x4D.shape, dyActivation, $filter, strides, pad);\n        const filterDer = conv2DBackpropFilter(x4D, dyActivation, $filter.shape, strides, pad);\n        const der = [xDer, filterDer];\n        if ($bias != null) {\n            const biasDer = getFusedBiasGradient($bias, dyActivation);\n            der.push(biasDer);\n        }\n        return der;\n    };\n    const inputs = {\n        x: x4D,\n        filter: $filter,\n        bias: $bias,\n        preluActivationWeights: $preluActivationWeights\n    };\n    const attrs = {\n        strides,\n        pad,\n        dataFormat,\n        dilations,\n        dimRoundingMode,\n        activation,\n        leakyreluAlpha\n    };\n    // Depending on the the params passed in we will have different number of\n    // inputs and thus a a different number of elements in the gradient.\n    if (bias == null) {\n        const customOp = customGrad((x4D, filter, save) => {\n            let res = \n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            ENGINE.runKernel(FusedConv2D, inputs, attrs);\n            save([filter, x4D, res]);\n            if (reshapedTo4D) {\n                // tslint:disable-next-line: no-unnecessary-type-assertion\n                res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);\n            }\n            return { value: res, gradFunc: grad };\n        });\n        return customOp(x4D, $filter);\n    }\n    else {\n        const customOpWithBias = customGrad((x4D, filter, bias, save) => {\n            let res = ENGINE.runKernel(FusedConv2D, inputs, attrs);\n            save([filter, x4D, res, bias]);\n            if (reshapedTo4D) {\n                // tslint:disable-next-line: no-unnecessary-type-assertion\n                res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);\n            }\n            return { value: res, gradFunc: grad };\n        });\n        return customOpWithBias(x4D, $filter, $bias);\n    }\n}\nexport const conv2d = /* @__PURE__ */ op({ fusedConv2d_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udjJkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvZnVzZWQvY29udjJkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFDcEMsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFBQyxXQUFXLEVBQXNDLE1BQU0sb0JBQW9CLENBQUM7QUFJcEYsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQ2pELE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUV0RCxPQUFPLEtBQUssSUFBSSxNQUFNLFlBQVksQ0FBQztBQUNuQyxPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sUUFBUSxDQUFDO0FBQzNCLE9BQU8sS0FBSyxjQUFjLE1BQU0sbUJBQW1CLENBQUM7QUFDcEQsT0FBTyxFQUFDLE1BQU0sSUFBSSxhQUFhLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDbEQsT0FBTyxFQUFDLG9CQUFvQixFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDL0QsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDN0QsT0FBTyxLQUFLLFNBQVMsTUFBTSxjQUFjLENBQUM7QUFFMUMsT0FBTyxFQUFDLGVBQWUsRUFBRSxvQkFBb0IsRUFBRSxvQkFBb0IsRUFBRSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDdEcsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUNoQyxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBRW5DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXdERztBQUNILFNB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LENBQUM7S0FDcEM7U0FBTTtRQUNMLE1BQU0sZ0JBQWdCLEdBQUcsVUFBVSxDQUMvQixDQUFDLEdBQWEsRUFBRSxNQUFnQixFQUFFLElBQVksRUFBRSxJQUFrQixFQUFFLEVBQUU7WUFDcEUsSUFBSSxHQUFHLEdBQXNCLE1BQU0sQ0FBQyxTQUFTLENBQ3pDLFdBQVcsRUFBRSxNQUFtQyxFQUNoRCxLQUFnQyxDQUFDLENBQUM7WUFFdEMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUUvQixJQUFJLFlBQVksRUFBRTtnQkFDaEIsMERBQTBEO2dCQUMxRCxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ2pELENBQUM7YUFDZDtZQUVELE9BQU8sRUFBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUMsQ0FBQztRQUN0QyxDQUFDLENBQUMsQ0FBQztRQUVQLE9BQU8sZ0JBQWdCLENBQUMsR0FBRyxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQU0sQ0FBQztLQUNuRDtBQUNILENBQUM7QUFDRCxNQUFNLENBQUMsTUFBTSxNQUFNLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFDLFlBQVksRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi8uLi9lbmdpbmUnO1xuaW1wb3J0IHtjdXN0b21HcmFkfSBmcm9tICcuLi8uLi9ncmFkaWVudHMnO1xuaW1wb3J0IHtGdXNlZENvbnYyRCwgRnVzZWRDb252MkRBdHRycywgRnVzZWRDb252MkRJbnB1dHN9IGZyb20gJy4uLy4uL2tlcm5lbF9uYW1lcyc7XG5pbXBvcnQge05hbWVkQXR0ck1hcH0gZnJvbSAnLi4vLi4va2VybmVsX3JlZ2lzdHJ5JztcbmltcG9ydCB7VGVuc29yLCBUZW5zb3IzRCwgVGVuc29yNER9IGZyb20gJy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge0dyYWRTYXZlRnVuYywgTmFtZWRUZW5zb3JNYXB9IGZyb20gJy4uLy4uL3RlbnNvcl90eXBlcyc7XG5pbXBvcnQge21ha2VUeXBlc01hdGNofSBmcm9tICcuLi8uLi90ZW5zb3JfdXRpbCc7XG5pbXBvcnQge2NvbnZlcnRUb1RlbnNvcn0gZnJvbSAnLi4vLi4vdGVuc29yX3V0aWxfZW52JztcbmltcG9ydCB7VGVuc29yTGlrZX0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7YWRkfSBmcm9tICcuLi9hZGQnO1xuaW1wb3J0ICogYXMgYnJvYWRjYXN0X3V0aWwgZnJvbSAnLi4vYnJvYWRjYXN0X3V0aWwnO1xuaW1wb3J0IHtjb252MmQgYXMgdW5mdXNlZENvbnYyZH0gZnJvbSAnLi4vY29udjJkJztcbmltcG9ydCB7Y29udjJEQmFja3Byb3BGaWx0ZXJ9IGZyb20gJy4uL2NvbnYyZF9iYWNrcHJvcF9maWx0ZXInO1xuaW1wb3J0IHtjb252MkRCYWNrcHJvcElucHV0fSBmcm9tICcuLi9jb252MmRfYmFja3Byb3BfaW5wdXQnO1xuaW1wb3J0ICogYXMgY29udl91dGlsIGZyb20gJy4uL2NvbnZfdXRpbCc7XG5pbXBvcnQge0FjdGl2YXRpb259IGZyb20gJy4uL2Z1c2VkX3R5cGVzJztcbmltcG9ydCB7YXBwbHlBY3RpdmF0aW9uLCBnZXRGdXNlZEJpYXNHcmFkaWVudCwgZ2V0RnVzZWREeUFjdGl2YXRpb24sIHNob3VsZEZ1c2V9IGZyb20gJy4uL2Z1c2VkX3V0aWwnO1xuaW1wb3J0IHtvcH0gZnJvbSAnLi4vb3BlcmF0aW9uJztcbmltcG9ydCB7cmVzaGFwZX0gZnJvbSAnLi4vcmVzaGFwZSc7XG5cbi8qKlxuICogQ29tcHV0ZXMgYSAyRCBjb252b2x1dGlvbiBvdmVyIHRoZSBpbnB1dCB4LCBvcHRpb25hbGx5IGZ1c2VkIHdpdGggYWRkaW5nIGFcbiAqIGJpYXMgYW5kIGFwcGx5aW5nIGFuIGFjdGl2YXRpb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGlucHV0RGVwdGggPSAyO1xuICogY29uc3QgaW5TaGFwZSA9IFsyLCAyLCAyLCBpbnB1dERlcHRoXTtcbiAqIGNvbnN0IG91dHB1dERlcHRoID0gMjtcbiAqIGNvbnN0IGZTaXplID0gMTtcbiAqIGNvbnN0IHBhZCA9IDA7XG4gKiBjb25zdCBzdHJpZGVzID0gMTtcbiAqXG4gKiBjb25zdCB4ID0gdGYudGVuc29yNGQoIFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICogMTZdLCBpblNoYXBlKTtcbiAqIGNvbnN0IHcgPSB0Zi50ZW5zb3I0ZChbLTEsIDEsIC0yLCAwLjVdLCBbZlNpemUsIGZTaXplLCBpbnB1dERlcHRoLFxuICogb3V0cHV0RGVwdGhdKTtcbiAqXG4gKiB0Zi5mdXNlZC5jb252MmQoeyB4LCBmaWx0ZXI6IHcsIHN0cmlkZXMsIHBhZCwgZGF0YUZvcm1hdDogJ05IV0MnLFxuICogZGlsYXRpb25zOiBbMSwgMV0sIGJpYXM6IHRmLnNjYWxhcig1KSwgYWN0aXZhdGlvbjogJ3JlbHUnIH0pLnByaW50KCk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb2JqIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIEBwYXJhbSB4IFRoZSBpbnB1dCB0ZW5zb3IsIG9mIHJhbmsgNCBvciByYW5rIDMsIG9mIHNoYXBlXG4gKiAgICAgYFtiYXRjaCwgaGVpZ2h0LCB3aWR0aCwgaW5DaGFubmVsc11gLiBJZiByYW5rIDMsIGJhdGNoIG9mIDEgaXNcbiAqIGFzc3VtZWQuXG4gKiBAcGFyYW0gZmlsdGVyIFRoZSBmaWx0ZXIsIHJhbmsgNCwgb2Ygc2hhcGVcbiAqICAgICBgW2ZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIGluRGVwdGgsIG91dERlcHRoXWAuXG4gKiBAcGFyYW0gc3RyaWRlcyBUaGUgc3RyaWRlcyBvZiB0aGUgY29udm9sdXRpb246IGBbc3RyaWRlSGVpZ2h0LFxuICogc3RyaWRlV2lkdGhdYC5cbiAqIEBwYXJhbSBwYWQgVGhlIHR5cGUgb2YgcGFkZGluZyBhbGdvcml0aG0uXG4gKiAgIC0gYHNhbWVgIGFuZCBzdHJpZGUgMTogb3V0cHV0IHdpbGwgYmUgb2Ygc2FtZSBzaXplIGFzIGlucHV0LFxuICogICAgICAgcmVnYXJkbGVzcyBvZiBmaWx0ZXIgc2l6ZS5cbiAqICAgLSBgdmFsaWRgIG91dHB1dCB3aWxsIGJlIHNtYWxsZXIgdGhhbiBpbnB1dCBpZiBmaWx0ZXIgaXMgbGFyZ2VyXG4gKiAgICAgICB0aGFuIDF4MS5cbiAqICAgLSBGb3IgbW9yZSBpbmZvLCBzZWUgdGhpcyBndWlkZTpcbiAqICAgICBbaHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL25uL2NvbnZvbHV0aW9uXShcbiAqICAgICAgICAgIGh0dHBzOi8vd3d3LnRlbnNvcmZsb3cub3JnL2FwaV9kb2NzL3B5dGhvbi90Zi9ubi9jb252b2x1dGlvbilcbiAqIEBwYXJhbSBkYXRhRm9ybWF0IEFuIG9wdGlvbmFsIHN0cmluZyBmcm9tOiBcIk5IV0NcIiwgXCJOQ0hXXCIuIERlZmF1bHRzIHRvXG4gKiAgICAgXCJOSFdDXCIuIFNwZWNpZnkgdGhlIGRhdGEgZm9ybWF0IG9mIHRoZSBpbnB1dCBhbmQgb3V0cHV0IGRhdGEuIFdpdGggdGhlXG4gKiAgICAgZGVmYXVsdCBmb3JtYXQgXCJOSFdDXCIsIHRoZSBkYXRhIGlzIHN0b3JlZCBpbiB0aGUgb3JkZXIgb2Y6IFtiYXRjaCxcbiAqICAgICBoZWlnaHQsIHdpZHRoLCBjaGFubmVsc10uIE9ubHkgXCJOSFdDXCIgaXMgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAqIEBwYXJhbSBkaWxhdGlvbnMgVGhlIGRpbGF0aW9uIHJhdGVzOiBgW2RpbGF0aW9uSGVpZ2h0LCBkaWxhdGlvbldpZHRoXWBcbiAqICAgICBpbiB3aGljaCB3ZSBzYW1wbGUgaW5wdXQgdmFsdWVzIGFjcm9zcyB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBkaW1lbnNpb25zXG4gKiAgICAgaW4gYXRyb3VzIGNvbnZvbHV0aW9uLiBEZWZhdWx0cyB0byBgWzEsIDFdYC4gSWYgYGRpbGF0aW9uc2AgaXMgYSBzaW5nbGVcbiAqICAgICBudW1iZXIsIHRoZW4gYGRpbGF0aW9uSGVpZ2h0ID09IGRpbGF0aW9uV2lkdGhgLiBJZiBpdCBpcyBncmVhdGVyIHRoYW5cbiAqICAgICAxLCB0aGVuIGFsbCB2YWx1ZXMgb2YgYHN0cmlkZXNgIG11c3QgYmUgMS5cbiAqIEBwYXJhbSBkaW1Sb3VuZGluZ01vZGUgQSBzdHJpbmcgZnJvbTogJ2NlaWwnLCAncm91bmQnLCAnZmxvb3InLiBJZiBub25lIGlzXG4gKiAgICAgcHJvdmlkZWQsIGl0IHdpbGwgZGVmYXVsdCB0byB0cnVuY2F0ZS5cbiAqIEBwYXJhbSBiaWFzIFRlbnNvciB0byBiZSBhZGRlZCB0byB0aGUgcmVzdWx0LlxuICogQHBhcmFtIGFjdGl2YXRpb24gTmFtZSBvZiBhY3RpdmF0aW9uIGtlcm5lbCAoZGVmYXVsdHMgdG8gYGxpbmVhcmApIHRvIGJlXG4gKiAgICAgYXBwbGllZFxuICogICAgICBhZnRlciBiaWFzQWRkLlxuICogQHBhcmFtIHByZWx1QWN0aXZhdGlvbldlaWdodHMgVGVuc29yIG9mIHByZWx1IHdlaWdodHMgdG8gYmUgYXBwbGllZCBhcyBwYXJ0XG4gKiAgICAgb2YgYSBgcHJlbHVgIGFjdGl2YXRpb24sIHR5cGljYWxseSB0aGUgc2FtZSBzaGFwZSBhcyBgeGAuXG4gKiBAcGFyYW0gbGVha3lyZWx1QWxwaGEgT3B0aW9uYWwuIEFscGhhIHRvIGJlIGFwcGxpZWQgYXMgcGFydCBvZiBhIGBsZWFreXJlbHVgXG4gKiAgICAgYWN0aXZhdGlvbi5cbiAqL1xuZnVuY3Rpb24gZnVzZWRDb252MmRfPFQgZXh0ZW5kcyBUZW5zb3IzRHxUZW5zb3I0RD4oe1xuICB4LFxuICBmaWx0ZXIsXG4gIHN0cmlkZXMsXG4gIHBhZCxcbiAgZGF0YUZvcm1hdCA9ICdOSFdDJyxcbiAgZGlsYXRpb25zID0gWzEsIDFdLFxuICBkaW1Sb3VuZGluZ01vZGUsXG4gIGJpYXMsXG4gIGFjdGl2YXRpb24gPSAnbGluZWFyJyxcbiAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyxcbiAgbGVha3lyZWx1QWxwaGFcbn06IHtcbiAgeDogVHxUZW5zb3JMaWtlLFxuICBmaWx0ZXI6IFRlbnNvcjREfFRlbnNvckxpa2UsXG4gIHN0cmlkZXM6IFtudW1iZXIsIG51bWJlcl18bnVtYmVyLFxuICBwYWQ6ICd2YWxpZCd8J3NhbWUnfG51bWJlcnxjb252X3V0aWwuRXhwbGljaXRQYWRkaW5nLFxuICBkYXRhRm9ybWF0PzogJ05IV0MnfCdOQ0hXJyxcbiAgZGlsYXRpb25zPzogW251bWJlciwgbnVtYmVyXXxudW1iZXIsXG4gIGRpbVJvdW5kaW5nTW9kZT86ICdmbG9vcid8J3JvdW5kJ3wnY2VpbCcsXG4gIGJpYXM/OiBUZW5zb3J8VGVuc29yTGlrZSxcbiAgYWN0aXZhdGlvbj86IEFjdGl2YXRpb24sXG4gIHByZWx1QWN0aXZhdGlvbldlaWdodHM/OiBUZW5zb3IsXG4gIGxlYWt5cmVsdUFscGhhPzogbnVtYmVyXG59KTogVCB7XG4gIGFjdGl2YXRpb24gPSBhY3RpdmF0aW9uIHx8ICdsaW5lYXInO1xuXG4gIGlmIChzaG91bGRGdXNlKEVOR0lORS5zdGF0ZS5ncmFkaWVudERlcHRoLCBhY3RpdmF0aW9uKSA9PT0gZmFsc2UpIHtcbiAgICAvLyBUT0RPOiBUcmFuc3Bvc2UgYmlhcyBhbmQgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyBwcm9wZXJseSBmb3IgTkNIV1xuICAgIC8vIGZvcm1hdCBiZWZvcmUgY29tcHV0YXRpb24uXG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGRhdGFGb3JtYXQgPT09ICdOSFdDJyxcbiAgICAgICAgKCkgPT4gYEVycm9yIGluIGZ1c2VkIGNvbnYyZDogZ290IGRhdGFGb3JtYXQgb2YgJHtkYXRhRm9ybWF0fSBidXQgYCArXG4gICAgICAgICAgICBgb25seSBOSFdDIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQgZm9yIHRoZSBjYXNlIG9mIGdyYWRpZW50IGRlcHRoIGAgK1xuICAgICAgICAgICAgYGlzIDAgYW5kIHRoZSBhY3RpdmF0aW9uIGlzIG5vdCBsaW5lYXIuYCk7XG5cbiAgICBsZXQgcmVzdWx0ID0gdW5mdXNlZENvbnYyZChcbiAgICAgICAgeCwgZmlsdGVyLCBzdHJpZGVzLCBwYWQsIGRhdGFGb3JtYXQsIGRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlKTtcbiAgICBpZiAoYmlhcyAhPSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBhZGQocmVzdWx0LCBiaWFzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXBwbHlBY3RpdmF0aW9uKFxuICAgICAgICAgICAgICAgcmVzdWx0LCBhY3RpdmF0aW9uLCBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLCBsZWFreXJlbHVBbHBoYSkgYXMgVDtcbiAgfVxuXG4gIGNvbnN0ICR4ID0gY29udmVydFRvVGVuc29yKHgsICd4JywgJ2NvbnYyZCcsICdmbG9hdDMyJyk7XG4gIGNvbnN0ICRmaWx0ZXIgPSBjb252ZXJ0VG9UZW5zb3IoZmlsdGVyLCAnZmlsdGVyJywgJ2NvbnYyZCcsICdmbG9hdDMyJyk7XG5cbiAgbGV0IHg0RCA9ICR4IGFzIFRlbnNvcjREO1xuICBsZXQgcmVzaGFwZWRUbzREID0gZmFsc2U7XG5cbiAgaWYgKCR4LnJhbmsgPT09IDMpIHtcbiAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgIHg0RCA9IHJlc2hhcGUoJHgsIFsxLCAkeC5zaGFwZVswXSwgJHguc2hhcGVbMV0sICR4LnNoYXBlWzJdXSk7XG4gIH1cbiAgdXRpbC5hc3NlcnQoXG4gICAgICB4NEQucmFuayA9PT0gNCxcbiAgICAgICgpID0+IGBFcnJvciBpbiBmdXNlZCBjb252MmQ6IGlucHV0IG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgYCArXG4gICAgICAgICAgYCR7eDRELnJhbmt9LmApO1xuICB1dGlsLmFzc2VydChcbiAgICAgICRmaWx0ZXIucmFuayA9PT0gNCxcbiAgICAgICgpID0+IGBFcnJvciBpbiBmdXNlZCBjb252MmQ6IGZpbHRlciBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIGAgK1xuICAgICAgICAgIGAkeyRmaWx0ZXIucmFua30uYCk7XG4gIGNvbnZfdXRpbC5jaGVja1BhZE9uRGltUm91bmRpbmdNb2RlKCdmdXNlZCBjb252MmQnLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gIGNvbnN0IGlucHV0Q2hhbm5lbHMgPSBkYXRhRm9ybWF0ID09PSAnTkhXQycgPyB4NEQuc2hhcGVbM10gOiB4NEQuc2hhcGVbMV07XG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgJGZpbHRlci5zaGFwZVsyXSA9PT0gaW5wdXRDaGFubmVscyxcbiAgICAgICgpID0+IGBFcnJvciBpbiBjb252MmQ6IGRlcHRoIG9mIGlucHV0ICgke2lucHV0Q2hhbm5lbHN9KSBtdXN0IG1hdGNoIGAgK1xuICAgICAgICAgIGBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyICR7JGZpbHRlci5zaGFwZVsyXX0uYCk7XG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgY29udl91dGlsLmVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShzdHJpZGVzLCBkaWxhdGlvbnMpLFxuICAgICAgKCkgPT4gJ0Vycm9yIGluIGNvbnYyRDogRWl0aGVyIHN0cmlkZXMgb3IgZGlsYXRpb25zIG11c3QgYmUgMS4gJyArXG4gICAgICAgICAgYEdvdCBzdHJpZGVzICR7c3RyaWRlc30gYW5kIGRpbGF0aW9ucyAnJHtkaWxhdGlvbnN9J2ApO1xuXG4gIGNvbnN0IGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVDb252MkRJbmZvKFxuICAgICAgeDRELnNoYXBlLCAkZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcblxuICBsZXQgJGJpYXM6IFRlbnNvcjtcbiAgaWYgKGJpYXMgIT0gbnVsbCkge1xuICAgICRiaWFzID0gY29udmVydFRvVGVuc29yKGJpYXMsICdiaWFzJywgJ2Z1c2VkIGNvbnYyZCcpO1xuICAgIFskYmlhc10gPSBtYWtlVHlwZXNNYXRjaCgkYmlhcywgJHgpO1xuXG4gICAgLy8gQWNjb3JkaW5nIHRvIFRlbnNvckZsb3csIHRoZSBiaWFzIGlzIHN1cHBvc2VkIGJlIGEgMS1EIHRlbnNvciBvciBhXG4gICAgLy8gc2NhbGFyLlxuICAgIC8vXG4gICAgLy8gMy1EIG9yIDQtRCBiaWFzIGlzIG5vdCBkaXNhYmxlZCBmb3IgTkhXQyBmb3JtYXQsIGJlY2F1c2UgdGhleSBhcmVcbiAgICAvLyBjdXJyZW50bHkgYmVpbmcgdXNlZCBpbiBzb21lIGNhc2VzLiBGb3IgZXhhbXBsZW0gaW4gb3VyIGNvZGUgYmFzZSxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZmpzL2Jsb2IvYjUzYmQ0N2U4ODAzNjdhZTU3NDkzZjBlYTYyOGFiYWYwOGRiMmQ1ZC90ZmpzLWNvcmUvc3JjL29wcy9mdXNlZC9mdXNlZF9jb252MmRfdGVzdC50cyNMMTk3Mi5cbiAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ05IV0MnKSB7XG4gICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShjb252SW5mby5vdXRTaGFwZSwgJGJpYXMuc2hhcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLmFzc2VydChcbiAgICAgICAgICAkYmlhcy5zaGFwZS5sZW5ndGggPD0gMSxcbiAgICAgICAgICAoKSA9PiBgRXJyb3IgaW4gZnVzZWQgY29udjJkOiBvbmx5IHN1cHBvcnRzIHNjYWxhciBvciAxLUQgVGVuc29yIGAgK1xuICAgICAgICAgICAgICBgYmlhcyBmb3IgTkNIVyBmb3JtYXQgYnV0IGdvdCB0aGUgYmlhcyBvZiBgICtcbiAgICAgICAgICAgICAgYHJhbmstJHskYmlhcy5zaGFwZS5sZW5ndGh9LmApO1xuXG4gICAgICB1dGlsLmFzc2VydChcbiAgICAgICAgICAkYmlhcy5zaGFwZS5sZW5ndGggPT09IDAgfHwgJGJpYXMuc2hhcGVbMF0gPT09IGNvbnZJbmZvLm91dENoYW5uZWxzIHx8XG4gICAgICAgICAgICAgICRiaWFzLnNoYXBlWzBdID09PSAxLFxuICAgICAgICAgICgpID0+IGBFcnJvciBpbiBmdXNlZCBjb252MmQ6IGJpYXMgc2hhcGUgKCR7JGJpYXMuc2hhcGV9KSBpcyBub3QgYCArXG4gICAgICAgICAgICAgIGBjb21wYXRpYmxlIHdpdGggdGhlIG51bWJlciBvZiBvdXRwdXQgY2hhbm5lbHMgYCArXG4gICAgICAgICAgICAgIGAoJHtjb252SW5mby5vdXRDaGFubmVsc30pYCk7XG4gICAgfVxuICB9XG5cbiAgbGV0ICRwcmVsdUFjdGl2YXRpb25XZWlnaHRzOiBUZW5zb3I7XG4gIGlmIChwcmVsdUFjdGl2YXRpb25XZWlnaHRzICE9IG51bGwpIHtcbiAgICAvLyBQUmVMVSdzIGFjdGl2YXRpb24gd2VpZ2h0cyBjb3VsZCBiZSBhIHNjYWxhciwgYSAxLUQgdGVuc29yIG9yIGEgMy1EXG4gICAgLy8gdGVuc29yLlxuICAgIGNvbnN0IGFscGhhU2hhcGUgPSBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLnNoYXBlO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBhbHBoYVNoYXBlLmxlbmd0aCA8PSAxIHx8IGFscGhhU2hhcGUubGVuZ3RoID09PSAzLFxuICAgICAgICAoKSA9PiBgRXJyb3IgaW4gZnVzZWQgY29udjJkOiBvbmx5IHN1cHBvcnRzIHNjYWxhciwgMS1EIFRlbnNvciBvciBgICtcbiAgICAgICAgICAgIGAzLUQgVGVuc29yIFBSZUxVIGFjdGl2YXRpb24gd2VpZ2h0cyBidXQgZ290IGEgdGVuc29yIG9mIGAgK1xuICAgICAgICAgICAgYHJhbmstJHthbHBoYVNoYXBlLmxlbmd0aH0uYCk7XG5cbiAgICBpZiAoYWxwaGFTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIFdoZXRoZXIgdGhlIGRhdGEgZm9ybWF0IGlzIE5DSFcgb3IgTkhXQywgdGhlIDEtRCBQUmVMVSBhY3RpdmF0aW9uXG4gICAgICAvLyB3ZWlnaHRzIHRlbnNvciBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHRoZSBvdXRwdXQgY2hhbm5lbHMgb2YgY29udjJkXG4gICAgICAvLyByZXN1bHQuXG4gICAgICB1dGlsLmFzc2VydChcbiAgICAgICAgICBhbHBoYVNoYXBlWzBdID09PSAxIHx8IGFscGhhU2hhcGVbMF0gPT09IGNvbnZJbmZvLm91dENoYW5uZWxzLFxuICAgICAgICAgICgpID0+IGBFcnJvciBpbiBmdXNlZCBjb252MmQ6IFBSZUxVIGFjdGl2YXRpb24gd2VpZ2h0cyBgICtcbiAgICAgICAgICAgICAgYCgke2FscGhhU2hhcGV9KSBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBudW1iZXIgb2Ygb3V0cHV0IGAgK1xuICAgICAgICAgICAgICBgY2hhbm5lbHMgKCR7Y29udkluZm8ub3V0Q2hhbm5lbHN9KS5gKTtcbiAgICB9IGVsc2UgaWYgKGFscGhhU2hhcGUubGVuZ3RoID09PSAzKSB7XG4gICAgICAvLyBXaGV0aGVyIHRoZSBkYXRhIGZvcm1hdCBpcyBOQ0hXIG9yIE5IV0MsIHRoZSBQUmVMVSBhY3RpdmF0aW9uIHdlaWdodHNcbiAgICAgIC8vIHRlbnNvciBzaG91bGQgaGFzIHRoZSBjb21wYXRpYmxlIHNoYXBlIHdpdGggdGhlIHJlc3VsdCBvZiBjb252MmQuXG4gICAgICB0cnkge1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShcbiAgICAgICAgICAgIGFscGhhU2hhcGUsIGNvbnZJbmZvLm91dFNoYXBlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID1cbiAgICAgICAgICAgIGBFcnJvciBpbiBmdXNlZCBjb252MmQ6IFBSZUxVIGFjdGl2YXRpb24gd2VpZ2h0cyAoJHthbHBoYVNoYXBlfSkgYCArXG4gICAgICAgICAgICBgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgb3V0cHV0IHNoYXBlIG9mIHRoZSBjb252MmQgYCArXG4gICAgICAgICAgICBgKCR7Y29udkluZm8ub3V0U2hhcGV9KS5gO1xuICAgICAgICB0aHJvdyBFcnJvcihlcnJNc2cpO1xuICAgICAgfVxuICAgIH1cblxuICAgICRwcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gY29udmVydFRvVGVuc29yKFxuICAgICAgICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLCAncHJlbHUgd2VpZ2h0cycsICdmdXNlZCBjb252MmQnKTtcbiAgfVxuXG4gIGNvbnN0IGdyYWQgPSAoZHk6IFRlbnNvcjRELCBzYXZlZDogVGVuc29yW10pID0+IHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgZGF0YUZvcm1hdCA9PT0gJ05IV0MnLFxuICAgICAgICAoKSA9PiBgRXJyb3IgaW4gZ3JhZGllbnQgb2YgZnVzZWQgY29udjJEOiBnb3QgZGF0YUZvcm1hdCBvZiAke1xuICAgICAgICAgICAgZGF0YUZvcm1hdH0gYnV0IG9ubHkgTkhXQyBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLmApO1xuXG4gICAgY29uc3QgWyRmaWx0ZXIsIHg0RCwgeSwgJGJpYXNdID1cbiAgICAgICAgc2F2ZWQgYXMgW1RlbnNvcjRELCBUZW5zb3I0RCwgVGVuc29yNEQsIFRlbnNvcl07XG5cbiAgICBjb25zdCBkeUFjdGl2YXRpb24gPSBnZXRGdXNlZER5QWN0aXZhdGlvbihkeSwgeSwgYWN0aXZhdGlvbikgYXMgVGVuc29yNEQ7XG5cbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgY29udl91dGlsLnR1cGxlVmFsdWVzQXJlT25lKGRpbGF0aW9ucyksXG4gICAgICAgICgpID0+ICdFcnJvciBpbiBncmFkaWVudCBvZiBmdXNlZCBjb252MkQ6ICcgK1xuICAgICAgICAgICAgYGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGAgK1xuICAgICAgICAgICAgYGFyZSBub3QgeWV0IHN1cHBvcnRlZCBpbiBncmFkaWVudHMuIEdvdCBkaWxhdGlvbnMgJyR7ZGlsYXRpb25zfSdgKTtcblxuICAgIGNvbnN0IHhEZXIgPVxuICAgICAgICBjb252MkRCYWNrcHJvcElucHV0KHg0RC5zaGFwZSwgZHlBY3RpdmF0aW9uLCAkZmlsdGVyLCBzdHJpZGVzLCBwYWQpO1xuICAgIGNvbnN0IGZpbHRlckRlciA9XG4gICAgICAgIGNvbnYyREJhY2twcm9wRmlsdGVyKHg0RCwgZHlBY3RpdmF0aW9uLCAkZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBwYWQpO1xuICAgIGNvbnN0IGRlcjogVGVuc29yW10gPSBbeERlciwgZmlsdGVyRGVyXTtcblxuICAgIGlmICgkYmlhcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBiaWFzRGVyID0gZ2V0RnVzZWRCaWFzR3JhZGllbnQoJGJpYXMsIGR5QWN0aXZhdGlvbik7XG4gICAgICBkZXIucHVzaChiaWFzRGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcjtcbiAgfTtcblxuICBjb25zdCBpbnB1dHM6IEZ1c2VkQ29udjJESW5wdXRzID0ge1xuICAgIHg6IHg0RCxcbiAgICBmaWx0ZXI6ICRmaWx0ZXIsXG4gICAgYmlhczogJGJpYXMsXG4gICAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0czogJHByZWx1QWN0aXZhdGlvbldlaWdodHNcbiAgfTtcblxuICBjb25zdCBhdHRyczogRnVzZWRDb252MkRBdHRycyA9IHtcbiAgICBzdHJpZGVzLFxuICAgIHBhZCxcbiAgICBkYXRhRm9ybWF0LFxuICAgIGRpbGF0aW9ucyxcbiAgICBkaW1Sb3VuZGluZ01vZGUsXG4gICAgYWN0aXZhdGlvbixcbiAgICBsZWFreXJlbHVBbHBoYVxuICB9O1xuXG4gIC8vIERlcGVuZGluZyBvbiB0aGUgdGhlIHBhcmFtcyBwYXNzZWQgaW4gd2Ugd2lsbCBoYXZlIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAgLy8gaW5wdXRzIGFuZCB0aHVzIGEgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBncmFkaWVudC5cbiAgaWYgKGJpYXMgPT0gbnVsbCkge1xuICAgIGNvbnN0IGN1c3RvbU9wID1cbiAgICAgICAgY3VzdG9tR3JhZCgoeDREOiBUZW5zb3I0RCwgZmlsdGVyOiBUZW5zb3I0RCwgc2F2ZTogR3JhZFNhdmVGdW5jKSA9PiB7XG4gICAgICAgICAgbGV0IHJlczogVGVuc29yNER8VGVuc29yM0QgPVxuICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgIEVOR0lORS5ydW5LZXJuZWwoXG4gICAgICAgICAgICAgICAgICBGdXNlZENvbnYyRCwgaW5wdXRzIGFzIHVua25vd24gYXMgTmFtZWRUZW5zb3JNYXAsXG4gICAgICAgICAgICAgICAgICBhdHRycyBhcyB1bmtub3duIGFzIE5hbWVkQXR0ck1hcCk7XG5cbiAgICAgICAgICBzYXZlKFtmaWx0ZXIsIHg0RCwgcmVzXSk7XG5cbiAgICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgICAgICByZXMgPSByZXNoYXBlKHJlcywgW3Jlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM11dKSBhc1xuICAgICAgICAgICAgICAgIFRlbnNvcjNEO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7dmFsdWU6IHJlcywgZ3JhZEZ1bmM6IGdyYWR9O1xuICAgICAgICB9KTtcbiAgICByZXR1cm4gY3VzdG9tT3AoeDRELCAkZmlsdGVyKSBhcyBUO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGN1c3RvbU9wV2l0aEJpYXMgPSBjdXN0b21HcmFkKFxuICAgICAgICAoeDREOiBUZW5zb3I0RCwgZmlsdGVyOiBUZW5zb3I0RCwgYmlhczogVGVuc29yLCBzYXZlOiBHcmFkU2F2ZUZ1bmMpID0+IHtcbiAgICAgICAgICBsZXQgcmVzOiBUZW5zb3I0RHxUZW5zb3IzRCA9IEVOR0lORS5ydW5LZXJuZWwoXG4gICAgICAgICAgICAgIEZ1c2VkQ29udjJELCBpbnB1dHMgYXMgdW5rbm93biBhcyBOYW1lZFRlbnNvck1hcCxcbiAgICAgICAgICAgICAgYXR0cnMgYXMgdW5rbm93biBhcyBOYW1lZEF0dHJNYXApO1xuXG4gICAgICAgICAgc2F2ZShbZmlsdGVyLCB4NEQsIHJlcywgYmlhc10pO1xuXG4gICAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxuICAgICAgICAgICAgcmVzID0gcmVzaGFwZShyZXMsIFtyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdXSkgYXNcbiAgICAgICAgICAgICAgICBUZW5zb3IzRDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge3ZhbHVlOiByZXMsIGdyYWRGdW5jOiBncmFkfTtcbiAgICAgICAgfSk7XG5cbiAgICByZXR1cm4gY3VzdG9tT3BXaXRoQmlhcyh4NEQsICRmaWx0ZXIsICRiaWFzKSBhcyBUO1xuICB9XG59XG5leHBvcnQgY29uc3QgY29udjJkID0gLyogQF9fUFVSRV9fICovIG9wKHtmdXNlZENvbnYyZF99KTtcbiJdfQ==","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { customGrad } from '../../gradients';\nimport { FusedDepthwiseConv2D } from '../../kernel_names';\nimport { makeTypesMatch } from '../../tensor_util';\nimport { convertToTensor } from '../../tensor_util_env';\nimport * as util from '../../util';\nimport { add } from '../add';\nimport * as broadcast_util from '../broadcast_util';\nimport * as conv_util from '../conv_util';\nimport { depthwiseConv2d as unfusedDepthwiseConv2d } from '../depthwise_conv2d';\nimport { depthwiseConv2dNativeBackpropFilter } from '../depthwise_conv2d_native_backprop_filter';\nimport { depthwiseConv2dNativeBackpropInput } from '../depthwise_conv2d_native_backprop_input';\nimport { applyActivation, getFusedBiasGradient, getFusedDyActivation, shouldFuse } from '../fused_util';\nimport { op } from '../operation';\nimport { reshape } from '../reshape';\n/**\n * Computes depthwise 2D convolution, optionally fused with adding a\n * bias and applying an activation.\n *\n * Given a 4D `input` array and a `filter` array of shape\n * `[filterHeight, filterWidth, inChannels, channelMultiplier]` containing\n * `inChannels` convolutional filters of depth 1, this op applies a\n * different filter to each input channel (expanding from 1 channel to\n * `channelMultiplier` channels for each), then concatenates the results\n * together. The output has `inChannels * channelMultiplier` channels.\n *\n * See\n * [https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d](\n *     https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d)\n * for more details.\n *\n * @param obj An object with the following properties:\n * @param x The input tensor, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n * assumed.\n * @param filter The filter tensor, rank 4, of shape\n *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`. If strides is a single number, then `strideHeight ==\n * strideWidth`.\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels]. Only \"NHWC\" is currently supported.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @param bias Tensor to be added to the result.\n * @param activation Name of activation kernel (defaults to `linear`).\n * @param preluActivationWeights Tensor of prelu weights to be applied as part\n *     of a `prelu` activation, typically the same shape as `x`.\n * @param leakyreluAlpha Optional. Alpha to be applied as part of a `leakyrelu`\n *     activation.\n */\nfunction fusedDepthwiseConv2d_({ x, filter, strides, pad, dataFormat = 'NHWC', dilations = [1, 1], dimRoundingMode, bias, activation = 'linear', preluActivationWeights, leakyreluAlpha }) {\n    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {\n        let result = unfusedDepthwiseConv2d(x, filter, strides, pad, dataFormat, dilations, dimRoundingMode);\n        if (bias != null) {\n            result = add(result, bias);\n        }\n        return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);\n    }\n    const $x = convertToTensor(x, 'x', 'depthwiseConv2d', 'float32');\n    const $filter = convertToTensor(filter, 'filter', 'depthwiseConv2d', 'float32');\n    let x4D = $x;\n    let reshapedTo4D = false;\n    if ($x.rank === 3) {\n        reshapedTo4D = true;\n        x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n    }\n    util.assert(x4D.rank === 4, () => `Error in fused depthwiseConv2d: input must be rank 4, but got ` +\n        `rank ${x4D.rank}.`);\n    util.assert($filter.rank === 4, () => `Error in fused depthwiseConv2d: filter must be rank 4, ` +\n        `but got rank ${$filter.rank}.`);\n    util.assert(x4D.shape[3] === $filter.shape[2], () => `Error in fused depthwiseConv2d: number of input channels ` +\n        `(${x4D.shape[3]}) must match the inChannels dimension in ` +\n        `filter ${$filter.shape[2]}.`);\n    if (dilations == null) {\n        dilations = [1, 1];\n    }\n    util.assert(conv_util.eitherStridesOrDilationsAreOne(strides, dilations), () => 'Error in fused depthwiseConv2d: Either strides or dilations must ' +\n        `be 1. Got strides ${strides} and dilations '${dilations}'`);\n    conv_util.checkPadOnDimRoundingMode('fused depthwiseConv2d', pad, dimRoundingMode);\n    const convInfo = conv_util.computeConv2DInfo(x4D.shape, $filter.shape, strides, dilations, pad, dimRoundingMode, true /* depthwise */);\n    let $bias;\n    if (bias != null) {\n        $bias = convertToTensor(bias, 'bias', 'fused conv2d');\n        [$bias] = makeTypesMatch($bias, $x);\n        broadcast_util.assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);\n    }\n    let $preluActivationWeights;\n    if (preluActivationWeights != null) {\n        $preluActivationWeights = convertToTensor(preluActivationWeights, 'prelu weights', 'fused depthwiseConv2d');\n    }\n    const grad = (dy, saved) => {\n        util.assert(conv_util.tupleValuesAreOne(dilations), () => 'Error in gradient of fused depthwiseConv2d: dilation rates ' +\n            `greater than 1 are not yet supported. Got dilations ` +\n            `'${dilations}'`);\n        const [$filter, x4D, y, bias] = saved;\n        const dyActivation = getFusedDyActivation(dy, y, activation);\n        const xDer = depthwiseConv2dNativeBackpropInput(x4D.shape, dyActivation, $filter, strides, pad, dilations, dimRoundingMode);\n        const filterDer = depthwiseConv2dNativeBackpropFilter(x4D, dyActivation, $filter.shape, strides, pad, dilations, dimRoundingMode);\n        if (bias != null) {\n            const biasDer = getFusedBiasGradient($bias, dyActivation);\n            return [xDer, filterDer, biasDer];\n        }\n        return [xDer, filterDer];\n    };\n    const inputs = {\n        x: x4D,\n        filter: $filter,\n        bias: $bias,\n        preluActivationWeights: $preluActivationWeights\n    };\n    const attrs = {\n        strides,\n        pad,\n        dataFormat,\n        dilations,\n        dimRoundingMode,\n        activation,\n        leakyreluAlpha\n    };\n    // Depending on the the params passed in we will have different number of\n    // inputs and thus a a different number of elements in the gradient.\n    if (bias == null) {\n        const customOp = customGrad((x4D, filter, save) => {\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);\n            save([filter, x4D, res]);\n            if (reshapedTo4D) {\n                // tslint:disable-next-line: no-unnecessary-type-assertion\n                res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);\n            }\n            return { value: res, gradFunc: grad };\n        });\n        return customOp(x4D, $filter);\n    }\n    else {\n        const customOpWithBias = customGrad((x4D, filter, bias, save) => {\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            let res = ENGINE.runKernel(FusedDepthwiseConv2D, inputs, attrs);\n            save([filter, x4D, res, bias]);\n            if (reshapedTo4D) {\n                // tslint:disable-next-line: no-unnecessary-type-assertion\n                res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]);\n            }\n            return { value: res, gradFunc: grad };\n        });\n        return customOpWithBias(x4D, $filter, $bias);\n    }\n}\nexport const depthwiseConv2d = /* @__PURE__ */ op({ fusedDepthwiseConv2d_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwdGh3aXNlX2NvbnYyZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL2Z1c2VkL2RlcHRod2lzZV9jb252MmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUNwQyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFDLG9CQUFvQixFQUF3RCxNQUFNLG9CQUFvQixDQUFDO0FBSS9HLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRCxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFdEQsT0FBTyxLQUFLLElBQUksTUFBTSxZQUFZLENBQUM7QUFDbkMsT0FBTyxFQUFDLEdBQUcsRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUMzQixPQUFPLEtBQUssY0FBYyxNQUFNLG1CQUFtQixDQUFDO0FBQ3BELE9BQU8sS0FBSyxTQUFTLE1BQU0sY0FBYyxDQUFDO0FBQzFDLE9BQU8sRUFBQyxlQUFlLElBQUksc0JBQXNCLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUM5RSxPQUFPLEVBQUMsbUNBQW1DLEVBQUMsTUFBTSw0Q0FBNEMsQ0FBQztBQUMvRixPQUFPLEVBQUMsa0NBQWtDLEVBQUMsTUFBTSwyQ0FBMkMsQ0FBQztBQUU3RixPQUFPLEVBQUMsZUFBZSxFQUFFLG9CQUFvQixFQUFFLG9CQUFvQixFQUFFLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN0RyxPQUFPLEVBQUMsRUFBRSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBQ2hDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFFbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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O0FBQ0QsTUFBTSxDQUFDLE1BQU0sZUFBZSxHQUFHLGVBQWUsQ0FBQyxFQUFFLENBQUMsRUFBQyxxQkFBcUIsRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi8uLi9lbmdpbmUnO1xuaW1wb3J0IHtjdXN0b21HcmFkfSBmcm9tICcuLi8uLi9ncmFkaWVudHMnO1xuaW1wb3J0IHtGdXNlZERlcHRod2lzZUNvbnYyRCwgRnVzZWREZXB0aHdpc2VDb252MkRBdHRycywgRnVzZWREZXB0aHdpc2VDb252MkRJbnB1dHN9IGZyb20gJy4uLy4uL2tlcm5lbF9uYW1lcyc7XG5pbXBvcnQge05hbWVkQXR0ck1hcH0gZnJvbSAnLi4vLi4va2VybmVsX3JlZ2lzdHJ5JztcbmltcG9ydCB7VGVuc29yLCBUZW5zb3IzRCwgVGVuc29yNER9IGZyb20gJy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge0dyYWRTYXZlRnVuYywgTmFtZWRUZW5zb3JNYXB9IGZyb20gJy4uLy4uL3RlbnNvcl90eXBlcyc7XG5pbXBvcnQge21ha2VUeXBlc01hdGNofSBmcm9tICcuLi8uLi90ZW5zb3JfdXRpbCc7XG5pbXBvcnQge2NvbnZlcnRUb1RlbnNvcn0gZnJvbSAnLi4vLi4vdGVuc29yX3V0aWxfZW52JztcbmltcG9ydCB7VGVuc29yTGlrZX0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7YWRkfSBmcm9tICcuLi9hZGQnO1xuaW1wb3J0ICogYXMgYnJvYWRjYXN0X3V0aWwgZnJvbSAnLi4vYnJvYWRjYXN0X3V0aWwnO1xuaW1wb3J0ICogYXMgY29udl91dGlsIGZyb20gJy4uL2NvbnZfdXRpbCc7XG5pbXBvcnQge2RlcHRod2lzZUNvbnYyZCBhcyB1bmZ1c2VkRGVwdGh3aXNlQ29udjJkfSBmcm9tICcuLi9kZXB0aHdpc2VfY29udjJkJztcbmltcG9ydCB7ZGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BGaWx0ZXJ9IGZyb20gJy4uL2RlcHRod2lzZV9jb252MmRfbmF0aXZlX2JhY2twcm9wX2ZpbHRlcic7XG5pbXBvcnQge2RlcHRod2lzZUNvbnYyZE5hdGl2ZUJhY2twcm9wSW5wdXR9IGZyb20gJy4uL2RlcHRod2lzZV9jb252MmRfbmF0aXZlX2JhY2twcm9wX2lucHV0JztcbmltcG9ydCB7QWN0aXZhdGlvbn0gZnJvbSAnLi4vZnVzZWRfdHlwZXMnO1xuaW1wb3J0IHthcHBseUFjdGl2YXRpb24sIGdldEZ1c2VkQmlhc0dyYWRpZW50LCBnZXRGdXNlZER5QWN0aXZhdGlvbiwgc2hvdWxkRnVzZX0gZnJvbSAnLi4vZnVzZWRfdXRpbCc7XG5pbXBvcnQge29wfSBmcm9tICcuLi9vcGVyYXRpb24nO1xuaW1wb3J0IHtyZXNoYXBlfSBmcm9tICcuLi9yZXNoYXBlJztcblxuLyoqXG4gKiBDb21wdXRlcyBkZXB0aHdpc2UgMkQgY29udm9sdXRpb24sIG9wdGlvbmFsbHkgZnVzZWQgd2l0aCBhZGRpbmcgYVxuICogYmlhcyBhbmQgYXBwbHlpbmcgYW4gYWN0aXZhdGlvbi5cbiAqXG4gKiBHaXZlbiBhIDREIGBpbnB1dGAgYXJyYXkgYW5kIGEgYGZpbHRlcmAgYXJyYXkgb2Ygc2hhcGVcbiAqIGBbZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgaW5DaGFubmVscywgY2hhbm5lbE11bHRpcGxpZXJdYCBjb250YWluaW5nXG4gKiBgaW5DaGFubmVsc2AgY29udm9sdXRpb25hbCBmaWx0ZXJzIG9mIGRlcHRoIDEsIHRoaXMgb3AgYXBwbGllcyBhXG4gKiBkaWZmZXJlbnQgZmlsdGVyIHRvIGVhY2ggaW5wdXQgY2hhbm5lbCAoZXhwYW5kaW5nIGZyb20gMSBjaGFubmVsIHRvXG4gKiBgY2hhbm5lbE11bHRpcGxpZXJgIGNoYW5uZWxzIGZvciBlYWNoKSwgdGhlbiBjb25jYXRlbmF0ZXMgdGhlIHJlc3VsdHNcbiAqIHRvZ2V0aGVyLiBUaGUgb3V0cHV0IGhhcyBgaW5DaGFubmVscyAqIGNoYW5uZWxNdWx0aXBsaWVyYCBjaGFubmVscy5cbiAqXG4gKiBTZWVcbiAqIFtodHRwczovL3d3dy50ZW5zb3JmbG93Lm9yZy9hcGlfZG9jcy9weXRob24vdGYvbm4vZGVwdGh3aXNlX2NvbnYyZF0oXG4gKiAgICAgaHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL25uL2RlcHRod2lzZV9jb252MmQpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBwYXJhbSBvYmogQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogQHBhcmFtIHggVGhlIGlucHV0IHRlbnNvciwgb2YgcmFuayA0IG9yIHJhbmsgMywgb2Ygc2hhcGVcbiAqICAgICBgW2JhdGNoLCBoZWlnaHQsIHdpZHRoLCBpbkNoYW5uZWxzXWAuIElmIHJhbmsgMywgYmF0Y2ggb2YgMSBpc1xuICogYXNzdW1lZC5cbiAqIEBwYXJhbSBmaWx0ZXIgVGhlIGZpbHRlciB0ZW5zb3IsIHJhbmsgNCwgb2Ygc2hhcGVcbiAqICAgICBgW2ZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIGluQ2hhbm5lbHMsIGNoYW5uZWxNdWx0aXBsaWVyXWAuXG4gKiBAcGFyYW0gc3RyaWRlcyBUaGUgc3RyaWRlcyBvZiB0aGUgY29udm9sdXRpb246IGBbc3RyaWRlSGVpZ2h0LFxuICogc3RyaWRlV2lkdGhdYC4gSWYgc3RyaWRlcyBpcyBhIHNpbmdsZSBudW1iZXIsIHRoZW4gYHN0cmlkZUhlaWdodCA9PVxuICogc3RyaWRlV2lkdGhgLlxuICogQHBhcmFtIHBhZCBUaGUgdHlwZSBvZiBwYWRkaW5nIGFsZ29yaXRobS5cbiAqICAgLSBgc2FtZWAgYW5kIHN0cmlkZSAxOiBvdXRwdXQgd2lsbCBiZSBvZiBzYW1lIHNpemUgYXMgaW5wdXQsXG4gKiAgICAgICByZWdhcmRsZXNzIG9mIGZpbHRlciBzaXplLlxuICogICAtIGB2YWxpZGA6IG91dHB1dCB3aWxsIGJlIHNtYWxsZXIgdGhhbiBpbnB1dCBpZiBmaWx0ZXIgaXMgbGFyZ2VyXG4gKiAgICAgICB0aGFuIDF4MS5cbiAqICAgLSBGb3IgbW9yZSBpbmZvLCBzZWUgdGhpcyBndWlkZTpcbiAqICAgICBbaHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvYXBpX2RvY3MvcHl0aG9uL3RmL25uL2NvbnZvbHV0aW9uXShcbiAqICAgICAgICAgIGh0dHBzOi8vd3d3LnRlbnNvcmZsb3cub3JnL2FwaV9kb2NzL3B5dGhvbi90Zi9ubi9jb252b2x1dGlvbilcbiAqIEBwYXJhbSBkaWxhdGlvbnMgVGhlIGRpbGF0aW9uIHJhdGVzOiBgW2RpbGF0aW9uSGVpZ2h0LCBkaWxhdGlvbldpZHRoXWBcbiAqICAgICBpbiB3aGljaCB3ZSBzYW1wbGUgaW5wdXQgdmFsdWVzIGFjcm9zcyB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBkaW1lbnNpb25zXG4gKiAgICAgaW4gYXRyb3VzIGNvbnZvbHV0aW9uLiBEZWZhdWx0cyB0byBgWzEsIDFdYC4gSWYgYHJhdGVgIGlzIGEgc2luZ2xlXG4gKiAgICAgbnVtYmVyLCB0aGVuIGBkaWxhdGlvbkhlaWdodCA9PSBkaWxhdGlvbldpZHRoYC4gSWYgaXQgaXMgZ3JlYXRlciB0aGFuXG4gKiAgICAgMSwgdGhlbiBhbGwgdmFsdWVzIG9mIGBzdHJpZGVzYCBtdXN0IGJlIDEuXG4gKiBAcGFyYW0gZGF0YUZvcm1hdDogQW4gb3B0aW9uYWwgc3RyaW5nIGZyb206IFwiTkhXQ1wiLCBcIk5DSFdcIi4gRGVmYXVsdHMgdG9cbiAqICAgICBcIk5IV0NcIi4gU3BlY2lmeSB0aGUgZGF0YSBmb3JtYXQgb2YgdGhlIGlucHV0IGFuZCBvdXRwdXQgZGF0YS4gV2l0aCB0aGVcbiAqICAgICBkZWZhdWx0IGZvcm1hdCBcIk5IV0NcIiwgdGhlIGRhdGEgaXMgc3RvcmVkIGluIHRoZSBvcmRlciBvZjogW2JhdGNoLFxuICogICAgIGhlaWdodCwgd2lkdGgsIGNoYW5uZWxzXS4gT25seSBcIk5IV0NcIiBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLlxuICogQHBhcmFtIGRpbVJvdW5kaW5nTW9kZSBBIHN0cmluZyBmcm9tOiAnY2VpbCcsICdyb3VuZCcsICdmbG9vcicuIElmIG5vbmUgaXNcbiAqICAgICBwcm92aWRlZCwgaXQgd2lsbCBkZWZhdWx0IHRvIHRydW5jYXRlLlxuICogQHBhcmFtIGJpYXMgVGVuc29yIHRvIGJlIGFkZGVkIHRvIHRoZSByZXN1bHQuXG4gKiBAcGFyYW0gYWN0aXZhdGlvbiBOYW1lIG9mIGFjdGl2YXRpb24ga2VybmVsIChkZWZhdWx0cyB0byBgbGluZWFyYCkuXG4gKiBAcGFyYW0gcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyBUZW5zb3Igb2YgcHJlbHUgd2VpZ2h0cyB0byBiZSBhcHBsaWVkIGFzIHBhcnRcbiAqICAgICBvZiBhIGBwcmVsdWAgYWN0aXZhdGlvbiwgdHlwaWNhbGx5IHRoZSBzYW1lIHNoYXBlIGFzIGB4YC5cbiAqIEBwYXJhbSBsZWFreXJlbHVBbHBoYSBPcHRpb25hbC4gQWxwaGEgdG8gYmUgYXBwbGllZCBhcyBwYXJ0IG9mIGEgYGxlYWt5cmVsdWBcbiAqICAgICBhY3RpdmF0aW9uLlxuICovXG5mdW5jdGlvbiBmdXNlZERlcHRod2lzZUNvbnYyZF88VCBleHRlbmRzIFRlbnNvcjNEfFRlbnNvcjREPih7XG4gIHgsXG4gIGZpbHRlcixcbiAgc3RyaWRlcyxcbiAgcGFkLFxuICBkYXRhRm9ybWF0ID0gJ05IV0MnLFxuICBkaWxhdGlvbnMgPSBbMSwgMV0sXG4gIGRpbVJvdW5kaW5nTW9kZSxcbiAgYmlhcyxcbiAgYWN0aXZhdGlvbiA9ICdsaW5lYXInLFxuICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLFxuICBsZWFreXJlbHVBbHBoYVxufToge1xuICB4OiBUfFRlbnNvckxpa2UsXG4gIGZpbHRlcjogVGVuc29yNER8VGVuc29yTGlrZSxcbiAgc3RyaWRlczogW251bWJlciwgbnVtYmVyXXxudW1iZXIsXG4gIHBhZDogJ3ZhbGlkJ3wnc2FtZSd8bnVtYmVyLFxuICBkYXRhRm9ybWF0PzogJ05IV0MnfCdOQ0hXJyxcbiAgZGlsYXRpb25zPzogW251bWJlciwgbnVtYmVyXXxudW1iZXIsXG4gIGRpbVJvdW5kaW5nTW9kZT86ICdmbG9vcid8J3JvdW5kJ3wnY2VpbCcsXG4gIGJpYXM/OiBUZW5zb3J8VGVuc29yTGlrZSxcbiAgYWN0aXZhdGlvbj86IEFjdGl2YXRpb24sXG4gIHByZWx1QWN0aXZhdGlvbldlaWdodHM/OiBUZW5zb3IsXG4gIGxlYWt5cmVsdUFscGhhPzogbnVtYmVyXG59KTogVCB7XG4gIGlmIChzaG91bGRGdXNlKEVOR0lORS5zdGF0ZS5ncmFkaWVudERlcHRoLCBhY3RpdmF0aW9uKSA9PT0gZmFsc2UpIHtcbiAgICBsZXQgcmVzdWx0ID0gdW5mdXNlZERlcHRod2lzZUNvbnYyZChcbiAgICAgICAgeCwgZmlsdGVyLCBzdHJpZGVzLCBwYWQsIGRhdGFGb3JtYXQsIGRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlKTtcbiAgICBpZiAoYmlhcyAhPSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBhZGQocmVzdWx0LCBiaWFzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXBwbHlBY3RpdmF0aW9uKFxuICAgICAgICAgICAgICAgcmVzdWx0LCBhY3RpdmF0aW9uLCBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLCBsZWFreXJlbHVBbHBoYSkgYXMgVDtcbiAgfVxuXG4gIGNvbnN0ICR4ID0gY29udmVydFRvVGVuc29yKHgsICd4JywgJ2RlcHRod2lzZUNvbnYyZCcsICdmbG9hdDMyJyk7XG4gIGNvbnN0ICRmaWx0ZXIgPVxuICAgICAgY29udmVydFRvVGVuc29yKGZpbHRlciwgJ2ZpbHRlcicsICdkZXB0aHdpc2VDb252MmQnLCAnZmxvYXQzMicpO1xuXG4gIGxldCB4NEQgPSAkeCBhcyBUZW5zb3I0RDtcbiAgbGV0IHJlc2hhcGVkVG80RCA9IGZhbHNlO1xuICBpZiAoJHgucmFuayA9PT0gMykge1xuICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgeDREID0gcmVzaGFwZSgkeCwgWzEsICR4LnNoYXBlWzBdLCAkeC5zaGFwZVsxXSwgJHguc2hhcGVbMl1dKTtcbiAgfVxuICB1dGlsLmFzc2VydChcbiAgICAgIHg0RC5yYW5rID09PSA0LFxuICAgICAgKCkgPT4gYEVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgYCArXG4gICAgICAgICAgYHJhbmsgJHt4NEQucmFua30uYCk7XG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgJGZpbHRlci5yYW5rID09PSA0LFxuICAgICAgKCkgPT4gYEVycm9yIGluIGZ1c2VkIGRlcHRod2lzZUNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBgICtcbiAgICAgICAgICBgYnV0IGdvdCByYW5rICR7JGZpbHRlci5yYW5rfS5gKTtcbiAgdXRpbC5hc3NlcnQoXG4gICAgICB4NEQuc2hhcGVbM10gPT09ICRmaWx0ZXIuc2hhcGVbMl0sXG4gICAgICAoKSA9PiBgRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBudW1iZXIgb2YgaW5wdXQgY2hhbm5lbHMgYCArXG4gICAgICAgICAgYCgke3g0RC5zaGFwZVszXX0pIG11c3QgbWF0Y2ggdGhlIGluQ2hhbm5lbHMgZGltZW5zaW9uIGluIGAgK1xuICAgICAgICAgIGBmaWx0ZXIgJHskZmlsdGVyLnNoYXBlWzJdfS5gKTtcbiAgaWYgKGRpbGF0aW9ucyA9PSBudWxsKSB7XG4gICAgZGlsYXRpb25zID0gWzEsIDFdO1xuICB9XG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgY29udl91dGlsLmVpdGhlclN0cmlkZXNPckRpbGF0aW9uc0FyZU9uZShzdHJpZGVzLCBkaWxhdGlvbnMpLFxuICAgICAgKCkgPT5cbiAgICAgICAgICAnRXJyb3IgaW4gZnVzZWQgZGVwdGh3aXNlQ29udjJkOiBFaXRoZXIgc3RyaWRlcyBvciBkaWxhdGlvbnMgbXVzdCAnICtcbiAgICAgICAgICBgYmUgMS4gR290IHN0cmlkZXMgJHtzdHJpZGVzfSBhbmQgZGlsYXRpb25zICcke2RpbGF0aW9uc30nYCk7XG4gIGNvbnZfdXRpbC5jaGVja1BhZE9uRGltUm91bmRpbmdNb2RlKFxuICAgICAgJ2Z1c2VkIGRlcHRod2lzZUNvbnYyZCcsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgY29uc3QgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oXG4gICAgICB4NEQuc2hhcGUsICRmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIGRpbGF0aW9ucywgcGFkLCBkaW1Sb3VuZGluZ01vZGUsXG4gICAgICB0cnVlIC8qIGRlcHRod2lzZSAqLyk7XG5cbiAgbGV0ICRiaWFzOiBUZW5zb3I7XG4gIGlmIChiaWFzICE9IG51bGwpIHtcbiAgICAkYmlhcyA9IGNvbnZlcnRUb1RlbnNvcihiaWFzLCAnYmlhcycsICdmdXNlZCBjb252MmQnKTtcbiAgICBbJGJpYXNdID0gbWFrZVR5cGVzTWF0Y2goJGJpYXMsICR4KTtcblxuICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGNvbnZJbmZvLm91dFNoYXBlLCAkYmlhcy5zaGFwZSk7XG4gIH1cblxuICBsZXQgJHByZWx1QWN0aXZhdGlvbldlaWdodHM6IFRlbnNvcjtcbiAgaWYgKHByZWx1QWN0aXZhdGlvbldlaWdodHMgIT0gbnVsbCkge1xuICAgICRwcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gY29udmVydFRvVGVuc29yKFxuICAgICAgICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLCAncHJlbHUgd2VpZ2h0cycsICdmdXNlZCBkZXB0aHdpc2VDb252MmQnKTtcbiAgfVxuXG4gIGNvbnN0IGdyYWQgPSAoZHk6IFRlbnNvcjRELCBzYXZlZDogVGVuc29yW10pID0+IHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgY29udl91dGlsLnR1cGxlVmFsdWVzQXJlT25lKGRpbGF0aW9ucyksXG4gICAgICAgICgpID0+ICdFcnJvciBpbiBncmFkaWVudCBvZiBmdXNlZCBkZXB0aHdpc2VDb252MmQ6IGRpbGF0aW9uIHJhdGVzICcgK1xuICAgICAgICAgICAgYGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0IHN1cHBvcnRlZC4gR290IGRpbGF0aW9ucyBgICtcbiAgICAgICAgICAgIGAnJHtkaWxhdGlvbnN9J2ApO1xuICAgIGNvbnN0IFskZmlsdGVyLCB4NEQsIHksIGJpYXNdID0gc2F2ZWQ7XG5cbiAgICBjb25zdCBkeUFjdGl2YXRpb24gPSBnZXRGdXNlZER5QWN0aXZhdGlvbihkeSwgeSwgYWN0aXZhdGlvbikgYXMgVGVuc29yNEQ7XG5cbiAgICBjb25zdCB4RGVyID0gZGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BJbnB1dChcbiAgICAgICAgKHg0RCBhcyBUZW5zb3I0RCkuc2hhcGUsIGR5QWN0aXZhdGlvbiwgJGZpbHRlciBhcyBUZW5zb3I0RCwgc3RyaWRlcyxcbiAgICAgICAgcGFkLCBkaWxhdGlvbnMsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgY29uc3QgZmlsdGVyRGVyID0gZGVwdGh3aXNlQ29udjJkTmF0aXZlQmFja3Byb3BGaWx0ZXIoXG4gICAgICAgIHg0RCBhcyBUZW5zb3I0RCwgZHlBY3RpdmF0aW9uLCAoJGZpbHRlciBhcyBUZW5zb3I0RCkuc2hhcGUsIHN0cmlkZXMsXG4gICAgICAgIHBhZCwgZGlsYXRpb25zLCBkaW1Sb3VuZGluZ01vZGUpO1xuXG4gICAgaWYgKGJpYXMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgYmlhc0RlciA9IGdldEZ1c2VkQmlhc0dyYWRpZW50KCRiaWFzLCBkeUFjdGl2YXRpb24pO1xuICAgICAgcmV0dXJuIFt4RGVyLCBmaWx0ZXJEZXIsIGJpYXNEZXJdO1xuICAgIH1cbiAgICByZXR1cm4gW3hEZXIsIGZpbHRlckRlcl07XG4gIH07XG5cbiAgY29uc3QgaW5wdXRzOiBGdXNlZERlcHRod2lzZUNvbnYyRElucHV0cyA9IHtcbiAgICB4OiB4NEQsXG4gICAgZmlsdGVyOiAkZmlsdGVyLFxuICAgIGJpYXM6ICRiaWFzLFxuICAgIHByZWx1QWN0aXZhdGlvbldlaWdodHM6ICRwcmVsdUFjdGl2YXRpb25XZWlnaHRzXG4gIH07XG4gIGNvbnN0IGF0dHJzOiBGdXNlZERlcHRod2lzZUNvbnYyREF0dHJzID0ge1xuICAgIHN0cmlkZXMsXG4gICAgcGFkLFxuICAgIGRhdGFGb3JtYXQsXG4gICAgZGlsYXRpb25zLFxuICAgIGRpbVJvdW5kaW5nTW9kZSxcbiAgICBhY3RpdmF0aW9uLFxuICAgIGxlYWt5cmVsdUFscGhhXG4gIH07XG5cbiAgLy8gRGVwZW5kaW5nIG9uIHRoZSB0aGUgcGFyYW1zIHBhc3NlZCBpbiB3ZSB3aWxsIGhhdmUgZGlmZmVyZW50IG51bWJlciBvZlxuICAvLyBpbnB1dHMgYW5kIHRodXMgYSBhIGRpZmZlcmVudCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGdyYWRpZW50LlxuICBpZiAoYmlhcyA9PSBudWxsKSB7XG4gICAgY29uc3QgY3VzdG9tT3AgPVxuICAgICAgICBjdXN0b21HcmFkKCh4NEQ6IFRlbnNvcjRELCBmaWx0ZXI6IFRlbnNvcjRELCBzYXZlOiBHcmFkU2F2ZUZ1bmMpID0+IHtcbiAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgICAgbGV0IHJlczogVGVuc29yNER8VGVuc29yM0QgPSBFTkdJTkUucnVuS2VybmVsKFxuICAgICAgICAgICAgICBGdXNlZERlcHRod2lzZUNvbnYyRCwgaW5wdXRzIGFzIHVua25vd24gYXMgTmFtZWRUZW5zb3JNYXAsXG4gICAgICAgICAgICAgIGF0dHJzIGFzIHVua25vd24gYXMgTmFtZWRBdHRyTWFwKTtcblxuICAgICAgICAgIHNhdmUoW2ZpbHRlciwgeDRELCByZXNdKTtcblxuICAgICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cbiAgICAgICAgICAgIHJlcyA9IHJlc2hhcGUocmVzLCBbcmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXV0pIGFzXG4gICAgICAgICAgICAgICAgVGVuc29yM0Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHt2YWx1ZTogcmVzLCBncmFkRnVuYzogZ3JhZH07XG4gICAgICAgIH0pO1xuICAgIHJldHVybiBjdXN0b21PcCh4NEQsICRmaWx0ZXIpIGFzIFQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY3VzdG9tT3BXaXRoQmlhcyA9IGN1c3RvbUdyYWQoXG4gICAgICAgICh4NEQ6IFRlbnNvcjRELCBmaWx0ZXI6IFRlbnNvcjRELCBiaWFzOiBUZW5zb3IsIHNhdmU6IEdyYWRTYXZlRnVuYykgPT4ge1xuICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cbiAgICAgICAgICBsZXQgcmVzOiBUZW5zb3I0RHxUZW5zb3IzRCA9IEVOR0lORS5ydW5LZXJuZWwoXG4gICAgICAgICAgICAgIEZ1c2VkRGVwdGh3aXNlQ29udjJELCBpbnB1dHMgYXMgdW5rbm93biBhcyBOYW1lZFRlbnNvck1hcCxcbiAgICAgICAgICAgICAgYXR0cnMgYXMgdW5rbm93biBhcyBOYW1lZEF0dHJNYXApO1xuXG4gICAgICAgICAgc2F2ZShbZmlsdGVyLCB4NEQsIHJlcywgYmlhc10pO1xuXG4gICAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxuICAgICAgICAgICAgcmVzID0gcmVzaGFwZShyZXMsIFtyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdXSkgYXNcbiAgICAgICAgICAgICAgICBUZW5zb3IzRDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge3ZhbHVlOiByZXMsIGdyYWRGdW5jOiBncmFkfTtcbiAgICAgICAgfSk7XG5cbiAgICByZXR1cm4gY3VzdG9tT3BXaXRoQmlhcyh4NEQsICRmaWx0ZXIsICRiaWFzKSBhcyBUO1xuICB9XG59XG5leHBvcnQgY29uc3QgZGVwdGh3aXNlQ29udjJkID0gLyogQF9fUFVSRV9fICovIG9wKHtmdXNlZERlcHRod2lzZUNvbnYyZF99KTtcbiJdfQ==","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../../engine';\nimport { customGrad } from '../../gradients';\nimport { _FusedMatMul } from '../../kernel_names';\nimport { makeTypesMatch } from '../../tensor_util';\nimport { convertToTensor } from '../../tensor_util_env';\nimport * as util from '../../util';\nimport { add } from '../add';\nimport * as broadcast_util from '../broadcast_util';\nimport { applyActivation, getFusedBiasGradient, getFusedDyActivation, shouldFuse } from '../fused_util';\nimport { matMul as unfusedMatMul } from '../mat_mul';\nimport { op } from '../operation';\nimport { reshape } from '../reshape';\n/**\n * Computes the dot product of two matrices with optional activation and bias.\n *\n * ```js\n * const a = tf.tensor2d([-1, -2], [1, 2]);\n * const b = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const bias = tf.tensor2d([1, 2], [1, 2]);\n *\n * tf.fused.matMul({a, b, bias, activation: 'relu'}).print();\n * ```\n *\n * @param obj An object with the following properties:\n * - `a` First matrix in dot product operation.\n * - `b` Second matrix in dot product operation.\n * - `transposeA` If true, `a` is transposed before multiplication.\n * - `transposeB` If true, `b` is transposed before multiplication.\n * - `bias` Matrix to be added to the result.\n * - `activation` Name of activation kernel (defaults to `linear`).\n * - `preluActivationWeights` Tensor of prelu weights.\n * - `leakyreluAlpha` Alpha of leakyrelu.\n */\nfunction fusedMatMul_({ a, b, transposeA = false, transposeB = false, bias, activation = 'linear', preluActivationWeights, leakyreluAlpha = 0.2, }) {\n    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {\n        let result = unfusedMatMul(a, b, transposeA, transposeB);\n        if (bias != null) {\n            result = add(result, bias);\n        }\n        return applyActivation(result, activation, preluActivationWeights, leakyreluAlpha);\n    }\n    let $a = convertToTensor(a, 'a', 'fused matMul');\n    let $b = convertToTensor(b, 'b', 'fused matMul');\n    [$a, $b] = makeTypesMatch($a, $b);\n    const innerShapeA = transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];\n    const innerShapeB = transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];\n    const outerShapeA = transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];\n    const outerShapeB = transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];\n    const outerDimsA = $a.shape.slice(0, -2);\n    const outerDimsB = $b.shape.slice(0, -2);\n    const batchDimA = util.sizeFromShape(outerDimsA);\n    const batchDimB = util.sizeFromShape(outerDimsB);\n    util.assert(innerShapeA === innerShapeB, () => `Error in fused matMul: inner shapes (${innerShapeA}) and (` +\n        `${innerShapeB}) of Tensors with shapes ${$a.shape} and ` +\n        `${$b.shape} and transposeA=${transposeA}` +\n        ` and transposeB=${transposeB} must match.`);\n    const outShapeOuterDims = broadcast_util.assertAndGetBroadcastShape($a.shape.slice(0, -2), $b.shape.slice(0, -2));\n    const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n    const a3D = transposeA ?\n        reshape($a, [batchDimA, innerShapeA, outerShapeA]) :\n        reshape($a, [batchDimA, outerShapeA, innerShapeA]);\n    const b3D = transposeB ?\n        reshape($b, [batchDimB, outerShapeB, innerShapeB]) :\n        reshape($b, [batchDimB, innerShapeB, outerShapeB]);\n    let $bias;\n    if (bias != null) {\n        $bias = convertToTensor(bias, 'bias', 'fused matMul');\n        [$bias] = makeTypesMatch($bias, $a);\n        broadcast_util.assertAndGetBroadcastShape(outShape, $bias.shape);\n    }\n    let $preluActivationWeights;\n    if (preluActivationWeights != null) {\n        $preluActivationWeights = convertToTensor(preluActivationWeights, 'prelu weights', 'fused matMul');\n    }\n    const grad = (dy, saved) => {\n        const [a3D, b3D, y, $bias] = saved;\n        // we reshape dy because the result of the forward is not\n        // necessarily going to be a 3d tensor due to a reshape done at the end of\n        // the customOp.\n        const dyActivation = getFusedDyActivation(reshape(dy, y.shape), y, activation);\n        let aDer;\n        let bDer;\n        if (!transposeA && !transposeB) {\n            aDer = unfusedMatMul(dyActivation, b3D, false, true);\n            bDer = unfusedMatMul(a3D, dyActivation, true, false);\n        }\n        else if (!transposeA && transposeB) {\n            aDer = unfusedMatMul(dyActivation, b3D, false, false);\n            bDer = unfusedMatMul(dyActivation, a3D, true, false);\n        }\n        else if (transposeA && !transposeB) {\n            aDer = unfusedMatMul(b3D, dyActivation, false, true);\n            bDer = unfusedMatMul(a3D, dyActivation, false, false);\n        }\n        else {\n            aDer = unfusedMatMul(b3D, dyActivation, true, true);\n            bDer = unfusedMatMul(dyActivation, a3D, true, true);\n        }\n        if (bias != null) {\n            const biasDer = getFusedBiasGradient($bias, dyActivation);\n            return [aDer, bDer, biasDer];\n        }\n        else {\n            return [aDer, bDer];\n        }\n    };\n    const inputs = {\n        a: a3D,\n        b: b3D,\n        bias: $bias,\n        preluActivationWeights: $preluActivationWeights\n    };\n    const attrs = { transposeA, transposeB, activation, leakyreluAlpha };\n    // Depending on the the params passed in we will have different number of\n    // inputs and thus a a different number of elements in the gradient.\n    if (bias == null) {\n        const customOp = customGrad((a3D, b3D, save) => {\n            const res = \n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            ENGINE.runKernel(_FusedMatMul, inputs, attrs);\n            save([a3D, b3D, res]);\n            return { value: reshape(res, outShape), gradFunc: grad };\n        });\n        return customOp(a3D, b3D);\n    }\n    else {\n        const customOpWithBias = customGrad((a3D, b3D, $bias, save) => {\n            const res = \n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            ENGINE.runKernel(_FusedMatMul, inputs, attrs);\n            save([a3D, b3D, res, $bias]);\n            return { value: reshape(res, outShape), gradFunc: grad };\n        });\n        return customOpWithBias(a3D, b3D, $bias);\n    }\n}\nexport const matMul = /* @__PURE__ */ op({ fusedMatMul_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0X211bC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL2Z1c2VkL21hdF9tdWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUNwQyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFDLFlBQVksRUFBd0MsTUFBTSxvQkFBb0IsQ0FBQztBQUl2RixPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDakQsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRXRELE9BQU8sS0FBSyxJQUFJLE1BQU0sWUFBWSxDQUFDO0FBRW5DLE9BQU8sRUFBQyxHQUFHLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDM0IsT0FBTyxLQUFLLGNBQWMsTUFBTSxtQkFBbUIsQ0FBQztBQUVwRCxPQUFPLEVBQUMsZUFBZSxFQUFFLG9CQUFvQixFQUFFLG9CQUFvQixFQUFFLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN0RyxPQUFPLEVBQUMsTUFBTSxJQUFJLGFBQWEsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUNuRCxPQUFPLEVBQUMsRUFBRSxFQUFDLE1BQU0sY0FBYyxDQUFDO0FBQ2hDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFFbkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBb0JHO0FBQ0gsU0FBUyxZQUFZLENBQUMsRUFDcEIsQ0FBQyxFQUNELENBQUMsRUFDRCxVQUFVLEdBQUcsS0FBSyxFQUNsQixVQUFVLEdBQUcsS0FBSyxFQUNsQixJQUFJLEVBQ0osVUFBVSxHQUFHLFFBQVEsRUFDckIsc0JBQXNCLEVBQ3RCLGNBQWMsR0FBRyxHQUFHLEdBVXJCO0lBQ0csSUFBSSxVQUFV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QUFFLEdBQWEsRUFBRSxLQUFhLEVBQUUsSUFBa0IsRUFBRSxFQUFFO1lBQ2xFLE1BQU0sR0FBRztZQUNMLDBEQUEwRDtZQUMxRCxNQUFNLENBQUMsU0FBUyxDQUNaLFlBQVksRUFBRSxNQUFtQyxFQUNqRCxLQUFnQyxDQUFXLENBQUM7WUFFcEQsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUU3QixPQUFPLEVBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBQyxDQUFDO1FBQ3pELENBQUMsQ0FBQyxDQUFDO1FBRVAsT0FBTyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQzFDO0FBQ0gsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLE1BQU0sR0FBRyxlQUFlLENBQUMsRUFBRSxDQUFDLEVBQUMsWUFBWSxFQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtFTkdJTkV9IGZyb20gJy4uLy4uL2VuZ2luZSc7XG5pbXBvcnQge2N1c3RvbUdyYWR9IGZyb20gJy4uLy4uL2dyYWRpZW50cyc7XG5pbXBvcnQge19GdXNlZE1hdE11bCwgX0Z1c2VkTWF0TXVsQXR0cnMsIF9GdXNlZE1hdE11bElucHV0c30gZnJvbSAnLi4vLi4va2VybmVsX25hbWVzJztcbmltcG9ydCB7TmFtZWRBdHRyTWFwfSBmcm9tICcuLi8uLi9rZXJuZWxfcmVnaXN0cnknO1xuaW1wb3J0IHtUZW5zb3IsIFRlbnNvcjNEfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtHcmFkU2F2ZUZ1bmMsIE5hbWVkVGVuc29yTWFwfSBmcm9tICcuLi8uLi90ZW5zb3JfdHlwZXMnO1xuaW1wb3J0IHttYWtlVHlwZXNNYXRjaH0gZnJvbSAnLi4vLi4vdGVuc29yX3V0aWwnO1xuaW1wb3J0IHtjb252ZXJ0VG9UZW5zb3J9IGZyb20gJy4uLy4uL3RlbnNvcl91dGlsX2Vudic7XG5pbXBvcnQge1RlbnNvckxpa2V9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vLi4vdXRpbCc7XG5cbmltcG9ydCB7YWRkfSBmcm9tICcuLi9hZGQnO1xuaW1wb3J0ICogYXMgYnJvYWRjYXN0X3V0aWwgZnJvbSAnLi4vYnJvYWRjYXN0X3V0aWwnO1xuaW1wb3J0IHtBY3RpdmF0aW9ufSBmcm9tICcuLi9mdXNlZF90eXBlcyc7XG5pbXBvcnQge2FwcGx5QWN0aXZhdGlvbiwgZ2V0RnVzZWRCaWFzR3JhZGllbnQsIGdldEZ1c2VkRHlBY3RpdmF0aW9uLCBzaG91bGRGdXNlfSBmcm9tICcuLi9mdXNlZF91dGlsJztcbmltcG9ydCB7bWF0TXVsIGFzIHVuZnVzZWRNYXRNdWx9IGZyb20gJy4uL21hdF9tdWwnO1xuaW1wb3J0IHtvcH0gZnJvbSAnLi4vb3BlcmF0aW9uJztcbmltcG9ydCB7cmVzaGFwZX0gZnJvbSAnLi4vcmVzaGFwZSc7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBtYXRyaWNlcyB3aXRoIG9wdGlvbmFsIGFjdGl2YXRpb24gYW5kIGJpYXMuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGEgPSB0Zi50ZW5zb3IyZChbLTEsIC0yXSwgWzEsIDJdKTtcbiAqIGNvbnN0IGIgPSB0Zi50ZW5zb3IyZChbMSwgMiwgMywgNF0sIFsyLCAyXSk7XG4gKiBjb25zdCBiaWFzID0gdGYudGVuc29yMmQoWzEsIDJdLCBbMSwgMl0pO1xuICpcbiAqIHRmLmZ1c2VkLm1hdE11bCh7YSwgYiwgYmlhcywgYWN0aXZhdGlvbjogJ3JlbHUnfSkucHJpbnQoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBvYmogQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogLSBgYWAgRmlyc3QgbWF0cml4IGluIGRvdCBwcm9kdWN0IG9wZXJhdGlvbi5cbiAqIC0gYGJgIFNlY29uZCBtYXRyaXggaW4gZG90IHByb2R1Y3Qgb3BlcmF0aW9uLlxuICogLSBgdHJhbnNwb3NlQWAgSWYgdHJ1ZSwgYGFgIGlzIHRyYW5zcG9zZWQgYmVmb3JlIG11bHRpcGxpY2F0aW9uLlxuICogLSBgdHJhbnNwb3NlQmAgSWYgdHJ1ZSwgYGJgIGlzIHRyYW5zcG9zZWQgYmVmb3JlIG11bHRpcGxpY2F0aW9uLlxuICogLSBgYmlhc2AgTWF0cml4IHRvIGJlIGFkZGVkIHRvIHRoZSByZXN1bHQuXG4gKiAtIGBhY3RpdmF0aW9uYCBOYW1lIG9mIGFjdGl2YXRpb24ga2VybmVsIChkZWZhdWx0cyB0byBgbGluZWFyYCkuXG4gKiAtIGBwcmVsdUFjdGl2YXRpb25XZWlnaHRzYCBUZW5zb3Igb2YgcHJlbHUgd2VpZ2h0cy5cbiAqIC0gYGxlYWt5cmVsdUFscGhhYCBBbHBoYSBvZiBsZWFreXJlbHUuXG4gKi9cbmZ1bmN0aW9uIGZ1c2VkTWF0TXVsXyh7XG4gIGEsXG4gIGIsXG4gIHRyYW5zcG9zZUEgPSBmYWxzZSxcbiAgdHJhbnNwb3NlQiA9IGZhbHNlLFxuICBiaWFzLFxuICBhY3RpdmF0aW9uID0gJ2xpbmVhcicsXG4gIHByZWx1QWN0aXZhdGlvbldlaWdodHMsXG4gIGxlYWt5cmVsdUFscGhhID0gMC4yLFxufToge1xuICBhOiBUZW5zb3J8VGVuc29yTGlrZSxcbiAgYjogVGVuc29yfFRlbnNvckxpa2UsXG4gIHRyYW5zcG9zZUE/OiBib29sZWFuLFxuICB0cmFuc3Bvc2VCPzogYm9vbGVhbixcbiAgYmlhcz86IFRlbnNvcnxUZW5zb3JMaWtlLFxuICBhY3RpdmF0aW9uPzogQWN0aXZhdGlvbixcbiAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cz86IFRlbnNvclxuICBsZWFreXJlbHVBbHBoYT86IG51bWJlclxufSk6IFRlbnNvciB7XG4gICAgaWYgKHNob3VsZEZ1c2UoRU5HSU5FLnN0YXRlLmdyYWRpZW50RGVwdGgsIGFjdGl2YXRpb24pID09PSBmYWxzZSkge1xuICAgICAgbGV0IHJlc3VsdCA9IHVuZnVzZWRNYXRNdWwoYSwgYiwgdHJhbnNwb3NlQSwgdHJhbnNwb3NlQik7XG4gICAgICBpZiAoYmlhcyAhPSBudWxsKSB7XG4gICAgICAgIHJlc3VsdCA9IGFkZChyZXN1bHQsIGJpYXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXBwbHlBY3RpdmF0aW9uKFxuICAgICAgICAgICAgICAgICByZXN1bHQsIGFjdGl2YXRpb24sIHByZWx1QWN0aXZhdGlvbldlaWdodHMsIGxlYWt5cmVsdUFscGhhKTtcbiAgICB9XG5cbiAgICBsZXQgJGEgPSBjb252ZXJ0VG9UZW5zb3IoYSwgJ2EnLCAnZnVzZWQgbWF0TXVsJyk7XG4gICAgbGV0ICRiID0gY29udmVydFRvVGVuc29yKGIsICdiJywgJ2Z1c2VkIG1hdE11bCcpO1xuICAgIFskYSwgJGJdID0gbWFrZVR5cGVzTWF0Y2goJGEsICRiKTtcblxuICAgIGNvbnN0IGlubmVyU2hhcGVBID1cbiAgICAgICAgdHJhbnNwb3NlQSA/ICRhLnNoYXBlWyRhLnJhbmsgLSAyXSA6ICRhLnNoYXBlWyRhLnJhbmsgLSAxXTtcbiAgICBjb25zdCBpbm5lclNoYXBlQiA9XG4gICAgICAgIHRyYW5zcG9zZUIgPyAkYi5zaGFwZVskYi5yYW5rIC0gMV0gOiAkYi5zaGFwZVskYi5yYW5rIC0gMl07XG5cbiAgICBjb25zdCBvdXRlclNoYXBlQSA9XG4gICAgICAgIHRyYW5zcG9zZUEgPyAkYS5zaGFwZVskYS5yYW5rIC0gMV0gOiAkYS5zaGFwZVskYS5yYW5rIC0gMl07XG4gICAgY29uc3Qgb3V0ZXJTaGFwZUIgPVxuICAgICAgICB0cmFuc3Bvc2VCID8gJGIuc2hhcGVbJGIucmFuayAtIDJdIDogJGIuc2hhcGVbJGIucmFuayAtIDFdO1xuXG4gICAgY29uc3Qgb3V0ZXJEaW1zQSA9ICRhLnNoYXBlLnNsaWNlKDAsIC0yKTtcbiAgICBjb25zdCBvdXRlckRpbXNCID0gJGIuc2hhcGUuc2xpY2UoMCwgLTIpO1xuICAgIGNvbnN0IGJhdGNoRGltQSA9IHV0aWwuc2l6ZUZyb21TaGFwZShvdXRlckRpbXNBKTtcbiAgICBjb25zdCBiYXRjaERpbUIgPSB1dGlsLnNpemVGcm9tU2hhcGUob3V0ZXJEaW1zQik7XG5cbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgaW5uZXJTaGFwZUEgPT09IGlubmVyU2hhcGVCLFxuICAgICAgICAoKSA9PiBgRXJyb3IgaW4gZnVzZWQgbWF0TXVsOiBpbm5lciBzaGFwZXMgKCR7aW5uZXJTaGFwZUF9KSBhbmQgKGAgK1xuICAgICAgICAgICAgYCR7aW5uZXJTaGFwZUJ9KSBvZiBUZW5zb3JzIHdpdGggc2hhcGVzICR7JGEuc2hhcGV9IGFuZCBgICtcbiAgICAgICAgICAgIGAkeyRiLnNoYXBlfSBhbmQgdHJhbnNwb3NlQT0ke3RyYW5zcG9zZUF9YCArXG4gICAgICAgICAgICBgIGFuZCB0cmFuc3Bvc2VCPSR7dHJhbnNwb3NlQn0gbXVzdCBtYXRjaC5gKTtcblxuICAgIGNvbnN0IG91dFNoYXBlT3V0ZXJEaW1zID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoXG4gICAgICAgICRhLnNoYXBlLnNsaWNlKDAsIC0yKSwgJGIuc2hhcGUuc2xpY2UoMCwgLTIpKTtcbiAgICBjb25zdCBvdXRTaGFwZSA9IG91dFNoYXBlT3V0ZXJEaW1zLmNvbmNhdChbb3V0ZXJTaGFwZUEsIG91dGVyU2hhcGVCXSk7XG5cbiAgICBjb25zdCBhM0Q6IFRlbnNvcjNEID0gdHJhbnNwb3NlQSA/XG4gICAgICAgIHJlc2hhcGUoJGEsIFtiYXRjaERpbUEsIGlubmVyU2hhcGVBLCBvdXRlclNoYXBlQV0pIDpcbiAgICAgICAgcmVzaGFwZSgkYSwgW2JhdGNoRGltQSwgb3V0ZXJTaGFwZUEsIGlubmVyU2hhcGVBXSk7XG4gICAgY29uc3QgYjNEOiBUZW5zb3IzRCA9IHRyYW5zcG9zZUIgP1xuICAgICAgICByZXNoYXBlKCRiLCBbYmF0Y2hEaW1CLCBvdXRlclNoYXBlQiwgaW5uZXJTaGFwZUJdKSA6XG4gICAgICAgIHJlc2hhcGUoJGIsIFtiYXRjaERpbUIsIGlubmVyU2hhcGVCLCBvdXRlclNoYXBlQl0pO1xuXG4gICAgbGV0ICRiaWFzOiBUZW5zb3I7XG4gICAgaWYgKGJpYXMgIT0gbnVsbCkge1xuICAgICAgJGJpYXMgPSBjb252ZXJ0VG9UZW5zb3IoYmlhcywgJ2JpYXMnLCAnZnVzZWQgbWF0TXVsJyk7XG4gICAgICBbJGJpYXNdID0gbWFrZVR5cGVzTWF0Y2goJGJpYXMsICRhKTtcblxuICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUob3V0U2hhcGUsICRiaWFzLnNoYXBlKTtcbiAgICB9XG5cbiAgICBsZXQgJHByZWx1QWN0aXZhdGlvbldlaWdodHM6IFRlbnNvcjtcbiAgICBpZiAocHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyAhPSBudWxsKSB7XG4gICAgICAkcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyA9IGNvbnZlcnRUb1RlbnNvcihcbiAgICAgICAgICBwcmVsdUFjdGl2YXRpb25XZWlnaHRzLCAncHJlbHUgd2VpZ2h0cycsICdmdXNlZCBtYXRNdWwnKTtcbiAgICB9XG5cbiAgICBjb25zdCBncmFkID0gKGR5OiBUZW5zb3IzRCwgc2F2ZWQ6IFRlbnNvcltdKSA9PiB7XG4gICAgICBjb25zdCBbYTNELCBiM0QsIHksICRiaWFzXSA9IHNhdmVkO1xuICAgICAgLy8gd2UgcmVzaGFwZSBkeSBiZWNhdXNlIHRoZSByZXN1bHQgb2YgdGhlIGZvcndhcmQgaXMgbm90XG4gICAgICAvLyBuZWNlc3NhcmlseSBnb2luZyB0byBiZSBhIDNkIHRlbnNvciBkdWUgdG8gYSByZXNoYXBlIGRvbmUgYXQgdGhlIGVuZCBvZlxuICAgICAgLy8gdGhlIGN1c3RvbU9wLlxuICAgICAgY29uc3QgZHlBY3RpdmF0aW9uID1cbiAgICAgICAgICBnZXRGdXNlZER5QWN0aXZhdGlvbihyZXNoYXBlKGR5LCB5LnNoYXBlKSwgeSwgYWN0aXZhdGlvbik7XG4gICAgICBsZXQgYURlcjogVGVuc29yO1xuICAgICAgbGV0IGJEZXI6IFRlbnNvcjtcblxuICAgICAgaWYgKCF0cmFuc3Bvc2VBICYmICF0cmFuc3Bvc2VCKSB7XG4gICAgICAgIGFEZXIgPSB1bmZ1c2VkTWF0TXVsKGR5QWN0aXZhdGlvbiwgYjNELCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGJEZXIgPSB1bmZ1c2VkTWF0TXVsKGEzRCwgZHlBY3RpdmF0aW9uLCB0cnVlLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKCF0cmFuc3Bvc2VBICYmIHRyYW5zcG9zZUIpIHtcbiAgICAgICAgYURlciA9IHVuZnVzZWRNYXRNdWwoZHlBY3RpdmF0aW9uLCBiM0QsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIGJEZXIgPSB1bmZ1c2VkTWF0TXVsKGR5QWN0aXZhdGlvbiwgYTNELCB0cnVlLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHRyYW5zcG9zZUEgJiYgIXRyYW5zcG9zZUIpIHtcbiAgICAgICAgYURlciA9IHVuZnVzZWRNYXRNdWwoYjNELCBkeUFjdGl2YXRpb24sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgYkRlciA9IHVuZnVzZWRNYXRNdWwoYTNELCBkeUFjdGl2YXRpb24sIGZhbHNlLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhRGVyID0gdW5mdXNlZE1hdE11bChiM0QsIGR5QWN0aXZhdGlvbiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGJEZXIgPSB1bmZ1c2VkTWF0TXVsKGR5QWN0aXZhdGlvbiwgYTNELCB0cnVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJpYXMgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBiaWFzRGVyID0gZ2V0RnVzZWRCaWFzR3JhZGllbnQoJGJpYXMsIGR5QWN0aXZhdGlvbik7XG4gICAgICAgIHJldHVybiBbYURlciwgYkRlciwgYmlhc0Rlcl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2FEZXIsIGJEZXJdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBpbnB1dHM6IF9GdXNlZE1hdE11bElucHV0cyA9IHtcbiAgICAgIGE6IGEzRCxcbiAgICAgIGI6IGIzRCxcbiAgICAgIGJpYXM6ICRiaWFzLFxuICAgICAgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0czogJHByZWx1QWN0aXZhdGlvbldlaWdodHNcbiAgICB9O1xuICAgIGNvbnN0IGF0dHJzOiBfRnVzZWRNYXRNdWxBdHRycyA9XG4gICAgICAgIHt0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCLCBhY3RpdmF0aW9uLCBsZWFreXJlbHVBbHBoYX07XG5cbiAgICAvLyBEZXBlbmRpbmcgb24gdGhlIHRoZSBwYXJhbXMgcGFzc2VkIGluIHdlIHdpbGwgaGF2ZSBkaWZmZXJlbnQgbnVtYmVyIG9mXG4gICAgLy8gaW5wdXRzIGFuZCB0aHVzIGEgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBncmFkaWVudC5cbiAgICBpZiAoYmlhcyA9PSBudWxsKSB7XG4gICAgICBjb25zdCBjdXN0b21PcCA9XG4gICAgICAgICAgY3VzdG9tR3JhZCgoYTNEOiBUZW5zb3IzRCwgYjNEOiBUZW5zb3IzRCwgc2F2ZTogR3JhZFNhdmVGdW5jKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPVxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tdW5uZWNlc3NhcnktdHlwZS1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICBFTkdJTkUucnVuS2VybmVsKFxuICAgICAgICAgICAgICAgICAgICBfRnVzZWRNYXRNdWwsIGlucHV0cyBhcyB1bmtub3duIGFzIE5hbWVkVGVuc29yTWFwLFxuICAgICAgICAgICAgICAgICAgICBhdHRycyBhcyB1bmtub3duIGFzIE5hbWVkQXR0ck1hcCkgYXMgVGVuc29yO1xuXG4gICAgICAgICAgICBzYXZlKFthM0QsIGIzRCwgcmVzXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7dmFsdWU6IHJlc2hhcGUocmVzLCBvdXRTaGFwZSksIGdyYWRGdW5jOiBncmFkfTtcbiAgICAgICAgICB9KTtcbiAgICAgIHJldHVybiBjdXN0b21PcChhM0QsIGIzRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGN1c3RvbU9wV2l0aEJpYXMgPSBjdXN0b21HcmFkKFxuICAgICAgICAgIChhM0Q6IFRlbnNvcjNELCBiM0Q6IFRlbnNvcjNELCAkYmlhczogVGVuc29yLCBzYXZlOiBHcmFkU2F2ZUZ1bmMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIEVOR0lORS5ydW5LZXJuZWwoXG4gICAgICAgICAgICAgICAgICAgIF9GdXNlZE1hdE11bCwgaW5wdXRzIGFzIHVua25vd24gYXMgTmFtZWRUZW5zb3JNYXAsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzIGFzIHVua25vd24gYXMgTmFtZWRBdHRyTWFwKSBhcyBUZW5zb3I7XG5cbiAgICAgICAgICAgIHNhdmUoW2EzRCwgYjNELCByZXMsICRiaWFzXSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7dmFsdWU6IHJlc2hhcGUocmVzLCBvdXRTaGFwZSksIGdyYWRGdW5jOiBncmFkfTtcbiAgICAgICAgICB9KTtcblxuICAgICAgcmV0dXJuIGN1c3RvbU9wV2l0aEJpYXMoYTNELCBiM0QsICRiaWFzKTtcbiAgICB9XG4gIH1cblxuICBleHBvcnQgY29uc3QgbWF0TXVsID0gLyogQF9fUFVSRV9fICovIG9wKHtmdXNlZE1hdE11bF99KTtcbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { GatherV2 } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Gather slices from tensor `x`'s axis `axis` according to `indices`.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * const indices = tf.tensor1d([1, 3, 3], 'int32');\n *\n * x.gather(indices).print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const indices = tf.tensor1d([1, 1, 0], 'int32');\n *\n * x.gather(indices).print();\n * ```\n * @param x The input tensor whose slices are to be gathered.\n * @param indices The indices of the values to extract.\n * @param axis The axis over which to select values. Defaults to 0.\n * @param batchDims Optional. The number of batch dimensions. It must be less\n *     than or equal to rank(indices). Defaults to 0.\n *     The output tensor will have shape of\n *     `x.shape[:axis] + indices.shape[batchDims:] + x.shape[axis + 1:]`\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction gather_(x, indices, axis = 0, batchDims = 0) {\n    const $x = convertToTensor(x, 'x', 'gather');\n    const $indices = convertToTensor(indices, 'indices', 'gather', 'int32');\n    const inputs = { x: $x, indices: $indices };\n    const attrs = { axis, batchDims };\n    return ENGINE.runKernel(GatherV2, inputs, attrs);\n}\nexport const gather = /* @__PURE__ */ op({ gather_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2F0aGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvZ2F0aGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDakMsT0FBTyxFQUFDLFFBQVEsRUFBZ0MsTUFBTSxpQkFBaUIsQ0FBQztBQUl4RSxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFHbkQsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUUvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlCRztBQUNILFNBQVMsT0FBTyxDQUNaLENBQWUsRUFBRSxPQUEwQixFQUFFLElBQUksR0FBRyxDQUFDLEVBQUUsU0FBUyxHQUFHLENBQUM7SUFDdEUsTUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDN0MsTUFBTSxRQUFRLEdBQUcsZUFBZSxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRXhFLE1BQU0sTUFBTSxHQUFtQixFQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBQyxDQUFDO0lBQzFELE1BQU0sS0FBSyxHQUFrQixFQUFDLElBQUksRUFBRSxTQUFTLEVBQUMsQ0FBQztJQUUvQyxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQ25CLFFBQVEsRUFBRSxNQUFtQyxFQUM3QyxLQUFnQyxDQUFDLENBQUM7QUFDeEMsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLE1BQU0sR0FBRyxlQUFlLENBQUMsRUFBRSxDQUFDLEVBQUMsT0FBTyxFQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtFTkdJTkV9IGZyb20gJy4uL2VuZ2luZSc7XG5pbXBvcnQge0dhdGhlclYyLCBHYXRoZXJWMkF0dHJzLCBHYXRoZXJWMklucHV0c30gZnJvbSAnLi4va2VybmVsX25hbWVzJztcbmltcG9ydCB7TmFtZWRBdHRyTWFwfSBmcm9tICcuLi9rZXJuZWxfcmVnaXN0cnknO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5pbXBvcnQge05hbWVkVGVuc29yTWFwfSBmcm9tICcuLi90ZW5zb3JfdHlwZXMnO1xuaW1wb3J0IHtjb252ZXJ0VG9UZW5zb3J9IGZyb20gJy4uL3RlbnNvcl91dGlsX2Vudic7XG5pbXBvcnQge1RlbnNvckxpa2V9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHtvcH0gZnJvbSAnLi9vcGVyYXRpb24nO1xuXG4vKipcbiAqIEdhdGhlciBzbGljZXMgZnJvbSB0ZW5zb3IgYHhgJ3MgYXhpcyBgYXhpc2AgYWNjb3JkaW5nIHRvIGBpbmRpY2VzYC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgeCA9IHRmLnRlbnNvcjFkKFsxLCAyLCAzLCA0XSk7XG4gKiBjb25zdCBpbmRpY2VzID0gdGYudGVuc29yMWQoWzEsIDMsIDNdLCAnaW50MzInKTtcbiAqXG4gKiB4LmdhdGhlcihpbmRpY2VzKS5wcmludCgpO1xuICogYGBgXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHggPSB0Zi50ZW5zb3IyZChbMSwgMiwgMywgNF0sIFsyLCAyXSk7XG4gKiBjb25zdCBpbmRpY2VzID0gdGYudGVuc29yMWQoWzEsIDEsIDBdLCAnaW50MzInKTtcbiAqXG4gKiB4LmdhdGhlcihpbmRpY2VzKS5wcmludCgpO1xuICogYGBgXG4gKiBAcGFyYW0geCBUaGUgaW5wdXQgdGVuc29yIHdob3NlIHNsaWNlcyBhcmUgdG8gYmUgZ2F0aGVyZWQuXG4gKiBAcGFyYW0gaW5kaWNlcyBUaGUgaW5kaWNlcyBvZiB0aGUgdmFsdWVzIHRvIGV4dHJhY3QuXG4gKiBAcGFyYW0gYXhpcyBUaGUgYXhpcyBvdmVyIHdoaWNoIHRvIHNlbGVjdCB2YWx1ZXMuIERlZmF1bHRzIHRvIDAuXG4gKiBAcGFyYW0gYmF0Y2hEaW1zIE9wdGlvbmFsLiBUaGUgbnVtYmVyIG9mIGJhdGNoIGRpbWVuc2lvbnMuIEl0IG11c3QgYmUgbGVzc1xuICogICAgIHRoYW4gb3IgZXF1YWwgdG8gcmFuayhpbmRpY2VzKS4gRGVmYXVsdHMgdG8gMC5cbiAqICAgICBUaGUgb3V0cHV0IHRlbnNvciB3aWxsIGhhdmUgc2hhcGUgb2ZcbiAqICAgICBgeC5zaGFwZVs6YXhpc10gKyBpbmRpY2VzLnNoYXBlW2JhdGNoRGltczpdICsgeC5zaGFwZVtheGlzICsgMTpdYFxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1NsaWNpbmcgYW5kIEpvaW5pbmcnfVxuICovXG5mdW5jdGlvbiBnYXRoZXJfPFQgZXh0ZW5kcyBUZW5zb3I+KFxuICAgIHg6IFR8VGVuc29yTGlrZSwgaW5kaWNlczogVGVuc29yfFRlbnNvckxpa2UsIGF4aXMgPSAwLCBiYXRjaERpbXMgPSAwKTogVCB7XG4gIGNvbnN0ICR4ID0gY29udmVydFRvVGVuc29yKHgsICd4JywgJ2dhdGhlcicpO1xuICBjb25zdCAkaW5kaWNlcyA9IGNvbnZlcnRUb1RlbnNvcihpbmRpY2VzLCAnaW5kaWNlcycsICdnYXRoZXInLCAnaW50MzInKTtcblxuICBjb25zdCBpbnB1dHM6IEdhdGhlclYySW5wdXRzID0ge3g6ICR4LCBpbmRpY2VzOiAkaW5kaWNlc307XG4gIGNvbnN0IGF0dHJzOiBHYXRoZXJWMkF0dHJzID0ge2F4aXMsIGJhdGNoRGltc307XG5cbiAgcmV0dXJuIEVOR0lORS5ydW5LZXJuZWwoXG4gICAgICBHYXRoZXJWMiwgaW5wdXRzIGFzIHVua25vd24gYXMgTmFtZWRUZW5zb3JNYXAsXG4gICAgICBhdHRycyBhcyB1bmtub3duIGFzIE5hbWVkQXR0ck1hcCk7XG59XG5cbmV4cG9ydCBjb25zdCBnYXRoZXIgPSAvKiBAX19QVVJFX18gKi8gb3Aoe2dhdGhlcl99KTtcbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { GatherNd } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Gather slices from input tensor into a Tensor with shape specified by\n * `indices`.\n *\n * `indices` is a K-dimensional integer tensor, best thought of as a\n * (K-1)-dimensional tensor of indices into input, where each element defines a\n * slice of input:\n * output[\\\\(i_0, ..., i_{K-2}\\\\)] = input[indices[\\\\(i_0, ..., i_{K-2}\\\\)]]\n *\n * Whereas in `tf.gather`, `indices` defines slices into the first dimension of\n * input, in `tf.gatherND`, `indices` defines slices into the first N dimensions\n * of input, where N = indices.shape[-1].\n *\n * The last dimension of indices can be at most the rank of input:\n * indices.shape[-1] <= input.rank\n *\n * The last dimension of `indices` corresponds to elements\n * (if indices.shape[-1] == input.rank) or slices\n * (if indices.shape[-1] < input.rank) along dimension indices.shape[-1] of\n * input.\n * The output tensor has shape\n * indices.shape[:-1] + input.shape[indices.shape[-1]:]\n *\n * Note that on CPU, if an out of bound index is found, an error is returned. On\n * GPU, if an out of bound index is found, a 0 is stored in the corresponding\n * output value.\n *\n * ```js\n * const indices = tf.tensor2d([0, 1, 1, 0], [2,2], 'int32');\n * const input = tf.tensor2d([9, 10, 11, 12], [2, 2]);\n * tf.gatherND(input, indices).print() // [10, 11]\n * ```\n *\n * @param x The tensor from which to gather values.\n * @param indices Index tensor, must be of type int32.\n *\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\n */\nfunction gatherND_(x, indices) {\n    const $indices = convertToTensor(indices, 'indices', 'gatherND', 'int32');\n    const $x = convertToTensor(x, 'x', 'gatherND', 'string_or_numeric');\n    const inputs = { params: $x, indices: $indices };\n    return ENGINE.runKernel(GatherNd, inputs);\n}\nexport const gatherND = /* @__PURE__ */ op({ gatherND_ });\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2F0aGVyX25kLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvZ2F0aGVyX25kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDakMsT0FBTyxFQUFDLFFBQVEsRUFBaUIsTUFBTSxpQkFBaUIsQ0FBQztBQUd6RCxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFFbkQsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUUvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFDRztBQUNILFNBQVMsU0FBUyxDQUFDLENBQW9CLEVBQUUsT0FBMEI7SUFDakUsTUFBTSxRQUFRLEdBQUcsZUFBZSxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzFFLE1BQU0sRUFBRSxHQUFHLGVBQWUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBRXBFLE1BQU0sTUFBTSxHQUFtQixFQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBQyxDQUFDO0lBRS9ELE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsTUFBbUMsQ0FBQyxDQUFDO0FBQ3pFLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxRQUFRLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxFQUFDLFNBQVMsRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5pbXBvcnQge0VOR0lORX0gZnJvbSAnLi4vZW5naW5lJztcbmltcG9ydCB7R2F0aGVyTmQsIEdhdGhlck5kSW5wdXRzfSBmcm9tICcuLi9rZXJuZWxfbmFtZXMnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5pbXBvcnQge05hbWVkVGVuc29yTWFwfSBmcm9tICcuLi90ZW5zb3JfdHlwZXMnO1xuaW1wb3J0IHtjb252ZXJ0VG9UZW5zb3J9IGZyb20gJy4uL3RlbnNvcl91dGlsX2Vudic7XG5pbXBvcnQge1RlbnNvckxpa2V9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7b3B9IGZyb20gJy4vb3BlcmF0aW9uJztcblxuLyoqXG4gKiBHYXRoZXIgc2xpY2VzIGZyb20gaW5wdXQgdGVuc29yIGludG8gYSBUZW5zb3Igd2l0aCBzaGFwZSBzcGVjaWZpZWQgYnlcbiAqIGBpbmRpY2VzYC5cbiAqXG4gKiBgaW5kaWNlc2AgaXMgYSBLLWRpbWVuc2lvbmFsIGludGVnZXIgdGVuc29yLCBiZXN0IHRob3VnaHQgb2YgYXMgYVxuICogKEstMSktZGltZW5zaW9uYWwgdGVuc29yIG9mIGluZGljZXMgaW50byBpbnB1dCwgd2hlcmUgZWFjaCBlbGVtZW50IGRlZmluZXMgYVxuICogc2xpY2Ugb2YgaW5wdXQ6XG4gKiBvdXRwdXRbXFxcXChpXzAsIC4uLiwgaV97Sy0yfVxcXFwpXSA9IGlucHV0W2luZGljZXNbXFxcXChpXzAsIC4uLiwgaV97Sy0yfVxcXFwpXV1cbiAqXG4gKiBXaGVyZWFzIGluIGB0Zi5nYXRoZXJgLCBgaW5kaWNlc2AgZGVmaW5lcyBzbGljZXMgaW50byB0aGUgZmlyc3QgZGltZW5zaW9uIG9mXG4gKiBpbnB1dCwgaW4gYHRmLmdhdGhlck5EYCwgYGluZGljZXNgIGRlZmluZXMgc2xpY2VzIGludG8gdGhlIGZpcnN0IE4gZGltZW5zaW9uc1xuICogb2YgaW5wdXQsIHdoZXJlIE4gPSBpbmRpY2VzLnNoYXBlWy0xXS5cbiAqXG4gKiBUaGUgbGFzdCBkaW1lbnNpb24gb2YgaW5kaWNlcyBjYW4gYmUgYXQgbW9zdCB0aGUgcmFuayBvZiBpbnB1dDpcbiAqIGluZGljZXMuc2hhcGVbLTFdIDw9IGlucHV0LnJhbmtcbiAqXG4gKiBUaGUgbGFzdCBkaW1lbnNpb24gb2YgYGluZGljZXNgIGNvcnJlc3BvbmRzIHRvIGVsZW1lbnRzXG4gKiAoaWYgaW5kaWNlcy5zaGFwZVstMV0gPT0gaW5wdXQucmFuaykgb3Igc2xpY2VzXG4gKiAoaWYgaW5kaWNlcy5zaGFwZVstMV0gPCBpbnB1dC5yYW5rKSBhbG9uZyBkaW1lbnNpb24gaW5kaWNlcy5zaGFwZVstMV0gb2ZcbiAqIGlucHV0LlxuICogVGhlIG91dHB1dCB0ZW5zb3IgaGFzIHNoYXBlXG4gKiBpbmRpY2VzLnNoYXBlWzotMV0gKyBpbnB1dC5zaGFwZVtpbmRpY2VzLnNoYXBlWy0xXTpdXG4gKlxuICogTm90ZSB0aGF0IG9uIENQVSwgaWYgYW4gb3V0IG9mIGJvdW5kIGluZGV4IGlzIGZvdW5kLCBhbiBlcnJvciBpcyByZXR1cm5lZC4gT25cbiAqIEdQVSwgaWYgYW4gb3V0IG9mIGJvdW5kIGluZGV4IGlzIGZvdW5kLCBhIDAgaXMgc3RvcmVkIGluIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBvdXRwdXQgdmFsdWUuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGluZGljZXMgPSB0Zi50ZW5zb3IyZChbMCwgMSwgMSwgMF0sIFsyLDJdLCAnaW50MzInKTtcbiAqIGNvbnN0IGlucHV0ID0gdGYudGVuc29yMmQoWzksIDEwLCAxMSwgMTJdLCBbMiwgMl0pO1xuICogdGYuZ2F0aGVyTkQoaW5wdXQsIGluZGljZXMpLnByaW50KCkgLy8gWzEwLCAxMV1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB4IFRoZSB0ZW5zb3IgZnJvbSB3aGljaCB0byBnYXRoZXIgdmFsdWVzLlxuICogQHBhcmFtIGluZGljZXMgSW5kZXggdGVuc29yLCBtdXN0IGJlIG9mIHR5cGUgaW50MzIuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnU2xpY2luZyBhbmQgSm9pbmluZyd9XG4gKi9cbmZ1bmN0aW9uIGdhdGhlck5EXyh4OiBUZW5zb3J8VGVuc29yTGlrZSwgaW5kaWNlczogVGVuc29yfFRlbnNvckxpa2UpOiBUZW5zb3Ige1xuICBjb25zdCAkaW5kaWNlcyA9IGNvbnZlcnRUb1RlbnNvcihpbmRpY2VzLCAnaW5kaWNlcycsICdnYXRoZXJORCcsICdpbnQzMicpO1xuICBjb25zdCAkeCA9IGNvbnZlcnRUb1RlbnNvcih4LCAneCcsICdnYXRoZXJORCcsICdzdHJpbmdfb3JfbnVtZXJpYycpO1xuXG4gIGNvbnN0IGlucHV0czogR2F0aGVyTmRJbnB1dHMgPSB7cGFyYW1zOiAkeCwgaW5kaWNlczogJGluZGljZXN9O1xuXG4gIHJldHVybiBFTkdJTkUucnVuS2VybmVsKEdhdGhlck5kLCBpbnB1dHMgYXMgdW5rbm93biBhcyBOYW1lZFRlbnNvck1hcCk7XG59XG5cbmV4cG9ydCBjb25zdCBnYXRoZXJORCA9IC8qIEBfX1BVUkVfXyAqLyBvcCh7Z2F0aGVyTkRffSk7XG4iXX0=","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as broadcast_util from './broadcast_util';\nimport { elu } from './elu';\nimport { leakyRelu } from './leaky_relu';\nimport { mul } from './mul';\nimport { prelu } from './prelu';\nimport { relu } from './relu';\nimport { relu6 } from './relu6';\nimport { reshape } from './reshape';\nimport { sigmoid } from './sigmoid';\nimport { step } from './step';\nimport { sum } from './sum';\n// Returns gradient for fused activation.\nexport function getFusedDyActivation(dy, y, activation) {\n    if (activation == null || activation === 'linear') {\n        return dy;\n    }\n    if (activation === 'relu') {\n        return mul(dy, step(y));\n    }\n    throw new Error(`Cannot compute gradient for fused activation ${activation}.`);\n}\n// Returns gradient for fused bias.\nexport function getFusedBiasGradient(bias, dyActivation) {\n    let res = dyActivation;\n    const reduceAxes = broadcast_util.getReductionAxes(bias.shape, dyActivation.shape);\n    if (reduceAxes.length > 0) {\n        res = sum(res, reduceAxes);\n    }\n    return reshape(res, bias.shape);\n}\nexport function applyActivation(x, activation, preluActivationWeights, leakyreluAlpha) {\n    if (activation === 'linear') {\n        return x;\n    }\n    else if (activation === 'relu') {\n        return relu(x);\n    }\n    else if (activation === 'elu') {\n        return elu(x);\n    }\n    else if (activation === 'relu6') {\n        return relu6(x);\n    }\n    else if (activation === 'prelu') {\n        return prelu(x, preluActivationWeights);\n    }\n    else if (activation === 'leakyrelu') {\n        return leakyRelu(x, leakyreluAlpha);\n    }\n    else if (activation === 'sigmoid') {\n        return sigmoid(x);\n    }\n    throw new Error(`Unknown fused activation ${activation}.`);\n}\n// Whether we should call fused ops.\nexport const shouldFuse = (gradientDepth, activation) => {\n    const gradientMode = gradientDepth > 0;\n    return !gradientMode || activation === 'linear';\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVzZWRfdXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL2Z1c2VkX3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBSUgsT0FBTyxLQUFLLGNBQWMsTUFBTSxrQkFBa0IsQ0FBQztBQUNuRCxPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sT0FBTyxDQUFDO0FBRTFCLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFDdkMsT0FBTyxFQUFDLEdBQUcsRUFBQyxNQUFNLE9BQU8sQ0FBQztBQUMxQixPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBQzlCLE9BQU8sRUFBQyxJQUFJLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDNUIsT0FBTyxFQUFDLEtBQUssRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUM5QixPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQ2xDLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDbEMsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUM1QixPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sT0FBTyxDQUFDO0FBRTFCLHlDQUF5QztBQUN6QyxNQUFNLFVBQVUsb0JBQW9CLENBQ2hDLEVBQVUsRUFBRSxDQUFTLEVBQUUsVUFBc0I7SUFDL0MsSUFBSSxVQUFVLElBQUksSUFBSSxJQUFJLFVBQVUsS0FBSyxRQUFRLEVBQUU7UUFDakQsT0FBTyxFQUFFLENBQUM7S0FDWDtJQUNELElBQUksVUFBVSxLQUFLLE1BQU0sRUFBRTtRQUN6QixPQUFPLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDekI7SUFDRCxNQUFNLElBQUksS0FBSyxDQUNYLGdEQUFnRCxVQUFVLEdBQUcsQ0FBQyxDQUFDO0FBQ3JFLENBQUM7QUFFRCxtQ0FBbUM7QUFDbkMsTUFBTSxVQUFVLG9CQUFvQixDQUNoQyxJQUFZLEVBQUUsWUFBb0I7SUFDcEMsSUFBSSxHQUFHLEdBQUcsWUFBWSxDQUFDO0lBQ3ZCLE1BQU0sVUFBVSxHQUNaLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNwRSxJQUFJLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3pCLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0tBQzVCO0lBQ0QsT0FBTyxPQUFPLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNsQyxDQUFDO0FBRUQsTUFBTSxVQUFVLGVBQWUsQ0FDM0IsQ0FBUyxFQUFFLFVBQXNCLEVBQUUsc0JBQStCLEVBQ2xFLGNBQXVCO0lBQ3pCLElBQUksVUFBVSxLQUFLLFFBQVEsRUFBRTtRQUMzQixPQUFPLENBQUMsQ0FBQztLQUNWO1NBQU0sSUFBSSxVQUFVLEtBQUssTUFBTSxFQUFFO1FBQ2hDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2hCO1NBQU0sSUFBSSxVQUFVLEtBQUssS0FBSyxFQUFFO1FBQy9CLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2Y7U0FBTSxJQUFJLFVBQVUsS0FBSyxPQUFPLEVBQUU7UUFDakMsT0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDakI7U0FBTSxJQUFJLFVBQVUsS0FBSyxPQUFPLEVBQUU7UUFDakMsT0FBTyxLQUFLLENBQUMsQ0FBQyxFQUFFLHNCQUFzQixDQUFDLENBQUM7S0FDekM7U0FBTSxJQUFJLFVBQVUsS0FBSyxXQUFXLEVBQUU7UUFDckMsT0FBTyxTQUFTLENBQUMsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDO0tBQ3JDO1NBQU0sSUFBSSxVQUFVLEtBQUssU0FBUyxFQUFFO1FBQ25DLE9BQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ25CO0lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsVUFBVSxHQUFHLENBQUMsQ0FBQztBQUM3RCxDQUFDO0FBRUQsb0NBQW9DO0FBQ3BDLE1BQU0sQ0FBQyxNQUFNLFVBQVUsR0FBRyxDQUFDLGFBQXFCLEVBQUUsVUFBc0IsRUFBRSxFQUFFO0lBQzFFLE1BQU0sWUFBWSxHQUFHLGFBQWEsR0FBRyxDQUFDLENBQUM7SUFDdkMsT0FBTyxDQUFDLFlBQVksSUFBSSxVQUFVLEtBQUssUUFBUSxDQUFDO0FBQ2xELENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uL3RlbnNvcic7XG5cbmltcG9ydCAqIGFzIGJyb2FkY2FzdF91dGlsIGZyb20gJy4vYnJvYWRjYXN0X3V0aWwnO1xuaW1wb3J0IHtlbHV9IGZyb20gJy4vZWx1JztcbmltcG9ydCB7QWN0aXZhdGlvbn0gZnJvbSAnLi9mdXNlZF90eXBlcyc7XG5pbXBvcnQge2xlYWt5UmVsdX0gZnJvbSAnLi9sZWFreV9yZWx1JztcbmltcG9ydCB7bXVsfSBmcm9tICcuL211bCc7XG5pbXBvcnQge3ByZWx1fSBmcm9tICcuL3ByZWx1JztcbmltcG9ydCB7cmVsdX0gZnJvbSAnLi9yZWx1JztcbmltcG9ydCB7cmVsdTZ9IGZyb20gJy4vcmVsdTYnO1xuaW1wb3J0IHtyZXNoYXBlfSBmcm9tICcuL3Jlc2hhcGUnO1xuaW1wb3J0IHtzaWdtb2lkfSBmcm9tICcuL3NpZ21vaWQnO1xuaW1wb3J0IHtzdGVwfSBmcm9tICcuL3N0ZXAnO1xuaW1wb3J0IHtzdW19IGZyb20gJy4vc3VtJztcblxuLy8gUmV0dXJucyBncmFkaWVudCBmb3IgZnVzZWQgYWN0aXZhdGlvbi5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdXNlZER5QWN0aXZhdGlvbihcbiAgICBkeTogVGVuc29yLCB5OiBUZW5zb3IsIGFjdGl2YXRpb246IEFjdGl2YXRpb24pOiBUZW5zb3Ige1xuICBpZiAoYWN0aXZhdGlvbiA9PSBudWxsIHx8IGFjdGl2YXRpb24gPT09ICdsaW5lYXInKSB7XG4gICAgcmV0dXJuIGR5O1xuICB9XG4gIGlmIChhY3RpdmF0aW9uID09PSAncmVsdScpIHtcbiAgICByZXR1cm4gbXVsKGR5LCBzdGVwKHkpKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ2Fubm90IGNvbXB1dGUgZ3JhZGllbnQgZm9yIGZ1c2VkIGFjdGl2YXRpb24gJHthY3RpdmF0aW9ufS5gKTtcbn1cblxuLy8gUmV0dXJucyBncmFkaWVudCBmb3IgZnVzZWQgYmlhcy5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdXNlZEJpYXNHcmFkaWVudChcbiAgICBiaWFzOiBUZW5zb3IsIGR5QWN0aXZhdGlvbjogVGVuc29yKTogVGVuc29yIHtcbiAgbGV0IHJlcyA9IGR5QWN0aXZhdGlvbjtcbiAgY29uc3QgcmVkdWNlQXhlcyA9XG4gICAgICBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGJpYXMuc2hhcGUsIGR5QWN0aXZhdGlvbi5zaGFwZSk7XG4gIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICByZXMgPSBzdW0ocmVzLCByZWR1Y2VBeGVzKTtcbiAgfVxuICByZXR1cm4gcmVzaGFwZShyZXMsIGJpYXMuc2hhcGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlBY3RpdmF0aW9uKFxuICAgIHg6IFRlbnNvciwgYWN0aXZhdGlvbjogQWN0aXZhdGlvbiwgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cz86IFRlbnNvcixcbiAgICBsZWFreXJlbHVBbHBoYT86IG51bWJlcik6IFRlbnNvciB7XG4gIGlmIChhY3RpdmF0aW9uID09PSAnbGluZWFyJykge1xuICAgIHJldHVybiB4O1xuICB9IGVsc2UgaWYgKGFjdGl2YXRpb24gPT09ICdyZWx1Jykge1xuICAgIHJldHVybiByZWx1KHgpO1xuICB9IGVsc2UgaWYgKGFjdGl2YXRpb24gPT09ICdlbHUnKSB7XG4gICAgcmV0dXJuIGVsdSh4KTtcbiAgfSBlbHNlIGlmIChhY3RpdmF0aW9uID09PSAncmVsdTYnKSB7XG4gICAgcmV0dXJuIHJlbHU2KHgpO1xuICB9IGVsc2UgaWYgKGFjdGl2YXRpb24gPT09ICdwcmVsdScpIHtcbiAgICByZXR1cm4gcHJlbHUoeCwgcHJlbHVBY3RpdmF0aW9uV2VpZ2h0cyk7XG4gIH0gZWxzZSBpZiAoYWN0aXZhdGlvbiA9PT0gJ2xlYWt5cmVsdScpIHtcbiAgICByZXR1cm4gbGVha3lSZWx1KHgsIGxlYWt5cmVsdUFscGhhKTtcbiAgfSBlbHNlIGlmIChhY3RpdmF0aW9uID09PSAnc2lnbW9pZCcpIHtcbiAgICByZXR1cm4gc2lnbW9pZCh4KTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZnVzZWQgYWN0aXZhdGlvbiAke2FjdGl2YXRpb259LmApO1xufVxuXG4vLyBXaGV0aGVyIHdlIHNob3VsZCBjYWxsIGZ1c2VkIG9wcy5cbmV4cG9ydCBjb25zdCBzaG91bGRGdXNlID0gKGdyYWRpZW50RGVwdGg6IG51bWJlciwgYWN0aXZhdGlvbjogQWN0aXZhdGlvbikgPT4ge1xuICBjb25zdCBncmFkaWVudE1vZGUgPSBncmFkaWVudERlcHRoID4gMDtcbiAgcmV0dXJuICFncmFkaWVudE1vZGUgfHwgYWN0aXZhdGlvbiA9PT0gJ2xpbmVhcic7XG59O1xuIl19","import { computeStrides, sizeFromShape } from '../util';\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\nexport function prepareAndValidate(tensor, indices) {\n    const tensorRank = tensor.shape.length;\n    const indicesRank = indices.shape.length;\n    if (tensorRank < 1) {\n        throw new Error('tf.gatherND() expects the input to be rank 1 or higher,' +\n            ` but the rank was ${tensorRank}.`);\n    }\n    if (indicesRank < 1) {\n        throw new Error('tf.gatherND() expects the indices to be rank 1 or higher,' +\n            ` but the rank was ${indicesRank}.`);\n    }\n    if (indices.dtype !== 'int32') {\n        throw new Error('tf.gatherND() expects the indices to be int32 type,' +\n            ` but the dtype was ${indices.dtype}.`);\n    }\n    if (indices.shape[indicesRank - 1] > tensorRank) {\n        throw new Error('index innermost dimension length must be <= tensor rank; saw: ' +\n            `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);\n    }\n    if (sizeFromShape(tensor.shape) === 0) {\n        throw new Error('Requested more than 0 entries, but input is empty.' +\n            ` Input shape: ${tensor.shape}.`);\n    }\n    const indicesShape = indices.shape;\n    const sliceRank = indicesShape[indicesShape.length - 1];\n    // The result shape is\n    //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n    let nResult = 1;\n    for (let i = 0; i < indicesShape.length - 1; ++i) {\n        nResult *= indicesShape[i];\n    }\n    const inputShape = tensor.shape;\n    const resultShape = indicesShape.slice();\n    resultShape.pop();\n    let sliceSize = 1;\n    for (let i = sliceRank; i < tensorRank; ++i) {\n        sliceSize *= inputShape[i];\n        resultShape.push(inputShape[i]);\n    }\n    const strides = [...computeStrides(tensor.shape).map(stride => stride / sliceSize),\n        1].slice(0, sliceRank);\n    return [resultShape, nResult, sliceSize, strides];\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2F0aGVyX25kX3V0aWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9nYXRoZXJfbmRfdXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpQkEsT0FBTyxFQUFDLGNBQWMsRUFBRSxhQUFhLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFFdEQ7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSxrQkFBa0IsQ0FBQyxNQUFrQixFQUFFLE9BQW1CO0lBRXhFLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO0lBQ3ZDLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO0lBQ3pDLElBQUksVUFBVSxHQUFHLENBQUMsRUFBRTtRQUNsQixNQUFNLElBQUksS0FBSyxDQUNYLHlEQUF5RDtZQUN6RCxxQkFBcUIsVUFBVSxHQUFHLENBQUMsQ0FBQztLQUN6QztJQUNELElBQUksV0FBVyxHQUFHLENBQUMsRUFBRTtRQUNuQixNQUFNLElBQUksS0FBSyxDQUNYLDJEQUEyRDtZQUMzRCxxQkFBcUIsV0FBVyxHQUFHLENBQUMsQ0FBQztLQUMxQztJQUNELElBQUksT0FBTyxDQUFDLEtBQUssS0FBSyxPQUFPLEVBQUU7UUFDN0IsTUFBTSxJQUFJLEtBQUssQ0FDWCxxREFBcUQ7WUFDckQsc0JBQXNCLE9BQU8sQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0tBQzdDO0lBQ0QsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsR0FBRyxVQUFVLEVBQUU7UUFDL0MsTUFBTSxJQUFJLEtBQUssQ0FDWCxnRUFBZ0U7WUFDaEUsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsUUFBUSxVQUFVLEVBQUUsQ0FBQyxDQUFDO0tBQzVEO0lBRUQsSUFBSSxhQUFhLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUNyQyxNQUFNLElBQUksS0FBSyxDQUNYLG9EQUFvRDtZQUNwRCxpQkFBaUIsTUFBTSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7S0FDdkM7SUFFRCxNQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO0lBQ25DLE1BQU0sU0FBUyxHQUFHLFlBQVksQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBRXhELHNCQUFzQjtJQUN0QiwwREFBMEQ7SUFDMUQsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0lBQ2hCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTtRQUNoRCxPQUFPLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzVCO0lBRUQsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQztJQUVoQyxNQUFNLFdBQVcsR0FBRyxZQUFZLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDekMsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBRWxCLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQztJQUNsQixLQUFLLElBQUksQ0FBQyxHQUFHLFNBQVMsRUFBRSxDQUFDLEdBQUcsVUFBVSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1FBQzNDLFNBQVMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDM0IsV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNqQztJQUVELE1BQU0sT0FBTyxHQUNULENBQUMsR0FBRyxjQUFjLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sR0FBRyxTQUFTLENBQUM7UUFDakUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUU1QixPQUFPLENBQUMsV0FBVyxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDcEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmltcG9ydCB7IFRlbnNvckluZm8gfSBmcm9tICcuLi90ZW5zb3JfaW5mbyc7XG5pbXBvcnQge2NvbXB1dGVTdHJpZGVzLCBzaXplRnJvbVNoYXBlfSBmcm9tICcuLi91dGlsJztcblxuLyoqXG4gKiBWYWxpZGF0ZSBnYXRoZXIgbmQgaW5wdXRzLlxuICpcbiAqIEBwYXJhbSB0ZW5zb3IgVGhlIHRlbnNvciBjb250YWlucyB0aGUgc291cmNlIHZhbHVlcy5cbiAqIEBwYXJhbSBpbmRpY2VzIFRoZSB0ZW5zb3IgY29udGFpbnMgdGhlIGluZGljZXMgdG8gc2xpY2UgdGhlIHNvdXJjZS5cbiAqXG4gKiBAcmV0dXJucyBbcmVzdWx0U2hhcGUsIG51bVVwZGF0ZXMsIHNsaWNlU2l6ZSwgc3RyaWRlc11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVBbmRWYWxpZGF0ZSh0ZW5zb3I6IFRlbnNvckluZm8sIGluZGljZXM6IFRlbnNvckluZm8pOlxuICAgIFtudW1iZXJbXSwgbnVtYmVyLCBudW1iZXIsIG51bWJlcltdXSB7XG4gIGNvbnN0IHRlbnNvclJhbmsgPSB0ZW5zb3Iuc2hhcGUubGVuZ3RoO1xuICBjb25zdCBpbmRpY2VzUmFuayA9IGluZGljZXMuc2hhcGUubGVuZ3RoO1xuICBpZiAodGVuc29yUmFuayA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICd0Zi5nYXRoZXJORCgpIGV4cGVjdHMgdGhlIGlucHV0IHRvIGJlIHJhbmsgMSBvciBoaWdoZXIsJyArXG4gICAgICAgIGAgYnV0IHRoZSByYW5rIHdhcyAke3RlbnNvclJhbmt9LmApO1xuICB9XG4gIGlmIChpbmRpY2VzUmFuayA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICd0Zi5nYXRoZXJORCgpIGV4cGVjdHMgdGhlIGluZGljZXMgdG8gYmUgcmFuayAxIG9yIGhpZ2hlciwnICtcbiAgICAgICAgYCBidXQgdGhlIHJhbmsgd2FzICR7aW5kaWNlc1Jhbmt9LmApO1xuICB9XG4gIGlmIChpbmRpY2VzLmR0eXBlICE9PSAnaW50MzInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAndGYuZ2F0aGVyTkQoKSBleHBlY3RzIHRoZSBpbmRpY2VzIHRvIGJlIGludDMyIHR5cGUsJyArXG4gICAgICAgIGAgYnV0IHRoZSBkdHlwZSB3YXMgJHtpbmRpY2VzLmR0eXBlfS5gKTtcbiAgfVxuICBpZiAoaW5kaWNlcy5zaGFwZVtpbmRpY2VzUmFuayAtIDFdID4gdGVuc29yUmFuaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2luZGV4IGlubmVybW9zdCBkaW1lbnNpb24gbGVuZ3RoIG11c3QgYmUgPD0gdGVuc29yIHJhbms7IHNhdzogJyArXG4gICAgICAgIGAke2luZGljZXMuc2hhcGVbaW5kaWNlc1JhbmsgLSAxXX0gdnMuICR7dGVuc29yUmFua31gKTtcbiAgfVxuXG4gIGlmIChzaXplRnJvbVNoYXBlKHRlbnNvci5zaGFwZSkgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdSZXF1ZXN0ZWQgbW9yZSB0aGFuIDAgZW50cmllcywgYnV0IGlucHV0IGlzIGVtcHR5LicgK1xuICAgICAgICBgIElucHV0IHNoYXBlOiAke3RlbnNvci5zaGFwZX0uYCk7XG4gIH1cblxuICBjb25zdCBpbmRpY2VzU2hhcGUgPSBpbmRpY2VzLnNoYXBlO1xuICBjb25zdCBzbGljZVJhbmsgPSBpbmRpY2VzU2hhcGVbaW5kaWNlc1NoYXBlLmxlbmd0aCAtIDFdO1xuXG4gIC8vIFRoZSByZXN1bHQgc2hhcGUgaXNcbiAgLy8gICBpbmRpY2VzLnNoYXBlWzotMV0gKyBwYXJhbXMuc2hhcGVbaW5kaWNlcy5zaGFwZVstMV06XVxuICBsZXQgblJlc3VsdCA9IDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlc1NoYXBlLmxlbmd0aCAtIDE7ICsraSkge1xuICAgIG5SZXN1bHQgKj0gaW5kaWNlc1NoYXBlW2ldO1xuICB9XG5cbiAgY29uc3QgaW5wdXRTaGFwZSA9IHRlbnNvci5zaGFwZTtcblxuICBjb25zdCByZXN1bHRTaGFwZSA9IGluZGljZXNTaGFwZS5zbGljZSgpO1xuICByZXN1bHRTaGFwZS5wb3AoKTtcblxuICBsZXQgc2xpY2VTaXplID0gMTtcbiAgZm9yIChsZXQgaSA9IHNsaWNlUmFuazsgaSA8IHRlbnNvclJhbms7ICsraSkge1xuICAgIHNsaWNlU2l6ZSAqPSBpbnB1dFNoYXBlW2ldO1xuICAgIHJlc3VsdFNoYXBlLnB1c2goaW5wdXRTaGFwZVtpXSk7XG4gIH1cblxuICBjb25zdCBzdHJpZGVzID1cbiAgICAgIFsuLi5jb21wdXRlU3RyaWRlcyh0ZW5zb3Iuc2hhcGUpLm1hcChzdHJpZGUgPT4gc3RyaWRlIC8gc2xpY2VTaXplKSxcbiAgICAgICAxXS5zbGljZSgwLCBzbGljZVJhbmspO1xuXG4gIHJldHVybiBbcmVzdWx0U2hhcGUsIG5SZXN1bHQsIHNsaWNlU2l6ZSwgc3RyaWRlc107XG59XG4iXX0="],"names":["op","fusedConv2d_","x","filter","strides","pad","dataFormat","dilations","dimRoundingMode","bias","activation","preluActivationWeights","leakyreluAlpha","state","gradientDepth","result","add","$x","$filter","x4D","reshapedTo4D","rank","reshape","shape","conv_util","inputChannels","convInfo","$bias","$preluActivationWeights","makeTypesMatch","broadcast_util","assertAndGetBroadcastShape","outShape","length","outChannels","alphaShape","e","errMsg","Error","grad","dy","saved","y","dyActivation","der","biasDer","push","inputs","attrs","customOp","save","res","runKernel","value","gradFunc","customOpWithBias","depthwiseConv2d","fusedDepthwiseConv2d_","xDer","filterDer","matMul","fusedMatMul_","a","b","transposeA","transposeB","$a","$b","innerShapeA","innerShapeB","outerShapeA","outerShapeB","outerDimsA","slice","outerDimsB","batchDimA","batchDimB","concat","a3D","b3D","aDer","bDer","gather","gather_","indices","axis","batchDims","gatherND","gatherND_","$indices","params","getFusedDyActivation","getFusedBiasGradient","reduceAxes","applyActivation","shouldFuse","prepareAndValidate","tensor","tensorRank","indicesRank","dtype","indicesShape","sliceRank","nResult","i","inputShape","resultShape","pop","sliceSize","map","stride"],"sourceRoot":""}