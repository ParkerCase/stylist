{"version":3,"file":"stylist-vendors-f6e5d052.2ec49a229b442a63ef77.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/version.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-data/dist/dataset.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-data/dist/datasets/text_line_dataset.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-data/dist/datasource.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-data/dist/datasets/csv_dataset.js"],"sourcesContent":["/** @license See the LICENSE file. */\n// This code is auto-generated, do not modify this file!\nconst version = '4.22.0';\nexport { version };\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvdmVyc2lvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxxQ0FBcUM7QUFFckMsd0RBQXdEO0FBQ3hELE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQztBQUN6QixPQUFPLEVBQUMsT0FBTyxFQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGxpY2Vuc2UgU2VlIHRoZSBMSUNFTlNFIGZpbGUuICovXG5cbi8vIFRoaXMgY29kZSBpcyBhdXRvLWdlbmVyYXRlZCwgZG8gbm90IG1vZGlmeSB0aGlzIGZpbGUhXG5jb25zdCB2ZXJzaW9uID0gJzQuMjIuMCc7XG5leHBvcnQge3ZlcnNpb259O1xuIl19","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport * as seedrandom from 'seedrandom';\nimport { iteratorFromConcatenated, iteratorFromFunction, iteratorFromItems, iteratorFromZipped, ZipMismatchMode } from './iterators/lazy_iterator';\nimport { canTensorify, deepMapAndAwaitAll, isIterable } from './util/deep_map';\n// TODO(soergel): consider vectorized operations within the pipeline.\n/**\n * Represents a potentially large list of independent data elements (typically\n * 'samples' or 'examples').\n *\n * A 'data example' may be a primitive, an array, a map from string keys to\n * values, or any nested structure of these.\n *\n * A `Dataset` represents an ordered collection of elements, together with a\n * chain of transformations to be performed on those elements. Each\n * transformation is a method of `Dataset` that returns another `Dataset`, so\n * these may be chained, e.g.\n * `const processedDataset = rawDataset.filter(...).map(...).batch(...)`.\n *\n * Data loading and transformation is done in a lazy, streaming fashion.  The\n * dataset may be iterated over multiple times; each iteration starts the data\n * loading anew and recapitulates the transformations.\n *\n * A `Dataset` is typically processed as a stream of unbatched examples -- i.e.,\n * its transformations are applied one example at a time. Batching produces a\n * new `Dataset` where each element is a batch. Batching should usually come\n * last in a pipeline, because data transformations are easier to express on a\n * per-example basis than on a per-batch basis.\n *\n * The following code examples are calling `await dataset.forEachAsync(...)` to\n * iterate once over the entire dataset in order to print out the data.\n *\n * @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'}\n */\nclass Dataset {\n    constructor() {\n        this.size = null;\n    }\n    // TODO(soergel): Make Datasets report whether repeated iterator() calls\n    // produce the same result (e.g., reading from a file) or different results\n    // (e.g., from the webcam).  Currently we don't make this distinction but it\n    // could be important for the user to know.\n    // abstract isDeterministic(): boolean;\n    /**\n     * Groups elements into batches.\n     *\n     * It is assumed that each of the incoming dataset elements has the same\n     * structure -- i.e. the same set of keys at each location in an object\n     * hierarchy.  For each key, the resulting `Dataset` provides a batched\n     * element collecting all of the incoming values for that key.\n     *\n     *  * Incoming primitives are grouped into a 1-D Tensor.\n     *  * Incoming Tensors are grouped into a new Tensor where the 0th axis is\n     *    the batch dimension.\n     *  * Incoming arrays are converted to Tensor and then batched.\n     *  * A nested array is interpreted as an n-D Tensor, so the batched result\n     *    has n+1 dimensions.\n     *  * An array that cannot be converted to Tensor produces an error.\n     *\n     * If an array should not be batched as a unit, it should first be converted\n     * to an object with integer keys.\n     *\n     * Here are a few examples:\n     *\n     * Batch a dataset of numbers:\n     * ```js\n     * const a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8]).batch(4);\n     * await a.forEachAsync(e => e.print());\n     * ```\n     *\n     * Batch a dataset of arrays:\n     * ```js\n     * const b = tf.data.array([[1], [2], [3], [4], [5], [6], [7], [8]]).batch(4);\n     * await b.forEachAsync(e => e.print());\n     * ```\n     *\n     * Batch a dataset of objects:\n     * ```js\n     * const c = tf.data.array([{a: 1, b: 11}, {a: 2, b: 12}, {a: 3, b: 13},\n     *   {a: 4, b: 14}, {a: 5, b: 15}, {a: 6, b: 16}, {a: 7, b: 17},\n     *   {a: 8, b: 18}]).batch(4);\n     * await c.forEachAsync(e => {\n     *   console.log('{');\n     *   for(var key in e) {\n     *     console.log(key+':');\n     *     e[key].print();\n     *   }\n     *   console.log('}');\n     * })\n     * ```\n     *\n     * @param batchSize The number of elements desired per batch.\n     * @param smallLastBatch Whether to emit the final batch when it has fewer\n     *   than batchSize elements. Default true.\n     * @returns A `Dataset`, from which a stream of batches can be obtained.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    batch(batchSize, smallLastBatch = true) {\n        const base = this;\n        tf.util.assert(batchSize > 0, () => `batchSize needs to be positive, but it is\n      ${batchSize}`);\n        let size;\n        if (this.size === Infinity || this.size == null) {\n            // If the size of this dataset is infinity or null, the new size keeps the\n            // same.\n            size = this.size;\n        }\n        else if (smallLastBatch) {\n            // If the size of this dataset is known and include small last batch, the\n            // new size is full batch count plus last batch.\n            size = Math.ceil(this.size / batchSize);\n        }\n        else {\n            // If the size of this dataset is known and not include small last batch,\n            // the new size is full batch count.\n            size = Math.floor(this.size / batchSize);\n        }\n        return datasetFromIteratorFn(async () => {\n            return (await base.iterator())\n                .columnMajorBatch(batchSize, smallLastBatch, deepBatchConcat);\n        }, size);\n    }\n    /**\n     * Concatenates this `Dataset` with another.\n     *\n     * ```js\n     * const a = tf.data.array([1, 2, 3]);\n     * const b = tf.data.array([4, 5, 6]);\n     * const c = a.concatenate(b);\n     * await c.forEachAsync(e => console.log(e));\n     * ```\n     *\n     * @param dataset A `Dataset` to be concatenated onto this one.\n     * @returns A `Dataset`.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    concatenate(dataset) {\n        const base = this;\n        let size;\n        if (this.size === Infinity || dataset.size === Infinity) {\n            // If the size of any of these two dataset is infinity, new size is\n            // infinity.\n            size = Infinity;\n        }\n        else if (this.size != null && dataset.size != null) {\n            // If the size of both datasets are known and not infinity, new size is\n            // sum the size of these two datasets.\n            size = this.size + dataset.size;\n        }\n        else {\n            // If neither of these two datasets has infinite size and any of these two\n            // datasets' size is null, the new size is null.\n            size = null;\n        }\n        return datasetFromIteratorFn(async () => (await base.iterator()).concatenate(await dataset.iterator()), size);\n    }\n    /**\n     * Filters this dataset according to `predicate`.\n     *\n     * ```js\n     * const a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n     *   .filter(x => x%2 === 0);\n     * await a.forEachAsync(e => console.log(e));\n     * ```\n     *\n     * @param predicate A function mapping a dataset element to a boolean or a\n     * `Promise` for one.\n     *\n     * @returns A `Dataset` of elements for which the predicate was true.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    filter(predicate) {\n        const base = this;\n        let size;\n        if (this.size === Infinity) {\n            // If the size of this dataset is infinity, new size is infinity\n            size = Infinity;\n        }\n        else {\n            // If this dataset has limited elements, new size is null because it might\n            // exhausted randomly.\n            size = null;\n        }\n        return datasetFromIteratorFn(async () => {\n            return (await base.iterator()).filter(x => tf.tidy(() => predicate(x)));\n        }, size);\n    }\n    /**\n     * Apply a function to every element of the dataset.\n     *\n     * After the function is applied to a dataset element, any Tensors contained\n     * within that element are disposed.\n     *\n     * ```js\n     * const a = tf.data.array([1, 2, 3]);\n     * await a.forEachAsync(e => console.log(e));\n     * ```\n     *\n     * @param f A function to apply to each dataset element.\n     * @returns A `Promise` that resolves after all elements have been processed.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    async forEachAsync(f) {\n        return (await this.iterator()).forEachAsync(f);\n    }\n    /**\n     * Maps this dataset through a 1-to-1 transform.\n     *\n     * ```js\n     * const a = tf.data.array([1, 2, 3]).map(x => x*x);\n     * await a.forEachAsync(e => console.log(e));\n     * ```\n     *\n     * @param transform A function mapping a dataset element to a transformed\n     *   dataset element.\n     *\n     * @returns A `Dataset` of transformed elements.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    map(transform) {\n        const base = this;\n        return datasetFromIteratorFn(async () => {\n            return (await base.iterator()).map(x => tf.tidy(() => transform(x)));\n        }, this.size);\n    }\n    /**\n     * Maps this dataset through an async 1-to-1 transform.\n     *\n     * ```js\n     * const a =\n     *  tf.data.array([1, 2, 3]).mapAsync(x => new Promise(function(resolve){\n     *    setTimeout(() => {\n     *      resolve(x * x);\n     *    }, Math.random()*1000 + 500);\n     *  }));\n     * console.log(await a.toArray());\n     * ```\n     *\n     * @param transform A function mapping a dataset element to a `Promise` for a\n     *   transformed dataset element.  This transform is responsible for disposing\n     *   any intermediate `Tensor`s, i.e. by wrapping its computation in\n     *   `tf.tidy()`; that cannot be automated here (as it is in the synchronous\n     *   `map()` case).\n     *\n     * @returns A `Dataset` of transformed elements.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    mapAsync(transform) {\n        const base = this;\n        return datasetFromIteratorFn(async () => {\n            return (await base.iterator()).mapAsync(transform);\n        }, this.size);\n    }\n    /**\n     *  Creates a `Dataset` that prefetches elements from this dataset.\n     *\n     * @param bufferSize: An integer specifying the number of elements to be\n     *   prefetched.\n     * @returns A `Dataset`.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    prefetch(bufferSize) {\n        if (bufferSize == null) {\n            throw new RangeError('`Dataset.prefetch()` requires bufferSize to be specified.');\n        }\n        const base = this;\n        return datasetFromIteratorFn(async () => (await base.iterator()).prefetch(bufferSize), this.size);\n    }\n    /**\n     * Repeats this dataset `count` times.\n     *\n     * NOTE: If this dataset is a function of global state (e.g. a random number\n     * generator), then different repetitions may produce different elements.\n     *\n     * ```js\n     * const a = tf.data.array([1, 2, 3]).repeat(3);\n     * await a.forEachAsync(e => console.log(e));\n     * ```\n     *\n     * @param count: (Optional) An integer, representing the number of times\n     *   the dataset should be repeated. The default behavior (if `count` is\n     *   `undefined` or negative) is for the dataset be repeated indefinitely.\n     * @returns A `Dataset`.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    repeat(count) {\n        const base = this;\n        let size;\n        if (this.size != null && count > 0) {\n            // If this dataset has size and count is positive, new size is current\n            // size multiply count. This also covers the case that current size is\n            // infinity.\n            size = this.size * count;\n        }\n        else if (count === 0) {\n            // If count is 0, new size is 0.\n            size = 0;\n        }\n        else if (this.size != null && (count === undefined || count < 0)) {\n            // If this dataset has size and count is undefined or negative, the\n            // dataset will be repeated indefinitely and new size is infinity.\n            size = Infinity;\n        }\n        else {\n            // If the size of this dataset is null, the new dataset's size is null.\n            size = null;\n        }\n        return datasetFromIteratorFn(async () => {\n            const iteratorIterator = iteratorFromFunction(async () => ({ value: await base.iterator(), done: false }));\n            return iteratorFromConcatenated(iteratorIterator.take(count));\n        }, size);\n    }\n    /**\n     * Creates a `Dataset` that skips `count` initial elements from this dataset.\n     *\n     * ```js\n     * const a = tf.data.array([1, 2, 3, 4, 5, 6]).skip(3);\n     * await a.forEachAsync(e => console.log(e));\n     * ```\n     *\n     * @param count: The number of elements of this dataset that should be skipped\n     *   to form the new dataset.  If `count` is greater than the size of this\n     *   dataset, the new dataset will contain no elements.  If `count`\n     *   is `undefined` or negative, skips the entire dataset.\n     *\n     * @returns A `Dataset`.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    skip(count) {\n        const base = this;\n        let size;\n        if (this.size != null && count >= 0 && this.size >= count) {\n            // If the size of this dataset is greater than count, the new dataset's\n            // size is current size minus skipped size.This also covers the case that\n            // current size is infinity.\n            size = this.size - count;\n        }\n        else if (this.size != null &&\n            (this.size < count || count === undefined || count < 0)) {\n            // If the size of this dataset is smaller than count, or count is\n            // undefined or negative, skips the entire dataset and the new size is 0.\n            size = 0;\n        }\n        else {\n            // If the size of this dataset is null, the new dataset's size is null.\n            size = null;\n        }\n        return datasetFromIteratorFn(async () => (await base.iterator()).skip(count), size);\n    }\n    /**\n     * Pseudorandomly shuffles the elements of this dataset. This is done in a\n     * streaming manner, by sampling from a given number of prefetched elements.\n     *\n     * ```js\n     * const a = tf.data.array([1, 2, 3, 4, 5, 6]).shuffle(3);\n     * await a.forEachAsync(e => console.log(e));\n     * ```\n     *\n     * @param bufferSize: An integer specifying the number of elements from this\n     *   dataset from which the new dataset will sample.\n     * @param seed: (Optional) An integer specifying the random seed that will\n     *   be used to create the distribution.\n     * @param reshuffleEachIteration: (Optional) A boolean, which if true\n     *   indicates that the dataset should be pseudorandomly reshuffled each time\n     *   it is iterated over. If false, elements will be returned in the same\n     *   shuffled order on each iteration. (Defaults to `true`.)\n     * @returns A `Dataset`.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    shuffle(bufferSize, seed, reshuffleEachIteration = true) {\n        if (bufferSize == null || bufferSize < 0) {\n            if (this.size == null) {\n                throw new RangeError('`Dataset.shuffle()` requires bufferSize to be specified.');\n            }\n            else {\n                throw new RangeError('`Dataset.shuffle()` requires bufferSize to be specified.  ' +\n                    'If your data fits in main memory (for regular JS objects), ' +\n                    'and/or GPU memory (for `tf.Tensor`s), consider setting ' +\n                    `bufferSize to the dataset size (${this.size} elements)`);\n            }\n        }\n        const base = this;\n        const random = seedrandom.alea(seed || tf.util.now().toString());\n        return datasetFromIteratorFn(async () => {\n            let seed2 = random.int32();\n            if (reshuffleEachIteration) {\n                seed2 += random.int32();\n            }\n            return (await base.iterator()).shuffle(bufferSize, seed2.toString());\n        }, this.size);\n    }\n    /**\n     * Creates a `Dataset` with at most `count` initial elements from this\n     * dataset.\n     *\n     * ```js\n     * const a = tf.data.array([1, 2, 3, 4, 5, 6]).take(3);\n     * await a.forEachAsync(e => console.log(e));\n     * ```\n     *\n     * @param count: The number of elements of this dataset that should be taken\n     *   to form the new dataset.  If `count` is `undefined` or negative, or if\n     *   `count` is greater than the size of this dataset, the new dataset will\n     *   contain all elements of this dataset.\n     * @returns A `Dataset`.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    take(count) {\n        const base = this;\n        let size;\n        if (this.size != null && this.size > count) {\n            // If the size of this dataset is greater than count, the new dataset's\n            // size is count.\n            size = count;\n        }\n        else if (this.size != null && this.size <= count) {\n            // If the size of this dataset is equal or smaller than count, the new\n            // dataset's size is the size of this dataset.\n            size = this.size;\n        }\n        else {\n            // If the size of this dataset is null, the new dataset's size is null.\n            size = null;\n        }\n        return datasetFromIteratorFn(async () => (await base.iterator()).take(count), size);\n    }\n    /**\n     * Collect all elements of this dataset into an array.\n     *\n     * Obviously this will succeed only for small datasets that fit in memory.\n     * Useful for testing and generally should be avoided if possible.\n     *\n     * ```js\n     * const a = tf.data.array([1, 2, 3, 4, 5, 6]);\n     * console.log(await a.toArray());\n     * ```\n     *\n     * @returns A Promise for an array of elements, which will resolve\n     *   when a new stream has been obtained and fully consumed.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    async toArray() {\n        if (this.size === Infinity) {\n            throw new Error('Can not convert infinite data stream to array.');\n        }\n        return (await this.iterator()).toArray();\n    }\n    /**\n     * Collect all elements of this dataset into an array with prefetching 100\n     * elements. This is useful for testing, because the prefetch changes the\n     * order in which the Promises are resolved along the processing pipeline.\n     * This may help expose bugs where results are dependent on the order of\n     * Promise resolution rather than on the logical order of the stream (i.e.,\n     * due to hidden mutable state).\n     *\n     * @returns A Promise for an array of elements, which will resolve\n     *   when a new stream has been obtained and fully consumed.\n     */\n    async toArrayForTest() {\n        if (this.size === Infinity) {\n            throw new Error('Can not convert infinite data stream to array.');\n        }\n        return (await this.iterator()).toArrayForTest();\n    }\n}\n// TODO(soergel): deep sharded shuffle, where supported\nDataset.MAX_BUFFER_SIZE = 10000;\nexport { Dataset };\n/**\n * Create a `Dataset` defined by a provided iterator() function.\n *\n * ```js\n * let i = -1;\n * const func = () =>\n *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};\n * const iter = tf.data.iteratorFromFunction(func);\n * const ds = tf.data.datasetFromIteratorFn(iter);\n * await ds.forEachAsync(e => console.log(e));\n * ```\n */\nexport function datasetFromIteratorFn(iteratorFn, size = null) {\n    return new class extends Dataset {\n        constructor() {\n            super(...arguments);\n            this.size = size;\n        }\n        /*\n         * Provide a new stream of elements.  Note this will also start new streams\n         * from any underlying `Dataset`s.\n         */\n        async iterator() {\n            return iteratorFn();\n        }\n    }();\n}\n/**\n * Create a `Dataset` from an array of elements.\n *\n * Create a Dataset from an array of objects:\n * ```js\n * const a = tf.data.array([{'item': 1}, {'item': 2}, {'item': 3}]);\n * await a.forEachAsync(e => console.log(e));\n * ```\n *\n * Create a Dataset from an array of numbers:\n * ```js\n * const a = tf.data.array([4, 5, 6]);\n * await a.forEachAsync(e => console.log(e));\n * ```\n * @param items An array of elements that will be parsed as items in a dataset.\n *\n * @doc {heading: 'Data', subheading: 'Creation', namespace: 'data'}\n */\nexport function array(items) {\n    return datasetFromIteratorFn(async () => iteratorFromItems(items), items.length);\n}\n/**\n * Create a `Dataset` by zipping together an array, dict, or nested\n * structure of `Dataset`s (and perhaps additional constants).\n * The underlying datasets must provide elements in a consistent order such that\n * they correspond.\n *\n * The number of elements in the resulting dataset is the same as the size of\n * the smallest dataset in datasets.\n *\n * The nested structure of the `datasets` argument determines the\n * structure of elements in the resulting iterator.\n *\n * Note this means that, given an array of two datasets that produce dict\n * elements, the result is a dataset that produces elements that are arrays\n * of two dicts:\n *\n * Zip an array of datasets:\n * ```js\n * console.log('Zip two datasets of objects:');\n * const ds1 = tf.data.array([{a: 1}, {a: 2}, {a: 3}]);\n * const ds2 = tf.data.array([{b: 4}, {b: 5}, {b: 6}]);\n * const ds3 = tf.data.zip([ds1, ds2]);\n * await ds3.forEachAsync(e => console.log(JSON.stringify(e)));\n *\n * // If the goal is to merge the dicts in order to produce elements like\n * // {a: ..., b: ...}, this requires a second step such as:\n * console.log('Merge the objects:');\n * const ds4 = ds3.map(x => {return {a: x[0].a, b: x[1].b}});\n * await ds4.forEachAsync(e => console.log(e));\n * ```\n *\n * Zip a dict of datasets:\n * ```js\n * const a = tf.data.array([{a: 1}, {a: 2}, {a: 3}]);\n * const b = tf.data.array([{b: 4}, {b: 5}, {b: 6}]);\n * const c = tf.data.zip({c: a, d: b});\n * await c.forEachAsync(e => console.log(JSON.stringify(e)));\n * ```\n *\n * @doc {heading: 'Data', subheading: 'Operations', namespace: 'data'}\n */\nexport function zip(datasets) {\n    // manually type-check the argument for JS users\n    if (!isIterable(datasets)) {\n        throw new Error('The argument to zip() must be an object or array.');\n    }\n    let size;\n    if (Array.isArray(datasets)) {\n        for (let i = 0; i < datasets.length; i++) {\n            size = size == null ? datasets[i].size :\n                Math.min(size, datasets[i].size);\n        }\n    }\n    else if (datasets instanceof Object) {\n        for (const ds in datasets) {\n            size = size == null ? datasets[ds].size :\n                Math.min(size, datasets[ds].size);\n        }\n    }\n    return datasetFromIteratorFn(async () => {\n        const streams = await deepMapAndAwaitAll(datasets, d => {\n            if (d instanceof Dataset) {\n                return { value: d.iterator(), recurse: false };\n            }\n            else if (isIterable(d)) {\n                return { value: null, recurse: true };\n            }\n            else {\n                throw new Error('Leaves of the structure passed to zip() must be Datasets, ' +\n                    'not primitives.');\n            }\n        });\n        return iteratorFromZipped(streams, ZipMismatchMode.SHORTEST);\n    }, size);\n}\n/**\n * A zip function for use with deepZip, passed via the columnMajorBatch call.\n *\n * Accepts an array of identically-structured nested elements and either batches\n * them (if they are primitives, numeric arrays, or Tensors) or requests\n * recursion (if not).\n */\n// tslint:disable-next-line:no-any\nfunction deepBatchConcat(rows) {\n    if (rows === null) {\n        return null;\n    }\n    // use the first item to decide whether to recurse or batch here.\n    const exampleRow = rows[0];\n    if (canTensorify(exampleRow)) {\n        // rows is an array of primitives, Tensors, or arrays.  Batch them.\n        const value = batchConcat(rows);\n        return { value, recurse: false };\n    }\n    // the example row is an object, so recurse into it.\n    return { value: null, recurse: true };\n}\n/**\n * Assembles a list of same-shaped numbers, number arrays, or Tensors\n * into a single new Tensor where axis 0 is the batch dimension.\n */\nfunction batchConcat(arrays) {\n    if (arrays.length === 0) {\n        // We can't return an empty Tensor because we don't know the element shape.\n        throw new Error('Can\\'t make a batch of zero elements.');\n    }\n    if (arrays[0] instanceof tf.Tensor) {\n        // Input is an array of Tensors\n        return tf.stack(arrays);\n    }\n    else {\n        // Input is a possibly-nested array of numbers.\n        return tf.tensor(arrays);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YXNldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtZGF0YS9zcmMvZGF0YXNldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7OztHQWdCRztBQUVILE9BQU8sS0FBSyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFNUMsT0FBTyxLQUFLLFVBQVUsTUFBTSxZQUFZLENBQUM7QUFFekMsT0FBTyxFQUFDLHdCQUF3QixFQUFFLG9CQUFvQixFQUFFLGlCQUFpQixFQUFFLGtCQUFrQixFQUFnQixlQUFlLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUUvSixPQUFPLEVBQUMsWUFBWSxFQUFFLGtCQUFrQixFQUFpQixVQUFVLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQU81RixxRUFBcUU7QUFFckU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTJCRztBQUNILE1BQXNCLE9BQU87SUFBN0I7UUFXVyxTQUFJLEdBQVcsSUFBSSxDQUFDO0lBMmMvQixDQUFDO0lBemNDLHdFQUF3RTtJQUN4RSwyRUFBMkU7SUFDM0UsNEVBQTRFO0lBQzVFLDJDQUEyQztJQUMzQyx1Q0FBdUM7SUFFdkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXNERztJQUNILEtBQUssQ0FBQyxTQUFpQixFQUFFLGNBQWMsR0FBRyxJQUFJO1FBQzVDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQztRQUNsQixFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FDVixTQUFTLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDO1FBQ3JCLFNBQVMsRUFBRSxDQUFDLENBQUM7UUFDakIsSUFBSSxJQUFJLENBQUM7UUFDVCxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssUUFBUSxJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxFQUFFO1lBQy9DLDBFQUEwRTtZQUMx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QUFNO1FBQ0wsK0NBQStDO1FBQy9DLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFvQixDQUFDLENBQUM7S0FDeEM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0ICogYXMgdGYgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7VGVuc29yQ29udGFpbmVyLCBUZW5zb3JMaWtlfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0ICogYXMgc2VlZHJhbmRvbSBmcm9tICdzZWVkcmFuZG9tJztcblxuaW1wb3J0IHtpdGVyYXRvckZyb21Db25jYXRlbmF0ZWQsIGl0ZXJhdG9yRnJvbUZ1bmN0aW9uLCBpdGVyYXRvckZyb21JdGVtcywgaXRlcmF0b3JGcm9tWmlwcGVkLCBMYXp5SXRlcmF0b3IsIFppcE1pc21hdGNoTW9kZX0gZnJvbSAnLi9pdGVyYXRvcnMvbGF6eV9pdGVyYXRvcic7XG5pbXBvcnQge0NvbnRhaW5lcn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge2NhblRlbnNvcmlmeSwgZGVlcE1hcEFuZEF3YWl0QWxsLCBEZWVwTWFwUmVzdWx0LCBpc0l0ZXJhYmxlfSBmcm9tICcuL3V0aWwvZGVlcF9tYXAnO1xuXG4vKipcbiAqIEEgbmVzdGVkIHN0cnVjdHVyZSBvZiBEYXRhc2V0cywgdXNlZCBhcyB0aGUgaW5wdXQgdG8gemlwKCkuXG4gKi9cbmV4cG9ydCB0eXBlIERhdGFzZXRDb250YWluZXIgPSBDb250YWluZXI8RGF0YXNldDxUZW5zb3JDb250YWluZXI+PjtcblxuLy8gVE9ETyhzb2VyZ2VsKTogY29uc2lkZXIgdmVjdG9yaXplZCBvcGVyYXRpb25zIHdpdGhpbiB0aGUgcGlwZWxpbmUuXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHBvdGVudGlhbGx5IGxhcmdlIGxpc3Qgb2YgaW5kZXBlbmRlbnQgZGF0YSBlbGVtZW50cyAodHlwaWNhbGx5XG4gKiAnc2FtcGxlcycgb3IgJ2V4YW1wbGVzJykuXG4gKlxuICogQSAnZGF0YSBleGFtcGxlJyBtYXkgYmUgYSBwcmltaXRpdmUsIGFuIGFycmF5LCBhIG1hcCBmcm9tIHN0cmluZyBrZXlzIHRvXG4gKiB2YWx1ZXMsIG9yIGFueSBuZXN0ZWQgc3RydWN0dXJlIG9mIHRoZXNlLlxuICpcbiAqIEEgYERhdGFzZXRgIHJlcHJlc2VudHMgYW4gb3JkZXJlZCBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzLCB0b2dldGhlciB3aXRoIGFcbiAqIGNoYWluIG9mIHRyYW5zZm9ybWF0aW9ucyB0byBiZSBwZXJmb3JtZWQgb24gdGhvc2UgZWxlbWVudHMuIEVhY2hcbiAqIHRyYW5zZm9ybWF0aW9uIGlzIGEgbWV0aG9kIG9mIGBEYXRhc2V0YCB0aGF0IHJldHVybnMgYW5vdGhlciBgRGF0YXNldGAsIHNvXG4gKiB0aGVzZSBtYXkgYmUgY2hhaW5lZCwgZS5nLlxuICogYGNvbnN0IHByb2Nlc3NlZERhdGFzZXQgPSByYXdEYXRhc2V0LmZpbHRlciguLi4pLm1hcCguLi4pLmJhdGNoKC4uLilgLlxuICpcbiAqIERhdGEgbG9hZGluZyBhbmQgdHJhbnNmb3JtYXRpb24gaXMgZG9uZSBpbiBhIGxhenksIHN0cmVhbWluZyBmYXNoaW9uLiAgVGhlXG4gKiBkYXRhc2V0IG1heSBiZSBpdGVyYXRlZCBvdmVyIG11bHRpcGxlIHRpbWVzOyBlYWNoIGl0ZXJhdGlvbiBzdGFydHMgdGhlIGRhdGFcbiAqIGxvYWRpbmcgYW5ldyBhbmQgcmVjYXBpdHVsYXRlcyB0aGUgdHJhbnNmb3JtYXRpb25zLlxuICpcbiAqIEEgYERhdGFzZXRgIGlzIHR5cGljYWxseSBwcm9jZXNzZWQgYXMgYSBzdHJlYW0gb2YgdW5iYXRjaGVkIGV4YW1wbGVzIC0tIGkuZS4sXG4gKiBpdHMgdHJhbnNmb3JtYXRpb25zIGFyZSBhcHBsaWVkIG9uZSBleGFtcGxlIGF0IGEgdGltZS4gQmF0Y2hpbmcgcHJvZHVjZXMgYVxuICogbmV3IGBEYXRhc2V0YCB3aGVyZSBlYWNoIGVsZW1lbnQgaXMgYSBiYXRjaC4gQmF0Y2hpbmcgc2hvdWxkIHVzdWFsbHkgY29tZVxuICogbGFzdCBpbiBhIHBpcGVsaW5lLCBiZWNhdXNlIGRhdGEgdHJhbnNmb3JtYXRpb25zIGFyZSBlYXNpZXIgdG8gZXhwcmVzcyBvbiBhXG4gKiBwZXItZXhhbXBsZSBiYXNpcyB0aGFuIG9uIGEgcGVyLWJhdGNoIGJhc2lzLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgY29kZSBleGFtcGxlcyBhcmUgY2FsbGluZyBgYXdhaXQgZGF0YXNldC5mb3JFYWNoQXN5bmMoLi4uKWAgdG9cbiAqIGl0ZXJhdGUgb25jZSBvdmVyIHRoZSBlbnRpcmUgZGF0YXNldCBpbiBvcmRlciB0byBwcmludCBvdXQgdGhlIGRhdGEuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ0RhdGEnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIG5hbWVzcGFjZTogJ2RhdGEnfVxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0YXNldDxUIGV4dGVuZHMgdGYuVGVuc29yQ29udGFpbmVyPiB7XG4gIC8qXG4gICAqIFByb3ZpZGUgYSBuZXcgc3RyZWFtIG9mIGVsZW1lbnRzLiAgTm90ZSB0aGlzIHdpbGwgYWxzbyBzdGFydCBuZXcgc3RyZWFtc1xuICAgKiBmcm9tIGFueSB1bmRlcmx5aW5nIGBEYXRhc2V0YHMuXG4gICAqXG4gICAqIENBVVRJT046IEFueSBUZW5zb3JzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGVsZW1lbnRzIHJldHVybmVkIGZyb21cbiAgICogdGhpcyBzdHJlYW0gKm11c3QqIGJlIG1hbnVhbGx5IGRpc3Bvc2VkIHRvIGF2b2lkIGEgR1BVIG1lbW9yeSBsZWFrLlxuICAgKiBUaGUgdGYudGlkeSgpIGFwcHJvYWNoIGNhbm5vdCBiZSB1c2VkIGluIGFuIGFzeW5jaHJvbm91cyBjb250ZXh0LlxuICAgKi9cbiAgYWJzdHJhY3QgaXRlcmF0b3IoKTogUHJvbWlzZTxMYXp5SXRlcmF0b3I8VD4+O1xuXG4gIHJlYWRvbmx5IHNpemU6IG51bWJlciA9IG51bGw7XG5cbiAgLy8gVE9ETyhzb2VyZ2VsKTogTWFrZSBEYXRhc2V0cyByZXBvcnQgd2hldGhlciByZXBlYXRlZCBpdGVyYXRvcigpIGNhbGxzXG4gIC8vIHByb2R1Y2UgdGhlIHNhbWUgcmVzdWx0IChlLmcuLCByZWFkaW5nIGZyb20gYSBmaWxlKSBvciBkaWZmZXJlbnQgcmVzdWx0c1xuICAvLyAoZS5nLiwgZnJvbSB0aGUgd2ViY2FtKS4gIEN1cnJlbnRseSB3ZSBkb24ndCBtYWtlIHRoaXMgZGlzdGluY3Rpb24gYnV0IGl0XG4gIC8vIGNvdWxkIGJlIGltcG9ydGFudCBmb3IgdGhlIHVzZXIgdG8ga25vdy5cbiAgLy8gYWJzdHJhY3QgaXNEZXRlcm1pbmlzdGljKCk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEdyb3VwcyBlbGVtZW50cyBpbnRvIGJhdGNoZXMuXG4gICAqXG4gICAqIEl0IGlzIGFzc3VtZWQgdGhhdCBlYWNoIG9mIHRoZSBpbmNvbWluZyBkYXRhc2V0IGVsZW1lbnRzIGhhcyB0aGUgc2FtZVxuICAgKiBzdHJ1Y3R1cmUgLS0gaS5lLiB0aGUgc2FtZSBzZXQgb2Yga2V5cyBhdCBlYWNoIGxvY2F0aW9uIGluIGFuIG9iamVjdFxuICAgKiBoaWVyYXJjaHkuICBGb3IgZWFjaCBrZXksIHRoZSByZXN1bHRpbmcgYERhdGFzZXRgIHByb3ZpZGVzIGEgYmF0Y2hlZFxuICAgKiBlbGVtZW50IGNvbGxlY3RpbmcgYWxsIG9mIHRoZSBpbmNvbWluZyB2YWx1ZXMgZm9yIHRoYXQga2V5LlxuICAgKlxuICAgKiAgKiBJbmNvbWluZyBwcmltaXRpdmVzIGFyZSBncm91cGVkIGludG8gYSAxLUQgVGVuc29yLlxuICAgKiAgKiBJbmNvbWluZyBUZW5zb3JzIGFyZSBncm91cGVkIGludG8gYSBuZXcgVGVuc29yIHdoZXJlIHRoZSAwdGggYXhpcyBpc1xuICAgKiAgICB0aGUgYmF0Y2ggZGltZW5zaW9uLlxuICAgKiAgKiBJbmNvbWluZyBhcnJheXMgYXJlIGNvbnZlcnRlZCB0byBUZW5zb3IgYW5kIHRoZW4gYmF0Y2hlZC5cbiAgICogICogQSBuZXN0ZWQgYXJyYXkgaXMgaW50ZXJwcmV0ZWQgYXMgYW4gbi1EIFRlbnNvciwgc28gdGhlIGJhdGNoZWQgcmVzdWx0XG4gICAqICAgIGhhcyBuKzEgZGltZW5zaW9ucy5cbiAgICogICogQW4gYXJyYXkgdGhhdCBjYW5ub3QgYmUgY29udmVydGVkIHRvIFRlbnNvciBwcm9kdWNlcyBhbiBlcnJvci5cbiAgICpcbiAgICogSWYgYW4gYXJyYXkgc2hvdWxkIG5vdCBiZSBiYXRjaGVkIGFzIGEgdW5pdCwgaXQgc2hvdWxkIGZpcnN0IGJlIGNvbnZlcnRlZFxuICAgKiB0byBhbiBvYmplY3Qgd2l0aCBpbnRlZ2VyIGtleXMuXG4gICAqXG4gICAqIEhlcmUgYXJlIGEgZmV3IGV4YW1wbGVzOlxuICAgKlxuICAgKiBCYXRjaCBhIGRhdGFzZXQgb2YgbnVtYmVyczpcbiAgICogYGBganNcbiAgICogY29uc3QgYSA9IHRmLmRhdGEuYXJyYXkoWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDhdKS5iYXRjaCg0KTtcbiAgICogYXdhaXQgYS5mb3JFYWNoQXN5bmMoZSA9PiBlLnByaW50KCkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQmF0Y2ggYSBkYXRhc2V0IG9mIGFycmF5czpcbiAgICogYGBganNcbiAgICogY29uc3QgYiA9IHRmLmRhdGEuYXJyYXkoW1sxXSwgWzJdLCBbM10sIFs0XSwgWzVdLCBbNl0sIFs3XSwgWzhdXSkuYmF0Y2goNCk7XG4gICAqIGF3YWl0IGIuZm9yRWFjaEFzeW5jKGUgPT4gZS5wcmludCgpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEJhdGNoIGEgZGF0YXNldCBvZiBvYmplY3RzOlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBjID0gdGYuZGF0YS5hcnJheShbe2E6IDEsIGI6IDExfSwge2E6IDIsIGI6IDEyfSwge2E6IDMsIGI6IDEzfSxcbiAgICogICB7YTogNCwgYjogMTR9LCB7YTogNSwgYjogMTV9LCB7YTogNiwgYjogMTZ9LCB7YTogNywgYjogMTd9LFxuICAgKiAgIHthOiA4LCBiOiAxOH1dKS5iYXRjaCg0KTtcbiAgICogYXdhaXQgYy5mb3JFYWNoQXN5bmMoZSA9PiB7XG4gICAqICAgY29uc29sZS5sb2coJ3snKTtcbiAgICogICBmb3IodmFyIGtleSBpbiBlKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyhrZXkrJzonKTtcbiAgICogICAgIGVba2V5XS5wcmludCgpO1xuICAgKiAgIH1cbiAgICogICBjb25zb2xlLmxvZygnfScpO1xuICAgKiB9KVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGJhdGNoU2l6ZSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGRlc2lyZWQgcGVyIGJhdGNoLlxuICAgKiBAcGFyYW0gc21hbGxMYXN0QmF0Y2ggV2hldGhlciB0byBlbWl0IHRoZSBmaW5hbCBiYXRjaCB3aGVuIGl0IGhhcyBmZXdlclxuICAgKiAgIHRoYW4gYmF0Y2hTaXplIGVsZW1lbnRzLiBEZWZhdWx0IHRydWUuXG4gICAqIEByZXR1cm5zIEEgYERhdGFzZXRgLCBmcm9tIHdoaWNoIGEgc3RyZWFtIG9mIGJhdGNoZXMgY2FuIGJlIG9idGFpbmVkLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnRGF0YScsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICovXG4gIGJhdGNoKGJhdGNoU2l6ZTogbnVtYmVyLCBzbWFsbExhc3RCYXRjaCA9IHRydWUpOiBEYXRhc2V0PHRmLlRlbnNvckNvbnRhaW5lcj4ge1xuICAgIGNvbnN0IGJhc2UgPSB0aGlzO1xuICAgIHRmLnV0aWwuYXNzZXJ0KFxuICAgICAgICBiYXRjaFNpemUgPiAwLCAoKSA9PiBgYmF0Y2hTaXplIG5lZWRzIHRvIGJlIHBvc2l0aXZlLCBidXQgaXQgaXNcbiAgICAgICR7YmF0Y2hTaXplfWApO1xuICAgIGxldCBzaXplO1xuICAgIGlmICh0aGlzLnNpemUgPT09IEluZmluaXR5IHx8IHRoaXMuc2l6ZSA9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGUgc2l6ZSBvZiB0aGlzIGRhdGFzZXQgaXMgaW5maW5pdHkgb3IgbnVsbCwgdGhlIG5ldyBzaXplIGtlZXBzIHRoZVxuICAgICAgLy8gc2FtZS5cbiAgICAgIHNpemUgPSB0aGlzLnNpemU7XG4gICAgfSBlbHNlIGlmIChzbWFsbExhc3RCYXRjaCkge1xuICAgICAgLy8gSWYgdGhlIHNpemUgb2YgdGhpcyBkYXRhc2V0IGlzIGtub3duIGFuZCBpbmNsdWRlIHNtYWxsIGxhc3QgYmF0Y2gsIHRoZVxuICAgICAgLy8gbmV3IHNpemUgaXMgZnVsbCBiYXRjaCBjb3VudCBwbHVzIGxhc3QgYmF0Y2guXG4gICAgICBzaXplID0gTWF0aC5jZWlsKHRoaXMuc2l6ZSAvIGJhdGNoU2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBzaXplIG9mIHRoaXMgZGF0YXNldCBpcyBrbm93biBhbmQgbm90IGluY2x1ZGUgc21hbGwgbGFzdCBiYXRjaCxcbiAgICAgIC8vIHRoZSBuZXcgc2l6ZSBpcyBmdWxsIGJhdGNoIGNvdW50LlxuICAgICAgc2l6ZSA9IE1hdGguZmxvb3IodGhpcy5zaXplIC8gYmF0Y2hTaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gKGF3YWl0IGJhc2UuaXRlcmF0b3IoKSlcbiAgICAgICAgICAuY29sdW1uTWFqb3JCYXRjaChiYXRjaFNpemUsIHNtYWxsTGFzdEJhdGNoLCBkZWVwQmF0Y2hDb25jYXQpO1xuICAgIH0sIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmNhdGVuYXRlcyB0aGlzIGBEYXRhc2V0YCB3aXRoIGFub3RoZXIuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGEgPSB0Zi5kYXRhLmFycmF5KFsxLCAyLCAzXSk7XG4gICAqIGNvbnN0IGIgPSB0Zi5kYXRhLmFycmF5KFs0LCA1LCA2XSk7XG4gICAqIGNvbnN0IGMgPSBhLmNvbmNhdGVuYXRlKGIpO1xuICAgKiBhd2FpdCBjLmZvckVhY2hBc3luYyhlID0+IGNvbnNvbGUubG9nKGUpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhc2V0IEEgYERhdGFzZXRgIHRvIGJlIGNvbmNhdGVuYXRlZCBvbnRvIHRoaXMgb25lLlxuICAgKiBAcmV0dXJucyBBIGBEYXRhc2V0YC5cbiAgICpcbiAgICogQGRvYyB7aGVhZGluZzogJ0RhdGEnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBjb25jYXRlbmF0ZShkYXRhc2V0OiBEYXRhc2V0PFQ+KTogRGF0YXNldDxUPiB7XG4gICAgY29uc3QgYmFzZSA9IHRoaXM7XG4gICAgbGV0IHNpemU7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkgfHwgZGF0YXNldC5zaXplID09PSBJbmZpbml0eSkge1xuICAgICAgLy8gSWYgdGhlIHNpemUgb2YgYW55IG9mIHRoZXNlIHR3byBkYXRhc2V0IGlzIGluZmluaXR5LCBuZXcgc2l6ZSBpc1xuICAgICAgLy8gaW5maW5pdHkuXG4gICAgICBzaXplID0gSW5maW5pdHk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNpemUgIT0gbnVsbCAmJiBkYXRhc2V0LnNpemUgIT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhlIHNpemUgb2YgYm90aCBkYXRhc2V0cyBhcmUga25vd24gYW5kIG5vdCBpbmZpbml0eSwgbmV3IHNpemUgaXNcbiAgICAgIC8vIHN1bSB0aGUgc2l6ZSBvZiB0aGVzZSB0d28gZGF0YXNldHMuXG4gICAgICBzaXplID0gdGhpcy5zaXplICsgZGF0YXNldC5zaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBuZWl0aGVyIG9mIHRoZXNlIHR3byBkYXRhc2V0cyBoYXMgaW5maW5pdGUgc2l6ZSBhbmQgYW55IG9mIHRoZXNlIHR3b1xuICAgICAgLy8gZGF0YXNldHMnIHNpemUgaXMgbnVsbCwgdGhlIG5ldyBzaXplIGlzIG51bGwuXG4gICAgICBzaXplID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihcbiAgICAgICAgYXN5bmMgKCkgPT5cbiAgICAgICAgICAgIChhd2FpdCBiYXNlLml0ZXJhdG9yKCkpLmNvbmNhdGVuYXRlKGF3YWl0IGRhdGFzZXQuaXRlcmF0b3IoKSksXG4gICAgICAgIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhpcyBkYXRhc2V0IGFjY29yZGluZyB0byBgcHJlZGljYXRlYC5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgYSA9IHRmLmRhdGEuYXJyYXkoWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXSlcbiAgICogICAuZmlsdGVyKHggPT4geCUyID09PSAwKTtcbiAgICogYXdhaXQgYS5mb3JFYWNoQXN5bmMoZSA9PiBjb25zb2xlLmxvZyhlKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gcHJlZGljYXRlIEEgZnVuY3Rpb24gbWFwcGluZyBhIGRhdGFzZXQgZWxlbWVudCB0byBhIGJvb2xlYW4gb3IgYVxuICAgKiBgUHJvbWlzZWAgZm9yIG9uZS5cbiAgICpcbiAgICogQHJldHVybnMgQSBgRGF0YXNldGAgb2YgZWxlbWVudHMgZm9yIHdoaWNoIHRoZSBwcmVkaWNhdGUgd2FzIHRydWUuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdEYXRhJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgZmlsdGVyKHByZWRpY2F0ZTogKHZhbHVlOiBUKSA9PiBib29sZWFuKTogRGF0YXNldDxUPiB7XG4gICAgY29uc3QgYmFzZSA9IHRoaXM7XG4gICAgbGV0IHNpemU7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIC8vIElmIHRoZSBzaXplIG9mIHRoaXMgZGF0YXNldCBpcyBpbmZpbml0eSwgbmV3IHNpemUgaXMgaW5maW5pdHlcbiAgICAgIHNpemUgPSBJbmZpbml0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhpcyBkYXRhc2V0IGhhcyBsaW1pdGVkIGVsZW1lbnRzLCBuZXcgc2l6ZSBpcyBudWxsIGJlY2F1c2UgaXQgbWlnaHRcbiAgICAgIC8vIGV4aGF1c3RlZCByYW5kb21seS5cbiAgICAgIHNpemUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiAoYXdhaXQgYmFzZS5pdGVyYXRvcigpKS5maWx0ZXIoeCA9PiB0Zi50aWR5KCgpID0+IHByZWRpY2F0ZSh4KSkpO1xuICAgIH0sIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEgZnVuY3Rpb24gdG8gZXZlcnkgZWxlbWVudCBvZiB0aGUgZGF0YXNldC5cbiAgICpcbiAgICogQWZ0ZXIgdGhlIGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gYSBkYXRhc2V0IGVsZW1lbnQsIGFueSBUZW5zb3JzIGNvbnRhaW5lZFxuICAgKiB3aXRoaW4gdGhhdCBlbGVtZW50IGFyZSBkaXNwb3NlZC5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgYSA9IHRmLmRhdGEuYXJyYXkoWzEsIDIsIDNdKTtcbiAgICogYXdhaXQgYS5mb3JFYWNoQXN5bmMoZSA9PiBjb25zb2xlLmxvZyhlKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gZiBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggZGF0YXNldCBlbGVtZW50LlxuICAgKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIGFmdGVyIGFsbCBlbGVtZW50cyBoYXZlIGJlZW4gcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnRGF0YScsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICovXG4gIGFzeW5jIGZvckVhY2hBc3luYyhmOiAoaW5wdXQ6IFQpID0+IHZvaWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuaXRlcmF0b3IoKSkuZm9yRWFjaEFzeW5jKGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcHMgdGhpcyBkYXRhc2V0IHRocm91Z2ggYSAxLXRvLTEgdHJhbnNmb3JtLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBhID0gdGYuZGF0YS5hcnJheShbMSwgMiwgM10pLm1hcCh4ID0+IHgqeCk7XG4gICAqIGF3YWl0IGEuZm9yRWFjaEFzeW5jKGUgPT4gY29uc29sZS5sb2coZSkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHRyYW5zZm9ybSBBIGZ1bmN0aW9uIG1hcHBpbmcgYSBkYXRhc2V0IGVsZW1lbnQgdG8gYSB0cmFuc2Zvcm1lZFxuICAgKiAgIGRhdGFzZXQgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybnMgQSBgRGF0YXNldGAgb2YgdHJhbnNmb3JtZWQgZWxlbWVudHMuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdEYXRhJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgbWFwPE8gZXh0ZW5kcyB0Zi5UZW5zb3JDb250YWluZXI+KHRyYW5zZm9ybTogKHZhbHVlOiBUKSA9PiBPKTogRGF0YXNldDxPPiB7XG4gICAgY29uc3QgYmFzZSA9IHRoaXM7XG4gICAgcmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gKGF3YWl0IGJhc2UuaXRlcmF0b3IoKSkubWFwKHggPT4gdGYudGlkeSgoKSA9PiB0cmFuc2Zvcm0oeCkpKTtcbiAgICB9LCB0aGlzLnNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcHMgdGhpcyBkYXRhc2V0IHRocm91Z2ggYW4gYXN5bmMgMS10by0xIHRyYW5zZm9ybS5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgYSA9XG4gICAqICB0Zi5kYXRhLmFycmF5KFsxLCAyLCAzXSkubWFwQXN5bmMoeCA9PiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKXtcbiAgICogICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAqICAgICAgcmVzb2x2ZSh4ICogeCk7XG4gICAqICAgIH0sIE1hdGgucmFuZG9tKCkqMTAwMCArIDUwMCk7XG4gICAqICB9KSk7XG4gICAqIGNvbnNvbGUubG9nKGF3YWl0IGEudG9BcnJheSgpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB0cmFuc2Zvcm0gQSBmdW5jdGlvbiBtYXBwaW5nIGEgZGF0YXNldCBlbGVtZW50IHRvIGEgYFByb21pc2VgIGZvciBhXG4gICAqICAgdHJhbnNmb3JtZWQgZGF0YXNldCBlbGVtZW50LiAgVGhpcyB0cmFuc2Zvcm0gaXMgcmVzcG9uc2libGUgZm9yIGRpc3Bvc2luZ1xuICAgKiAgIGFueSBpbnRlcm1lZGlhdGUgYFRlbnNvcmBzLCBpLmUuIGJ5IHdyYXBwaW5nIGl0cyBjb21wdXRhdGlvbiBpblxuICAgKiAgIGB0Zi50aWR5KClgOyB0aGF0IGNhbm5vdCBiZSBhdXRvbWF0ZWQgaGVyZSAoYXMgaXQgaXMgaW4gdGhlIHN5bmNocm9ub3VzXG4gICAqICAgYG1hcCgpYCBjYXNlKS5cbiAgICpcbiAgICogQHJldHVybnMgQSBgRGF0YXNldGAgb2YgdHJhbnNmb3JtZWQgZWxlbWVudHMuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdEYXRhJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgbWFwQXN5bmM8TyBleHRlbmRzIHRmLlRlbnNvckNvbnRhaW5lcj4odHJhbnNmb3JtOiAodmFsdWU6IFQpID0+IFByb21pc2U8Tz4pOlxuICAgICAgRGF0YXNldDxPPiB7XG4gICAgY29uc3QgYmFzZSA9IHRoaXM7XG4gICAgcmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihhc3luYyAoKSA9PiB7XG4gICAgICByZXR1cm4gKGF3YWl0IGJhc2UuaXRlcmF0b3IoKSkubWFwQXN5bmModHJhbnNmb3JtKTtcbiAgICB9LCB0aGlzLnNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqICBDcmVhdGVzIGEgYERhdGFzZXRgIHRoYXQgcHJlZmV0Y2hlcyBlbGVtZW50cyBmcm9tIHRoaXMgZGF0YXNldC5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlclNpemU6IEFuIGludGVnZXIgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGJlXG4gICAqICAgcHJlZmV0Y2hlZC5cbiAgICogQHJldHVybnMgQSBgRGF0YXNldGAuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdEYXRhJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgcHJlZmV0Y2goYnVmZmVyU2l6ZTogbnVtYmVyKTogRGF0YXNldDxUPiB7XG4gICAgaWYgKGJ1ZmZlclNpemUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgJ2BEYXRhc2V0LnByZWZldGNoKClgIHJlcXVpcmVzIGJ1ZmZlclNpemUgdG8gYmUgc3BlY2lmaWVkLicpO1xuICAgIH1cblxuICAgIGNvbnN0IGJhc2UgPSB0aGlzO1xuICAgIHJldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oXG4gICAgICAgIGFzeW5jICgpID0+IChhd2FpdCBiYXNlLml0ZXJhdG9yKCkpLnByZWZldGNoKGJ1ZmZlclNpemUpLCB0aGlzLnNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGVhdHMgdGhpcyBkYXRhc2V0IGBjb3VudGAgdGltZXMuXG4gICAqXG4gICAqIE5PVEU6IElmIHRoaXMgZGF0YXNldCBpcyBhIGZ1bmN0aW9uIG9mIGdsb2JhbCBzdGF0ZSAoZS5nLiBhIHJhbmRvbSBudW1iZXJcbiAgICogZ2VuZXJhdG9yKSwgdGhlbiBkaWZmZXJlbnQgcmVwZXRpdGlvbnMgbWF5IHByb2R1Y2UgZGlmZmVyZW50IGVsZW1lbnRzLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBhID0gdGYuZGF0YS5hcnJheShbMSwgMiwgM10pLnJlcGVhdCgzKTtcbiAgICogYXdhaXQgYS5mb3JFYWNoQXN5bmMoZSA9PiBjb25zb2xlLmxvZyhlKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gY291bnQ6IChPcHRpb25hbCkgQW4gaW50ZWdlciwgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2YgdGltZXNcbiAgICogICB0aGUgZGF0YXNldCBzaG91bGQgYmUgcmVwZWF0ZWQuIFRoZSBkZWZhdWx0IGJlaGF2aW9yIChpZiBgY291bnRgIGlzXG4gICAqICAgYHVuZGVmaW5lZGAgb3IgbmVnYXRpdmUpIGlzIGZvciB0aGUgZGF0YXNldCBiZSByZXBlYXRlZCBpbmRlZmluaXRlbHkuXG4gICAqIEByZXR1cm5zIEEgYERhdGFzZXRgLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnRGF0YScsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICovXG4gIHJlcGVhdChjb3VudD86IG51bWJlcik6IERhdGFzZXQ8VD4ge1xuICAgIGNvbnN0IGJhc2UgPSB0aGlzO1xuICAgIGxldCBzaXplO1xuICAgIGlmICh0aGlzLnNpemUgIT0gbnVsbCAmJiBjb3VudCA+IDApIHtcbiAgICAgIC8vIElmIHRoaXMgZGF0YXNldCBoYXMgc2l6ZSBhbmQgY291bnQgaXMgcG9zaXRpdmUsIG5ldyBzaXplIGlzIGN1cnJlbnRcbiAgICAgIC8vIHNpemUgbXVsdGlwbHkgY291bnQuIFRoaXMgYWxzbyBjb3ZlcnMgdGhlIGNhc2UgdGhhdCBjdXJyZW50IHNpemUgaXNcbiAgICAgIC8vIGluZmluaXR5LlxuICAgICAgc2l6ZSA9IHRoaXMuc2l6ZSAqIGNvdW50O1xuICAgIH0gZWxzZSBpZiAoY291bnQgPT09IDApIHtcbiAgICAgIC8vIElmIGNvdW50IGlzIDAsIG5ldyBzaXplIGlzIDAuXG4gICAgICBzaXplID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2l6ZSAhPSBudWxsICYmIChjb3VudCA9PT0gdW5kZWZpbmVkIHx8IGNvdW50IDwgMCkpIHtcbiAgICAgIC8vIElmIHRoaXMgZGF0YXNldCBoYXMgc2l6ZSBhbmQgY291bnQgaXMgdW5kZWZpbmVkIG9yIG5lZ2F0aXZlLCB0aGVcbiAgICAgIC8vIGRhdGFzZXQgd2lsbCBiZSByZXBlYXRlZCBpbmRlZmluaXRlbHkgYW5kIG5ldyBzaXplIGlzIGluZmluaXR5LlxuICAgICAgc2l6ZSA9IEluZmluaXR5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgc2l6ZSBvZiB0aGlzIGRhdGFzZXQgaXMgbnVsbCwgdGhlIG5ldyBkYXRhc2V0J3Mgc2l6ZSBpcyBudWxsLlxuICAgICAgc2l6ZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhc2V0RnJvbUl0ZXJhdG9yRm4oYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaXRlcmF0b3JJdGVyYXRvciA9IGl0ZXJhdG9yRnJvbUZ1bmN0aW9uKFxuICAgICAgICAgIGFzeW5jICgpID0+ICh7dmFsdWU6IGF3YWl0IGJhc2UuaXRlcmF0b3IoKSwgZG9uZTogZmFsc2V9KSk7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGcm9tQ29uY2F0ZW5hdGVkKGl0ZXJhdG9ySXRlcmF0b3IudGFrZShjb3VudCkpO1xuICAgIH0sIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBgRGF0YXNldGAgdGhhdCBza2lwcyBgY291bnRgIGluaXRpYWwgZWxlbWVudHMgZnJvbSB0aGlzIGRhdGFzZXQuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGEgPSB0Zi5kYXRhLmFycmF5KFsxLCAyLCAzLCA0LCA1LCA2XSkuc2tpcCgzKTtcbiAgICogYXdhaXQgYS5mb3JFYWNoQXN5bmMoZSA9PiBjb25zb2xlLmxvZyhlKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gY291bnQ6IFRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgdGhpcyBkYXRhc2V0IHRoYXQgc2hvdWxkIGJlIHNraXBwZWRcbiAgICogICB0byBmb3JtIHRoZSBuZXcgZGF0YXNldC4gIElmIGBjb3VudGAgaXMgZ3JlYXRlciB0aGFuIHRoZSBzaXplIG9mIHRoaXNcbiAgICogICBkYXRhc2V0LCB0aGUgbmV3IGRhdGFzZXQgd2lsbCBjb250YWluIG5vIGVsZW1lbnRzLiAgSWYgYGNvdW50YFxuICAgKiAgIGlzIGB1bmRlZmluZWRgIG9yIG5lZ2F0aXZlLCBza2lwcyB0aGUgZW50aXJlIGRhdGFzZXQuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgYERhdGFzZXRgLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnRGF0YScsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICovXG4gIHNraXAoY291bnQ6IG51bWJlcik6IERhdGFzZXQ8VD4ge1xuICAgIGNvbnN0IGJhc2UgPSB0aGlzO1xuICAgIGxldCBzaXplO1xuICAgIGlmICh0aGlzLnNpemUgIT0gbnVsbCAmJiBjb3VudCA+PSAwICYmIHRoaXMuc2l6ZSA+PSBjb3VudCkge1xuICAgICAgLy8gSWYgdGhlIHNpemUgb2YgdGhpcyBkYXRhc2V0IGlzIGdyZWF0ZXIgdGhhbiBjb3VudCwgdGhlIG5ldyBkYXRhc2V0J3NcbiAgICAgIC8vIHNpemUgaXMgY3VycmVudCBzaXplIG1pbnVzIHNraXBwZWQgc2l6ZS5UaGlzIGFsc28gY292ZXJzIHRoZSBjYXNlIHRoYXRcbiAgICAgIC8vIGN1cnJlbnQgc2l6ZSBpcyBpbmZpbml0eS5cbiAgICAgIHNpemUgPSB0aGlzLnNpemUgLSBjb3VudDtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0aGlzLnNpemUgIT0gbnVsbCAmJlxuICAgICAgICAodGhpcy5zaXplIDwgY291bnQgfHwgY291bnQgPT09IHVuZGVmaW5lZCB8fCBjb3VudCA8IDApKSB7XG4gICAgICAvLyBJZiB0aGUgc2l6ZSBvZiB0aGlzIGRhdGFzZXQgaXMgc21hbGxlciB0aGFuIGNvdW50LCBvciBjb3VudCBpc1xuICAgICAgLy8gdW5kZWZpbmVkIG9yIG5lZ2F0aXZlLCBza2lwcyB0aGUgZW50aXJlIGRhdGFzZXQgYW5kIHRoZSBuZXcgc2l6ZSBpcyAwLlxuICAgICAgc2l6ZSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBzaXplIG9mIHRoaXMgZGF0YXNldCBpcyBudWxsLCB0aGUgbmV3IGRhdGFzZXQncyBzaXplIGlzIG51bGwuXG4gICAgICBzaXplID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihcbiAgICAgICAgYXN5bmMgKCkgPT4gKGF3YWl0IGJhc2UuaXRlcmF0b3IoKSkuc2tpcChjb3VudCksIHNpemUpO1xuICB9XG5cbiAgLy8gVE9ETyhzb2VyZ2VsKTogZGVlcCBzaGFyZGVkIHNodWZmbGUsIHdoZXJlIHN1cHBvcnRlZFxuXG4gIHN0YXRpYyByZWFkb25seSBNQVhfQlVGRkVSX1NJWkUgPSAxMDAwMDtcblxuICAvKipcbiAgICogUHNldWRvcmFuZG9tbHkgc2h1ZmZsZXMgdGhlIGVsZW1lbnRzIG9mIHRoaXMgZGF0YXNldC4gVGhpcyBpcyBkb25lIGluIGFcbiAgICogc3RyZWFtaW5nIG1hbm5lciwgYnkgc2FtcGxpbmcgZnJvbSBhIGdpdmVuIG51bWJlciBvZiBwcmVmZXRjaGVkIGVsZW1lbnRzLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBhID0gdGYuZGF0YS5hcnJheShbMSwgMiwgMywgNCwgNSwgNl0pLnNodWZmbGUoMyk7XG4gICAqIGF3YWl0IGEuZm9yRWFjaEFzeW5jKGUgPT4gY29uc29sZS5sb2coZSkpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlclNpemU6IEFuIGludGVnZXIgc3BlY2lmeWluZyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGZyb20gdGhpc1xuICAgKiAgIGRhdGFzZXQgZnJvbSB3aGljaCB0aGUgbmV3IGRhdGFzZXQgd2lsbCBzYW1wbGUuXG4gICAqIEBwYXJhbSBzZWVkOiAoT3B0aW9uYWwpIEFuIGludGVnZXIgc3BlY2lmeWluZyB0aGUgcmFuZG9tIHNlZWQgdGhhdCB3aWxsXG4gICAqICAgYmUgdXNlZCB0byBjcmVhdGUgdGhlIGRpc3RyaWJ1dGlvbi5cbiAgICogQHBhcmFtIHJlc2h1ZmZsZUVhY2hJdGVyYXRpb246IChPcHRpb25hbCkgQSBib29sZWFuLCB3aGljaCBpZiB0cnVlXG4gICAqICAgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGFzZXQgc2hvdWxkIGJlIHBzZXVkb3JhbmRvbWx5IHJlc2h1ZmZsZWQgZWFjaCB0aW1lXG4gICAqICAgaXQgaXMgaXRlcmF0ZWQgb3Zlci4gSWYgZmFsc2UsIGVsZW1lbnRzIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIHNhbWVcbiAgICogICBzaHVmZmxlZCBvcmRlciBvbiBlYWNoIGl0ZXJhdGlvbi4gKERlZmF1bHRzIHRvIGB0cnVlYC4pXG4gICAqIEByZXR1cm5zIEEgYERhdGFzZXRgLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnRGF0YScsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICovXG4gIHNodWZmbGUoYnVmZmVyU2l6ZTogbnVtYmVyLCBzZWVkPzogc3RyaW5nLCByZXNodWZmbGVFYWNoSXRlcmF0aW9uID0gdHJ1ZSk6XG4gICAgICBEYXRhc2V0PFQ+IHtcbiAgICBpZiAoYnVmZmVyU2l6ZSA9PSBudWxsIHx8IGJ1ZmZlclNpemUgPCAwKSB7XG4gICAgICBpZiAodGhpcy5zaXplID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAgICAgICAnYERhdGFzZXQuc2h1ZmZsZSgpYCByZXF1aXJlcyBidWZmZXJTaXplIHRvIGJlIHNwZWNpZmllZC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgJ2BEYXRhc2V0LnNodWZmbGUoKWAgcmVxdWlyZXMgYnVmZmVyU2l6ZSB0byBiZSBzcGVjaWZpZWQuICAnICtcbiAgICAgICAgICAgICdJZiB5b3VyIGRhdGEgZml0cyBpbiBtYWluIG1lbW9yeSAoZm9yIHJlZ3VsYXIgSlMgb2JqZWN0cyksICcgK1xuICAgICAgICAgICAgJ2FuZC9vciBHUFUgbWVtb3J5IChmb3IgYHRmLlRlbnNvcmBzKSwgY29uc2lkZXIgc2V0dGluZyAnICtcbiAgICAgICAgICAgIGBidWZmZXJTaXplIHRvIHRoZSBkYXRhc2V0IHNpemUgKCR7dGhpcy5zaXplfSBlbGVtZW50cylgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYmFzZSA9IHRoaXM7XG4gICAgY29uc3QgcmFuZG9tID0gc2VlZHJhbmRvbS5hbGVhKHNlZWQgfHwgdGYudXRpbC5ub3coKS50b1N0cmluZygpKTtcbiAgICByZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBzZWVkMiA9IHJhbmRvbS5pbnQzMigpO1xuICAgICAgaWYgKHJlc2h1ZmZsZUVhY2hJdGVyYXRpb24pIHtcbiAgICAgICAgc2VlZDIgKz0gcmFuZG9tLmludDMyKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGF3YWl0IGJhc2UuaXRlcmF0b3IoKSkuc2h1ZmZsZShidWZmZXJTaXplLCBzZWVkMi50b1N0cmluZygpKTtcbiAgICB9LCB0aGlzLnNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBgRGF0YXNldGAgd2l0aCBhdCBtb3N0IGBjb3VudGAgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHRoaXNcbiAgICogZGF0YXNldC5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgYSA9IHRmLmRhdGEuYXJyYXkoWzEsIDIsIDMsIDQsIDUsIDZdKS50YWtlKDMpO1xuICAgKiBhd2FpdCBhLmZvckVhY2hBc3luYyhlID0+IGNvbnNvbGUubG9nKGUpKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBjb3VudDogVGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiB0aGlzIGRhdGFzZXQgdGhhdCBzaG91bGQgYmUgdGFrZW5cbiAgICogICB0byBmb3JtIHRoZSBuZXcgZGF0YXNldC4gIElmIGBjb3VudGAgaXMgYHVuZGVmaW5lZGAgb3IgbmVnYXRpdmUsIG9yIGlmXG4gICAqICAgYGNvdW50YCBpcyBncmVhdGVyIHRoYW4gdGhlIHNpemUgb2YgdGhpcyBkYXRhc2V0LCB0aGUgbmV3IGRhdGFzZXQgd2lsbFxuICAgKiAgIGNvbnRhaW4gYWxsIGVsZW1lbnRzIG9mIHRoaXMgZGF0YXNldC5cbiAgICogQHJldHVybnMgQSBgRGF0YXNldGAuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdEYXRhJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgdGFrZShjb3VudDogbnVtYmVyKTogRGF0YXNldDxUPiB7XG4gICAgY29uc3QgYmFzZSA9IHRoaXM7XG4gICAgbGV0IHNpemU7XG4gICAgaWYgKHRoaXMuc2l6ZSAhPSBudWxsICYmIHRoaXMuc2l6ZSA+IGNvdW50KSB7XG4gICAgICAvLyBJZiB0aGUgc2l6ZSBvZiB0aGlzIGRhdGFzZXQgaXMgZ3JlYXRlciB0aGFuIGNvdW50LCB0aGUgbmV3IGRhdGFzZXQnc1xuICAgICAgLy8gc2l6ZSBpcyBjb3VudC5cbiAgICAgIHNpemUgPSBjb3VudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2l6ZSAhPSBudWxsICYmIHRoaXMuc2l6ZSA8PSBjb3VudCkge1xuICAgICAgLy8gSWYgdGhlIHNpemUgb2YgdGhpcyBkYXRhc2V0IGlzIGVxdWFsIG9yIHNtYWxsZXIgdGhhbiBjb3VudCwgdGhlIG5ld1xuICAgICAgLy8gZGF0YXNldCdzIHNpemUgaXMgdGhlIHNpemUgb2YgdGhpcyBkYXRhc2V0LlxuICAgICAgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIHNpemUgb2YgdGhpcyBkYXRhc2V0IGlzIG51bGwsIHRoZSBuZXcgZGF0YXNldCdzIHNpemUgaXMgbnVsbC5cbiAgICAgIHNpemUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuKFxuICAgICAgICBhc3luYyAoKSA9PiAoYXdhaXQgYmFzZS5pdGVyYXRvcigpKS50YWtlKGNvdW50KSwgc2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdCBhbGwgZWxlbWVudHMgb2YgdGhpcyBkYXRhc2V0IGludG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIE9idmlvdXNseSB0aGlzIHdpbGwgc3VjY2VlZCBvbmx5IGZvciBzbWFsbCBkYXRhc2V0cyB0aGF0IGZpdCBpbiBtZW1vcnkuXG4gICAqIFVzZWZ1bCBmb3IgdGVzdGluZyBhbmQgZ2VuZXJhbGx5IHNob3VsZCBiZSBhdm9pZGVkIGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBhID0gdGYuZGF0YS5hcnJheShbMSwgMiwgMywgNCwgNSwgNl0pO1xuICAgKiBjb25zb2xlLmxvZyhhd2FpdCBhLnRvQXJyYXkoKSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgZm9yIGFuIGFycmF5IG9mIGVsZW1lbnRzLCB3aGljaCB3aWxsIHJlc29sdmVcbiAgICogICB3aGVuIGEgbmV3IHN0cmVhbSBoYXMgYmVlbiBvYnRhaW5lZCBhbmQgZnVsbHkgY29uc3VtZWQuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdEYXRhJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgYXN5bmMgdG9BcnJheSgpIHtcbiAgICBpZiAodGhpcy5zaXplID09PSBJbmZpbml0eSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGNvbnZlcnQgaW5maW5pdGUgZGF0YSBzdHJlYW0gdG8gYXJyYXkuJyk7XG4gICAgfVxuICAgIHJldHVybiAoYXdhaXQgdGhpcy5pdGVyYXRvcigpKS50b0FycmF5KCk7XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdCBhbGwgZWxlbWVudHMgb2YgdGhpcyBkYXRhc2V0IGludG8gYW4gYXJyYXkgd2l0aCBwcmVmZXRjaGluZyAxMDBcbiAgICogZWxlbWVudHMuIFRoaXMgaXMgdXNlZnVsIGZvciB0ZXN0aW5nLCBiZWNhdXNlIHRoZSBwcmVmZXRjaCBjaGFuZ2VzIHRoZVxuICAgKiBvcmRlciBpbiB3aGljaCB0aGUgUHJvbWlzZXMgYXJlIHJlc29sdmVkIGFsb25nIHRoZSBwcm9jZXNzaW5nIHBpcGVsaW5lLlxuICAgKiBUaGlzIG1heSBoZWxwIGV4cG9zZSBidWdzIHdoZXJlIHJlc3VsdHMgYXJlIGRlcGVuZGVudCBvbiB0aGUgb3JkZXIgb2ZcbiAgICogUHJvbWlzZSByZXNvbHV0aW9uIHJhdGhlciB0aGFuIG9uIHRoZSBsb2dpY2FsIG9yZGVyIG9mIHRoZSBzdHJlYW0gKGkuZS4sXG4gICAqIGR1ZSB0byBoaWRkZW4gbXV0YWJsZSBzdGF0ZSkuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHdoaWNoIHdpbGwgcmVzb2x2ZVxuICAgKiAgIHdoZW4gYSBuZXcgc3RyZWFtIGhhcyBiZWVuIG9idGFpbmVkIGFuZCBmdWxseSBjb25zdW1lZC5cbiAgICovXG4gIGFzeW5jIHRvQXJyYXlGb3JUZXN0KCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IEluZmluaXR5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgY29udmVydCBpbmZpbml0ZSBkYXRhIHN0cmVhbSB0byBhcnJheS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIChhd2FpdCB0aGlzLml0ZXJhdG9yKCkpLnRvQXJyYXlGb3JUZXN0KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgRGF0YXNldGAgZGVmaW5lZCBieSBhIHByb3ZpZGVkIGl0ZXJhdG9yKCkgZnVuY3Rpb24uXG4gKlxuICogYGBganNcbiAqIGxldCBpID0gLTE7XG4gKiBjb25zdCBmdW5jID0gKCkgPT5cbiAqICAgICsraSA8IDUgPyB7dmFsdWU6IGksIGRvbmU6IGZhbHNlfSA6IHt2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZX07XG4gKiBjb25zdCBpdGVyID0gdGYuZGF0YS5pdGVyYXRvckZyb21GdW5jdGlvbihmdW5jKTtcbiAqIGNvbnN0IGRzID0gdGYuZGF0YS5kYXRhc2V0RnJvbUl0ZXJhdG9yRm4oaXRlcik7XG4gKiBhd2FpdCBkcy5mb3JFYWNoQXN5bmMoZSA9PiBjb25zb2xlLmxvZyhlKSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFzZXRGcm9tSXRlcmF0b3JGbjxUIGV4dGVuZHMgdGYuVGVuc29yQ29udGFpbmVyPihcbiAgICBpdGVyYXRvckZuOiAoKSA9PiBQcm9taXNlPExhenlJdGVyYXRvcjxUPj4sXG4gICAgc2l6ZTogbnVtYmVyID0gbnVsbCk6IERhdGFzZXQ8VD4ge1xuICByZXR1cm4gbmV3IGNsYXNzIGV4dGVuZHMgRGF0YXNldDxUPiB7XG4gICAgb3ZlcnJpZGUgc2l6ZSA9IHNpemU7XG5cbiAgICAvKlxuICAgICAqIFByb3ZpZGUgYSBuZXcgc3RyZWFtIG9mIGVsZW1lbnRzLiAgTm90ZSB0aGlzIHdpbGwgYWxzbyBzdGFydCBuZXcgc3RyZWFtc1xuICAgICAqIGZyb20gYW55IHVuZGVybHlpbmcgYERhdGFzZXRgcy5cbiAgICAgKi9cbiAgICBhc3luYyBpdGVyYXRvcigpOiBQcm9taXNlPExhenlJdGVyYXRvcjxUPj4ge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm4oKTtcbiAgICB9XG4gIH1cbiAgKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYERhdGFzZXRgIGZyb20gYW4gYXJyYXkgb2YgZWxlbWVudHMuXG4gKlxuICogQ3JlYXRlIGEgRGF0YXNldCBmcm9tIGFuIGFycmF5IG9mIG9iamVjdHM6XG4gKiBgYGBqc1xuICogY29uc3QgYSA9IHRmLmRhdGEuYXJyYXkoW3snaXRlbSc6IDF9LCB7J2l0ZW0nOiAyfSwgeydpdGVtJzogM31dKTtcbiAqIGF3YWl0IGEuZm9yRWFjaEFzeW5jKGUgPT4gY29uc29sZS5sb2coZSkpO1xuICogYGBgXG4gKlxuICogQ3JlYXRlIGEgRGF0YXNldCBmcm9tIGFuIGFycmF5IG9mIG51bWJlcnM6XG4gKiBgYGBqc1xuICogY29uc3QgYSA9IHRmLmRhdGEuYXJyYXkoWzQsIDUsIDZdKTtcbiAqIGF3YWl0IGEuZm9yRWFjaEFzeW5jKGUgPT4gY29uc29sZS5sb2coZSkpO1xuICogYGBgXG4gKiBAcGFyYW0gaXRlbXMgQW4gYXJyYXkgb2YgZWxlbWVudHMgdGhhdCB3aWxsIGJlIHBhcnNlZCBhcyBpdGVtcyBpbiBhIGRhdGFzZXQuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ0RhdGEnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nLCBuYW1lc3BhY2U6ICdkYXRhJ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5PFQgZXh0ZW5kcyB0Zi5UZW5zb3JDb250YWluZXI+KGl0ZW1zOiBUW10pOiBEYXRhc2V0PFQ+IHtcbiAgcmV0dXJuIGRhdGFzZXRGcm9tSXRlcmF0b3JGbihcbiAgICAgIGFzeW5jICgpID0+IGl0ZXJhdG9yRnJvbUl0ZW1zKGl0ZW1zKSwgaXRlbXMubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgRGF0YXNldGAgYnkgemlwcGluZyB0b2dldGhlciBhbiBhcnJheSwgZGljdCwgb3IgbmVzdGVkXG4gKiBzdHJ1Y3R1cmUgb2YgYERhdGFzZXRgcyAoYW5kIHBlcmhhcHMgYWRkaXRpb25hbCBjb25zdGFudHMpLlxuICogVGhlIHVuZGVybHlpbmcgZGF0YXNldHMgbXVzdCBwcm92aWRlIGVsZW1lbnRzIGluIGEgY29uc2lzdGVudCBvcmRlciBzdWNoIHRoYXRcbiAqIHRoZXkgY29ycmVzcG9uZC5cbiAqXG4gKiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSByZXN1bHRpbmcgZGF0YXNldCBpcyB0aGUgc2FtZSBhcyB0aGUgc2l6ZSBvZlxuICogdGhlIHNtYWxsZXN0IGRhdGFzZXQgaW4gZGF0YXNldHMuXG4gKlxuICogVGhlIG5lc3RlZCBzdHJ1Y3R1cmUgb2YgdGhlIGBkYXRhc2V0c2AgYXJndW1lbnQgZGV0ZXJtaW5lcyB0aGVcbiAqIHN0cnVjdHVyZSBvZiBlbGVtZW50cyBpbiB0aGUgcmVzdWx0aW5nIGl0ZXJhdG9yLlxuICpcbiAqIE5vdGUgdGhpcyBtZWFucyB0aGF0LCBnaXZlbiBhbiBhcnJheSBvZiB0d28gZGF0YXNldHMgdGhhdCBwcm9kdWNlIGRpY3RcbiAqIGVsZW1lbnRzLCB0aGUgcmVzdWx0IGlzIGEgZGF0YXNldCB0aGF0IHByb2R1Y2VzIGVsZW1lbnRzIHRoYXQgYXJlIGFycmF5c1xuICogb2YgdHdvIGRpY3RzOlxuICpcbiAqIFppcCBhbiBhcnJheSBvZiBkYXRhc2V0czpcbiAqIGBgYGpzXG4gKiBjb25zb2xlLmxvZygnWmlwIHR3byBkYXRhc2V0cyBvZiBvYmplY3RzOicpO1xuICogY29uc3QgZHMxID0gdGYuZGF0YS5hcnJheShbe2E6IDF9LCB7YTogMn0sIHthOiAzfV0pO1xuICogY29uc3QgZHMyID0gdGYuZGF0YS5hcnJheShbe2I6IDR9LCB7YjogNX0sIHtiOiA2fV0pO1xuICogY29uc3QgZHMzID0gdGYuZGF0YS56aXAoW2RzMSwgZHMyXSk7XG4gKiBhd2FpdCBkczMuZm9yRWFjaEFzeW5jKGUgPT4gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoZSkpKTtcbiAqXG4gKiAvLyBJZiB0aGUgZ29hbCBpcyB0byBtZXJnZSB0aGUgZGljdHMgaW4gb3JkZXIgdG8gcHJvZHVjZSBlbGVtZW50cyBsaWtlXG4gKiAvLyB7YTogLi4uLCBiOiAuLi59LCB0aGlzIHJlcXVpcmVzIGEgc2Vjb25kIHN0ZXAgc3VjaCBhczpcbiAqIGNvbnNvbGUubG9nKCdNZXJnZSB0aGUgb2JqZWN0czonKTtcbiAqIGNvbnN0IGRzNCA9IGRzMy5tYXAoeCA9PiB7cmV0dXJuIHthOiB4WzBdLmEsIGI6IHhbMV0uYn19KTtcbiAqIGF3YWl0IGRzNC5mb3JFYWNoQXN5bmMoZSA9PiBjb25zb2xlLmxvZyhlKSk7XG4gKiBgYGBcbiAqXG4gKiBaaXAgYSBkaWN0IG9mIGRhdGFzZXRzOlxuICogYGBganNcbiAqIGNvbnN0IGEgPSB0Zi5kYXRhLmFycmF5KFt7YTogMX0sIHthOiAyfSwge2E6IDN9XSk7XG4gKiBjb25zdCBiID0gdGYuZGF0YS5hcnJheShbe2I6IDR9LCB7YjogNX0sIHtiOiA2fV0pO1xuICogY29uc3QgYyA9IHRmLmRhdGEuemlwKHtjOiBhLCBkOiBifSk7XG4gKiBhd2FpdCBjLmZvckVhY2hBc3luYyhlID0+IGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGUpKSk7XG4gKiBgYGBcbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnRGF0YScsIHN1YmhlYWRpbmc6ICdPcGVyYXRpb25zJywgbmFtZXNwYWNlOiAnZGF0YSd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6aXA8TyBleHRlbmRzIHRmLlRlbnNvckNvbnRhaW5lcj4oZGF0YXNldHM6IERhdGFzZXRDb250YWluZXIpOlxuICAgIERhdGFzZXQ8Tz4ge1xuICAvLyBtYW51YWxseSB0eXBlLWNoZWNrIHRoZSBhcmd1bWVudCBmb3IgSlMgdXNlcnNcbiAgaWYgKCFpc0l0ZXJhYmxlKGRhdGFzZXRzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGFyZ3VtZW50IHRvIHppcCgpIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFycmF5LicpO1xuICB9XG4gIGxldCBzaXplO1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhc2V0cykpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzaXplID0gc2l6ZSA9PSBudWxsID8gKGRhdGFzZXRzW2ldIGFzIERhdGFzZXQ8Tz4pLnNpemUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKHNpemUsIChkYXRhc2V0c1tpXSBhcyBEYXRhc2V0PE8+KS5zaXplKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0YXNldHMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICBmb3IgKGNvbnN0IGRzIGluIGRhdGFzZXRzKSB7XG4gICAgICBzaXplID0gc2l6ZSA9PSBudWxsID8gKGRhdGFzZXRzW2RzXSBhcyBEYXRhc2V0PE8+KS5zaXplIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihzaXplLCAoZGF0YXNldHNbZHNdIGFzIERhdGFzZXQ8Tz4pLnNpemUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YXNldEZyb21JdGVyYXRvckZuPE8+KGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBzdHJlYW1zID0gYXdhaXQgZGVlcE1hcEFuZEF3YWl0QWxsKGRhdGFzZXRzLCBkID0+IHtcbiAgICAgIGlmIChkIGluc3RhbmNlb2YgRGF0YXNldCkge1xuICAgICAgICByZXR1cm4ge3ZhbHVlOiBkLml0ZXJhdG9yKCksIHJlY3Vyc2U6IGZhbHNlfTtcbiAgICAgIH0gZWxzZSBpZiAoaXNJdGVyYWJsZShkKSkge1xuICAgICAgICByZXR1cm4ge3ZhbHVlOiBudWxsLCByZWN1cnNlOiB0cnVlfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdMZWF2ZXMgb2YgdGhlIHN0cnVjdHVyZSBwYXNzZWQgdG8gemlwKCkgbXVzdCBiZSBEYXRhc2V0cywgJyArXG4gICAgICAgICAgICAnbm90IHByaW1pdGl2ZXMuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRnJvbVppcHBlZDxPPihzdHJlYW1zLCBaaXBNaXNtYXRjaE1vZGUuU0hPUlRFU1QpO1xuICB9LCBzaXplKTtcbn1cblxuLyoqXG4gKiBBIHppcCBmdW5jdGlvbiBmb3IgdXNlIHdpdGggZGVlcFppcCwgcGFzc2VkIHZpYSB0aGUgY29sdW1uTWFqb3JCYXRjaCBjYWxsLlxuICpcbiAqIEFjY2VwdHMgYW4gYXJyYXkgb2YgaWRlbnRpY2FsbHktc3RydWN0dXJlZCBuZXN0ZWQgZWxlbWVudHMgYW5kIGVpdGhlciBiYXRjaGVzXG4gKiB0aGVtIChpZiB0aGV5IGFyZSBwcmltaXRpdmVzLCBudW1lcmljIGFycmF5cywgb3IgVGVuc29ycykgb3IgcmVxdWVzdHNcbiAqIHJlY3Vyc2lvbiAoaWYgbm90KS5cbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuZnVuY3Rpb24gZGVlcEJhdGNoQ29uY2F0KHJvd3M6IGFueVtdKTogRGVlcE1hcFJlc3VsdCB7XG4gIGlmIChyb3dzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyB1c2UgdGhlIGZpcnN0IGl0ZW0gdG8gZGVjaWRlIHdoZXRoZXIgdG8gcmVjdXJzZSBvciBiYXRjaCBoZXJlLlxuICBjb25zdCBleGFtcGxlUm93ID0gcm93c1swXTtcblxuICBpZiAoY2FuVGVuc29yaWZ5KGV4YW1wbGVSb3cpKSB7XG4gICAgLy8gcm93cyBpcyBhbiBhcnJheSBvZiBwcmltaXRpdmVzLCBUZW5zb3JzLCBvciBhcnJheXMuICBCYXRjaCB0aGVtLlxuICAgIGNvbnN0IHZhbHVlID0gYmF0Y2hDb25jYXQocm93cyk7XG4gICAgcmV0dXJuIHt2YWx1ZSwgcmVjdXJzZTogZmFsc2V9O1xuICB9XG5cbiAgLy8gdGhlIGV4YW1wbGUgcm93IGlzIGFuIG9iamVjdCwgc28gcmVjdXJzZSBpbnRvIGl0LlxuICByZXR1cm4ge3ZhbHVlOiBudWxsLCByZWN1cnNlOiB0cnVlfTtcbn1cblxuLyoqXG4gKiBBc3NlbWJsZXMgYSBsaXN0IG9mIHNhbWUtc2hhcGVkIG51bWJlcnMsIG51bWJlciBhcnJheXMsIG9yIFRlbnNvcnNcbiAqIGludG8gYSBzaW5nbGUgbmV3IFRlbnNvciB3aGVyZSBheGlzIDAgaXMgdGhlIGJhdGNoIGRpbWVuc2lvbi5cbiAqL1xuZnVuY3Rpb24gYmF0Y2hDb25jYXQ8VCBleHRlbmRzKFRlbnNvckxpa2UgfCB0Zi5UZW5zb3IpPihhcnJheXM6IFRbXSk6XG4gICAgdGYuVGVuc29yIHtcbiAgaWYgKGFycmF5cy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBXZSBjYW4ndCByZXR1cm4gYW4gZW1wdHkgVGVuc29yIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyB0aGUgZWxlbWVudCBzaGFwZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgbWFrZSBhIGJhdGNoIG9mIHplcm8gZWxlbWVudHMuJyk7XG4gIH1cblxuICBpZiAoYXJyYXlzWzBdIGluc3RhbmNlb2YgdGYuVGVuc29yKSB7XG4gICAgLy8gSW5wdXQgaXMgYW4gYXJyYXkgb2YgVGVuc29yc1xuICAgIHJldHVybiB0Zi5zdGFjayhhcnJheXMgYXMgdGYuVGVuc29yW10pO1xuICB9IGVsc2Uge1xuICAgIC8vIElucHV0IGlzIGEgcG9zc2libHktbmVzdGVkIGFycmF5IG9mIG51bWJlcnMuXG4gICAgcmV0dXJuIHRmLnRlbnNvcihhcnJheXMgYXMgVGVuc29yTGlrZSk7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { Dataset } from '../dataset';\n/**\n * Represents a potentially large collection of text lines.\n *\n * The results are not batched.\n */\nexport class TextLineDataset extends Dataset {\n    /**\n     * Create a `TextLineDataset`.\n     *\n     * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.\n     */\n    constructor(input) {\n        super();\n        this.input = input;\n    }\n    async iterator() {\n        const inputIterator = await this.input.iterator();\n        const utf8Iterator = inputIterator.decodeUTF8();\n        const lineIterator = utf8Iterator.split('\\n').map(line => {\n            // Windows/DOS format text file has extra line breaker at the end of line.\n            if (line.endsWith('\\r')) {\n                line = line.slice(0, -1);\n            }\n            return line;\n        });\n        return lineIterator;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dF9saW5lX2RhdGFzZXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWRhdGEvc3JjL2RhdGFzZXRzL3RleHRfbGluZV9kYXRhc2V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBRUgsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFlBQVksQ0FBQztBQUluQzs7OztHQUlHO0FBQ0gsTUFBTSxPQUFPLGVBQWdCLFNBQVEsT0FBZTtJQUNsRDs7OztPQUlHO0lBQ0gsWUFBK0IsS0FBaUI7UUFDOUMsS0FBSyxFQUFFLENBQUM7UUFEcUIsVUFBSyxHQUFMLEtBQUssQ0FBWTtJQUVoRCxDQUFDO0lBRUQsS0FBSyxDQUFDLFFBQVE7UUFDWixNQUFNLGFBQWEsR0FBRyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDbEQsTUFBTSxZQUFZLEdBQUcsYUFBYSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ2hELE1BQU0sWUFBWSxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3ZELDBFQUEwRTtZQUMxRSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ3ZCLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzFCO1lBQ0QsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sWUFBWSxDQUFDO0lBQ3RCLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RGF0YXNldH0gZnJvbSAnLi4vZGF0YXNldCc7XG5pbXBvcnQge0RhdGFTb3VyY2V9IGZyb20gJy4uL2RhdGFzb3VyY2UnO1xuaW1wb3J0IHtMYXp5SXRlcmF0b3J9IGZyb20gJy4uL2l0ZXJhdG9ycy9sYXp5X2l0ZXJhdG9yJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcG90ZW50aWFsbHkgbGFyZ2UgY29sbGVjdGlvbiBvZiB0ZXh0IGxpbmVzLlxuICpcbiAqIFRoZSByZXN1bHRzIGFyZSBub3QgYmF0Y2hlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRleHRMaW5lRGF0YXNldCBleHRlbmRzIERhdGFzZXQ8c3RyaW5nPiB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgVGV4dExpbmVEYXRhc2V0YC5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IEEgYERhdGFTb3VyY2VgIHByb3ZpZGluZyBhIGNodW5rZWQsIFVURjgtZW5jb2RlZCBieXRlIHN0cmVhbS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSBpbnB1dDogRGF0YVNvdXJjZSkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBhc3luYyBpdGVyYXRvcigpOiBQcm9taXNlPExhenlJdGVyYXRvcjxzdHJpbmc+PiB7XG4gICAgY29uc3QgaW5wdXRJdGVyYXRvciA9IGF3YWl0IHRoaXMuaW5wdXQuaXRlcmF0b3IoKTtcbiAgICBjb25zdCB1dGY4SXRlcmF0b3IgPSBpbnB1dEl0ZXJhdG9yLmRlY29kZVVURjgoKTtcbiAgICBjb25zdCBsaW5lSXRlcmF0b3IgPSB1dGY4SXRlcmF0b3Iuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IHtcbiAgICAgIC8vIFdpbmRvd3MvRE9TIGZvcm1hdCB0ZXh0IGZpbGUgaGFzIGV4dHJhIGxpbmUgYnJlYWtlciBhdCB0aGUgZW5kIG9mIGxpbmUuXG4gICAgICBpZiAobGluZS5lbmRzV2l0aCgnXFxyJykpIHtcbiAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpbmVJdGVyYXRvcjtcbiAgfVxufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n/**\n * Represents a data source readable as a stream of binary data chunks.\n *\n * Because `Dataset`s can be read repeatedly (via `Dataset.iterator()`), this\n * provides a means to repeatedly create streams from the underlying data\n * sources.\n */\nexport class DataSource {\n}\n// TODO(soergel): consider convenience factory functions here\n// in combination with chainable source->dataset above, e.g.:\n// tf.data.url(...).asCsvDataset().shuffle().batch()\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YXNvdXJjZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtZGF0YS9zcmMvZGF0YXNvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7OztHQWdCRztBQUlIOzs7Ozs7R0FNRztBQUNILE1BQU0sT0FBZ0IsVUFBVTtDQVUvQjtBQUVELDZEQUE2RDtBQUM3RCw2REFBNkQ7QUFDN0Qsb0RBQW9EIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtCeXRlQ2h1bmtJdGVyYXRvcn0gZnJvbSAnLi9pdGVyYXRvcnMvYnl0ZV9jaHVua19pdGVyYXRvcic7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGRhdGEgc291cmNlIHJlYWRhYmxlIGFzIGEgc3RyZWFtIG9mIGJpbmFyeSBkYXRhIGNodW5rcy5cbiAqXG4gKiBCZWNhdXNlIGBEYXRhc2V0YHMgY2FuIGJlIHJlYWQgcmVwZWF0ZWRseSAodmlhIGBEYXRhc2V0Lml0ZXJhdG9yKClgKSwgdGhpc1xuICogcHJvdmlkZXMgYSBtZWFucyB0byByZXBlYXRlZGx5IGNyZWF0ZSBzdHJlYW1zIGZyb20gdGhlIHVuZGVybHlpbmcgZGF0YVxuICogc291cmNlcy5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERhdGFTb3VyY2Uge1xuICAvKipcbiAgICogT2J0YWluIGEgbmV3IHN0cmVhbSBvZiBiaW5hcnkgZGF0YSBjaHVua3MuXG4gICAqXG4gICAqIFN0YXJ0cyB0aGUgbmV3IHN0cmVhbSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRhdGEgc291cmNlLCBldmVuIGlmIG90aGVyXG4gICAqIHN0cmVhbXMgaGF2ZSBiZWVuIG9idGFpbmVkIHByZXZpb3VzbHkuXG4gICAqL1xuICBhYnN0cmFjdCBpdGVyYXRvcigpOiBQcm9taXNlPEJ5dGVDaHVua0l0ZXJhdG9yPjtcblxuICAvLyBUT0RPKHNvZXJnZWwpOiBjb25zaWRlciBjaGFpbmFibGUgRGF0YXNldCBjb25zdHJ1Y3Rpb24gaGVyZVxufVxuXG4vLyBUT0RPKHNvZXJnZWwpOiBjb25zaWRlciBjb252ZW5pZW5jZSBmYWN0b3J5IGZ1bmN0aW9ucyBoZXJlXG4vLyBpbiBjb21iaW5hdGlvbiB3aXRoIGNoYWluYWJsZSBzb3VyY2UtPmRhdGFzZXQgYWJvdmUsIGUuZy46XG4vLyB0Zi5kYXRhLnVybCguLi4pLmFzQ3N2RGF0YXNldCgpLnNodWZmbGUoKS5iYXRjaCgpXG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nimport { Dataset } from '../dataset';\nimport { TextLineDataset } from './text_line_dataset';\nconst CODE_QUOTE = '\"';\nconst STATE_OUT = Symbol('out');\nconst STATE_FIELD = Symbol('field');\nconst STATE_QUOTE = Symbol('quote');\nconst STATE_QUOTE_AFTER_QUOTE = Symbol('quoteafterquote');\nconst STATE_WITHIN_QUOTE_IN_QUOTE = Symbol('quoteinquote');\n/**\n * Represents a potentially large collection of delimited text records.\n *\n * The produced `TensorContainer`s each contain one key-value pair for\n * every column of the table.  When a field is empty in the incoming data, the\n * resulting value is `undefined`, or throw error if it is required.  Values\n * that can be parsed as numbers are emitted as type `number`, other values\n * are parsed as `string`.\n *\n * The results are not batched.\n *\n * @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'}\n */\nexport class CSVDataset extends Dataset {\n    /**\n     * Returns column names of the csv dataset. If `configuredColumnsOnly` is\n     * true, return column names in `columnConfigs`. If `configuredColumnsOnly` is\n     * false and `columnNames` is provided, `columnNames`. If\n     * `configuredColumnsOnly` is false and `columnNames` is not provided, return\n     * all column names parsed from the csv file. For example usage please go to\n     * `tf.data.csv`.\n     *\n     * @doc {heading: 'Data', subheading: 'Classes'}\n     */\n    async columnNames() {\n        if (!this.columnNamesValidated) {\n            await this.setColumnNames();\n        }\n        return this.configuredColumnsOnly ? Object.keys(this.columnConfigs) :\n            this.fullColumnNames;\n    }\n    /* 1) If `columnNames` is provided as string[], use this string[] as output\n     * keys in corresponding order. The length must match the number of inferred\n     * columns if `hasHeader` is true .\n     * 2) If `columnNames` is not provided, parse header line as `columnNames` if\n     * hasHeader is true. If `hasHeader` is false, throw an error.\n     * 3) If `columnConfigs` is provided, all the keys in `columnConfigs` must\n     * exist in parsed `columnNames`.\n     */\n    async setColumnNames() {\n        const columnNamesFromFile = await this.maybeReadHeaderLine();\n        if (!this.fullColumnNames && !columnNamesFromFile) {\n            // Throw an error if columnNames is not provided and no header line.\n            throw new Error('Column names must be provided if there is no header line.');\n        }\n        else if (this.fullColumnNames && columnNamesFromFile) {\n            // Check provided columnNames match header line.\n            util.assert(columnNamesFromFile.length === this.fullColumnNames.length, () => 'The length of provided columnNames (' +\n                this.fullColumnNames.length.toString() +\n                ') does not match the length of the header line read from ' +\n                'file (' + columnNamesFromFile.length.toString() + ').');\n        }\n        if (!this.fullColumnNames) {\n            this.fullColumnNames = columnNamesFromFile;\n        }\n        // Check if there are duplicate column names.\n        const counts = this.fullColumnNames.reduce((countAcc, name) => {\n            countAcc[name] = (countAcc[name] + 1) || 1;\n            return countAcc;\n        }, {});\n        const duplicateNames = Object.keys(counts).filter((name) => (counts[name] > 1));\n        util.assert(duplicateNames.length === 0, () => 'Duplicate column names found: ' + duplicateNames.toString());\n        // Check if keys in columnConfigs match columnNames.\n        if (this.columnConfigs) {\n            for (const key of Object.keys(this.columnConfigs)) {\n                const index = this.fullColumnNames.indexOf(key);\n                if (index === -1) {\n                    throw new Error('The key \"' + key +\n                        '\" provided in columnConfigs does not match any of the column ' +\n                        'names (' + this.fullColumnNames.toString() + ').');\n                }\n            }\n        }\n        this.columnNamesValidated = true;\n    }\n    async maybeReadHeaderLine() {\n        if (this.hasHeader) {\n            const iter = await this.base.iterator();\n            const firstElement = await iter.next();\n            if (firstElement.done) {\n                throw new Error('No data was found for CSV parsing.');\n            }\n            const firstLine = firstElement.value;\n            const headers = this.parseRow(firstLine, false);\n            return headers;\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Create a `CSVDataset`.\n     *\n     * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.\n     * @param csvConfig (Optional) A CSVConfig object that contains configurations\n     *     of reading and decoding from CSV file(s).\n     *\n     *     hasHeader: (Optional) A boolean value that indicates whether the first\n     *     row of provided CSV file is a header line with column names, and should\n     *     not be included in the data. Defaults to `true`.\n     *\n     *     columnNames: (Optional) A list of strings that corresponds to\n     *     the CSV column names, in order. If provided, it ignores the column\n     *     names inferred from the header row. If not provided, infers the column\n     *     names from the first row of the records. If hasHeader is false and\n     *     columnNames is not provided, this method throws an error.\n     *\n     *     columnConfigs: (Optional) A dictionary whose key is column names, value\n     *     is an object stating if this column is required, column's data type,\n     *     default value, and if this column is label. If provided, keys must\n     *     correspond to names provided in columnNames or inferred from the file\n     *     header lines. If isLabel is true any column, returns an array of two\n     *     items: the first item is a dict of features key/value pairs, the second\n     *     item is a dict of labels key/value pairs. If no feature is marked as\n     *     label, returns a dict of features only.\n     *\n     *     configuredColumnsOnly (Optional) If true, only columns provided in\n     *     columnConfigs will be parsed and provided during iteration.\n     *\n     *     delimiter (Optional) The string used to parse each line of the input\n     *     file. Defaults to `,`.\n     */\n    constructor(input, csvConfig) {\n        super();\n        this.input = input;\n        this.hasHeader = true;\n        this.fullColumnNames = null;\n        this.columnNamesValidated = false;\n        this.columnConfigs = null;\n        this.configuredColumnsOnly = false;\n        this.delimiter = ',';\n        this.delimWhitespace = false;\n        this.base = new TextLineDataset(input);\n        if (!csvConfig) {\n            csvConfig = {};\n        }\n        this.hasHeader = csvConfig.hasHeader === false ? false : true;\n        this.fullColumnNames = csvConfig.columnNames;\n        this.columnConfigs = csvConfig.columnConfigs;\n        this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;\n        if (csvConfig.delimWhitespace) {\n            util.assert(csvConfig.delimiter == null, () => 'Delimiter should not be provided when delimWhitespace is true.');\n            this.delimWhitespace = true;\n            this.delimiter = ' ';\n        }\n        else {\n            this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ',';\n        }\n    }\n    async iterator() {\n        if (!this.columnNamesValidated) {\n            await this.setColumnNames();\n        }\n        let lines = await this.base.iterator();\n        if (this.hasHeader) {\n            // We previously read the first line to get the columnNames.\n            // Now that we're providing data, skip it.\n            lines = lines.skip(1);\n        }\n        return lines.map(x => this.makeDataElement(x));\n    }\n    makeDataElement(line) {\n        const values = this.parseRow(line);\n        const features = {};\n        const labels = {};\n        for (let i = 0; i < this.fullColumnNames.length; i++) {\n            const key = this.fullColumnNames[i];\n            const config = this.columnConfigs ? this.columnConfigs[key] : null;\n            if (this.configuredColumnsOnly && !config) {\n                // This column is not selected.\n                continue;\n            }\n            else {\n                const value = values[i];\n                let parsedValue = null;\n                if (value === '') {\n                    // If default value is provided, use it. If default value is not\n                    // provided, set as undefined.\n                    if (config && config.default !== undefined) {\n                        parsedValue = config.default;\n                    }\n                    else if (config && (config.required || config.isLabel)) {\n                        throw new Error(`Required column ${key} is empty in this line: ${line}`);\n                    }\n                    else {\n                        parsedValue = undefined;\n                    }\n                }\n                else {\n                    // A value is present, so parse it based on type\n                    const valueAsNum = Number(value);\n                    if (isNaN(valueAsNum)) {\n                        // The value is a string and this column is declared as boolean\n                        // in config, parse it as boolean.\n                        if (config && config.dtype === 'bool') {\n                            parsedValue = this.getBoolean(value);\n                        }\n                        else {\n                            // Set value as string\n                            parsedValue = value;\n                        }\n                    }\n                    else if (!config || !config.dtype) {\n                        // If this value is a number and no type config is provided, return\n                        // it as number.\n                        parsedValue = valueAsNum;\n                    }\n                    else {\n                        // If this value is a number and data type is provided, parse it\n                        // according to provided data type.\n                        switch (config.dtype) {\n                            case 'float32':\n                                parsedValue = valueAsNum;\n                                break;\n                            case 'int32':\n                                parsedValue = Math.floor(valueAsNum);\n                                break;\n                            case 'bool':\n                                parsedValue = this.getBoolean(value);\n                                break;\n                            default:\n                                parsedValue = valueAsNum;\n                        }\n                    }\n                }\n                // Check if this column is label.\n                (config && config.isLabel) ? labels[key] = parsedValue :\n                    features[key] = parsedValue;\n            }\n        }\n        // If label exists, return an object of features and labels as {xs:features,\n        // ys:labels}, otherwise return features only.\n        if (Object.keys(labels).length === 0) {\n            return features;\n        }\n        else {\n            return { xs: features, ys: labels };\n        }\n    }\n    getBoolean(value) {\n        if (value === '1' || value.toLowerCase() === 'true') {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    // adapted from https://beta.observablehq.com/@mbostock/streaming-csv\n    parseRow(line, validateElementCount = true) {\n        const result = [];\n        let readOffset = 0;\n        const readLength = line.length;\n        let currentState = STATE_OUT;\n        // Goes through the line to parse quote.\n        for (let i = 0; i < readLength; i++) {\n            switch (currentState) {\n                // Before enter a new field\n                case STATE_OUT:\n                    switch (line.charAt(i)) {\n                        // Enter a quoted field\n                        case CODE_QUOTE:\n                            readOffset = i + 1;\n                            currentState = STATE_QUOTE;\n                            break;\n                        // Read an empty field\n                        case this.delimiter:\n                            readOffset = i + 1;\n                            // If delimiter is white space and configured to collapse\n                            // multiple white spaces, ignore this white space.\n                            if (this.delimiter === ' ' && this.delimWhitespace) {\n                                break;\n                            }\n                            result.push('');\n                            currentState = STATE_OUT;\n                            break;\n                        // Enter an unquoted field\n                        default:\n                            currentState = STATE_FIELD;\n                            readOffset = i;\n                            break;\n                    }\n                    break;\n                // In an unquoted field\n                case STATE_FIELD:\n                    switch (line.charAt(i)) {\n                        // Exit an unquoted field, add it to result\n                        case this.delimiter:\n                            result.push(line.substring(readOffset, i));\n                            currentState = STATE_OUT;\n                            readOffset = i + 1;\n                            break;\n                        default:\n                    }\n                    break;\n                // In a quoted field\n                case STATE_QUOTE:\n                    switch (line.charAt(i)) {\n                        // Read a quote after a quote\n                        case CODE_QUOTE:\n                            currentState = STATE_QUOTE_AFTER_QUOTE;\n                            break;\n                        default:\n                    }\n                    break;\n                // This state means it's right after a second quote in a field\n                case STATE_QUOTE_AFTER_QUOTE:\n                    switch (line.charAt(i)) {\n                        // Finished a quoted field\n                        case this.delimiter:\n                            result.push(line.substring(readOffset, i - 1));\n                            currentState = STATE_OUT;\n                            readOffset = i + 1;\n                            break;\n                        // Finished a quoted part in a quoted field\n                        case CODE_QUOTE:\n                            currentState = STATE_QUOTE;\n                            break;\n                        // In a quoted part in a quoted field\n                        default:\n                            currentState = STATE_WITHIN_QUOTE_IN_QUOTE;\n                            break;\n                    }\n                    break;\n                case STATE_WITHIN_QUOTE_IN_QUOTE:\n                    switch (line.charAt(i)) {\n                        // Exit a quoted part in a quoted field\n                        case CODE_QUOTE:\n                            currentState = STATE_QUOTE;\n                            break;\n                        default:\n                    }\n                    break;\n                default:\n            }\n        }\n        // Adds last item based on if it is quoted.\n        if (currentState === STATE_QUOTE_AFTER_QUOTE) {\n            result.push(line.substring(readOffset, readLength - 1));\n        }\n        else {\n            result.push(line.substring(readOffset));\n        }\n        // Check if each row has the same number of elements as column names.\n        if (validateElementCount && result.length !== this.fullColumnNames.length) {\n            throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${result}`);\n        }\n        return result;\n    }\n}\n// TODO(soergel): add more basic datasets for parity with tf.data\n// tf.data.FixedLengthRecordDataset()\n// tf.data.TFRecordDataset()\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3N2X2RhdGFzZXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWRhdGEvc3JjL2RhdGFzZXRzL2Nzdl9kYXRhc2V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBRUgsT0FBTyxFQUFrQixJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUM1RCxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBSW5DLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUVwRCxNQUFNLFVBQVUsR0FBRyxHQUFHLENBQUM7QUFDdkIsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2hDLE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNwQyxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDcEMsTUFBTSx1QkFBdUIsR0FBRyxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUMxRCxNQUFNLDJCQUEyQixHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUUzRDs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSCxNQUFNLE9BQU8sVUFBVyxTQUFRLE9BQXdCO0lBVXREOzs7Ozs7Ozs7T0FTRztJQUNILEtBQUssQ0FBQyxXQUFXO1FBQ2YsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtZQUM5QixNQUFNLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztTQUM3QjtRQUNELE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxlQUFlLENBQUM7SUFDM0QsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSyxLQUFLLENBQUMsY0FB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VTs0QkFDYixZQUFZLEdBQUcsV0FBVyxDQUFDOzRCQUMzQixNQUFNO3dCQUNSLFFBQVE7cUJBQ1Q7b0JBQ0QsTUFBTTtnQkFDUixRQUFRO2FBQ1Q7U0FDRjtRQUNELDJDQUEyQztRQUMzQyxJQUFJLFlBQVksS0FBSyx1QkFBdUIsRUFBRTtZQUM1QyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3pEO2FBQU07WUFDTCxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztTQUN6QztRQUNELHFFQUFxRTtRQUNyRSxJQUFJLG9CQUFvQixJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUU7WUFDekUsTUFBTSxJQUFJLEtBQUssQ0FBQyx3Q0FDWixJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sK0JBQStCLE1BQU0sRUFBRSxDQUFDLENBQUM7U0FDekU7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0NBQ0Y7QUFFRCxpRUFBaUU7QUFDakUscUNBQXFDO0FBQ3JDLDRCQUE0QiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7VGVuc29yQ29udGFpbmVyLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtEYXRhc2V0fSBmcm9tICcuLi9kYXRhc2V0JztcbmltcG9ydCB7RGF0YVNvdXJjZX0gZnJvbSAnLi4vZGF0YXNvdXJjZSc7XG5pbXBvcnQge0xhenlJdGVyYXRvcn0gZnJvbSAnLi4vaXRlcmF0b3JzL2xhenlfaXRlcmF0b3InO1xuaW1wb3J0IHtDb2x1bW5Db25maWcsIENTVkNvbmZpZ30gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtUZXh0TGluZURhdGFzZXR9IGZyb20gJy4vdGV4dF9saW5lX2RhdGFzZXQnO1xuXG5jb25zdCBDT0RFX1FVT1RFID0gJ1wiJztcbmNvbnN0IFNUQVRFX09VVCA9IFN5bWJvbCgnb3V0Jyk7XG5jb25zdCBTVEFURV9GSUVMRCA9IFN5bWJvbCgnZmllbGQnKTtcbmNvbnN0IFNUQVRFX1FVT1RFID0gU3ltYm9sKCdxdW90ZScpO1xuY29uc3QgU1RBVEVfUVVPVEVfQUZURVJfUVVPVEUgPSBTeW1ib2woJ3F1b3RlYWZ0ZXJxdW90ZScpO1xuY29uc3QgU1RBVEVfV0lUSElOX1FVT1RFX0lOX1FVT1RFID0gU3ltYm9sKCdxdW90ZWlucXVvdGUnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcG90ZW50aWFsbHkgbGFyZ2UgY29sbGVjdGlvbiBvZiBkZWxpbWl0ZWQgdGV4dCByZWNvcmRzLlxuICpcbiAqIFRoZSBwcm9kdWNlZCBgVGVuc29yQ29udGFpbmVyYHMgZWFjaCBjb250YWluIG9uZSBrZXktdmFsdWUgcGFpciBmb3JcbiAqIGV2ZXJ5IGNvbHVtbiBvZiB0aGUgdGFibGUuICBXaGVuIGEgZmllbGQgaXMgZW1wdHkgaW4gdGhlIGluY29taW5nIGRhdGEsIHRoZVxuICogcmVzdWx0aW5nIHZhbHVlIGlzIGB1bmRlZmluZWRgLCBvciB0aHJvdyBlcnJvciBpZiBpdCBpcyByZXF1aXJlZC4gIFZhbHVlc1xuICogdGhhdCBjYW4gYmUgcGFyc2VkIGFzIG51bWJlcnMgYXJlIGVtaXR0ZWQgYXMgdHlwZSBgbnVtYmVyYCwgb3RoZXIgdmFsdWVzXG4gKiBhcmUgcGFyc2VkIGFzIGBzdHJpbmdgLlxuICpcbiAqIFRoZSByZXN1bHRzIGFyZSBub3QgYmF0Y2hlZC5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnRGF0YScsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJywgbmFtZXNwYWNlOiAnZGF0YSd9XG4gKi9cbmV4cG9ydCBjbGFzcyBDU1ZEYXRhc2V0IGV4dGVuZHMgRGF0YXNldDxUZW5zb3JDb250YWluZXI+IHtcbiAgYmFzZTogVGV4dExpbmVEYXRhc2V0O1xuICBwcml2YXRlIGhhc0hlYWRlciA9IHRydWU7XG4gIHByaXZhdGUgZnVsbENvbHVtbk5hbWVzOiBzdHJpbmdbXSA9IG51bGw7XG4gIHByaXZhdGUgY29sdW1uTmFtZXNWYWxpZGF0ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBjb2x1bW5Db25maWdzOiB7W2tleTogc3RyaW5nXTogQ29sdW1uQ29uZmlnfSA9IG51bGw7XG4gIHByaXZhdGUgY29uZmlndXJlZENvbHVtbnNPbmx5ID0gZmFsc2U7XG4gIHByaXZhdGUgZGVsaW1pdGVyID0gJywnO1xuICBwcml2YXRlIGRlbGltV2hpdGVzcGFjZSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvbHVtbiBuYW1lcyBvZiB0aGUgY3N2IGRhdGFzZXQuIElmIGBjb25maWd1cmVkQ29sdW1uc09ubHlgIGlzXG4gICAqIHRydWUsIHJldHVybiBjb2x1bW4gbmFtZXMgaW4gYGNvbHVtbkNvbmZpZ3NgLiBJZiBgY29uZmlndXJlZENvbHVtbnNPbmx5YCBpc1xuICAgKiBmYWxzZSBhbmQgYGNvbHVtbk5hbWVzYCBpcyBwcm92aWRlZCwgYGNvbHVtbk5hbWVzYC4gSWZcbiAgICogYGNvbmZpZ3VyZWRDb2x1bW5zT25seWAgaXMgZmFsc2UgYW5kIGBjb2x1bW5OYW1lc2AgaXMgbm90IHByb3ZpZGVkLCByZXR1cm5cbiAgICogYWxsIGNvbHVtbiBuYW1lcyBwYXJzZWQgZnJvbSB0aGUgY3N2IGZpbGUuIEZvciBleGFtcGxlIHVzYWdlIHBsZWFzZSBnbyB0b1xuICAgKiBgdGYuZGF0YS5jc3ZgLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnRGF0YScsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICovXG4gIGFzeW5jIGNvbHVtbk5hbWVzKCkge1xuICAgIGlmICghdGhpcy5jb2x1bW5OYW1lc1ZhbGlkYXRlZCkge1xuICAgICAgYXdhaXQgdGhpcy5zZXRDb2x1bW5OYW1lcygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25maWd1cmVkQ29sdW1uc09ubHkgPyBPYmplY3Qua2V5cyh0aGlzLmNvbHVtbkNvbmZpZ3MpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZ1bGxDb2x1bW5OYW1lcztcbiAgfVxuXG4gIC8qIDEpIElmIGBjb2x1bW5OYW1lc2AgaXMgcHJvdmlkZWQgYXMgc3RyaW5nW10sIHVzZSB0aGlzIHN0cmluZ1tdIGFzIG91dHB1dFxuICAgKiBrZXlzIGluIGNvcnJlc3BvbmRpbmcgb3JkZXIuIFRoZSBsZW5ndGggbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGluZmVycmVkXG4gICAqIGNvbHVtbnMgaWYgYGhhc0hlYWRlcmAgaXMgdHJ1ZSAuXG4gICAqIDIpIElmIGBjb2x1bW5OYW1lc2AgaXMgbm90IHByb3ZpZGVkLCBwYXJzZSBoZWFkZXIgbGluZSBhcyBgY29sdW1uTmFtZXNgIGlmXG4gICAqIGhhc0hlYWRlciBpcyB0cnVlLiBJZiBgaGFzSGVhZGVyYCBpcyBmYWxzZSwgdGhyb3cgYW4gZXJyb3IuXG4gICAqIDMpIElmIGBjb2x1bW5Db25maWdzYCBpcyBwcm92aWRlZCwgYWxsIHRoZSBrZXlzIGluIGBjb2x1bW5Db25maWdzYCBtdXN0XG4gICAqIGV4aXN0IGluIHBhcnNlZCBgY29sdW1uTmFtZXNgLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzZXRDb2x1bW5OYW1lcygpIHtcbiAgICBjb25zdCBjb2x1bW5OYW1lc0Zyb21GaWxlID0gYXdhaXQgdGhpcy5tYXliZVJlYWRIZWFkZXJMaW5lKCk7XG4gICAgaWYgKCF0aGlzLmZ1bGxDb2x1bW5OYW1lcyAmJiAhY29sdW1uTmFtZXNGcm9tRmlsZSkge1xuICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgY29sdW1uTmFtZXMgaXMgbm90IHByb3ZpZGVkIGFuZCBubyBoZWFkZXIgbGluZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ29sdW1uIG5hbWVzIG11c3QgYmUgcHJvdmlkZWQgaWYgdGhlcmUgaXMgbm8gaGVhZGVyIGxpbmUuJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZ1bGxDb2x1bW5OYW1lcyAmJiBjb2x1bW5OYW1lc0Zyb21GaWxlKSB7XG4gICAgICAvLyBDaGVjayBwcm92aWRlZCBjb2x1bW5OYW1lcyBtYXRjaCBoZWFkZXIgbGluZS5cbiAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgIGNvbHVtbk5hbWVzRnJvbUZpbGUubGVuZ3RoID09PSB0aGlzLmZ1bGxDb2x1bW5OYW1lcy5sZW5ndGgsXG4gICAgICAgICAgKCkgPT4gJ1RoZSBsZW5ndGggb2YgcHJvdmlkZWQgY29sdW1uTmFtZXMgKCcgK1xuICAgICAgICAgICAgICB0aGlzLmZ1bGxDb2x1bW5OYW1lcy5sZW5ndGgudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICcpIGRvZXMgbm90IG1hdGNoIHRoZSBsZW5ndGggb2YgdGhlIGhlYWRlciBsaW5lIHJlYWQgZnJvbSAnICtcbiAgICAgICAgICAgICAgJ2ZpbGUgKCcgKyBjb2x1bW5OYW1lc0Zyb21GaWxlLmxlbmd0aC50b1N0cmluZygpICsgJykuJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy5mdWxsQ29sdW1uTmFtZXMpIHtcbiAgICAgIHRoaXMuZnVsbENvbHVtbk5hbWVzID0gY29sdW1uTmFtZXNGcm9tRmlsZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGR1cGxpY2F0ZSBjb2x1bW4gbmFtZXMuXG4gICAgY29uc3QgY291bnRzOiB7W2tleTogc3RyaW5nXTogbnVtYmVyfSA9IHRoaXMuZnVsbENvbHVtbk5hbWVzLnJlZHVjZShcbiAgICAgICAgKGNvdW50QWNjOiB7W2tleTogc3RyaW5nXTogbnVtYmVyfSwgbmFtZSkgPT4ge1xuICAgICAgICAgIGNvdW50QWNjW25hbWVdID0gKGNvdW50QWNjW25hbWVdICsgMSkgfHwgMTtcbiAgICAgICAgICByZXR1cm4gY291bnRBY2M7XG4gICAgICAgIH0sXG4gICAgICAgIHt9KTtcbiAgICBjb25zdCBkdXBsaWNhdGVOYW1lcyA9XG4gICAgICAgIE9iamVjdC5rZXlzKGNvdW50cykuZmlsdGVyKChuYW1lKSA9PiAoY291bnRzW25hbWVdID4gMSkpO1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICBkdXBsaWNhdGVOYW1lcy5sZW5ndGggPT09IDAsXG4gICAgICAgICgpID0+ICdEdXBsaWNhdGUgY29sdW1uIG5hbWVzIGZvdW5kOiAnICsgZHVwbGljYXRlTmFtZXMudG9TdHJpbmcoKSk7XG4gICAgLy8gQ2hlY2sgaWYga2V5cyBpbiBjb2x1bW5Db25maWdzIG1hdGNoIGNvbHVtbk5hbWVzLlxuICAgIGlmICh0aGlzLmNvbHVtbkNvbmZpZ3MpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuY29sdW1uQ29uZmlncykpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZ1bGxDb2x1bW5OYW1lcy5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdUaGUga2V5IFwiJyArIGtleSArXG4gICAgICAgICAgICAgICdcIiBwcm92aWRlZCBpbiBjb2x1bW5Db25maWdzIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgY29sdW1uICcgK1xuICAgICAgICAgICAgICAnbmFtZXMgKCcgKyB0aGlzLmZ1bGxDb2x1bW5OYW1lcy50b1N0cmluZygpICsgJykuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb2x1bW5OYW1lc1ZhbGlkYXRlZCA9IHRydWU7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIG1heWJlUmVhZEhlYWRlckxpbmUoKSB7XG4gICAgaWYgKHRoaXMuaGFzSGVhZGVyKSB7XG4gICAgICBjb25zdCBpdGVyID0gYXdhaXQgdGhpcy5iYXNlLml0ZXJhdG9yKCk7XG4gICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSBhd2FpdCBpdGVyLm5leHQoKTtcbiAgICAgIGlmIChmaXJzdEVsZW1lbnQuZG9uZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGEgd2FzIGZvdW5kIGZvciBDU1YgcGFyc2luZy4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpcnN0TGluZTogc3RyaW5nID0gZmlyc3RFbGVtZW50LnZhbHVlO1xuICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMucGFyc2VSb3coZmlyc3RMaW5lLCBmYWxzZSk7XG4gICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGBDU1ZEYXRhc2V0YC5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0IEEgYERhdGFTb3VyY2VgIHByb3ZpZGluZyBhIGNodW5rZWQsIFVURjgtZW5jb2RlZCBieXRlIHN0cmVhbS5cbiAgICogQHBhcmFtIGNzdkNvbmZpZyAoT3B0aW9uYWwpIEEgQ1NWQ29uZmlnIG9iamVjdCB0aGF0IGNvbnRhaW5zIGNvbmZpZ3VyYXRpb25zXG4gICAqICAgICBvZiByZWFkaW5nIGFuZCBkZWNvZGluZyBmcm9tIENTViBmaWxlKHMpLlxuICAgKlxuICAgKiAgICAgaGFzSGVhZGVyOiAoT3B0aW9uYWwpIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBmaXJzdFxuICAgKiAgICAgcm93IG9mIHByb3ZpZGVkIENTViBmaWxlIGlzIGEgaGVhZGVyIGxpbmUgd2l0aCBjb2x1bW4gbmFtZXMsIGFuZCBzaG91bGRcbiAgICogICAgIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgZGF0YS4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKlxuICAgKiAgICAgY29sdW1uTmFtZXM6IChPcHRpb25hbCkgQSBsaXN0IG9mIHN0cmluZ3MgdGhhdCBjb3JyZXNwb25kcyB0b1xuICAgKiAgICAgdGhlIENTViBjb2x1bW4gbmFtZXMsIGluIG9yZGVyLiBJZiBwcm92aWRlZCwgaXQgaWdub3JlcyB0aGUgY29sdW1uXG4gICAqICAgICBuYW1lcyBpbmZlcnJlZCBmcm9tIHRoZSBoZWFkZXIgcm93LiBJZiBub3QgcHJvdmlkZWQsIGluZmVycyB0aGUgY29sdW1uXG4gICAqICAgICBuYW1lcyBmcm9tIHRoZSBmaXJzdCByb3cgb2YgdGhlIHJlY29yZHMuIElmIGhhc0hlYWRlciBpcyBmYWxzZSBhbmRcbiAgICogICAgIGNvbHVtbk5hbWVzIGlzIG5vdCBwcm92aWRlZCwgdGhpcyBtZXRob2QgdGhyb3dzIGFuIGVycm9yLlxuICAgKlxuICAgKiAgICAgY29sdW1uQ29uZmlnczogKE9wdGlvbmFsKSBBIGRpY3Rpb25hcnkgd2hvc2Uga2V5IGlzIGNvbHVtbiBuYW1lcywgdmFsdWVcbiAgICogICAgIGlzIGFuIG9iamVjdCBzdGF0aW5nIGlmIHRoaXMgY29sdW1uIGlzIHJlcXVpcmVkLCBjb2x1bW4ncyBkYXRhIHR5cGUsXG4gICAqICAgICBkZWZhdWx0IHZhbHVlLCBhbmQgaWYgdGhpcyBjb2x1bW4gaXMgbGFiZWwuIElmIHByb3ZpZGVkLCBrZXlzIG11c3RcbiAgICogICAgIGNvcnJlc3BvbmQgdG8gbmFtZXMgcHJvdmlkZWQgaW4gY29sdW1uTmFtZXMgb3IgaW5mZXJyZWQgZnJvbSB0aGUgZmlsZVxuICAgKiAgICAgaGVhZGVyIGxpbmVzLiBJZiBpc0xhYmVsIGlzIHRydWUgYW55IGNvbHVtbiwgcmV0dXJucyBhbiBhcnJheSBvZiB0d29cbiAgICogICAgIGl0ZW1zOiB0aGUgZmlyc3QgaXRlbSBpcyBhIGRpY3Qgb2YgZmVhdHVyZXMga2V5L3ZhbHVlIHBhaXJzLCB0aGUgc2Vjb25kXG4gICAqICAgICBpdGVtIGlzIGEgZGljdCBvZiBsYWJlbHMga2V5L3ZhbHVlIHBhaXJzLiBJZiBubyBmZWF0dXJlIGlzIG1hcmtlZCBhc1xuICAgKiAgICAgbGFiZWwsIHJldHVybnMgYSBkaWN0IG9mIGZlYXR1cmVzIG9ubHkuXG4gICAqXG4gICAqICAgICBjb25maWd1cmVkQ29sdW1uc09ubHkgKE9wdGlvbmFsKSBJZiB0cnVlLCBvbmx5IGNvbHVtbnMgcHJvdmlkZWQgaW5cbiAgICogICAgIGNvbHVtbkNvbmZpZ3Mgd2lsbCBiZSBwYXJzZWQgYW5kIHByb3ZpZGVkIGR1cmluZyBpdGVyYXRpb24uXG4gICAqXG4gICAqICAgICBkZWxpbWl0ZXIgKE9wdGlvbmFsKSBUaGUgc3RyaW5nIHVzZWQgdG8gcGFyc2UgZWFjaCBsaW5lIG9mIHRoZSBpbnB1dFxuICAgKiAgICAgZmlsZS4gRGVmYXVsdHMgdG8gYCxgLlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHJlYWRvbmx5IGlucHV0OiBEYXRhU291cmNlLCBjc3ZDb25maWc/OiBDU1ZDb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYmFzZSA9IG5ldyBUZXh0TGluZURhdGFzZXQoaW5wdXQpO1xuICAgIGlmICghY3N2Q29uZmlnKSB7XG4gICAgICBjc3ZDb25maWcgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5oYXNIZWFkZXIgPSBjc3ZDb25maWcuaGFzSGVhZGVyID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB0aGlzLmZ1bGxDb2x1bW5OYW1lcyA9IGNzdkNvbmZpZy5jb2x1bW5OYW1lcztcbiAgICB0aGlzLmNvbHVtbkNvbmZpZ3MgPSBjc3ZDb25maWcuY29sdW1uQ29uZmlncztcbiAgICB0aGlzLmNvbmZpZ3VyZWRDb2x1bW5zT25seSA9IGNzdkNvbmZpZy5jb25maWd1cmVkQ29sdW1uc09ubHk7XG4gICAgaWYgKGNzdkNvbmZpZy5kZWxpbVdoaXRlc3BhY2UpIHtcbiAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgIGNzdkNvbmZpZy5kZWxpbWl0ZXIgPT0gbnVsbCxcbiAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgICAnRGVsaW1pdGVyIHNob3VsZCBub3QgYmUgcHJvdmlkZWQgd2hlbiBkZWxpbVdoaXRlc3BhY2UgaXMgdHJ1ZS4nKTtcbiAgICAgIHRoaXMuZGVsaW1XaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGVsaW1pdGVyID0gJyAnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlbGltaXRlciA9IGNzdkNvbmZpZy5kZWxpbWl0ZXIgPyBjc3ZDb25maWcuZGVsaW1pdGVyIDogJywnO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGl0ZXJhdG9yKCk6IFByb21pc2U8TGF6eUl0ZXJhdG9yPFRlbnNvckNvbnRhaW5lcj4+IHtcbiAgICBpZiAoIXRoaXMuY29sdW1uTmFtZXNWYWxpZGF0ZWQpIHtcbiAgICAgIGF3YWl0IHRoaXMuc2V0Q29sdW1uTmFtZXMoKTtcbiAgICB9XG4gICAgbGV0IGxpbmVzID0gYXdhaXQgdGhpcy5iYXNlLml0ZXJhdG9yKCk7XG4gICAgaWYgKHRoaXMuaGFzSGVhZGVyKSB7XG4gICAgICAvLyBXZSBwcmV2aW91c2x5IHJlYWQgdGhlIGZpcnN0IGxpbmUgdG8gZ2V0IHRoZSBjb2x1bW5OYW1lcy5cbiAgICAgIC8vIE5vdyB0aGF0IHdlJ3JlIHByb3ZpZGluZyBkYXRhLCBza2lwIGl0LlxuICAgICAgbGluZXMgPSBsaW5lcy5za2lwKDEpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXMubWFwKHggPT4gdGhpcy5tYWtlRGF0YUVsZW1lbnQoeCkpO1xuICB9XG5cbiAgbWFrZURhdGFFbGVtZW50KGxpbmU6IHN0cmluZyk6IFRlbnNvckNvbnRhaW5lciB7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy5wYXJzZVJvdyhsaW5lKTtcbiAgICBjb25zdCBmZWF0dXJlczoge1trZXk6IHN0cmluZ106IFRlbnNvckNvbnRhaW5lcn0gPSB7fTtcbiAgICBjb25zdCBsYWJlbHM6IHtba2V5OiBzdHJpbmddOiBUZW5zb3JDb250YWluZXJ9ID0ge307XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZnVsbENvbHVtbk5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLmZ1bGxDb2x1bW5OYW1lc1tpXTtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29sdW1uQ29uZmlncyA/IHRoaXMuY29sdW1uQ29uZmlnc1trZXldIDogbnVsbDtcbiAgICAgIGlmICh0aGlzLmNvbmZpZ3VyZWRDb2x1bW5zT25seSAmJiAhY29uZmlnKSB7XG4gICAgICAgIC8vIFRoaXMgY29sdW1uIGlzIG5vdCBzZWxlY3RlZC5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgbGV0IHBhcnNlZFZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgIC8vIElmIGRlZmF1bHQgdmFsdWUgaXMgcHJvdmlkZWQsIHVzZSBpdC4gSWYgZGVmYXVsdCB2YWx1ZSBpcyBub3RcbiAgICAgICAgICAvLyBwcm92aWRlZCwgc2V0IGFzIHVuZGVmaW5lZC5cbiAgICAgICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcnNlZFZhbHVlID0gY29uZmlnLmRlZmF1bHQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb25maWcgJiYgKGNvbmZpZy5yZXF1aXJlZCB8fCBjb25maWcuaXNMYWJlbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgUmVxdWlyZWQgY29sdW1uICR7a2V5fSBpcyBlbXB0eSBpbiB0aGlzIGxpbmU6ICR7bGluZX1gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyc2VkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEEgdmFsdWUgaXMgcHJlc2VudCwgc28gcGFyc2UgaXQgYmFzZWQgb24gdHlwZVxuICAgICAgICAgIGNvbnN0IHZhbHVlQXNOdW0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGlmIChpc05hTih2YWx1ZUFzTnVtKSkge1xuICAgICAgICAgICAgLy8gVGhlIHZhbHVlIGlzIGEgc3RyaW5nIGFuZCB0aGlzIGNvbHVtbiBpcyBkZWNsYXJlZCBhcyBib29sZWFuXG4gICAgICAgICAgICAvLyBpbiBjb25maWcsIHBhcnNlIGl0IGFzIGJvb2xlYW4uXG4gICAgICAgICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5kdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgICAgICAgIHBhcnNlZFZhbHVlID0gdGhpcy5nZXRCb29sZWFuKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFNldCB2YWx1ZSBhcyBzdHJpbmdcbiAgICAgICAgICAgICAgcGFyc2VkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb25maWcgfHwgIWNvbmZpZy5kdHlwZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyB2YWx1ZSBpcyBhIG51bWJlciBhbmQgbm8gdHlwZSBjb25maWcgaXMgcHJvdmlkZWQsIHJldHVyblxuICAgICAgICAgICAgLy8gaXQgYXMgbnVtYmVyLlxuICAgICAgICAgICAgcGFyc2VkVmFsdWUgPSB2YWx1ZUFzTnVtO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHZhbHVlIGlzIGEgbnVtYmVyIGFuZCBkYXRhIHR5cGUgaXMgcHJvdmlkZWQsIHBhcnNlIGl0XG4gICAgICAgICAgICAvLyBhY2NvcmRpbmcgdG8gcHJvdmlkZWQgZGF0YSB0eXBlLlxuICAgICAgICAgICAgc3dpdGNoIChjb25maWcuZHR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICAgICAgICAgICAgcGFyc2VkVmFsdWUgPSB2YWx1ZUFzTnVtO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgICAgICAgICAgcGFyc2VkVmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlQXNOdW0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdib29sJzpcbiAgICAgICAgICAgICAgICBwYXJzZWRWYWx1ZSA9IHRoaXMuZ2V0Qm9vbGVhbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcGFyc2VkVmFsdWUgPSB2YWx1ZUFzTnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGNvbHVtbiBpcyBsYWJlbC5cbiAgICAgICAgKGNvbmZpZyAmJiBjb25maWcuaXNMYWJlbCkgPyBsYWJlbHNba2V5XSA9IHBhcnNlZFZhbHVlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlc1trZXldID0gcGFyc2VkVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIElmIGxhYmVsIGV4aXN0cywgcmV0dXJuIGFuIG9iamVjdCBvZiBmZWF0dXJlcyBhbmQgbGFiZWxzIGFzIHt4czpmZWF0dXJlcyxcbiAgICAvLyB5czpsYWJlbHN9LCBvdGhlcndpc2UgcmV0dXJuIGZlYXR1cmVzIG9ubHkuXG4gICAgaWYgKE9iamVjdC5rZXlzKGxhYmVscykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmVhdHVyZXM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt4czogZmVhdHVyZXMsIHlzOiBsYWJlbHN9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0Qm9vbGVhbih2YWx1ZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBpZiAodmFsdWUgPT09ICcxJyB8fCB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9iZXRhLm9ic2VydmFibGVocS5jb20vQG1ib3N0b2NrL3N0cmVhbWluZy1jc3ZcbiAgcHJpdmF0ZSBwYXJzZVJvdyhsaW5lOiBzdHJpbmcsIHZhbGlkYXRlRWxlbWVudENvdW50ID0gdHJ1ZSk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCByZXN1bHQ6IHN0cmluZ1tdID0gW107XG4gICAgbGV0IHJlYWRPZmZzZXQgPSAwO1xuICAgIGNvbnN0IHJlYWRMZW5ndGggPSBsaW5lLmxlbmd0aDtcbiAgICBsZXQgY3VycmVudFN0YXRlID0gU1RBVEVfT1VUO1xuICAgIC8vIEdvZXMgdGhyb3VnaCB0aGUgbGluZSB0byBwYXJzZSBxdW90ZS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlYWRMZW5ndGg7IGkrKykge1xuICAgICAgc3dpdGNoIChjdXJyZW50U3RhdGUpIHtcbiAgICAgICAgLy8gQmVmb3JlIGVudGVyIGEgbmV3IGZpZWxkXG4gICAgICAgIGNhc2UgU1RBVEVfT1VUOlxuICAgICAgICAgIHN3aXRjaCAobGluZS5jaGFyQXQoaSkpIHtcbiAgICAgICAgICAgIC8vIEVudGVyIGEgcXVvdGVkIGZpZWxkXG4gICAgICAgICAgICBjYXNlIENPREVfUVVPVEU6XG4gICAgICAgICAgICAgIHJlYWRPZmZzZXQgPSBpICsgMTtcbiAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gU1RBVEVfUVVPVEU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gUmVhZCBhbiBlbXB0eSBmaWVsZFxuICAgICAgICAgICAgY2FzZSB0aGlzLmRlbGltaXRlcjpcbiAgICAgICAgICAgICAgcmVhZE9mZnNldCA9IGkgKyAxO1xuICAgICAgICAgICAgICAvLyBJZiBkZWxpbWl0ZXIgaXMgd2hpdGUgc3BhY2UgYW5kIGNvbmZpZ3VyZWQgdG8gY29sbGFwc2VcbiAgICAgICAgICAgICAgLy8gbXVsdGlwbGUgd2hpdGUgc3BhY2VzLCBpZ25vcmUgdGhpcyB3aGl0ZSBzcGFjZS5cbiAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsaW1pdGVyID09PSAnICcgJiYgdGhpcy5kZWxpbVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IFNUQVRFX09VVDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBFbnRlciBhbiB1bnF1b3RlZCBmaWVsZFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gU1RBVEVfRklFTEQ7XG4gICAgICAgICAgICAgIHJlYWRPZmZzZXQgPSBpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEluIGFuIHVucXVvdGVkIGZpZWxkXG4gICAgICAgIGNhc2UgU1RBVEVfRklFTEQ6XG4gICAgICAgICAgc3dpdGNoIChsaW5lLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgLy8gRXhpdCBhbiB1bnF1b3RlZCBmaWVsZCwgYWRkIGl0IHRvIHJlc3VsdFxuICAgICAgICAgICAgY2FzZSB0aGlzLmRlbGltaXRlcjpcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGluZS5zdWJzdHJpbmcocmVhZE9mZnNldCwgaSkpO1xuICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBTVEFURV9PVVQ7XG4gICAgICAgICAgICAgIHJlYWRPZmZzZXQgPSBpICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gSW4gYSBxdW90ZWQgZmllbGRcbiAgICAgICAgY2FzZSBTVEFURV9RVU9URTpcbiAgICAgICAgICBzd2l0Y2ggKGxpbmUuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICAvLyBSZWFkIGEgcXVvdGUgYWZ0ZXIgYSBxdW90ZVxuICAgICAgICAgICAgY2FzZSBDT0RFX1FVT1RFOlxuICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBTVEFURV9RVU9URV9BRlRFUl9RVU9URTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhpcyBzdGF0ZSBtZWFucyBpdCdzIHJpZ2h0IGFmdGVyIGEgc2Vjb25kIHF1b3RlIGluIGEgZmllbGRcbiAgICAgICAgY2FzZSBTVEFURV9RVU9URV9BRlRFUl9RVU9URTpcbiAgICAgICAgICBzd2l0Y2ggKGxpbmUuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICAvLyBGaW5pc2hlZCBhIHF1b3RlZCBmaWVsZFxuICAgICAgICAgICAgY2FzZSB0aGlzLmRlbGltaXRlcjpcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGluZS5zdWJzdHJpbmcocmVhZE9mZnNldCwgaSAtIDEpKTtcbiAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gU1RBVEVfT1VUO1xuICAgICAgICAgICAgICByZWFkT2Zmc2V0ID0gaSArIDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gRmluaXNoZWQgYSBxdW90ZWQgcGFydCBpbiBhIHF1b3RlZCBmaWVsZFxuICAgICAgICAgICAgY2FzZSBDT0RFX1FVT1RFOlxuICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBTVEFURV9RVU9URTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBJbiBhIHF1b3RlZCBwYXJ0IGluIGEgcXVvdGVkIGZpZWxkXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBTVEFURV9XSVRISU5fUVVPVEVfSU5fUVVPVEU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTVEFURV9XSVRISU5fUVVPVEVfSU5fUVVPVEU6XG4gICAgICAgICAgc3dpdGNoIChsaW5lLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgLy8gRXhpdCBhIHF1b3RlZCBwYXJ0IGluIGEgcXVvdGVkIGZpZWxkXG4gICAgICAgICAgICBjYXNlIENPREVfUVVPVEU6XG4gICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSA9IFNUQVRFX1FVT1RFO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cbiAgICAvLyBBZGRzIGxhc3QgaXRlbSBiYXNlZCBvbiBpZiBpdCBpcyBxdW90ZWQuXG4gICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gU1RBVEVfUVVPVEVfQUZURVJfUVVPVEUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmUuc3Vic3RyaW5nKHJlYWRPZmZzZXQsIHJlYWRMZW5ndGggLSAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmUuc3Vic3RyaW5nKHJlYWRPZmZzZXQpKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgZWFjaCByb3cgaGFzIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cyBhcyBjb2x1bW4gbmFtZXMuXG4gICAgaWYgKHZhbGlkYXRlRWxlbWVudENvdW50ICYmIHJlc3VsdC5sZW5ndGggIT09IHRoaXMuZnVsbENvbHVtbk5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJvdyBpbiBjc3YgZmlsZS4gU2hvdWxkIGhhdmUgJHtcbiAgICAgICAgICB0aGlzLmZ1bGxDb2x1bW5OYW1lcy5sZW5ndGh9IGVsZW1lbnRzIGluIGEgcm93LCBidXQgZ290ICR7cmVzdWx0fWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbi8vIFRPRE8oc29lcmdlbCk6IGFkZCBtb3JlIGJhc2ljIGRhdGFzZXRzIGZvciBwYXJpdHkgd2l0aCB0Zi5kYXRhXG4vLyB0Zi5kYXRhLkZpeGVkTGVuZ3RoUmVjb3JkRGF0YXNldCgpXG4vLyB0Zi5kYXRhLlRGUmVjb3JkRGF0YXNldCgpXG4iXX0="],"names":["version","Dataset","constructor","this","size","batch","batchSize","smallLastBatch","base","Infinity","Math","ceil","floor","datasetFromIteratorFn","async","iterator","columnMajorBatch","deepBatchConcat","concatenate","dataset","filter","predicate","x","forEachAsync","f","map","transform","mapAsync","prefetch","bufferSize","RangeError","repeat","count","undefined","iteratorIterator","value","done","take","skip","shuffle","seed","reshuffleEachIteration","random","toString","seed2","int32","toArray","Error","toArrayForTest","iteratorFn","super","arguments","rows","exampleRow","arrays","length","batchConcat","recurse","MAX_BUFFER_SIZE","TextLineDataset","input","decodeUTF8","split","line","endsWith","slice","DataSource","Symbol"],"sourceRoot":""}