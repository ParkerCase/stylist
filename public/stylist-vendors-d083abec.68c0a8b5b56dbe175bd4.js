"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[6611],{14565:function(t,e,n){n.d(e,{i:function(){return s}});var r=n(9495),a=n(52610);const s={kernelName:r.Range,backendName:"cpu",kernelFunc:function(t){const{backend:e,attrs:n}=t,{start:r,stop:s,dtype:o,step:i}=n,l=(0,a.q)(r,s,i,o);return e.makeTensorInfo([l.length],o,l)}}},15844:function(t,e,n){n.d(e,{u:function(){return i}});var r=n(9495);function a(t,e,n,r){const a=[];let s=0;const o=e.length-1+n.length,i=new Array(o).fill(null).map((()=>[0]));!function(t,e){for(let n=0;n<t.length;++n){const r=t[n],a=n===t.length-1?e:t[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let t=1;t<r.length;++t)if(r[t-1]>r[t])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];const t=e[u+1];for(let e=1;e<l+1;++e)i[u].push(e*t)}for(let u=0;u<t.length;++u){let r=t[u],o=t[u]+1;for(let t=0;t<n.length;++t){const a=n[t],s=t+e.length-1;if(s>=0){const t=i[s],e=t[t.length-1]-a[r];for(let n=r;n<o;++n)i[s].push(a[n+1]+e)}r=a[r],o=a[o]}o!==r&&(a.push([r,o]),s+=o-r)}return{outSplits:i,valueSlices:a,numValues:s}}function s(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function o(t,e,n,a,o){const i=e.slice();i[0]=o;const l=r.util.getArrayFromDType(n,r.util.sizeFromShape(i)),u=t.length;return function(t,e,n,r,a,o){const i=s(e,2)[1],l=s(o,2)[1];let u=0;for(const s of n)for(let e=s[0];e<s[1];++e){for(let n=0;n<r;++n)a[u*l+n]=t[e*i+n];++u}}(t,e,a,0===u?0:u/e[0],l,i),[l,i]}function i(t,e,n,s,i,l,u,h){if(0===t.length)throw new Error("paramsNestedSplits must be non empty");if(0===e[0].length)throw new Error("Split tensors must not be scalars");if(function(t,e,n){t.forEach(((t,a)=>{if(t<0||t>=n){const s=r.util.indexToLoc(a,e.length,r.util.computeStrides(e)).join(",");throw new Error(`indices[${s}] = ${t} is not in [0, ${n})`)}}))}(l,u,e[0][0]-1),0===s.length)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:p,valueSlices:f,numValues:g}=a(l,u,t,c),d=function(t){const e=[];for(let n=0;n<t.length;++n){const a=t[n].length,s=r.util.getArrayFromDType("int32",a);e.push(s),t[n].forEach(((t,e)=>s[e]=t))}return e}(p),w=o(n,s,i,f,g);return[d,w[0],w[1]]}},37089:function(t,e,n){n.d(e,{g:function(){return s}});var r=n(9495),a=n(80814);const s={kernelName:r.RaggedTensorToTensor,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{shape:s,values:o,defaultValue:i,rowPartitionTensors:l}=e,{rowPartitionTypes:u}=r,h=n.data.get(s.dataId).values,c=n.data.get(o.dataId).values,p=n.data.get(i.dataId).values,f=l.map((t=>n.data.get(t.dataId).values)),g=l.map((t=>t.shape)),[d,w]=(0,a.K)(h,s.shape,c,o.shape,o.dtype,p,i.shape,f,g,u);return n.makeTensorInfo(d,o.dtype,w)}}},47620:function(t,e,n){n.d(e,{_:function(){return s}});var r=n(9495);const a=2147483647;function s(t,e,n,s,o,i,l){if(e.length>1)throw new Error("starts must be a scalar or vector");if(o.length>1)throw new Error("limits must be a scalar or vector");if(l.length>1)throw new Error("deltas must be a scalar or vector");const u=0===e.length,h=0===o.length,c=0===l.length,p=[];u||p.push(e[0]),h||p.push(o[0]),c||p.push(l[0]);for(let r=1;r<p.length;++r)if(p[r]!==p[r-1])throw new Error("starts, limits, and deltas must have the same shape");const f=0===p.length?1:p[0],g=r.util.getArrayFromDType("int32",f+1);g[0]=0;for(let r=0;r<f;++r){const e=u?t[0]:t[r],n=h?s[0]:s[r],o=c?i[0]:i[r];if(0===o)throw new Error("Requires delta != 0");let l;if(o>0&&n<e||o<0&&n>e)l=0;else if(l=Math.ceil(Math.abs((n-e)/o)),l>a)throw new Error(`Requires ((limit - start) / delta) <= ${a}`);g[r+1]=g[r]+l}const d=g[f],w=r.util.getArrayFromDType(n,d);let m=0;for(let r=0;r<f;++r){const e=g[r+1]-g[r];let n=u?t[0]:t[r];const a=c?i[0]:i[r];for(let t=0;t<e;++t)w[m++]=n,n+=a}return[g,w]}},52610:function(t,e,n){n.d(e,{q:function(){return a}});var r=n(9495);function a(t,e,n,a){if(t===e||t<e&&n<0||e<t&&n>1)return r.util.makeZerosTypedArray(0,a);const s=Math.abs(Math.ceil((e-t)/n)),o=r.util.makeZerosTypedArray(s,a);e<t&&1===n&&(n=-1),o[0]=t;for(let r=1;r<o.length;r++)o[r]=o[r-1]+n;return o}},59623:function(t,e,n){n.d(e,{i:function(){return s}});var r=n(9495),a=n(15844);const s={kernelName:r.RaggedGather,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:s,paramsDenseValues:o,indices:i}=e,{outputRaggedRank:l}=r,u=s.map((t=>n.data.get(t.dataId).values)),h=s.map((t=>t.shape)),c=n.data.get(o.dataId).values,p=n.data.get(i.dataId).values,[f,g,d]=(0,a.u)(u,h,c,o.shape,o.dtype,p,i.shape,l),w=f.map((t=>n.makeTensorInfo([t.length],"int32",t))),m=n.makeTensorInfo(d,o.dtype,g);return w.concat([m])}}},80814:function(t,e,n){n.d(e,{K:function(){return l}});var r=n(9495),a=r.backend_util.RowPartitionType;class s{constructor(t,e,n,a,s,o,i,l,u,h){this.shape=t,this.shapeShape=e,this.values=n,this.valuesShape=a,this.valuesDType=s,this.defaultValue=o,this.defaultValueShape=i,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=r.backend_util.getRowPartitionTypesHelper(h),this.raggedRank=r.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===a.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===a.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case a.VALUE_ROWIDS:return s.getMaxWidthValueRowID(e);case a.ROW_SPLITS:return s.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${a[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let n=0;for(let r=0;r<e-1;++r){const e=t[r+1]-t[r];e>n&&(n=e)}return n}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let n=0,r=t[0],a=0;for(let s=1;s<e;++s){const e=t[s];e!==r&&(r=e,a=Math.max(s-n,a),n=s)}return Math.max(e-n,a)}tensorShapeFromTensor(t,e,n=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return i(t,n)}calculateOutputSize(t){const e=this.valuesShape,n=this.defaultValueShape;r.backend_util.validateDefaultValueShape(n,e);const a=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=r.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,a,e);s[0]<0&&(s[0]=t);for(let r=1;r<=this.raggedRank;++r)s[r]<0&&(s[r]=this.getMaxWidth(r));return s}calculateFirstParentOutputIndex(t,e,n){const a=Math.min(t,n),s=[];let o=0;for(let r=0;r<a;++r,o+=e)s.push(o);for(let r=a;r<t;++r)s.push(-1);return r.util.assert(s.length===t,(()=>"Final length of result must be equal to firstDimension.")),s}calculateOutputIndexRowSplit(t,e,n,r){const a=t.length,s=[];for(let o=0;o<a-1;++o){const a=t[o+1]-t[o];let i=Math.min(r,a),l=e[o];-1===l&&(i=0);for(let t=0;t<i;++t)s.push(l),l+=n;for(let t=0;t<a-i;++t)s.push(-1)}if(a>0&&s.length!==t[a-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(t,e,n,r){const a=t.length,s=[];if(0===a)return[];let o=0,i=t[0];if(i>=e.length)throw new Error(`Got currentValueRowId=${i}, which is not less than ${e.length}`);let l=e[i];s.push(l);for(let u=1;u<a;++u){const a=t[u];if(a===i)l>=0&&(++o,o<r?l+=n:l=-1);else{if(o=0,i=a,a>=e.length)throw new Error(`Got nextValueRowId=${a} which is not less than ${e.length}`);l=e[a]}s.push(l)}if(s.length!==t.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(t,e,n,r){const s=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case a.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,e,n,r);case a.ROW_SPLITS:if(s.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(s,e,n,r);default:throw new Error(`Unsupported partition type: ${a[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case a.FIRST_DIM_SIZE:return t[0];case a.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case a.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${a[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),e=this.calculateOutputSize(t),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let r=n.length-2;r>=0;--r)n[r]=n[r+1]*e[r+1];const a=i(e,!1),s=r.util.getArrayFromDType(this.valuesDType,r.util.sizeFromShape(a));if(n[0]*e[0]>0){let r=this.calculateFirstParentOutputIndex(t,n[0],e[0]);for(let t=1;t<=this.raggedRank;++t){r=this.calculateOutputIndex(t-1,r,n[t],e[t])}this.setOutput(this.raggedRank,r,s,a)}return[a,s]}setOutput(t,e,n,a){if(0===n.length)return;const s=this.values,i=n;let l=a.slice();l=l.slice(t+1);const u=r.util.sizeFromShape(l),h=e.length;let c=this.defaultValue;if(c.length!==u&&1!==c.length){const t=this.defaultValueShape;(0,r.tidy)((()=>{const e=(0,r.reshape)(c,t),n=(0,r.broadcastTo)(e,l);c=n.dataSync()}))}let p=0,f=0,g=0;for(let r=0;r<=h;++r){let t=r<h?e[r]:-1;if(t!==g){if(f<g){const t=s.subarray(p*u);o(i.subarray(f*u),t,(g-f)*u)}if(r>=h){const e=n.length;t=Math.floor(e/u)}if(t>g)if(1===this.defaultValue.length)i.subarray(g*u,t*u).fill(this.defaultValue[0]),g=t;else for(;t>g;){o(i.slice(g*u),c,u),++g}t<0?(p=r+1,f=g):(p=r,f=g,g=f+1)}else++g}}}function o(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function i(t,e){const n=[];for(let r of t){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function l(t,e,n,r,a,o,i,l,u,h){return new s(t,e,n,r,a,o,i,l,u,h).compute()}},93287:function(t,e,n){n.d(e,{Y:function(){return s}});var r=n(9495),a=n(47620);const s={kernelName:r.RaggedRange,backendName:"cpu",kernelFunc:function(t){const{inputs:e,backend:n}=t,{starts:r,limits:s,deltas:o}=e,i=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values,[h,c]=(0,a._)(i,r.shape,r.dtype,l,s.shape,u,o.shape);return[n.makeTensorInfo([h.length],"int32",h),n.makeTensorInfo([c.length],r.dtype,c)]}}}}]);
//# sourceMappingURL=stylist-vendors-d083abec.68c0a8b5b56dbe175bd4.js.map