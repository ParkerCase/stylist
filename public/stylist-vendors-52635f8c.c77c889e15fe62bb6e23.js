"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[7219],{8537:function(e,n,t){t.d(n,{X:function(){return r}});var a=t(9495),s=t(64374);const r={kernelName:a.BatchMatMul,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{a:r,b:u}=n,{transposeA:c,transposeB:l}=a;return(0,s.L)({a:r,b:u,transposeA:c,transposeB:l,backend:t})}}},17845:function(e,n,t){t.d(n,{LY:function(){return c}});var a=t(9495),s=t(22897),r=t(46334),u=t(76905);const c={kernelName:a.BitwiseAnd,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{a:c,b:l}=n,i=(0,a.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"),p=(0,a.env)().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([c,l])||1===p){const e=t.texData.get(c.dataId).values,n=t.texData.get(l.dataId).values,[a,s]=(0,u.PA)(c.shape,l.shape,e,n,c.dtype),r=t.makeTensorInfo(s,c.dtype);return t.texData.get(r.dataId).values=a,r}let o;return o=i?new r.VI("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",c.shape,l.shape,!1):new s.x("\n  return float(int(a.r) & int(b.r));\n",c.shape,l.shape),t.runWebGLProgram(o,[c,l],c.dtype)}}},36951:function(e,n,t){t.d(n,{N:function(){return s}});var a=t(9495);const s={kernelName:a.BroadcastArgs,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{s0:s,s1:r}=n,u=t.readSync(s.dataId),c=t.readSync(r.dataId),l=a.backend_util.assertAndGetBroadcastShape(Array.from(u),Array.from(c));return t.makeTensorInfo([l.length],"int32",Int32Array.from(l))}}},64374:function(e,n,t){t.d(n,{L:function(){return o},U:function(){return p}});var a=t(9495),s=t(15411),r=t(63288),u=t(26041),c=t(94043),l=t(22853),i=t(58246);const p=1e3;function o({a:e,b:n,transposeA:t,transposeB:o,backend:h,bias:d=null,preluActivationWeights:b=null,leakyreluAlpha:k=0,activation:m=null}){const g=e.shape.length,f=n.shape.length,x=t?e.shape[g-2]:e.shape[g-1],v=o?n.shape[f-1]:n.shape[f-2],B=t?e.shape[g-1]:e.shape[g-2],I=o?n.shape[f-2]:n.shape[f-1],N=e.shape.slice(0,-2),y=n.shape.slice(0,-2),A=a.util.sizeFromShape(N),S=a.util.sizeFromShape(y),w=a.broadcast_util.assertAndGetBroadcastShape(e.shape.slice(0,-2),n.shape.slice(0,-2)).concat([B,I]);a.util.assert(x===v,(()=>`Error in matMul: inner shapes (${x}) and (${v}) of Tensors with shapes ${e.shape} and ${n.shape} and transposeA=${t} and transposeB=${o} must match.`));const _=t?[A,x,B]:[A,B,x],T=o?[S,I,v]:[S,v,I],L=(0,c.t)({inputs:{x:e},backend:h,attrs:{shape:_}}),P=(0,c.t)({inputs:{x:n},backend:h,attrs:{shape:T}}),E=[L,P],W=Math.max(A,S),F=t?L.shape[1]:L.shape[2],G=null!=d,z=null!=b,q="leakyrelu"===m,C=null!=m?(0,s.bE)(m,!0):null;let D;if((1===B||1===I)&&F>p&&!1===(G||z||q||null!=C)){let e=L,n=P;t&&(e=(0,i.m)({inputs:{x:L},backend:h,attrs:{perm:[0,2,1]}}),E.push(e)),o&&(n=(0,i.m)({inputs:{x:P},backend:h,attrs:{perm:[0,2,1]}}),E.push(n));const a=1===I;let s=e;1!==I&&(s=(0,c.t)({inputs:{x:e},backend:h,attrs:{shape:[W,F,1]}}),E.push(s));const r=1===I?2:1;let p=n;a&&(p=(0,c.t)({inputs:{x:n},backend:h,attrs:{shape:[W,1,F]}}),E.push(p));const d=(0,u.l)({inputs:{a:s,b:p},backend:h});D=(0,l.c)({inputs:{x:d},backend:h,attrs:{axis:r,keepDims:!0}}),E.push(d)}else{const s=(0,a.upcastType)(e.dtype,n.dtype),u=new r.P(_,T,[W,B,I],t,o,G,C,z,q),c=[L,P];if(null!=d&&c.push(d),z&&c.push(b),q){const e=h.makeTensorInfo([],"float32",a.util.createScalarValue(k,"float32"));c.push(e),E.push(e)}D=h.runWebGLProgram(u,c,s)}const O=(0,c.t)({inputs:{x:D},backend:h,attrs:{shape:w}});E.push(D);for(const a of E)h.disposeIntermediateTensorInfo(a);return O}},65514:function(e,n,t){t.d(n,{e:function(){return c}});var a=t(9495),s=t(94043),r=t(29547),u=t(58246);const c={kernelName:a.BatchToSpaceND,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:c}=e,{x:l}=n,{blockShape:i,crops:p}=c;a.util.assert(l.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=i.reduce(((e,n)=>e*n)),h=a.backend_util.getReshaped(l.shape,i,o),d=a.backend_util.getPermuted(h.length,i.length),b=a.backend_util.getReshapedPermuted(l.shape,i,o),k=a.backend_util.getSliceBeginCoords(p,i.length),m=a.backend_util.getSliceSize(b,p,i.length),g=[],f=(0,s.t)({inputs:{x:l},backend:t,attrs:{shape:h}}),x=(0,u.m)({inputs:{x:f},backend:t,attrs:{perm:d}}),v=(0,s.t)({inputs:{x:x},backend:t,attrs:{shape:b}}),B=(0,r.d)({inputs:{x:v},backend:t,attrs:{begin:k,size:m}});return g.push(f),g.push(x),g.push(v),g.forEach((e=>t.disposeIntermediateTensorInfo(e))),B}}},72517:function(e,n,t){t.d(n,{l:function(){return r}});var a=t(9495),s=t(76905);const r={kernelName:a.Bincount,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{x:r,weights:u}=n,{size:c}=a,l=t.readSync(r.dataId),i=t.readSync(u.dataId),p=(0,s.jm)(l,i,u.dtype,u.shape,c);return t.makeTensorInfo([c],u.dtype,p)}}},82339:function(e,n,t){t.d(n,{V:function(){return u}});var a=t(9495),s=t(29643),r=t(68616);const u={kernelName:a.FusedBatchNorm,backendName:"webgl",kernelFunc:({inputs:e,backend:n,attrs:t})=>{const{x:u,mean:c,variance:l,offset:i,scale:p}=e;a.util.assert(c.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),a.util.assert(null==i||c.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),a.util.assert(null==p||c.shape.length===p.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:o}=t;null==o&&(o=.001);const h=[u,c,l];let d=null;null!=i&&(d=i.shape,h.push(i));let b=null;null!=p&&(b=p.shape,h.push(p));const k=(0,a.env)().getBool("WEBGL_PACK_NORMALIZATION")?new r.x(u.shape,c.shape,l.shape,d,b,o):new s.f(u.shape,c.shape,l.shape,d,b,o);return n.runWebGLProgram(k,h,h[0].dtype)}}}}]);
//# sourceMappingURL=stylist-vendors-52635f8c.c77c889e15fe62bb6e23.js.map