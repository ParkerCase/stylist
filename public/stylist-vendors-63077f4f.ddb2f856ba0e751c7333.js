"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[4874],{2249:function(e,n,t){t.d(n,{T:function(){return u}});var a=t(9495),r=t(26180),s=t(16853);const u={kernelName:a.ResizeBilinear,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:u}=e,{images:o}=n,{alignCorners:i,halfPixelCenters:c,size:d}=u,[l,p]=d,h=(0,a.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new s.x(o.shape,l,p,i,c):new r.z(o.shape,l,p,i,c);return t.runWebGLProgram(h,[o],"float32")}}},4313:function(e,n,t){t.d(n,{r:function(){return u},x:function(){return s}});var a=t(9495),r=t(77723);function s(e){const{inputs:n,backend:t}=e,{input:a}=n,s=t.texData.get(a.dataId);return(0,r.D)({inputs:{x:s.complexTensorInfos.real},backend:t})}const u={kernelName:a.Real,backendName:"webgl",kernelFunc:s}},4490:function(e,n,t){t.d(n,{G:function(){return s},M:function(){return r}});var a=t(9495);const r=(0,t(15411).j0)({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),s={kernelName:a.RealDiv,backendName:"webgl",kernelFunc:r}},14421:function(e,n,t){t.d(n,{X:function(){return o}});var a=t(9495),r=t(15411);const s=t(68173).dR+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",u=(0,r.vi)({opSnippet:s,packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),o={kernelName:a.Relu6,backendName:"webgl",kernelFunc:u}},24129:function(e,n,t){t.d(n,{X:function(){return i}});var a=t(9495),r=t(15411),s=t(76905);const u=r.Zt+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",o=(0,r.vi)({opSnippet:u,packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:s.BC}),i={kernelName:a.Sigmoid,backendName:"webgl",kernelFunc:o}},24929:function(e,n,t){t.d(n,{f:function(){return s}});var a=t(9495),r=t(40784);const s={kernelName:a.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:e,attrs:n,backend:t})=>{const{image:s}=e,{radians:u,fillValue:o,center:i}=n,c=t,d=new r.e(s.shape,o),[l,p]=a.backend_util.getImageCenter(i,s.shape[1],s.shape[2]),h=[[l,p,Math.sin(u),Math.cos(u)]];return c.runWebGLProgram(d,[s],s.dtype,h)}}},25103:function(e,n,t){t.d(n,{F:function(){return s}});var a=t(9495),r=t(76905);const s={kernelName:a.SparseReshape,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{inputIndices:a,inputShape:s,newShape:u}=n;if(2!==a.shape.length)throw new Error(`Input indices should be a matrix but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==u.shape.length)throw new Error(`Target shape should be a vector but received shape ${u.shape}`);const o=Array.from(t.readSync(s.dataId)),i=t.readSync(a.dataId),c=Array.from(t.readSync(u.dataId)),[d,l,p]=(0,r.vo)(i,a.shape,a.dtype,o,c);return[t.makeTensorInfo(l,a.dtype,d),t.makeTensorInfo([p.length],u.dtype,new Int32Array(p))]}}},29547:function(e,n,t){t.d(n,{d:function(){return o},l:function(){return i}});var a=t(9495),r=t(76905),s=t(10043),u=t(5144);function o(e){const{inputs:n,backend:t,attrs:o}=e,{x:i}=n,{begin:c,size:d}=o,[l,p]=a.slice_util.parseSliceParams(i,c,d);if(a.slice_util.assertParamsValid(i,l,p),0===a.util.sizeFromShape(p))return t.makeTensorInfo(p,i.dtype,[]);if(t.shouldExecuteOnCPU([i])||"string"===i.dtype){const e=t.texData.get(i.dataId),n=(0,r.J3)(e.values,l,p,i.shape,i.dtype);return t.makeTensorInfo(p,i.dtype,n)}const{isPacked:h}=t.texData.get(i.dataId),f=a.slice_util.isSliceContinous(i.shape,l,p);if(h||!f){const e=(0,a.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new u.V(p):new s.J(p),n=[l];return t.runWebGLProgram(e,[i],i.dtype,n)}return t.uploadToGPU(i.dataId),function(e,n,t,r){const s=r.texData.get(e.dataId),u=r.makeTensorInfo(t,e.dtype),o=r.texData.get(u.dataId);Object.assign(o,s),o.refCount=1,o.shape=t,o.dtype=e.dtype;let i=a.slice_util.computeFlatOffset(n,a.util.computeStrides(e.shape));s.slice&&(i+=s.slice.flatOffset),o.slice={flatOffset:i,origDataId:s.slice&&s.slice.origDataId||e.dataId};const c=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,c+1),u}(i,l,p,t)}const i={kernelName:a.Slice,backendName:"webgl",kernelFunc:o}},33556:function(e,n,t){t.d(n,{M:function(){return s}});var a=t(9495),r=t(473);const s={kernelName:a.SearchSorted,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{sortedSequence:s,values:u}=n,{side:o}=a,i=new r.i(s.shape[0],s.shape[1],u.shape[1],o),c=[[s.shape[1]]];return t.runWebGLProgram(i,[s,u],"int32",c)}}},34733:function(e,n,t){t.d(n,{L:function(){return o}});var a=t(9495),r=t(15411),s=t(76905);const u=(0,r.vi)({opSnippet:"return inversesqrt(x);",cpuKernelImpl:s.tc}),o={kernelName:a.Rsqrt,backendName:"webgl",kernelFunc:u}},37647:function(e,n,t){t.d(n,{z:function(){return o}});var a=t(9495),r=t(15411);const s=t(68173).dR+"\n  return (x < 0.0) ? 0.0 : x;\n",u=(0,r.vi)({opSnippet:s,packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),o={kernelName:a.Relu,backendName:"webgl",kernelFunc:u}},39264:function(e,n,t){t.d(n,{i:function(){return u},y:function(){return s}});var a=t(9495),r=t(76905);const s=e=>{const{backend:n,attrs:t}=e,{start:a,stop:s,step:u,dtype:o}=t,i=(0,r.we)(a,s,u,o);return n.makeTensorInfo([i.length],o,i)},u={kernelName:a.Range,backendName:"webgl",kernelFunc:s}},40257:function(e,n,t){t.d(n,{j:function(){return s}});var a=t(9495),r=t(76905);const s={kernelName:a.SparseSegmentSum,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{data:a,indices:s,segmentIds:u}=n;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==u.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${u.shape}`);const o=t.readSync(a.dataId),i=t.readSync(s.dataId),c=t.readSync(u.dataId),[d,l]=(0,r.zN)(o,a.shape,a.dtype,i,c);return t.makeTensorInfo(l,a.dtype,d)}}},43137:function(e,n,t){t.d(n,{j:function(){return u}});var a=t(9495),r=t(6917),s=t(59250);const u={kernelName:a.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:u}=e,{images:o}=n,{alignCorners:i,halfPixelCenters:c,size:d}=u,[l,p]=d,h=(0,a.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new s.z(o.shape,l,p,i,c):new r.$(o.shape,l,p,i,c);return t.runWebGLProgram(h,[o],o.dtype)}}},43168:function(e,n,t){t.d(n,{C:function(){return s}});var a=t(9495);const r=(0,t(15411).vi)({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),s={kernelName:a.Sign,backendName:"webgl",kernelFunc:r}},49442:function(e,n,t){t.d(n,{K:function(){return s}});var a=t(9495),r=t(76905);const s={kernelName:a.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{indices:a,values:s,denseShape:u,defaultValue:o}=n;if(1!==u.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${u.shape}`);if(2!==a.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${a.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const i=t.readSync(a.dataId),c=t.readSync(s.dataId),d=t.readSync(u.dataId),l=t.readSync(o.dataId)[0],[p,h,f,b,k]=(0,r.sB)(i,a.shape,a.dtype,c,s.dtype,d,l);return[t.makeTensorInfo(h,a.dtype,p),t.makeTensorInfo([h[0]],s.dtype,f),t.makeTensorInfo([b.length],"bool",new Uint8Array(b.map((e=>Number(e))))),t.makeTensorInfo([k.length],a.dtype,new Int32Array(k))]}}},49627:function(e,n,t){t.d(n,{$:function(){return s}});var a=t(9495);const r=(0,t(15411).vi)({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),s={kernelName:a.Sinh,backendName:"webgl",kernelFunc:r}},49649:function(e,n,t){t.d(n,{l:function(){return s}});var a=t(9495);const r=(0,t(15411).vi)({opSnippet:"return 1.0 / x;"}),s={kernelName:a.Reciprocal,backendName:"webgl",kernelFunc:r}},50894:function(e,n,t){t.d(n,{W:function(){return o}});var a=t(9495),r=t(92616),s=t(94043),u=t(58246);const o={kernelName:a.SpaceToBatchND,backendName:"webgl",kernelFunc:e=>{const{inputs:n,backend:t,attrs:o}=e,{x:i}=n,{blockShape:c,paddings:d}=o;a.util.assert(i.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const l=c.reduce(((e,n)=>e*n)),p=[[0,0]];p.push(...d);for(let a=1+c.length;a<i.shape.length;++a)p.push([0,0]);const h=[],f=(0,r.w)({inputs:{x:i},backend:t,attrs:{paddings:p,constantValue:0}}),b=a.backend_util.getReshaped(f.shape,c,l,!1),k=a.backend_util.getPermuted(b.length,c.length,!1),m=a.backend_util.getReshapedPermuted(f.shape,c,l,!1),g=(0,s.t)({inputs:{x:f},backend:t,attrs:{shape:b}}),N=(0,u.m)({inputs:{x:g},backend:t,attrs:{perm:k}}),x=(0,s.t)({inputs:{x:N},backend:t,attrs:{shape:m}});return h.push(f),h.push(g),h.push(N),h.forEach((e=>t.disposeIntermediateTensorInfo(e))),x}}},51361:function(e,n,t){t.d(n,{z:function(){return s}});var a=t(9495),r=t(81847);const s={kernelName:a.Select,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{condition:s,t:u,e:o}=n,i=new r.T(s.shape.length,u.shape,u.shape.length);return t.runWebGLProgram(i,[s,u,o],(0,a.upcastType)(u.dtype,o.dtype))}}},53874:function(e,n,t){t.d(n,{Y:function(){return s}});var a=t(9495),r=t(76905);const s={kernelName:a.RaggedRange,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{starts:a,limits:s,deltas:u}=n,o=t.readSync(a.dataId),i=t.readSync(s.dataId),c=t.readSync(u.dataId),[d,l]=(0,r.Oy)(o,a.shape,a.dtype,i,s.shape,c,u.shape);return[t.makeTensorInfo([d.length],"int32",d),t.makeTensorInfo([l.length],a.dtype,l)]}}},57518:function(e,n,t){t.d(n,{H:function(){return o}});var a=t(9495),r=t(8939),s=t(57160),u=t(94043);const o={kernelName:a.ScatterNd,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{indices:i,updates:c}=n,{shape:d}=o,{sliceRank:l,numUpdates:p,sliceSize:h,strides:f,outputSize:b}=a.backend_util.calculateShapes(c,i,d),k=[b/h,h];if(0===b)return t.makeTensorInfo(d,i.dtype);const m=(0,u.t)({inputs:{x:i},backend:t,attrs:{shape:[p,l]}}),g=(0,u.t)({inputs:{x:c},backend:t,attrs:{shape:[p,h]}}),N=t.makeTensorInfo([],"float32",new Float32Array([0]));let x;x=(0,a.env)().getBool("WEBGL_PACK")?new s.h(p,l,m.shape.length,g.shape.length,f,k):new r.$(p,l,m.shape.length,g.shape.length,f,k);const I=t.runWebGLProgram(x,[g,m,N],g.dtype),S=(0,u.t)({inputs:{x:I},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(N),S}}},58137:function(e,n,t){t.d(n,{v:function(){return s}});var a=t(9495),r=t(76905);const s={kernelName:a.SparseSegmentMean,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t}=e,{data:a,indices:s,segmentIds:u}=n;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==u.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${u.shape}`);const o=t.readSync(a.dataId),i=t.readSync(s.dataId),c=t.readSync(u.dataId),[d,l]=(0,r.zN)(o,a.shape,a.dtype,i,c,!0);return t.makeTensorInfo(l,a.dtype,d)}}},60739:function(e,n,t){t.d(n,{b:function(){return c}});var a=t(9495),r=t(46334),s=t(15411);const u=s.Zt+"\n  return sin(x);\n",o=`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${r.qq}\n  return result;\n`,i=(0,s.vi)({opSnippet:u,packedOpSnippet:o}),c={kernelName:a.Sin,backendName:"webgl",kernelFunc:i}},62667:function(e,n,t){t.d(n,{$:function(){return l},V:function(){return d}});var a=t(9495),r=t(29450),s=t(99160),u=t(4490),o=t(94043),i=t(38483),c=t(22853);function d(e){const{inputs:n,backend:t,attrs:d}=e,{logits:l}=n,{dim:p}=d,h=a.util.parseAxisParam([p],l.shape),f=(0,s.T)({inputs:{x:l},backend:t,attrs:{reductionIndices:h,keepDims:!1}}),b=a.backend_util.expandShapeToKeepDim(f.shape,h),k=(0,o.t)({inputs:{x:f},backend:t,attrs:{shape:b}}),m=(0,i.j)({inputs:{a:l,b:k},backend:t}),g=(0,r.oN)({inputs:{x:m},backend:t}),N=(0,c.c)({inputs:{x:g},backend:t,attrs:{axis:h,keepDims:!1}}),x=(0,o.t)({inputs:{x:N},backend:t,attrs:{shape:b}}),I=(0,u.M)({inputs:{a:g,b:x},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(k),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(N),t.disposeIntermediateTensorInfo(x),I}const l={kernelName:a.Softmax,backendName:"webgl",kernelFunc:d}},63575:function(e,n,t){t.d(n,{t:function(){return s}});var a=t(9495),r=t(29547);const s={kernelName:a.SplitV,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:s}=e,{x:u}=n,{numOrSizeSplits:o,axis:i}=s,c=a.util.parseAxisParam(i,u.shape)[0],d=a.backend_util.prepareSplitSize(u,o,c),l=u.shape.length,p=new Array(l).fill(0),h=u.shape.slice();return d.map((e=>{const n=[...h];n[c]=e;const a=(0,r.d)({inputs:{x:u},backend:t,attrs:{begin:p,size:n}});return p[c]+=e,a}))}}},64770:function(e,n,t){t.d(n,{k:function(){return o}});var a=t(9495),r=t(15411);const s=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${a.backend_util.SELU_SCALEALPHA};\n  float scale = ${a.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,u=(0,r.vi)({opSnippet:s}),o={kernelName:a.Selu,backendName:"webgl",kernelFunc:u}},67926:function(e,n,t){t.d(n,{g:function(){return s}});var a=t(9495),r=t(76905);const s={kernelName:a.RaggedTensorToTensor,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{shape:s,values:u,defaultValue:o,rowPartitionTensors:i}=n,{rowPartitionTypes:c}=a,d=t.readSync(s.dataId),l=t.readSync(u.dataId),p=t.readSync(o.dataId),h=i.map((e=>t.readSync(e.dataId))),f=i.map((e=>e.shape)),[b,k]=(0,r.G3)(d,s.shape,l,u.shape,u.dtype,p,o.shape,h,f,c);return t.makeTensorInfo(b,u.dtype,k)}}},68065:function(e,n,t){t.d(n,{Z:function(){return s}});var a=t(9495);const r=(0,t(15411).vi)({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),s={kernelName:a.Softplus,backendName:"webgl",kernelFunc:r}},68889:function(e,n,t){t.d(n,{j:function(){return s}});var a=t(9495),r=t(47791);const s={kernelName:a.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{images:s,dy:u}=n,{alignCorners:o}=a,i=new r.h(u.shape,s.shape,o);return t.runWebGLProgram(i,[u],u.dtype)}}},73008:function(e,n,t){t.d(n,{i:function(){return s}});var a=t(9495),r=t(76905);const s={kernelName:a.RaggedGather,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{paramsNestedSplits:s,paramsDenseValues:u,indices:o}=n,{outputRaggedRank:i}=a,c=s.map((e=>t.readSync(e.dataId))),d=s.map((e=>e.shape)),l=t.readSync(u.dataId),p=t.readSync(o.dataId),[h,f,b]=(0,r.G4)(c,d,l,u.shape,u.dtype,p,o.shape,i),k=h.map((e=>t.makeTensorInfo([e.length],"int32",e))),m=t.makeTensorInfo(b,u.dtype,f);return k.concat([m])}}},80809:function(e,n,t){t.d(n,{x:function(){return o}});var a=t(9495),r=t(76905),s=t(8939),u=t(94043);const o={kernelName:a.SparseToDense,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{sparseIndices:i,sparseValues:c,defaultValue:d}=n,{outputShape:l}=o,{sliceRank:p,numUpdates:h,sliceSize:f,strides:b,outputSize:k}=a.backend_util.calculateShapes(c,i,l),m=!1;if("string"===c.dtype){const e=t.bufferSync(i),n=t.bufferSync(c),s=a.util.decodeString(t.readSync(d.dataId)[0]),u=(0,r.fC)(e,n,l,k,f,h,p,b,s,m);return t.makeTensorInfo(l,u.dtype,u.values)}const g=new s.$(h,p,i.shape.length,c.shape.length,b,[k,1],m),N=t.runWebGLProgram(g,[c,i,d],c.dtype),x=(0,u.t)({inputs:{x:N},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(N),x}}},84745:function(e,n,t){t.d(n,{$:function(){return s}});var a=t(9495);const r=(0,t(15411).vi)({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),s={kernelName:a.Round,backendName:"webgl",kernelFunc:r}},86567:function(e,n,t){t.d(n,{r:function(){return o}});var a=t(9495),r=t(71967),s=t(68636),u=t(77723);const o={kernelName:a.Reverse,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:o}=e,{x:i}=n,{dims:c}=o,d=i.shape.length,l=a.util.parseAxisParam(c,i.shape);if(0===d)return(0,u.D)({inputs:{x:i},backend:t});const p=(0,a.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new s.X(i.shape,l):new r.N(i.shape,l);return t.runWebGLProgram(p,[i],i.dtype)}}},94043:function(e,n,t){t.d(n,{V:function(){return o},t:function(){return u}});var a=t(9495),r=t(99992),s=t(88380);function u(e){const{inputs:n,backend:t,attrs:u}=e,{x:o}=n,{shape:i}=u,c=t,d=a.util.sizeFromShape(o.shape),l=a.util.inferFromImplicitShape(i,d),p=a.util.sizeFromShape(l);a.util.assert(d===p,(()=>`The new shape (${l}) has ${p} elements and the old shape (${o.shape}) has ${d} elements. The new shape and old shape must have the same number of elements.`));const h=c.texData.get(o.dataId);return!h.isPacked||(0,s.P0)(o.shape,l)||null!==h.texture&&(0,s.P0)(h.shape,l)?(c.incRef(o.dataId),{dataId:o.dataId,shape:l,dtype:o.dtype}):(0,r.p)(o,l,c)}const o={kernelName:a.Reshape,backendName:"webgl",kernelFunc:u}},96017:function(e,n,t){t.d(n,{n:function(){return s}});var a=t(9495),r=t(27436);const s={kernelName:a.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function(e){const{inputs:n,backend:t,attrs:a}=e,{images:s,dy:u}=n,{alignCorners:o}=a,i=new r.x(u.shape,s.shape,o);return t.runWebGLProgram(i,[u],u.dtype)}}}}]);
//# sourceMappingURL=stylist-vendors-63077f4f.ddb2f856ba0e751c7333.js.map