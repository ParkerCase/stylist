"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[7591],{17328:function(t,s,e){e.d(s,{m:function(){return y}});var n=e(9495),i=e(91686),o=e(15841),a=e(55795),r=e(44813),u=e(91928),l=e(63057),h=e(71765),c=e(52700),p=e(45978),d=e(78825),f=e(79730);class y extends f.Wd{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=(0,i.v)(t)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],r.Am(this.inputs).length!==this.inputs.length)throw new o.Qp(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((t=>t.name))}`);r.Am(this.outputs).length,this.outputs.length,this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const i of this.outputs){const t=i.sourceLayer,s=i.nodeIndex,e=i.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(s),this.outputLayersTensorIndices.push(e)}for(const i of this.inputs){const t=i.sourceLayer,s=i.nodeIndex,e=i.tensorIndex;r.vA(0===s,"input layer has >1 nodes"),r.vA(0===e,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(s),this.inputLayersTensorIndices.push(e)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let i=0;i<this.inputLayers.length;i++){const s=this.inputLayers[i];if(!(s instanceof d.m))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${i} (0-based) originates from layer type ${s.getClassName()}.`);this.inputNames.push(s.name),this.feedInputShapes.push(s.batchInputShape),this.feedInputNames.push(s.name)}for(const i of this.outputLayers)this.outputNames.push(i.name);this.internalInputShapes=this.inputs.map((t=>t.shape)),this.internalOutputShapes=this.outputs.map((t=>t.shape));const s={},e={},n={},a={},u={},l=[],h=(t,s,e,n,i,a)=>{null!=n&&null!=i&&null!=a||(n=t.sourceLayer,i=t.nodeIndex,a=t.tensorIndex);const r=n.inboundNodes[i];if(-1!==e.indexOf(r))throw new o.bu(`The tensor ${t.name} at layer "${n.name}" is part of a cycle.`);if(-1!==s.indexOf(r))return;this.containerNodes.add(y.nodeKey(n,i)),n.id in u||(u[n.id]=Object.keys(u).length),-1===e.indexOf(r)&&e.push(r);const c=r.inboundLayers.length;for(let o=0;o<c;o++){const t=r.inputTensors[o],n=r.inboundLayers[o],i=r.nodeIndices[o],a=r.tensorIndices[o];h(t,s,e,n,i,a)}for(s.push(r);e.indexOf(r)>=0;)e.splice(e.indexOf(r),1);l.push(r)},c=[],p=[];for(const i of this.outputs)h(i,c,p);const m=l.slice().reverse();for(const i of m){e[i.id]=i,i.id in s||(s[i.id]=0);let t=s[i.id];const o=null==n[i.outboundLayer.id]?0:n[i.outboundLayer.id];t=Math.max(t,o),n[i.outboundLayer.id]=t,a[i.outboundLayer.id]=i.outboundLayer,s[i.id]=t;for(let n=0;n<i.inboundLayers.length;n++){const o=i.inboundLayers[n],a=i.nodeIndices[n],r=o.inboundNodes[a],u=null==s[r.id]?0:s[r.id];s[r.id]=Math.max(t+1,u),e[r.id]=r}}const g={};for(const i in s){const t=s[i];t in g||(g[t]=[]),g[t].push(e[i])}const b={};for(const i in n){const t=n[i];t in b||(b[t]=[]),b[t].push(a[i])}let N=Object.keys(b).map((t=>parseInt(t,10))).sort(r.th);this.layers=[];for(const i of N){const t=b[i];t.sort(((t,s)=>{const e=u[t.id],n=u[s.id];return e<n?-1:e>n?1:0}));for(const s of t)s instanceof y&&this.internalContainerRefs.push(s),this.layers.push(s)}this.layersByDepth=b,N=Object.keys(g).map((t=>parseInt(t,10))).sort(r.th);const x=this.inputs.slice(),L=[];for(const i of N)for(const t of g[i]){const s=t.outboundLayer;if(null!=s){for(const e of t.inputTensors)if(-1===x.indexOf(e))throw new o.bu(`Graph disconnected: cannot obtain value for tensor ${e} at layer "${s.name}". The following previous layers were accessed without issue: ${L}`);for(const s of t.outputTensors)x.push(s);L.push(s.name)}}this.nodesByDepth=g;const w=this.layers.map((t=>t.name));for(const i of w){const t=w.filter((t=>t===i)).length;if(1!==t)throw new o.bu(`The name "${i}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(w))}this.outboundNodes=[],this.inboundNodes=[],new f.bP({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((t=>null)),outputMasks:this.outputs.map((t=>null)),inputShapes:this.inputs.map((t=>t.shape)),outputShapes:this.outputs.map((t=>t.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const s of this.layers)t.numDisposedVariables+=s.dispose().numDisposedVariables;for(const s of this.internalContainerRefs)t.numDisposedVariables+=s.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach((s=>{s._trainableWeights.forEach((s=>s.trainable=t))})),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new o.Qp("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const s of this.layers)t=t.concat(s.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const s of this.layers)t.push(...s.nonTrainableWeights);if(!this.trainable){const s=[];for(const t of this.layers)s.push(...t.trainableWeights);return s.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,s=!0){const e={};let n=0;for(const a of this.layers)for(const t of a.weights){if(null!=e[t.originalName])throw new o.Qp(`Duplicate weight name: ${t.originalName}`);e[t.originalName]=t,n++}const i=[];for(const a in t){let n=a;if(null==e[a]){const t=a.split("/");n=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=e[n])i.push([e[n],t[a]]);else if(s)throw new o.Qp(`Provided weight data has no target variable: ${a}`);delete e[n]}if(s){const t=[];for(const s in e)t.push(s);if(t.length>0)throw new o.Qp(`${t.length} of ${n} weights are not set: ${t}`)}(0,h.UM)(i)}updatedConfig(){const t=this.getConfig(),s={};return s.className=this.getClassName(),s.config=t,s.kerasVersion=`tfjs-layers ${c.r}`,s.backend="TensorFlow.js",s}toJSON(t,s=!0){const e=(0,u.M)(this.updatedConfig());return s?JSON.stringify(e):e}call(t,s){return(0,n.tidy)((()=>{t=r.st(t);const e=new p.RW;for(let s=0;s<this.inputs.length;++s)e.add(this.inputs[s],t[s]);return(0,p.g7)(this.outputs,e,s)}))}computeMask(t,s){return(0,n.tidy)((()=>{let e;return t=r.st(t),e=null==s?r.fD(null,t.length):r.st(s),this.runInternalGraph(t,e)[1]}))}computeOutputShape(t){const s=l.FS(t);if(s.length!==this.inputLayers.length)throw new o.Qp(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const e={};for(let o=0;o<s.length;o++){const t=this.inputLayers[o],n=s[o];e[t.name+"_0_0"]=n}const n=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(r.th);if(n.length>1)for(const o of n){const t=this.nodesByDepth[o];for(const s of t){const t=s.outboundLayer;if(-1!==this.inputLayers.map((t=>t.id)).indexOf(t.id))continue;const n=[];for(let r=0;r<s.inboundLayers.length;r++){const t=s.inboundLayers[r],i=s.nodeIndices[r],o=s.tensorIndices[r],a=e[`${t.name}_${i}_${o}`];n.push(a)}const i=t.computeOutputShape(r.wL(n)),o=l.FS(i),a=t.inboundNodes.indexOf(s);for(let s=0;s<o.length;s++){e[`${t.name}_${a}_${s}`]=o[s]}}}const i=[],a=[];for(let o=0;o<this.outputLayers.length;o++){const t=this.outputLayers[o],s=this.outputLayersNodeIndices[o],e=this.outputLayersTensorIndices[o],n=`${t.name}_${s}_${e}`;a.push(n)}for(let o=0;o<a.length;o++){const t=a[o];r.vA(t in e),i.push(e[t])}return r.wL(i)}runInternalGraph(t,s){null==s&&(s=r.fD(null,t.length));const e={};for(let o=0;o<this.inputs.length;++o){const n=this.inputs[o],i=t[o],a=s[o];e[n.id]=[i,a]}const n=Object.keys(this.nodesByDepth).map((t=>parseInt(t,10))).sort(r.th);for(const l of n){const t=this.nodesByDepth[l];for(const s of t){const t=s.outboundLayer,n=s.inputTensors,i=s.outputTensors,a=new Array;for(const s of n)s.id in e&&a.push(e[s.id]);if(a.length===n.length){let n,u,l,h,c={};if(null!=s.callArgs&&(c=s.callArgs),1===a.length){const[s,e]=a[0];null==c.mask&&(c.mask=e),l=r.st(t.call(s,c)),h=r.st(t.computeMask(s,e)),n=[s],u=[e]}else n=a.map((t=>t[0])),u=a.map((t=>t[1])),null==c.mask&&(c.mask=u),l=r.st(t.call(n,c)),h=r.st(t.computeMask(n,u));if(t.activityRegularizer)throw new o.EH("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<i.length;++t){const s=i[t],n=l[t],o=h[t];e[s.id]=[n,o]}}}}const i=[],a=[],u=[];for(const o of this.outputs){r.vA(o.id in e,`Could not compute output ${o.name} : ${o.id}`);const[t,s]=e[o.id];u.push(t.shape),i.push(t),a.push(s)}return[i,a,u]}buildNodeConversionMap(t){const s={};let e;for(const n of this.layers){e=n instanceof y?1:0;for(let t=0;t<n.inboundNodes.length;t++){const i=y.nodeKey(n,t);this.containerNodes.has(i)&&(s[i]=e,e+=1)}}return s}getLayer(t,s){if(null!=s){if(this.layers.length<=s)throw new o.Qp(`Was asked to retrieve layer at index ${s}, but model only has ${this.layers.length} layer(s).`);return this.layers[s]}if(null==t)throw new o.Qp("Provide either a layer name or layer index");for(const e of this.layers)if(e.name===t)return e;throw new o.Qp(`No such layer: ${t}`)}calculateLosses(){return(0,n.tidy)((()=>{const t=[];for(const s of this.layers)for(let e=0;e<s.inboundNodes.length;++e){const n=y.nodeKey(s,e);this.containerNodes.has(n)&&t.push(...s.calculateLosses())}return t}))}getConfig(){const t={name:this.name},s=this.buildNodeConversionMap(this.layers),e=[];for(const a of this.layers){const t=a.getClassName(),n=a.getConfig(),i=[];for(let e=0;e<a.inboundNodes.length;e++){const t=a.inboundNodes[e],n=y.nodeKey(a,e);let r={};if(this.containerNodes.has(n)){if(t.callArgs)try{JSON.stringify(t.callArgs),r=t.callArgs}catch(o){r={}}if(t.inboundLayers.length>0){const e=[];for(let n=0;n<t.inboundLayers.length;n++){const i=t.inboundLayers[n],o=t.nodeIndices[n],a=t.tensorIndices[n];let u=s[y.nodeKey(i,o)];null==u&&(u=0),e.push([i.name,u,a,r])}i.push(e)}}}const r={};r.name=a.name,r.className=t,r.config=n,r.inboundNodes=i,e.push(r)}t.layers=e;const n=[];for(let a=0;a<this.inputLayers.length;a++){const t=this.inputLayers[a],e=this.inputLayersNodeIndices[a],i=y.nodeKey(t,e);if(!this.containerNodes.has(i))continue;let o=s[i];null!==o&&void 0!==o||(o=0);const r=this.inputLayersTensorIndices[a];n.push([t.name,o,r])}t.inputLayers=n;const i=[];for(let a=0;a<this.outputLayers.length;a++){const t=this.outputLayers[a],e=this.outputLayersNodeIndices[a],n=y.nodeKey(t,e);if(!this.containerNodes.has(n))continue;let o=s[n];null!==o&&void 0!==o||(o=0);const r=this.outputLayersTensorIndices[a];i.push([t.name,o,r])}return t.outputLayers=i,t}static fromConfig(t,s,e={},n=!1){const i={},u={};function l(t,s){t.name in u?u[t.name].push(s):u[t.name]=[s]}function h(t,s){const e=[];let n;for(const o of s){const a=o[0],r=o[1],u=o[2];if(n=null==o[3]?{}:o[3],!(a in i))return void l(t,s);const h=i[a];if(h.inboundNodes.length<=r)return void l(t,s);const c=h.inboundNodes[r];e.push(c.outputTensors[u])}e.length>0&&t.apply(r.wL(e),n)}function c(t){const e=t.name,r=(0,a.i)(t,null!=s.customObjects?s.customObjects:{});r.setFastWeightInitDuringBuild(n),i[e]=r;t.inboundNodes.forEach((t=>{if(!(t instanceof Array))throw new o.Qp(`Corrupted configuration, expected array for nodeData: ${t}`);l(r,t)}))}const p=s.name,d=s.layers;for(const o of d)c(o);for(;!r.ZF(u);)for(const t of d){const s=i[t.name];if(s.name in u){const t=u[s.name];delete u[s.name];for(const e of t)h(s,e)}}const f=[],y=[],m=s.inputLayers;for(const o of m){const t=o[0],s=o[1],e=o[2];r.vA(t in i);const n=i[t].inboundNodes[s].outputTensors;f.push(n[e])}const g=s.outputLayers;for(const o of g){const t=o[0],s=o[1],e=o[2];r.vA(t in i);const n=i[t].inboundNodes[s].outputTensors;y.push(n[e])}return new t({inputs:f,outputs:y,name:p})}get stateful(){if(this._stateful)throw new o.Qp("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){(0,n.tidy)((()=>{this.layers.forEach((t=>{t.stateful&&t.resetStates()}))}))}}},39459:function(t,s,e){e.d(s,{BC:function(){return d},IU:function(){return p},Kx:function(){return l},Uc:function(){return f},tB:function(){return u},uM:function(){return a},uU:function(){return r}});var n=e(84604),i=e(44813);const o=new Map;function a(t){(0,i.E6)(n.To,"DataFormat",t)}function r(t){(0,i.E6)(n.ft,"InterpolationFormat",t)}function u(t){(0,i.E6)(n.EY,"PaddingMode",t)}function l(t){(0,i.E6)(n.bb,"PoolMode",t)}const h=[],c="/";function p(t,s){h.push(t);try{const t=s();return h.pop(),t}catch(e){throw h.pop(),e}}function d(t){if(!m(t))throw new Error("Not a valid tensor name: '"+t+"'");return(0===h.length?"":h.join(c)+c)+t}function f(t){if(!m(t))throw new Error("Not a valid tensor name: '"+t+"'");o.has(t)||o.set(t,0);const s=o.get(t);if(o.set(t,o.get(t)+1),s>0){const e=`${t}_${s}`;return o.set(e,1),e}return t}const y=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function m(t){return!!t.match(y)}},49044:function(t,s,e){var n=e(85244);e(71837),e(15841),e(96681);n.J5},87504:function(t,s,e){e.d(s,{YZ:function(){return y},uH:function(){return d}});var n=e(9495),i=e(6090),o=e(44813);function a(t,s){return(0,n.tidy)((()=>n.sqrt(n.sum(n.mul(t,t),s,!0))))}class r extends n.serialization.Serializable{getConfig(){return{}}}class u extends r{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return(0,n.tidy)((()=>{const s=a(t,this.axis),e=n.clipByValue(s,0,this.maxValue);return n.mul(t,n.div(e,n.add((0,i.Ni)(),s)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}u.className="MaxNorm",n.serialization.registerClass(u);class l extends r{constructor(t){super(),this.defaultAxis=0,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return(0,n.tidy)((()=>n.div(t,n.add((0,i.Ni)(),a(t,this.axis)))))}getConfig(){return{axis:this.axis}}}l.className="UnitNorm",n.serialization.registerClass(l);class h extends r{apply(t){return n.relu(t)}}h.className="NonNeg",n.serialization.registerClass(h);class c extends r{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=t.minValue?t.minValue:this.defaultMinValue,this.maxValue=null!=t.maxValue?t.maxValue:this.defaultMaxValue,this.rate=null!=t.rate?t.rate:this.defaultRate,this.axis=null!=t.axis?t.axis:this.defaultAxis}apply(t){return(0,n.tidy)((()=>{const s=a(t,this.axis),e=n.add(n.mul(this.rate,n.clipByValue(s,this.minValue,this.maxValue)),n.mul(1-this.rate,s));return n.mul(t,n.div(e,n.add((0,i.Ni)(),s)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}c.className="MinMaxNorm",n.serialization.registerClass(c);const p={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function d(t){return(0,o.k4)(t)}function f(t,s={}){return(0,o.Xv)(t,n.serialization.SerializationMap.getMap().classNameMap,s,"constraint")}function y(t){if(null==t)return null;if("string"===typeof t){return f({className:t in p?p[t]:t,config:{}})}return t instanceof r?t:f(t)}}}]);
//# sourceMappingURL=stylist-vendors-75b6a1ac.f794190d38d7493ceb89.js.map