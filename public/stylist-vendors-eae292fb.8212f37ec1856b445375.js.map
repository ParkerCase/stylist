{"version":3,"file":"stylist-vendors-eae292fb.8212f37ec1856b445375.js","mappings":"uMAoBO,MAAMA,UAA0B,KAUnC,UAAAC,GACI,OAAO,IAAIC,EAAaC,KAC5B,EAWJ,MAAMD,UAAqB,IACvB,WAAAE,CAAYC,GACRC,QACAH,KAAKE,SAAWA,EAChBF,KAAKI,KAAO,IAAIC,EAAiBH,EACrC,CACA,OAAAI,GACI,OAAON,KAAKI,KAAKE,SACrB,CACA,UAAMC,GACF,OAAOP,KAAKI,KAAKG,MACrB,EAwBJ,MAAMF,UAAyB,KAC3B,WAAAJ,CAAYC,GAGR,GAFAC,QACAH,KAAKE,SAAWA,GACZ,IAAAM,OAAMC,IAAI,cACVT,KAAKU,QAAU,IAAIC,YAAY,aAE9B,CAED,MAAM,cAAEC,GAAkB,EAAQ,MAClCZ,KAAKU,QAAU,IAAIE,EAAc,OACrC,CACJ,CACA,OAAAN,GACI,MAAO,GAAGN,KAAKE,SAASI,mBAC5B,CACA,UAAMO,GACF,MAAMC,QAAoBd,KAAKE,SAASK,OACxC,IAAIQ,EAOAC,EANJ,OAAIF,EAAYG,OAIZF,EAAQD,EAAYI,MAIpBF,GADA,IAAAR,OAAMC,IAAI,cACHT,KAAKU,QAAQS,OAAOJ,EAAO,CAAEK,QAAQ,IAGrCpB,KAAKU,QAAQW,MAAMC,EAAOC,KAAKR,EAAMS,SAEhDxB,KAAKyB,YAAYC,KAAKV,IACf,EACX,ECrFG,MAAMW,UAA0B9B,EACnC,WAAAI,CAAY2B,EAAMC,EAAU,CAAC,GACzB1B,QACAH,KAAK4B,KAAOA,EACZ5B,KAAK6B,QAAUA,EACf,EAAAC,KAAA,OAAaF,aAAgBG,eACxB,IAAAvB,OAAMC,IAAI,gBACNmB,aAAgBI,MAAQJ,aAAgBK,OACjC,IAAM,yEAEtBjC,KAAKkC,OAASL,EAAQK,QAAU,EAEhClC,KAAKmC,UAAYN,EAAQM,WAAa,OAC1C,CACA,OAAA7B,GACI,MAAO,cAAcN,KAAK4B,MAC9B,CACA,UAAMrB,GACF,GAAIP,KAAKkC,SAAYlC,KAAK4B,gBAAgBG,WACtC/B,KAAK4B,KAAKQ,WACVpC,KAAK4B,KAAKS,MACV,MAAO,CAAEnB,MAAO,KAAMD,MAAM,GAEhC,MAAMF,EAAQ,IAAIuB,SAAQ,CAACC,EAASC,KAChC,MAAMC,EAAMzC,KAAKkC,OAASlC,KAAKmC,UAC/B,GAAInC,KAAK4B,gBAAgBG,WAGrBQ,EAAQ,IAAIR,WAAW/B,KAAK4B,KAAKc,MAAM1C,KAAKkC,OAAQO,SAEnD,CAID,MAAME,EAAa,IAAIC,WACvBD,EAAWE,OAAUC,IACjB,IAAIC,EAAOJ,EAAWK,OAOtB,GAHID,aAAgBE,cAChBF,EAAO,IAAIhB,WAAWgB,MAEpBA,aAAgBhB,YAClB,OAAOS,EAAO,IAAIU,UAAU,sCAEhCX,EAAQQ,EAAK,EAEjBJ,EAAWQ,QAAWL,GACXN,EAAO,IAAIY,MAAM,YAE5BT,EAAWU,QAAWP,GACXN,EAAO,IAAIY,MAAMN,EAAMQ,OAIlC,MAAMZ,EAAQ1C,KAAK4B,KAAKc,MAAM1C,KAAKkC,OAAQO,GAG3CE,EAAWY,kBAAkBb,EACjC,CACA1C,KAAKkC,OAASO,CAAG,IAErB,MAAO,CAAEvB,YAAcH,EAAQE,MAAM,EACzC,E","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-data/dist/iterators/byte_chunk_iterator.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-data/dist/iterators/file_chunk_iterator.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { LazyIterator, OneToManyIterator } from './lazy_iterator';\nimport { StringIterator } from './string_iterator';\nexport class ByteChunkIterator extends LazyIterator {\n    /**\n     * Decode a stream of UTF8-encoded byte arrays to a stream of strings.\n     *\n     * The byte arrays producetd from the ByteChunkIterator on which this is\n     * called will be interpreted as concatenated.  No assumptions are made about\n     * the boundaries of the incoming chunks, so a multi-byte UTF8 encoding of a\n     * character may span the boundary between chunks.  This naturally happens,\n     * for instance, when reading fixed-size byte arrays from a file.\n     */\n    decodeUTF8() {\n        return new Utf8Iterator(this);\n    }\n}\n// ============================================================================\n// The following private classes serve to implement the chainable methods\n// on ByteChunkIterator.  Unfortunately they can't be placed in separate files,\n// due to resulting trouble with circular imports.\n// ============================================================================\n// We wanted multiple inheritance, e.g.\n//   class Utf8Iterator extends QueueIterator<string>, StringIterator\n// but the TypeScript mixin approach is a bit hacky, so we take this adapter\n// approach instead.\nclass Utf8Iterator extends StringIterator {\n    constructor(upstream) {\n        super();\n        this.upstream = upstream;\n        this.impl = new Utf8IteratorImpl(upstream);\n    }\n    summary() {\n        return this.impl.summary();\n    }\n    async next() {\n        return this.impl.next();\n    }\n}\n/**\n * Decode a stream of UTF8-encoded byte arrays to a stream of strings.\n *\n * This is tricky because the incoming byte array boundaries may disrupt a\n * multi-byte UTF8 character. Thus any incomplete character data at the end of\n * a chunk must be carried over and prepended to the next chunk before\n * decoding. Luckily with native decoder, TextDecoder in browser and\n * string_decoder in node, byte array boundaries are handled automatically.\n *\n * In the context of an input pipeline for machine learning, UTF8 decoding is\n * needed to parse text files containing training examples or prediction\n * requests (e.g., formatted as CSV or JSON). We cannot use the built-in\n * decoding provided by FileReader.readAsText() because here we are in a\n * streaming context, which FileReader does not support.\n *\n * @param upstream A `LazyIterator` of `Uint8Arrays` containing UTF8-encoded\n *   text, which should be interpreted as concatenated.  No assumptions are\n *   made about the boundaries of the incoming chunks, so a multi-byte UTF8\n *   encoding of a character may span the boundary between chunks.  This\n *   naturally happens, for instance, when reading fixed-size byte arrays from a\n *   file.\n */\nclass Utf8IteratorImpl extends OneToManyIterator {\n    constructor(upstream) {\n        super();\n        this.upstream = upstream;\n        if (env().get('IS_BROWSER')) {\n            this.decoder = new TextDecoder('utf-8');\n        }\n        else {\n            // tslint:disable-next-line:no-require-imports\n            const { StringDecoder } = require('string_decoder');\n            this.decoder = new StringDecoder('utf8');\n        }\n    }\n    summary() {\n        return `${this.upstream.summary()} -> Utf8`;\n    }\n    async pump() {\n        const chunkResult = await this.upstream.next();\n        let chunk;\n        if (chunkResult.done) {\n            return false;\n        }\n        else {\n            chunk = chunkResult.value;\n        }\n        let text;\n        if (env().get('IS_BROWSER')) {\n            text = this.decoder.decode(chunk, { stream: true });\n        }\n        else {\n            text = this.decoder.write(Buffer.from(chunk.buffer));\n        }\n        this.outputQueue.push(text);\n        return true;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnl0ZV9jaHVua19pdGVyYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtZGF0YS9zcmMvaXRlcmF0b3JzL2J5dGVfY2h1bmtfaXRlcmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFFSCxPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDMUMsT0FBTyxFQUFDLFlBQVksRUFBRSxpQkFBaUIsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQ2hFLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUVqRCxNQUFNLE9BQWdCLGlCQUFrQixTQUFRLFlBQXdCO0lBQ3RFOzs7Ozs7OztPQVFHO0lBQ0gsVUFBVTtRQUNSLE9BQU8sSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEMsQ0FBQztDQUNGO0FBRUQsK0VBQStFO0FBQy9FLHlFQUF5RTtBQUN6RSwrRUFBK0U7QUFDL0Usa0RBQWtEO0FBQ2xELCtFQUErRTtBQUUvRSx1Q0FBdUM7QUFDdkMscUVBQXFFO0FBQ3JFLDRFQUE0RTtBQUM1RSxvQkFBb0I7QUFFcEIsTUFBTSxZQUFhLFNBQVEsY0FBYztJQUd2QyxZQUFzQixRQUFrQztRQUN0RCxLQUFLLEVBQUUsQ0FBQztRQURZLGFBQVEsR0FBUixRQUFRLENBQTBCO1FBRXRELElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQsT0FBTztRQUNMLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQsS0FBSyxDQUFDLElBQUk7UUFDUixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDMUIsQ0FBQztDQUNGO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCRztBQUNILE1BQU0sZ0JBQWlCLFNBQVEsaUJBQXlCO0lBTXRELFlBQStCLFFBQWtDO1FBQy9ELEtBQUssRUFBRSxDQUFDO1FBRHFCLGFBQVEsR0FBUixRQUFRLENBQTBCO1FBRS9ELElBQUksR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxFQUFFO1lBQzNCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDekM7YUFBTTtZQUNMLDhDQUE4QztZQUM5QyxNQUFNLEVBQUMsYUFBYSxFQUFDLEdBQUcsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFDbEQsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUMxQztJQUNILENBQUM7SUFDRCxPQUFPO1FBQ0wsT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQztJQUM5QyxDQUFDO0lBRUQsS0FBSyxDQUFDLElBQUk7UUFDUixNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDL0MsSUFBSSxLQUFLLENBQUM7UUFDVixJQUFJLFdBQVcsQ0FBQyxJQUFJLEVBQUU7WUFDcEIsT0FBTyxLQUFLLENBQUM7U0FDZDthQUFNO1lBQ0wsS0FBSyxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUM7U0FDM0I7UUFFRCxJQUFJLElBQVksQ0FBQztRQUNqQixJQUFJLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsRUFBRTtZQUMzQixJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLEVBQUMsTUFBTSxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7U0FDbkQ7YUFBTTtZQUNMLElBQUksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1NBQ3REO1FBQ0QsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2Vudn0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7TGF6eUl0ZXJhdG9yLCBPbmVUb01hbnlJdGVyYXRvcn0gZnJvbSAnLi9sYXp5X2l0ZXJhdG9yJztcbmltcG9ydCB7U3RyaW5nSXRlcmF0b3J9IGZyb20gJy4vc3RyaW5nX2l0ZXJhdG9yJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJ5dGVDaHVua0l0ZXJhdG9yIGV4dGVuZHMgTGF6eUl0ZXJhdG9yPFVpbnQ4QXJyYXk+IHtcbiAgLyoqXG4gICAqIERlY29kZSBhIHN0cmVhbSBvZiBVVEY4LWVuY29kZWQgYnl0ZSBhcnJheXMgdG8gYSBzdHJlYW0gb2Ygc3RyaW5ncy5cbiAgICpcbiAgICogVGhlIGJ5dGUgYXJyYXlzIHByb2R1Y2V0ZCBmcm9tIHRoZSBCeXRlQ2h1bmtJdGVyYXRvciBvbiB3aGljaCB0aGlzIGlzXG4gICAqIGNhbGxlZCB3aWxsIGJlIGludGVycHJldGVkIGFzIGNvbmNhdGVuYXRlZC4gIE5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIGFib3V0XG4gICAqIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBpbmNvbWluZyBjaHVua3MsIHNvIGEgbXVsdGktYnl0ZSBVVEY4IGVuY29kaW5nIG9mIGFcbiAgICogY2hhcmFjdGVyIG1heSBzcGFuIHRoZSBib3VuZGFyeSBiZXR3ZWVuIGNodW5rcy4gIFRoaXMgbmF0dXJhbGx5IGhhcHBlbnMsXG4gICAqIGZvciBpbnN0YW5jZSwgd2hlbiByZWFkaW5nIGZpeGVkLXNpemUgYnl0ZSBhcnJheXMgZnJvbSBhIGZpbGUuXG4gICAqL1xuICBkZWNvZGVVVEY4KCk6IFN0cmluZ0l0ZXJhdG9yIHtcbiAgICByZXR1cm4gbmV3IFV0ZjhJdGVyYXRvcih0aGlzKTtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBUaGUgZm9sbG93aW5nIHByaXZhdGUgY2xhc3NlcyBzZXJ2ZSB0byBpbXBsZW1lbnQgdGhlIGNoYWluYWJsZSBtZXRob2RzXG4vLyBvbiBCeXRlQ2h1bmtJdGVyYXRvci4gIFVuZm9ydHVuYXRlbHkgdGhleSBjYW4ndCBiZSBwbGFjZWQgaW4gc2VwYXJhdGUgZmlsZXMsXG4vLyBkdWUgdG8gcmVzdWx0aW5nIHRyb3VibGUgd2l0aCBjaXJjdWxhciBpbXBvcnRzLlxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyBXZSB3YW50ZWQgbXVsdGlwbGUgaW5oZXJpdGFuY2UsIGUuZy5cbi8vICAgY2xhc3MgVXRmOEl0ZXJhdG9yIGV4dGVuZHMgUXVldWVJdGVyYXRvcjxzdHJpbmc+LCBTdHJpbmdJdGVyYXRvclxuLy8gYnV0IHRoZSBUeXBlU2NyaXB0IG1peGluIGFwcHJvYWNoIGlzIGEgYml0IGhhY2t5LCBzbyB3ZSB0YWtlIHRoaXMgYWRhcHRlclxuLy8gYXBwcm9hY2ggaW5zdGVhZC5cblxuY2xhc3MgVXRmOEl0ZXJhdG9yIGV4dGVuZHMgU3RyaW5nSXRlcmF0b3Ige1xuICBwcml2YXRlIGltcGw6IFV0ZjhJdGVyYXRvckltcGw7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHVwc3RyZWFtOiBMYXp5SXRlcmF0b3I8VWludDhBcnJheT4pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaW1wbCA9IG5ldyBVdGY4SXRlcmF0b3JJbXBsKHVwc3RyZWFtKTtcbiAgfVxuXG4gIHN1bW1hcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1wbC5zdW1tYXJ5KCk7XG4gIH1cblxuICBhc3luYyBuZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmltcGwubmV4dCgpO1xuICB9XG59XG5cbi8qKlxuICogRGVjb2RlIGEgc3RyZWFtIG9mIFVURjgtZW5jb2RlZCBieXRlIGFycmF5cyB0byBhIHN0cmVhbSBvZiBzdHJpbmdzLlxuICpcbiAqIFRoaXMgaXMgdHJpY2t5IGJlY2F1c2UgdGhlIGluY29taW5nIGJ5dGUgYXJyYXkgYm91bmRhcmllcyBtYXkgZGlzcnVwdCBhXG4gKiBtdWx0aS1ieXRlIFVURjggY2hhcmFjdGVyLiBUaHVzIGFueSBpbmNvbXBsZXRlIGNoYXJhY3RlciBkYXRhIGF0IHRoZSBlbmQgb2ZcbiAqIGEgY2h1bmsgbXVzdCBiZSBjYXJyaWVkIG92ZXIgYW5kIHByZXBlbmRlZCB0byB0aGUgbmV4dCBjaHVuayBiZWZvcmVcbiAqIGRlY29kaW5nLiBMdWNraWx5IHdpdGggbmF0aXZlIGRlY29kZXIsIFRleHREZWNvZGVyIGluIGJyb3dzZXIgYW5kXG4gKiBzdHJpbmdfZGVjb2RlciBpbiBub2RlLCBieXRlIGFycmF5IGJvdW5kYXJpZXMgYXJlIGhhbmRsZWQgYXV0b21hdGljYWxseS5cbiAqXG4gKiBJbiB0aGUgY29udGV4dCBvZiBhbiBpbnB1dCBwaXBlbGluZSBmb3IgbWFjaGluZSBsZWFybmluZywgVVRGOCBkZWNvZGluZyBpc1xuICogbmVlZGVkIHRvIHBhcnNlIHRleHQgZmlsZXMgY29udGFpbmluZyB0cmFpbmluZyBleGFtcGxlcyBvciBwcmVkaWN0aW9uXG4gKiByZXF1ZXN0cyAoZS5nLiwgZm9ybWF0dGVkIGFzIENTViBvciBKU09OKS4gV2UgY2Fubm90IHVzZSB0aGUgYnVpbHQtaW5cbiAqIGRlY29kaW5nIHByb3ZpZGVkIGJ5IEZpbGVSZWFkZXIucmVhZEFzVGV4dCgpIGJlY2F1c2UgaGVyZSB3ZSBhcmUgaW4gYVxuICogc3RyZWFtaW5nIGNvbnRleHQsIHdoaWNoIEZpbGVSZWFkZXIgZG9lcyBub3Qgc3VwcG9ydC5cbiAqXG4gKiBAcGFyYW0gdXBzdHJlYW0gQSBgTGF6eUl0ZXJhdG9yYCBvZiBgVWludDhBcnJheXNgIGNvbnRhaW5pbmcgVVRGOC1lbmNvZGVkXG4gKiAgIHRleHQsIHdoaWNoIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBjb25jYXRlbmF0ZWQuICBObyBhc3N1bXB0aW9ucyBhcmVcbiAqICAgbWFkZSBhYm91dCB0aGUgYm91bmRhcmllcyBvZiB0aGUgaW5jb21pbmcgY2h1bmtzLCBzbyBhIG11bHRpLWJ5dGUgVVRGOFxuICogICBlbmNvZGluZyBvZiBhIGNoYXJhY3RlciBtYXkgc3BhbiB0aGUgYm91bmRhcnkgYmV0d2VlbiBjaHVua3MuICBUaGlzXG4gKiAgIG5hdHVyYWxseSBoYXBwZW5zLCBmb3IgaW5zdGFuY2UsIHdoZW4gcmVhZGluZyBmaXhlZC1zaXplIGJ5dGUgYXJyYXlzIGZyb20gYVxuICogICBmaWxlLlxuICovXG5jbGFzcyBVdGY4SXRlcmF0b3JJbXBsIGV4dGVuZHMgT25lVG9NYW55SXRlcmF0b3I8c3RyaW5nPiB7XG4gIC8vIGBkZWNvZGVyYCBhcyBgYW55YCBoZXJlIHRvIGR5bmFtaWNhbGx5IGFzc2lnbiB2YWx1ZSBiYXNlZCBvbiB0aGVcbiAgLy8gZW52aXJvbm1lbnQuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgZGVjb2RlcjogYW55O1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCByZWFkb25seSB1cHN0cmVhbTogTGF6eUl0ZXJhdG9yPFVpbnQ4QXJyYXk+KSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoZW52KCkuZ2V0KCdJU19CUk9XU0VSJykpIHtcbiAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgY29uc3Qge1N0cmluZ0RlY29kZXJ9ID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKTtcbiAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCd1dGY4Jyk7XG4gICAgfVxuICB9XG4gIHN1bW1hcnkoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMudXBzdHJlYW0uc3VtbWFyeSgpfSAtPiBVdGY4YDtcbiAgfVxuXG4gIGFzeW5jIHB1bXAoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgY2h1bmtSZXN1bHQgPSBhd2FpdCB0aGlzLnVwc3RyZWFtLm5leHQoKTtcbiAgICBsZXQgY2h1bms7XG4gICAgaWYgKGNodW5rUmVzdWx0LmRvbmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2h1bmsgPSBjaHVua1Jlc3VsdC52YWx1ZTtcbiAgICB9XG5cbiAgICBsZXQgdGV4dDogc3RyaW5nO1xuICAgIGlmIChlbnYoKS5nZXQoJ0lTX0JST1dTRVInKSkge1xuICAgICAgdGV4dCA9IHRoaXMuZGVjb2Rlci5kZWNvZGUoY2h1bmssIHtzdHJlYW06IHRydWV9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dCA9IHRoaXMuZGVjb2Rlci53cml0ZShCdWZmZXIuZnJvbShjaHVuay5idWZmZXIpKTtcbiAgICB9XG4gICAgdGhpcy5vdXRwdXRRdWV1ZS5wdXNoKHRleHQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\n// inspired by https://github.com/maxogden/filereader-stream\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { ByteChunkIterator } from './byte_chunk_iterator';\n/**\n * Provide a stream of chunks from a File, Blob, or Uint8Array.\n * @param file The source File, Blob or Uint8Array.\n * @param options Optional settings controlling file reading.\n * @returns a lazy Iterator of Uint8Arrays containing sequential chunks of the\n *   input File, Blob or Uint8Array.\n */\nexport class FileChunkIterator extends ByteChunkIterator {\n    constructor(file, options = {}) {\n        super();\n        this.file = file;\n        this.options = options;\n        util.assert((file instanceof Uint8Array) ||\n            (env().get('IS_BROWSER') ?\n                (file instanceof File || file instanceof Blob) :\n                false), () => 'FileChunkIterator only supports File, Blob and Uint8Array ' +\n            'right now.');\n        this.offset = options.offset || 0;\n        // default 1MB chunk has tolerable perf on large files\n        this.chunkSize = options.chunkSize || 1024 * 1024;\n    }\n    summary() {\n        return `FileChunks ${this.file}`;\n    }\n    async next() {\n        if (this.offset >= ((this.file instanceof Uint8Array) ?\n            this.file.byteLength :\n            this.file.size)) {\n            return { value: null, done: true };\n        }\n        const chunk = new Promise((resolve, reject) => {\n            const end = this.offset + this.chunkSize;\n            if (this.file instanceof Uint8Array) {\n                // Note if end > this.uint8Array.byteLength, we just get a small last\n                // chunk.\n                resolve(new Uint8Array(this.file.slice(this.offset, end)));\n            }\n            else {\n                // This branch assumes that this.file type is File or Blob, which\n                // means it is in the browser environment.\n                // TODO(soergel): is this a performance issue?\n                const fileReader = new FileReader();\n                fileReader.onload = (event) => {\n                    let data = fileReader.result;\n                    // Not sure we can trust the return type of\n                    // FileReader.readAsArrayBuffer See e.g.\n                    // https://github.com/node-file-api/FileReader/issues/2\n                    if (data instanceof ArrayBuffer) {\n                        data = new Uint8Array(data);\n                    }\n                    if (!(data instanceof Uint8Array)) {\n                        return reject(new TypeError('FileReader returned unknown type.'));\n                    }\n                    resolve(data);\n                };\n                fileReader.onabort = (event) => {\n                    return reject(new Error('Aborted'));\n                };\n                fileReader.onerror = (event) => {\n                    return reject(new Error(event.type));\n                };\n                // TODO(soergel): better handle onabort, onerror\n                // Note if end > this.file.size, we just get a small last chunk.\n                const slice = this.file.slice(this.offset, end);\n                // We can't use readAsText here (even if we know the file is text)\n                // because the slice boundary may fall within a multi-byte character.\n                fileReader.readAsArrayBuffer(slice);\n            }\n            this.offset = end;\n        });\n        return { value: (await chunk), done: false };\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZV9jaHVua19pdGVyYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtZGF0YS9zcmMvaXRlcmF0b3JzL2ZpbGVfY2h1bmtfaXRlcmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFFSCw0REFBNEQ7QUFDNUQsT0FBTyxFQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUVoRCxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQVN4RDs7Ozs7O0dBTUc7QUFDSCxNQUFNLE9BQU8saUJBQWtCLFNBQVEsaUJBQWlCO0lBSXRELFlBQ2MsSUFBaUIsRUFDakIsVUFBb0MsRUFBRTtRQUNsRCxLQUFLLEVBQUUsQ0FBQztRQUZJLFNBQUksR0FBSixJQUFJLENBQWE7UUFDakIsWUFBTyxHQUFQLE9BQU8sQ0FBK0I7UUFFbEQsSUFBSSxDQUFDLE1BQU0sQ0FDUCxDQUFDLElBQUksWUFBWSxVQUFVLENBQUM7WUFDeEIsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztnQkFDckIsQ0FBQyxJQUFJLFlBQVksSUFBSSxJQUFJLElBQUksWUFBWSxJQUFJLENBQUMsQ0FBQyxDQUFDO2dCQUNoRCxLQUFLLENBQUMsRUFDZixHQUFHLEVBQUUsQ0FBQyw0REFBNEQ7WUFDOUQsWUFBWSxDQUFDLENBQUM7UUFDdEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQztRQUNsQyxzREFBc0Q7UUFDdEQsSUFBSSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7SUFDcEQsQ0FBQztJQUVELE9BQU87UUFDTCxPQUFPLGNBQWMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFRCxLQUFLLENBQUMsSUFBSTtRQUNSLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksWUFBWSxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQy9CLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN2QyxPQUFPLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFDLENBQUM7U0FDbEM7UUFDRCxNQUFNLEtBQUssR0FBRyxJQUFJLE9BQU8sQ0FBYSxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtZQUN4RCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDekMsSUFBSSxJQUFJLENBQUMsSUFBSSxZQUFZLFVBQVUsRUFBRTtnQkFDbkMscUVBQXFFO2dCQUNyRSxTQUFTO2dCQUNULE9BQU8sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUM1RDtpQkFBTTtnQkFDTCxpRUFBaUU7Z0JBQ2pFLDBDQUEwQztnQkFFMUMsOENBQThDO2dCQUM5QyxNQUFNLFVBQVUsR0FBRyxJQUFJLFVBQVUsRUFBRSxDQUFDO2dCQUNwQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsS0FBSyxFQUFFLEVBQUU7b0JBQzVCLElBQUksSUFBSSxHQUFrQyxVQUFVLENBQUMsTUFBTSxDQUFDO29CQUM1RCwyQ0FBMkM7b0JBQzNDLHdDQUF3QztvQkFDeEMsdURBQXVEO29CQUN2RCxJQUFJLElBQUksWUFBWSxXQUFXLEVBQUU7d0JBQy9CLElBQUksR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztxQkFDN0I7b0JBQ0QsSUFBSSxDQUFDLENBQUMsSUFBSSxZQUFZLFVBQVUsQ0FBQyxFQUFFO3dCQUNqQyxPQUFPLE1BQU0sQ0FBQyxJQUFJLFNBQVMsQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDLENBQUM7cUJBQ25FO29CQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDaEIsQ0FBQyxDQUFDO2dCQUNGLFVBQVUsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxLQUFLLEVBQUUsRUFBRTtvQkFDN0IsT0FBTyxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztnQkFDdEMsQ0FBQyxDQUFDO2dCQUNGLFVBQVUsQ0FBQyxPQUFPLEdBQUcsQ0FBQyxLQUFLLEVBQUUsRUFBRTtvQkFDN0IsT0FBTyxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ3ZDLENBQUMsQ0FBQztnQkFDRixnREFBZ0Q7Z0JBQ2hELGdFQUFnRTtnQkFDaEUsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFDaEQsa0VBQWtFO2dCQUNsRSxxRUFBcUU7Z0JBQ3JFLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUNyQztZQUNELElBQUksQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO1FBQ3BCLENBQUMsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxFQUFDLEtBQUssRUFBRSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBQyxDQUFDO0lBQzdDLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXhvZ2Rlbi9maWxlcmVhZGVyLXN0cmVhbVxuaW1wb3J0IHtlbnYsIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge0ZpbGVFbGVtZW50fSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge0J5dGVDaHVua0l0ZXJhdG9yfSBmcm9tICcuL2J5dGVfY2h1bmtfaXRlcmF0b3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVDaHVua0l0ZXJhdG9yT3B0aW9ucyB7XG4gIC8qKiBUaGUgYnl0ZSBvZmZzZXQgYXQgd2hpY2ggdG8gYmVnaW4gcmVhZGluZyB0aGUgRmlsZSBvciBCbG9iLiBEZWZhdWx0IDAuICovXG4gIG9mZnNldD86IG51bWJlcjtcbiAgLyoqIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZCBhdCBhIHRpbWUuIERlZmF1bHQgMU1CLiAqL1xuICBjaHVua1NpemU/OiBudW1iZXI7XG59XG5cbi8qKlxuICogUHJvdmlkZSBhIHN0cmVhbSBvZiBjaHVua3MgZnJvbSBhIEZpbGUsIEJsb2IsIG9yIFVpbnQ4QXJyYXkuXG4gKiBAcGFyYW0gZmlsZSBUaGUgc291cmNlIEZpbGUsIEJsb2Igb3IgVWludDhBcnJheS5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIHNldHRpbmdzIGNvbnRyb2xsaW5nIGZpbGUgcmVhZGluZy5cbiAqIEByZXR1cm5zIGEgbGF6eSBJdGVyYXRvciBvZiBVaW50OEFycmF5cyBjb250YWluaW5nIHNlcXVlbnRpYWwgY2h1bmtzIG9mIHRoZVxuICogICBpbnB1dCBGaWxlLCBCbG9iIG9yIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWxlQ2h1bmtJdGVyYXRvciBleHRlbmRzIEJ5dGVDaHVua0l0ZXJhdG9yIHtcbiAgb2Zmc2V0OiBudW1iZXI7XG4gIGNodW5rU2l6ZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJvdGVjdGVkIGZpbGU6IEZpbGVFbGVtZW50LFxuICAgICAgcHJvdGVjdGVkIG9wdGlvbnM6IEZpbGVDaHVua0l0ZXJhdG9yT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgKGZpbGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB8fFxuICAgICAgICAgICAgKGVudigpLmdldCgnSVNfQlJPV1NFUicpID9cbiAgICAgICAgICAgICAgICAgKGZpbGUgaW5zdGFuY2VvZiBGaWxlIHx8IGZpbGUgaW5zdGFuY2VvZiBCbG9iKSA6XG4gICAgICAgICAgICAgICAgIGZhbHNlKSxcbiAgICAgICAgKCkgPT4gJ0ZpbGVDaHVua0l0ZXJhdG9yIG9ubHkgc3VwcG9ydHMgRmlsZSwgQmxvYiBhbmQgVWludDhBcnJheSAnICtcbiAgICAgICAgICAgICdyaWdodCBub3cuJyk7XG4gICAgdGhpcy5vZmZzZXQgPSBvcHRpb25zLm9mZnNldCB8fCAwO1xuICAgIC8vIGRlZmF1bHQgMU1CIGNodW5rIGhhcyB0b2xlcmFibGUgcGVyZiBvbiBsYXJnZSBmaWxlc1xuICAgIHRoaXMuY2h1bmtTaXplID0gb3B0aW9ucy5jaHVua1NpemUgfHwgMTAyNCAqIDEwMjQ7XG4gIH1cblxuICBzdW1tYXJ5KCkge1xuICAgIHJldHVybiBgRmlsZUNodW5rcyAke3RoaXMuZmlsZX1gO1xuICB9XG5cbiAgYXN5bmMgbmV4dCgpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PFVpbnQ4QXJyYXk+PiB7XG4gICAgaWYgKHRoaXMub2Zmc2V0ID49ICgodGhpcy5maWxlIGluc3RhbmNlb2YgVWludDhBcnJheSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZS5ieXRlTGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGUuc2l6ZSkpIHtcbiAgICAgIHJldHVybiB7dmFsdWU6IG51bGwsIGRvbmU6IHRydWV9O1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IG5ldyBQcm9taXNlPFVpbnQ4QXJyYXk+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGVuZCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5jaHVua1NpemU7XG4gICAgICBpZiAodGhpcy5maWxlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAvLyBOb3RlIGlmIGVuZCA+IHRoaXMudWludDhBcnJheS5ieXRlTGVuZ3RoLCB3ZSBqdXN0IGdldCBhIHNtYWxsIGxhc3RcbiAgICAgICAgLy8gY2h1bmsuXG4gICAgICAgIHJlc29sdmUobmV3IFVpbnQ4QXJyYXkodGhpcy5maWxlLnNsaWNlKHRoaXMub2Zmc2V0LCBlbmQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGJyYW5jaCBhc3N1bWVzIHRoYXQgdGhpcy5maWxlIHR5cGUgaXMgRmlsZSBvciBCbG9iLCB3aGljaFxuICAgICAgICAvLyBtZWFucyBpdCBpcyBpbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudC5cblxuICAgICAgICAvLyBUT0RPKHNvZXJnZWwpOiBpcyB0aGlzIGEgcGVyZm9ybWFuY2UgaXNzdWU/XG4gICAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgIGxldCBkYXRhOiBzdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheSA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICAgIC8vIE5vdCBzdXJlIHdlIGNhbiB0cnVzdCB0aGUgcmV0dXJuIHR5cGUgb2ZcbiAgICAgICAgICAvLyBGaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyIFNlZSBlLmcuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmlsZS1hcGkvRmlsZVJlYWRlci9pc3N1ZXMvMlxuICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0ZpbGVSZWFkZXIgcmV0dXJuZWQgdW5rbm93biB0eXBlLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgZmlsZVJlYWRlci5vbmFib3J0ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ0Fib3J0ZWQnKSk7XG4gICAgICAgIH07XG4gICAgICAgIGZpbGVSZWFkZXIub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGV2ZW50LnR5cGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVE9ETyhzb2VyZ2VsKTogYmV0dGVyIGhhbmRsZSBvbmFib3J0LCBvbmVycm9yXG4gICAgICAgIC8vIE5vdGUgaWYgZW5kID4gdGhpcy5maWxlLnNpemUsIHdlIGp1c3QgZ2V0IGEgc21hbGwgbGFzdCBjaHVuay5cbiAgICAgICAgY29uc3Qgc2xpY2UgPSB0aGlzLmZpbGUuc2xpY2UodGhpcy5vZmZzZXQsIGVuZCk7XG4gICAgICAgIC8vIFdlIGNhbid0IHVzZSByZWFkQXNUZXh0IGhlcmUgKGV2ZW4gaWYgd2Uga25vdyB0aGUgZmlsZSBpcyB0ZXh0KVxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBzbGljZSBib3VuZGFyeSBtYXkgZmFsbCB3aXRoaW4gYSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihzbGljZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9mZnNldCA9IGVuZDtcbiAgICB9KTtcbiAgICByZXR1cm4ge3ZhbHVlOiAoYXdhaXQgY2h1bmspLCBkb25lOiBmYWxzZX07XG4gIH1cbn1cbiJdfQ=="],"names":["ByteChunkIterator","decodeUTF8","Utf8Iterator","this","constructor","upstream","super","impl","Utf8IteratorImpl","summary","next","env","get","decoder","TextDecoder","StringDecoder","pump","chunkResult","chunk","text","done","value","decode","stream","write","Buffer","from","buffer","outputQueue","push","FileChunkIterator","file","options","util","Uint8Array","File","Blob","offset","chunkSize","byteLength","size","Promise","resolve","reject","end","slice","fileReader","FileReader","onload","event","data","result","ArrayBuffer","TypeError","onabort","Error","onerror","type","readAsArrayBuffer"],"sourceRoot":""}