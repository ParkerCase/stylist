"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[785],{473:function(n,t,e){e.d(t,{i:function(){return d}});var i=e(9495);class d{constructor(n,t,e,d){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[n,e];const s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,u=2===(0,i.env)().getNumber("WEBGL_VERSION")?"while (left < right) {":s,a="left"===d?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${u}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${a} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}},8939:function(n,t,e){e.d(t,{$:function(){return d}});var i=e(27575);class d{constructor(n,t,e,d,s,u,a=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=u;const l=(0,i.bf)(s.length),c=(0,i.bf)(u.length);let r="";1===e?r="i":2===e&&(r="i, j");const f=`getIndices(${r})`;let g="";1===d?g="i":2===d&&(g="i, coords[1]");const I=`getUpdates(${g})`;let x="";o&&(x="coords[0], coords[1]");const h=`getDefaultValue(${x})`,v=t>1?"strides[j]":"strides";this.userCode=`\n        ${l} strides = ${l}(${s});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${n}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${f});\n              flattenedIndex += index * ${v};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${I};\n              found = true;\n            }\n          }\n          setOutput(mix(${h}, sum, float(found)));\n        }\n      `}}},50476:function(n,t,e){e.d(t,{v:function(){return i}});class i{constructor(n,t){this.variableNames=["x","segmentIds"];const e=n.windowSize,i=n.batchSize,d=n.inSize,s=n.numSegments,u=s*Math.ceil(d/e);this.outputShape=[i,u];const a=4*Math.floor(e/4),o=e%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";d%e>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${d}) {\n          return initializationValue;\n        }\n      `);let r="";d%e>0&&(r=`\n        if (inIdx < 0 || inIdx >= ${d}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${r}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${e}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}},57160:function(n,t,e){e.d(t,{h:function(){return d}});var i=e(27575);class d{constructor(n,t,e,d,s,u,a=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=u;const l=(0,i.bf)(s.length),c=(0,i.bf)(u.length);let r="";1===e?r="i":2===e&&(r="i, j");const f=`getIndices(${r})`;let g="";1===d?g="i":2===d&&(g="i, coords[1]");const I=`getUpdates(${g})`;let x="";o&&(x="coords[0], coords[1]");const h=`getDefaultValue(${x})`,v=t>1?"strides[j]":"strides",m=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${l} strides = ${l}(${s});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${n}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${f});\n              flattenedIndex += index.xz * ${v};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${m};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${I};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${h}, sum, found));\n        }\n      `}}}}]);
//# sourceMappingURL=stylist-vendors-e96f6c03.9662180f24b0617cbfc1.js.map