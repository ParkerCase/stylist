"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[5388],{237:function(e,t,n){n.d(t,{e:function(){return u}});var a=n(9495),s=n(97870),o=n(14590),r=n(87906),i=n(85655);const u={kernelName:a.BatchToSpaceND,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:u}=e,{x:d}=t,{blockShape:c,crops:l}=u;(0,s.C)([d],"batchToSpaceND");const p=c.reduce(((e,t)=>e*t)),h=a.backend_util.getReshaped(d.shape,c,p),f=a.backend_util.getPermuted(h.length,c.length),m=a.backend_util.getReshapedPermuted(d.shape,c,p),k=a.backend_util.getSliceBeginCoords(l,c.length),g=a.backend_util.getSliceSize(m,l,c.length),b=(0,o.t)({inputs:{x:d},backend:n,attrs:{shape:h}}),I=(0,i.m)({inputs:{x:b},backend:n,attrs:{perm:f}}),v=(0,o.t)({inputs:{x:I},backend:n,attrs:{shape:m}}),y=(0,r.di)({inputs:{x:v},backend:n,attrs:{begin:k,size:g}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(v),y}}},1090:function(e,t,n){n.d(t,{R:function(){return i}});var a=n(9495),s=n(97870),o=n(6307),r=n(46936);const i={kernelName:a.AvgPool,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:u}=t;(0,s.C)(u,"avgPool");const{filterSize:d,strides:c,pad:l,dimRoundingMode:p}=i;a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(c,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${c} and dilations '1'`));const h=a.backend_util.computePool2DInfo(u.shape,d,c,1,l,p);let f;if(1===h.filterWidth&&1===h.filterHeight&&a.util.arraysEqual(h.inShape,h.outShape))f=(0,r.D)({inputs:{x:u},backend:n});else{const e=n.data.get(u.dataId).values,t=a.util.computeStrides(u.shape),s=(0,o.dz)(e,u.shape,u.dtype,t,h,"avg");f=n.makeTensorInfo(h.outShape,u.dtype,s.values)}return f}}},1903:function(e,t,n){n.d(t,{Y:function(){return o}});var a=n(9495),s=n(86995);const o={kernelName:a.DenseBincount,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o,weights:r}=t,{size:i,binaryOutput:u}=a;if(1===o.shape.length){const e=n.data.get(o.dataId).values,t=n.data.get(r.dataId).values,a=(0,s.X)(e,t,r.dtype,r.shape,i);return n.makeTensorInfo([i],r.dtype,a)}if(2===o.shape.length){const e=n.bufferSync(o),t=n.bufferSync(r),a=(0,s.N)(e,t,i,u);return n.makeTensorInfo(a.shape,r.dtype,a.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}}},3822:function(e,t,n){n.d(t,{$:function(){return o}});var a=n(9495),s=n(97870);const o={kernelName:a.AvgPoolGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:r,input:i}=t,u=i;(0,s.C)([r,i],"avgPoolGrad");const{filterSize:d,strides:c,pad:l}=o,p=a.backend_util.computePool2DInfo(u.shape,d,c,1,l),h=p.strideHeight,f=p.strideWidth,m=p.filterHeight,k=p.filterWidth,g=p.dilationHeight,b=p.dilationWidth,I=p.effectiveFilterHeight,v=p.effectiveFilterWidth,y=v-1-p.padInfo.left,x=I-1-p.padInfo.top,N=(0,a.buffer)(u.shape,"float32"),S=1/(m*k),F=n.data.get(r.dataId).values,C=(0,a.buffer)(r.shape,"float32",F);for(let a=0;a<p.batchSize;++a)for(let e=0;e<p.inChannels;++e)for(let t=0;t<p.inHeight;++t)for(let n=0;n<p.inWidth;++n){const s=t-x,o=n-y;let r=0;for(let t=0;t<I;t+=g){const n=(s+t)/h;if(!(n<0||n>=p.outHeight||Math.floor(n)!==n))for(let t=0;t<v;t+=b){const s=(o+t)/f;if(s<0||s>=p.outWidth||Math.floor(s)!==s)continue;r+=C.get(a,n,s,e)}}N.set(r*S,a,t,n,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}}},4652:function(e,t,n){n.d(t,{x:function(){return o}});var a=n(9495),s=n(97870);const o={kernelName:a.EluGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:o,y:r}=t;(0,s.C)([o,r],"eluGrad");const i=new Float32Array(a.util.sizeFromShape(r.shape)),u=n.data.get(r.dataId).values,d=n.data.get(o.dataId).values;for(let a=0;a<u.length;++a){const e=u[a];i[a]=e>=1?d[a]:d[a]*(e+1)}return n.makeTensorInfo(r.shape,"float32",i)}}},6941:function(e,t,n){n.d(t,{e:function(){return o}});var a=n(9495),s=n(97870);const o={kernelName:a.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:r,filter:i}=t,{pad:u,strides:d,inputShape:c}=o;(0,s.C)([r],"conv3dBackpropInputV2");const l=a.util.computeStrides(r.shape),p=a.util.computeStrides(i.shape),h=a.backend_util.computeConv3DInfo(c,i.shape,d,1,u),f=new a.TensorBuffer(h.inShape,"float32"),m=f.values,[k,g,b,I]=f.strides,v=n.data.get(r.dataId).values,[y,x,N,S]=l,F=n.data.get(i.dataId).values,[C,M,D,T]=p,{batchSize:A,filterDepth:_,filterHeight:W,filterWidth:H,inChannels:w,inDepth:E,inHeight:z,inWidth:B,outChannels:P,outDepth:R,outHeight:$,outWidth:O,strideDepth:G,strideHeight:V,strideWidth:q}=h,U=_-1-h.padInfo.front,Z=W-1-h.padInfo.top,j=H-1-h.padInfo.left;for(let a=0;a<A;++a)for(let e=0;e<w;++e)for(let t=0;t<E;++t){const n=t-U,s=Math.max(0,Math.ceil(n/G)),o=Math.min(R,(_+n)/G);for(let r=0;r<z;++r){const i=r-Z,u=Math.max(0,Math.ceil(i/V)),d=Math.min($,(W+i)/V);for(let c=0;c<B;++c){const l=c-j,p=Math.max(0,Math.ceil(l/q)),h=Math.min(O,(H+l)/q);let f=0;for(let t=s;t<o;++t){const s=t*G-n;for(let n=u;n<d;++n){const o=n*V-i;for(let r=p;r<h;++r){const i=y*a+x*t+N*n+S*r,u=C*(_-1-s)+M*(W-1-o)+D*(H-1-(r*q-l))+T*e;for(let e=0;e<P;++e){f+=v[i+e]*F[u+e]}}}}m[k*a+g*t+b*r+I*c+e]=f}}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}}},7478:function(e,t,n){n.d(t,{D:function(){return o}});var a=n(9495);const s=(0,n(21694).v)(a.Acosh,(e=>Math.acosh(e))),o={kernelName:a.Acosh,backendName:"cpu",kernelFunc:s}},7676:function(e,t,n){n.d(t,{rL:function(){return u}});var a=n(9495),s=n(8195),o=n(98880);const r=(0,s.Z)(((e,t)=>Math.atan2(e,t))),i=(0,o.j)(a.Atan2,r),u={kernelName:a.Atan2,backendName:"cpu",kernelFunc:i}},11355:function(e,t,n){n.d(t,{k:function(){return o}});var a=n(9495);const s=(0,n(21694).v)(a.Cosh,(e=>Math.cosh(e))),o={kernelName:a.Cosh,backendName:"cpu",kernelFunc:s}},13484:function(e,t,n){n.d(t,{L:function(){return o}});var a=n(9495);const s=(0,n(21694).v)(a.Atan,(e=>Math.atan(e))),o={kernelName:a.Atan,backendName:"cpu",kernelFunc:s}},13713:function(e,t,n){n.d(t,{M:function(){return c},w:function(){return d}});var a=n(9495),s=n(8195),o=n(11317),r=n(89436),i=n(46936),u=n(85806);function d(e){const{inputs:t,backend:n,attrs:c}=e,{x:l}=t,{dtype:p}=c;if("complex64"===p){if("complex64"===l.dtype)return(0,i.D)({inputs:{x:l},backend:n});const e=(0,o.U)(n,l.shape,l.dtype),t=d({inputs:{x:l},backend:n,attrs:{dtype:"float32"}}),a=(0,r.f)({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===l.dtype){const e=(0,u.x)({inputs:{input:l},backend:n}),t=d({inputs:{x:e},backend:n,attrs:{dtype:p}});return n.disposeIntermediateTensorInfo(e),t}if(!a.util.hasEncodingLoss(l.dtype,p)){const e=(0,i.D)({inputs:{x:l},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:p}}if("int32"===p){const e=n.data.get(l.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(l.shape,"int32",t)}if("bool"===p){const e=n.data.get(l.dataId).values,t=a.util.toTypedArray([0],l.dtype),[o,r]=(0,s.Z)(((e,t)=>e!==t?1:0))(l.shape,[],e,t,"bool");return n.makeTensorInfo(r,"bool",o)}throw new Error(`Error in Cast: failed to cast ${l.dtype} to ${p}`)}const c={kernelName:a.Cast,backendName:"cpu",kernelFunc:d}},14666:function(e,t,n){n.d(t,{n:function(){return o}});var a=n(9495),s=n(97870);const o={kernelName:a.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:r,dy:i}=t,{strides:u,dilations:d,pad:c,dimRoundingMode:l,filterShape:p}=o;(0,s.C)([r,i],"depthwiseConv2dNativeBackpropFilter");const h=a.backend_util.computeConv2DInfo(r.shape,p,u,d,c,l,!0),{strideHeight:f,strideWidth:m,filterHeight:k,filterWidth:g}=h,b=new a.TensorBuffer(h.filterShape,"float32"),I=h.padInfo.left,v=h.padInfo.top,y=h.outChannels/h.inChannels,x=n.data.get(r.dataId).values,N=new a.TensorBuffer(r.shape,r.dtype,x),S=n.data.get(i.dataId).values,F=new a.TensorBuffer(i.shape,i.dtype,S);for(let a=0;a<k;++a){const e=Math.max(0,Math.ceil((v-a)/f)),t=Math.min(h.outHeight,(h.inHeight+v-a)/f);for(let n=0;n<g;++n){const s=Math.max(0,Math.ceil((I-n)/m)),o=Math.min(h.outWidth,(h.inWidth+I-n)/m);for(let r=0;r<h.outChannels;++r){const i=Math.trunc(r/y),u=r%y;let d=0;for(let c=0;c<h.batchSize;++c)for(let u=e;u<t;++u){const e=a+u*f-v;for(let t=s;t<o;++t){const a=n+t*m-I;d+=N.get(c,e,a,i)*F.get(c,u,t,r)}}b.set(d,a,n,i,u)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}}},14759:function(e,t,n){n.d(t,{YG:function(){return r},uf:function(){return u}});var a=n(9495),s=n(45705),o=n(21694);const r=(0,s.o)((e=>Math.ceil(e))),i=(0,o.F)(a.Ceil,r),u={kernelName:a.Ceil,backendName:"cpu",kernelFunc:i}},19910:function(e,t,n){n.d(t,{B:function(){return s}});var a=n(9495);const s={kernelName:a.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:o,dy:r}=e,{strides:i,pad:u,dilations:d}=n,c=t,l=a.util.toNestedArray(s.shape,c.data.get(s.dataId).values),p=a.util.toNestedArray(o.shape,c.data.get(o.dataId).values),{batchSize:h,inHeight:f,inWidth:m,inChannels:k,outHeight:g,outWidth:b,padInfo:I,strideHeight:v,strideWidth:y,filterHeight:x,filterWidth:N,dilationHeight:S,dilationWidth:F,outShape:C}=a.backend_util.computeDilation2DInfo(s.shape,o.shape,i,u,"NHWC",d);a.util.assert(r.rank===C.length,(()=>`Error in ${a.Dilation2DBackpropInput}, dy must have the same rank as output ${C.length}, but got ${r.rank}`));const M=a.util.toNestedArray(C,c.data.get(r.dataId).values),D=a.util.makeZerosNestedTypedArray(s.shape,s.dtype);for(let a=0;a<h;++a)for(let e=0;e<g;++e){const t=e*v-I.top;for(let n=0;n<b;++n){const s=n*y-I.left;for(let o=0;o<k;++o){let r=Number.MIN_SAFE_INTEGER,i=t<0?0:t,u=s<0?0:s;for(let e=0;e<x;++e){const n=t+e*S;if(n>=0&&n<f)for(let t=0;t<N;++t){const d=s+t*F;if(d>=0&&d<m){const s=l[a][n][d][o]+p[e][t][o];s>r&&(r=s,i=n,u=d)}}}D[a][i][u][o]+=M[a][e][n][o]}}}return{dataId:c.write(a.util.toTypedArray(D,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}}},23530:function(e,t,n){n.d(t,{r:function(){return o}});var a=n(9495),s=n(97870);const o={kernelName:a.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:r,dy:i}=t,{strides:u,pad:d,dataFormat:c,dimRoundingMode:l,filterShape:p}=o;(0,s.C)([r,i],"conv2dBackpropFilter");const h=a.backend_util.convertConv2DDataFormat(c),f=a.backend_util.computeConv2DInfo(r.shape,p,u,1,d,l,!1,h),{strideHeight:m,strideWidth:k,filterHeight:g,filterWidth:b}=f,I="channelsLast"===f.dataFormat,v=new a.TensorBuffer(f.filterShape,"float32"),y=f.padInfo.left,x=f.padInfo.top,N=n.data.get(r.dataId).values,S=n.data.get(i.dataId).values,F=new a.TensorBuffer(r.shape,r.dtype,N),C=new a.TensorBuffer(i.shape,i.dtype,S);for(let a=0;a<g;++a){const e=Math.max(0,Math.ceil((x-a)/m)),t=Math.min(f.outHeight,(f.inHeight+x-a)/m);for(let n=0;n<b;++n){const s=Math.max(0,Math.ceil((y-n)/k)),o=Math.min(f.outWidth,(f.inWidth+y-n)/k);for(let r=0;r<f.inChannels;++r)for(let i=0;i<f.outChannels;++i){let u=0;for(let d=0;d<f.batchSize;++d)for(let c=e;c<t;++c){const e=a+c*m-x;for(let t=s;t<o;++t){const a=n+t*k-y;u+=I?F.get(d,e,a,r)*C.get(d,c,t,i):F.get(d,r,e,a)*C.get(d,i,c,t)}}v.set(u,a,n,r,i)}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}}},24856:function(e,t,n){n.d(t,{J:function(){return o},P:function(){return s}});var a=n(9495);const s=(0,n(21694).v)(a.Elu,(e=>e>=0?e:Math.exp(e)-1)),o={kernelName:a.Elu,backendName:"cpu",kernelFunc:s}},25242:function(e,t,n){n.d(t,{p:function(){return s}});var a=n(9495);const s={kernelName:a.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:o,dy:r}=e,{strides:i,pad:u,dilations:d}=n,c=t,l=a.util.toNestedArray(s.shape,c.data.get(s.dataId).values),p=a.util.toNestedArray(o.shape,c.data.get(o.dataId).values),{batchSize:h,inHeight:f,inWidth:m,inChannels:k,outHeight:g,outWidth:b,padInfo:I,strideHeight:v,strideWidth:y,filterHeight:x,filterWidth:N,dilationHeight:S,dilationWidth:F,outShape:C}=a.backend_util.computeDilation2DInfo(s.shape,o.shape,i,u,"NHWC",d);a.util.assert(r.rank===C.length,(()=>`Error in ${a.Dilation2DBackpropFilter}, dy must have the same rank as output ${C.length}, but got ${r.rank}`));const M=a.util.toNestedArray(C,c.data.get(r.dataId).values),D=a.util.makeZerosNestedTypedArray(o.shape,o.dtype);for(let a=0;a<h;++a)for(let e=0;e<g;++e){const t=e*v-I.top;for(let n=0;n<b;++n){const s=n*y-I.left;for(let o=0;o<k;++o){let r=Number.MIN_SAFE_INTEGER,i=0,u=0;for(let e=0;e<x;++e){const n=t+e*S;if(n>=0&&n<f)for(let t=0;t<N;++t){const d=s+t*F;if(d>=0&&d<m){const s=l[a][n][d][o]+p[e][t][o];s>r&&(r=s,i=e,u=t)}}}D[i][u][o]+=M[a][e][n][o]}}}return{dataId:c.write(a.util.toTypedArray(D,s.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}}},25954:function(e,t,n){n.d(t,{l:function(){return r}});var a=n(9495),s=n(97870),o=n(85655);const r={kernelName:a.ArgMin,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:u}=r;(0,s.C)(i,"argMin");let d=a.util.parseAxisParam(u,i.shape);const c=a.backend_util.getAxesPermutation(d,i.shape.length);let l=i;const p=[];null!=c&&(l=(0,o.m)({inputs:{x:i},backend:n,attrs:{perm:c}}),p.push(l),d=a.backend_util.getInnerMostAxes(d.length,l.shape.length)),d=[d[0]],a.backend_util.assertAxesAreInnerMostDims("argMin",d,l.shape.length);const[h,f]=a.backend_util.computeOutAndReduceShapes(l.shape,d),m=a.util.sizeFromShape(h),k=a.util.makeZerosTypedArray(m,"int32"),g=a.util.sizeFromShape(f),b=n.data.get(l.dataId).values;for(let a=0;a<k.length;++a){const e=a*g;let t=b[e],n=0;for(let a=0;a<g;++a){const s=b[e+a];s<t&&(t=s,n=a)}k[a]=n}return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(h,"int32",k)}}},26789:function(e,t,n){n.d(t,{Yp:function(){return u},uM:function(){return r}});var a=n(9495),s=n(45705),o=n(21694);const r=(0,s.o)((e=>Math.expm1(e))),i=(0,o.F)(a.Expm1,r),u={kernelName:a.Expm1,backendName:"cpu",kernelFunc:i}},30766:function(e,t,n){n.d(t,{l:function(){return i}});var a=n(9495),s=n(97870),o=n(14590),r=n(85655);const i={kernelName:a.Any,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:u}=t,{axis:d,keepDims:c}=i;(0,s.C)(u,"any");const l=a.util.parseAxisParam(d,u.shape);let p=l;const h=a.backend_util.getAxesPermutation(p,u.shape.length);let f=u;null!=h&&(f=(0,r.m)({inputs:{x:u},backend:n,attrs:{perm:h}}),p=a.backend_util.getInnerMostAxes(p.length,u.shape.length)),a.backend_util.assertAxesAreInnerMostDims("any",p,f.shape.length);const[m,k]=a.backend_util.computeOutAndReduceShapes(f.shape,p),g=a.util.sizeFromShape(k),b=a.util.makeZerosTypedArray(a.util.sizeFromShape(m),f.dtype),I=n.data.get(f.dataId).values;for(let a=0;a<b.length;++a){const e=a*g;let t=I[e];for(let n=0;n<g;++n){const a=I[e+n];t=t||a}b[a]=t}null!=h&&n.disposeIntermediateTensorInfo(f);const v=n.makeTensorInfo(m,f.dtype,b);if(c){const e=a.backend_util.expandShapeToKeepDim(m,l),t=(0,o.t)({inputs:{x:v},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(v),t}return v}}},33910:function(e,t,n){n.d(t,{f:function(){return o}});var a=n(9495),s=n(97870);const o={kernelName:a.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:r,filter:i}=t,{inputShape:u,strides:d,pad:c,dataFormat:l,dimRoundingMode:p}=o;(0,s.C)([r,i],"conv2dBackpropInput");const h=a.util.computeStrides(i.shape),f=a.util.computeStrides(r.shape);let m=a.backend_util.convertConv2DDataFormat(l);const k=a.backend_util.computeConv2DInfo(u,i.shape,d,1,c,p,!1,m),g=new a.TensorBuffer(k.inShape,"float32"),b=g.values,I=n.data.get(r.dataId).values,v=n.data.get(i.dataId).values,[y,x,N]=h,{batchSize:S,filterHeight:F,filterWidth:C,inChannels:M,inHeight:D,inWidth:T,outChannels:A,outHeight:_,outWidth:W,strideHeight:H,strideWidth:w}=k;m=k.dataFormat;const E=F-1-k.padInfo.top,z=C-1-k.padInfo.left,B="channelsLast"===m,P=g.strides[0],R=B?g.strides[1]:g.strides[2],$=B?g.strides[2]:1,O=B?1:g.strides[1],G=f[0],V=B?f[1]:f[2],q=B?f[2]:1,U=B?1:f[1];for(let a=0;a<S;++a)for(let e=0;e<M;++e)for(let t=0;t<D;++t){const n=t-E,s=Math.max(0,Math.ceil(n/H)),o=Math.min(_,(F+n)/H);for(let r=0;r<T;++r){const i=r-z,u=Math.max(0,Math.ceil(i/w)),d=Math.min(W,(C+i)/w);let c=0;for(let t=s;t<o;++t){const s=t*H-n;for(let n=u;n<d;++n){const o=G*a+V*t+q*n,r=y*(F-1-s)+x*(C-1-(n*w-i))+N*e;for(let e=0;e<A;++e){c+=I[o+U*e]*v[r+e]}}}b[P*a+R*t+$*r+O*e]=c}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}}},36085:function(e,t,n){n.d(t,{U:function(){return o},a:function(){return r}});var a=n(9495),s=n(14590);function o(e){const{inputs:t,backend:n,attrs:o}=e,{input:r}=t,{dim:i}=o,u=r.shape.length,d=r.shape.slice();let c=i;return i<0&&(a.util.assert(-(u+1)<=i,(()=>`Axis must be in the interval [${-(u+1)}, ${u}]`)),c=u+i+1),d.splice(c,0,1),(0,s.t)({inputs:{x:r},backend:n,attrs:{shape:d}})}const r={kernelName:a.ExpandDims,backendName:"cpu",kernelFunc:o}},36541:function(e,t,n){n.d(t,{M:function(){return o}});var a=n(9495);const s=(0,n(21694).v)(a.Asinh,(e=>Math.asinh(e))),o={kernelName:a.Asinh,backendName:"cpu",kernelFunc:s}},36813:function(e,t,n){n.d(t,{_:function(){return u}});var a=n(9495),s=n(65646),o=n(14590),r=n(25231),i=n(85655);const u={kernelName:a.Einsum,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:u}=e,{equation:d}=u,c=t,{allDims:l,summedDims:p,idDims:h}=a.backend_util.decodeEinsumEquation(d,c.length);a.backend_util.checkEinsumDimSizes(l.length,h,c);const{path:f,steps:m}=a.backend_util.getEinsumComputePath(p,h),k=m.length;let g=null,b=l.length;const I=[];for(let v=0;v<k;++v){for(const e of m[v]){const{permutationIndices:t,expandDims:r}=a.backend_util.getEinsumPermutation(b,h[e]);let u;a.backend_util.isIdentityPermutation(t)?u=c[e]:(u=(0,i.m)({inputs:{x:c[e]},backend:n,attrs:{perm:t}}),I.push(u));const d=u.shape.slice();for(let e=0;e<r.length;++e)d.splice(r[e],0,1);a.util.arraysEqual(u.shape,d)||(u=(0,o.t)({inputs:{x:u},backend:n,attrs:{shape:d}}),I.push(u)),null===g?g=u:(g=(0,s.lw)({inputs:{a:u,b:g},backend:n}),I.push(g))}v<k-1&&(f[v]>=0&&(g=(0,r.c)({inputs:{x:g},backend:n,attrs:{axis:f[v]-(l.length-b),keepDims:!1}}),I.push(g)),b--)}for(const a of I)a!==g&&n.disposeIntermediateTensorInfo(a);return g}}},41347:function(e,t,n){n.d(t,{o:function(){return o}});var a=n(9495);const s=(0,n(21694).v)(a.Cos,(e=>Math.cos(e))),o={kernelName:a.Cos,backendName:"cpu",kernelFunc:s}},43898:function(e,t,n){n.d(t,{J:function(){return o},x:function(){return r}});var a=n(9495),s=n(97870);function o(e){const{inputs:t,backend:n,attrs:o}=e,{x:r,filter:i}=t,{strides:u,pad:d,dataFormat:c,dilations:l,dimRoundingMode:p}=o;(0,s.C)([r,i],"conv2d");const h=a.backend_util.convertConv2DDataFormat(c),f=a.backend_util.computeConv2DInfo(r.shape,i.shape,u,l,d,p,!1,h),m=f.filterHeight,k=f.filterWidth,g=f.dilationHeight,b=f.dilationWidth,I=f.padInfo.left,v=f.padInfo.top,y="channelsLast"===f.dataFormat,x=new a.TensorBuffer(f.outShape,r.dtype),N=a.util.computeStrides(r.shape),S=a.util.computeStrides(i.shape),F=N[0],C=y?N[1]:N[2],M=y?N[2]:1,D=y?1:N[1],T=x.strides[0],A=y?x.strides[1]:x.strides[2],_=y?x.strides[2]:1,W=y?1:x.strides[1],H=n.data.get(r.dataId).values,w=n.data.get(i.dataId).values,E=x.values;for(let a=0;a<f.batchSize;++a){const e=a*F,t=a*T;for(let n=0;n<f.outHeight;++n){const a=t+n*A,s=n*f.strideHeight-v;for(let t=0;t<m;++t){const n=s+t*g;if(n<0||n>=f.inHeight)continue;const o=t*S[0],r=e+n*C;for(let e=0;e<f.outWidth;++e){const t=a+e*_,n=e*f.strideWidth-I;for(let e=0;e<k;++e){const a=n+e*b;if(a<0||a>=f.inWidth)continue;const s=r+a*M;let i=o+e*S[1];for(let e=0;e<f.inChannels;++e){const n=H[s+e*D];for(let e=0;e<f.outChannels;++e)E[t+e*W]+=n*w[i+e];i+=f.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,E)}const r={kernelName:a.Conv2D,backendName:"cpu",kernelFunc:o}},45655:function(e,t,n){n.d(t,{i:function(){return o}});var a=n(9495),s=n(97870);const o={kernelName:a.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:r,dy:i}=t,{strides:u,pad:d,filterShape:c}=o;(0,s.C)([r,i],"conv3dBackpropFilterV2");const l=a.util.computeStrides(r.shape),p=a.util.computeStrides(i.shape),h=a.backend_util.computeConv3DInfo(r.shape,c,u,1,d),f=h.strideDepth,m=h.strideHeight,k=h.strideWidth,g=h.filterDepth,b=h.filterHeight,I=h.filterWidth,v=new a.TensorBuffer(h.filterShape,"float32"),y=v.values,[x,N,S,F]=v.strides,C=n.data.get(i.dataId).values,[M,D,T,A]=p,_=n.data.get(r.dataId).values,[W,H,w,E]=l,z=h.padInfo.front,B=h.padInfo.left,P=h.padInfo.top;for(let a=0;a<g;++a){const e=Math.max(0,Math.ceil((z-a)/f)),t=Math.min(h.outDepth,(h.inDepth+z-a)/f),n=a*x;for(let s=0;s<b;++s){const o=Math.max(0,Math.ceil((P-s)/m)),r=Math.min(h.outHeight,(h.inHeight+P-s)/m),i=s*N+n;for(let n=0;n<I;++n){const u=Math.max(0,Math.ceil((B-n)/k)),d=Math.min(h.outWidth,(h.inWidth+B-n)/k),c=n*S+i;for(let i=0;i<h.inChannels;++i){const l=i*F+c;for(let c=0;c<h.outChannels;++c){let p=0;for(let l=0;l<h.batchSize;++l){const h=l*W,g=l*M;for(let l=e;l<t;++l){const e=(a+l*f-z)*H+h,t=l*D+g;for(let a=o;a<r;++a){const o=(s+a*m-P)*w+e,r=a*T+t;for(let e=u;e<d;++e){const t=e*A+r;p+=_[(n+e*k-B)*E+o+i]*C[t+c]}}}}y[l+c]=p}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}}},46838:function(e,t,n){n.d(t,{l:function(){return o}});var a=n(9495),s=n(86995);const o={kernelName:a.Bincount,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:o,weights:r}=t,{size:i}=a,u=n.data.get(o.dataId).values,d=n.data.get(r.dataId).values,c=(0,s.X)(u,d,r.dtype,r.shape,i);return n.makeTensorInfo([i],r.dtype,c)}}},49220:function(e,t,n){n.d(t,{Um:function(){return i.r}});var a=n(9495),s=n(97870);const o=a.kernel_impls.whereImpl;class r extends a.KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new a.DataStorage(this,(0,a.engine)())}nextDataId(){return r.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,(0,a.env)().get("IS_NODE")&&a.backend_util.warn("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:n,refCount:1}),s}makeTensorInfo(e,t,n){let s;if("string"===t&&null!=n&&n.length>0&&a.util.isString(n[0])){const o=n.map((e=>a.util.encodeString(e)));s=this.write(o,e,t)}else s=this.write(n,e,t);return{dataId:s,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,a,s){this.data.set(e,{values:t,dtype:a,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){const e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return a.backend_util.mergeRealAndImagArrays(e,t)}return this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map((e=>a.util.decodeString(e)))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,a.buffer)(e.shape,e.dtype,n)}makeOutput(e,t,n){const s=this.write(e,t,n);return(0,a.engine)().makeTensorFromDataId(s,t,n,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=a.util.now();e();return{kernelMs:a.util.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){(0,s.C)([e],"where");const t=this.readSync(e.dataId);return o(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}r.nextDataId=0;var i=n(33113);(0,a.registerBackend)("cpu",(()=>new r),1);n(92163)},50046:function(e,t,n){n.d(t,{l:function(){return o}});var a=n(9495);const s=(0,n(21694).v)(a.Atanh,(e=>Math.atanh(e))),o={kernelName:a.Atanh,backendName:"cpu",kernelFunc:s}},50120:function(e,t,n){n.d(t,{$:function(){return r}});var a=n(9495),s=n(97870),o=n(85655);const r={kernelName:a.Cumsum,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:u,exclusive:d,reverse:c}=r;(0,s.C)(i,"cumsum");const l=a.backend_util.getAxesPermutation([u],i.shape.length);let p=i;null!=l&&(p=(0,o.m)({inputs:{x:i},backend:n,attrs:{perm:l}}));const h=a.backend_util.getInnerMostAxes(1,i.shape.length)[0];if(h!==p.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${p.shape.length-1} but got axis=${h}`);const f=(0,a.upcastType)(p.dtype,"int32"),m=a.util.makeZerosTypedArray(a.util.sizeFromShape(p.shape),f),k=n.data.get(p.dataId).values,g=p.shape[p.shape.length-1],b=c?(e,t)=>e+g-t-1:(e,t)=>e+t;for(let a=0;a<k.length;a+=g)for(let e=0;e<g;e++){const t=b(a,e);if(0===e)m[t]=d?0:k[t];else{const n=b(a,e-1);m[t]=d?k[n]+m[n]:k[t]+m[n]}}const I=n.makeTensorInfo(p.shape,f,m);if(null!=l){const e=a.backend_util.getUndoAxesPermutation(l),t=(0,o.m)({inputs:{x:I},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(p),t}return I}}},50745:function(e,t,n){n.d(t,{S:function(){return o}});var a=n(9495);const s=(0,n(21694).v)(a.Asin,(e=>Math.asin(e))),o={kernelName:a.Asin,backendName:"cpu",kernelFunc:s}},52999:function(e,t,n){n.d(t,{_:function(){return p}});var a=n(9495),s=n(21694);const o=a.backend_util.ERF_P,r=a.backend_util.ERF_A1,i=a.backend_util.ERF_A2,u=a.backend_util.ERF_A3,d=a.backend_util.ERF_A4,c=a.backend_util.ERF_A5,l=(0,s.v)(a.Erf,(e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+o*n);return t*(1-((((c*a+d)*a+u)*a+i)*a+r)*a*Math.exp(-n*n))})),p={kernelName:a.Erf,backendName:"cpu",kernelFunc:l}},53747:function(e,t,n){n.d(t,{k:function(){return i}});var a=n(9495),s=n(97870),o=n(14590),r=n(85655);const i={kernelName:a.All,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:u}=t,{axis:d,keepDims:c}=i;(0,s.C)(u,"all");const l=a.util.parseAxisParam(d,u.shape);let p=l;const h=a.backend_util.getAxesPermutation(p,u.shape.length);let f=u;null!=h&&(f=(0,r.m)({inputs:{x:u},backend:n,attrs:{perm:h}}),p=a.backend_util.getInnerMostAxes(p.length,u.shape.length)),a.backend_util.assertAxesAreInnerMostDims("all",p,f.shape.length);const[m,k]=a.backend_util.computeOutAndReduceShapes(f.shape,p),g=a.util.sizeFromShape(k),b=a.util.makeZerosTypedArray(a.util.sizeFromShape(m),f.dtype),I=n.data.get(f.dataId).values;for(let a=0;a<b.length;++a){const e=a*g;let t=I[e];for(let n=0;n<g;++n){const a=I[e+n];t=t&&a}b[a]=t}null!=h&&n.disposeIntermediateTensorInfo(f);const v=n.makeTensorInfo(m,f.dtype,b);if(c){const e=a.backend_util.expandShapeToKeepDim(m,l),t=(0,o.t)({inputs:{x:v},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(v),t}return v}}},55671:function(e,t,n){n.d(t,{O:function(){return s}});var a=n(9495);const s={kernelName:a.CropAndResize,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{image:o,boxes:r,boxInd:i}=t,{cropSize:u,method:d,extrapolationValue:c}=s,[l,p,h,f]=o.shape,m=r.shape[0],[k,g]=u,b=(0,a.buffer)([m,k,g,f],"float32"),I=n.data.get(r.dataId).values,v=n.data.get(i.dataId).values,y=n.data.get(o.dataId).values,x=a.util.computeStrides(o.shape),N=a.util.computeStrides(b.shape);for(let a=0;a<m;a++){const e=4*a,t=I[e],n=I[e+1],s=I[e+2],o=I[e+3],r=v[a];if(r>=l)continue;const i=k>1?(s-t)*(p-1)/(k-1):0,u=g>1?(o-n)*(h-1)/(g-1):0;for(let l=0;l<k;l++){const e=k>1?t*(p-1)+l*i:.5*(t+s)*(p-1);if(e<0||e>p-1)for(let t=0;t<g;t++)for(let e=0;e<f;e++){const n=e+t*N[2]+l*N[1]+a*N[0];b.values[n]=c}else if("bilinear"===d){const t=Math.floor(e),s=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const d=g>1?n*(h-1)+e*u:.5*(n+o)*(h-1);if(d<0||d>h-1){for(let t=0;t<f;t++){const n=t+e*N[2]+l*N[1]+a*N[0];b.values[n]=c}continue}const p=Math.floor(d),m=Math.ceil(d),k=d-p;for(let n=0;n<f;n++){let o=n+p*x[2]+t*x[1]+r*x[0];const u=y[o];o=n+m*x[2]+t*x[1]+r*x[0];const d=y[o];o=n+p*x[2]+s*x[1]+r*x[0];const c=y[o];o=n+m*x[2]+s*x[1]+r*x[0];const h=u+(d-u)*k,f=c+(y[o]-c)*k;o=n+e*N[2]+l*N[1]+a*N[0],b.values[o]=h+(f-h)*i}}}else for(let t=0;t<g;++t){const s=g>1?n*(h-1)+t*u:.5*(n+o)*(h-1);if(s<0||s>h-1){for(let e=0;e<f;e++){const n=e+t*N[2]+l*N[1]+a*N[0];b.values[n]=c}continue}const i=Math.round(s),d=Math.round(e);for(let e=0;e<f;e++){const n=e+i*x[2]+d*x[1]+r*x[0],s=e+t*N[2]+l*N[1]+a*N[0];b.values[s]=y[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}}},57152:function(e,t,n){n.d(t,{R:function(){return s}});var a=n(9495);const s={kernelName:a.DepthToSpace,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:o}=t,{blockSize:r,dataFormat:i}=s;a.util.assert("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`)),a.util.assert(r>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${r}`));const u=o.shape[0],d=o.shape[1],c=o.shape[2],l=o.shape[3],p=d*r,h=c*r,f=l/(r*r),m=n.data.get(o.dataId).values,k=new Float32Array(u*p*h*f);let g=0;for(let a=0;a<u;++a)for(let e=0;e<p;++e){const t=Math.floor(e/r),n=e%r;for(let e=0;e<h;++e){const s=Math.floor(e/r),o=(n*r+e%r)*f;for(let e=0;e<f;++e){const n=e+o+l*(s+c*(t+d*a));k[g++]=m[n]}}}return n.makeTensorInfo([u,p,h,f],o.dtype,k)}}},58306:function(e,t,n){n.d(t,{V:function(){return o}});var a=n(9495),s=n(97870);const o={kernelName:a.FusedBatchNorm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:r,scale:i,offset:u,mean:d,variance:c}=t;a.util.assert(d.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),a.util.assert(null==u||d.shape.length===u.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),a.util.assert(null==i||d.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),(0,s.C)([r,d,c,i,u],"batchNorm");let{varianceEpsilon:l}=o;null==l&&(l=.001);const p=n.data.get(r.dataId).values,h=n.data.get(d.dataId).values,f=n.data.get(c.dataId).values,m=i?n.data.get(i.dataId).values:new Float32Array([1]),k=u?n.data.get(u.dataId).values:new Float32Array([0]),g=new Float32Array(p.length),b=k.length,I=m.length,v=f.length,y=h.length;let x=0,N=0,S=0,F=0;for(let a=0;a<p.length;++a)g[a]=k[x++]+(p[a]-h[N++])*m[S++]/Math.sqrt(f[F++]+l),x>=b&&(x=0),N>=y&&(N=0),S>=I&&(S=0),F>=v&&(F=0);return n.makeTensorInfo(r.shape,r.dtype,g)}}},58449:function(e,t,n){n.d(t,{O:function(){return r}});var a=n(9495),s=n(97870),o=n(6307);const r={kernelName:a.AvgPool3D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:u,strides:d,pad:c,dimRoundingMode:l,dataFormat:p}=r;(0,s.C)(i,"avgPool3d");const h=a.backend_util.computePool3DInfo(i.shape,u,d,1,c,l,p),f=n.data.get(i.dataId).values,m=(0,o.W_)(f,i.shape,i.dtype,a.util.computeStrides(i.shape),h,"avg");return n.makeTensorInfo(m.shape,"float32",m.values)}}},62680:function(e,t,n){n.d(t,{dH:function(){return o},lO:function(){return r}});var a=n(9495),s=n(97870);function o(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const r={kernelName:a.Abs,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;(0,s.C)(t,"abs");let r=new Float32Array(a.util.sizeFromShape(t.shape));return r=o(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,"float32")}}},63330:function(e,t,n){n.d(t,{t:function(){return s}});var a=n(9495);const s={kernelName:a.ComplexAbs,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,s=new Float32Array(a.util.sizeFromShape(t.shape)),o=n.data.get(t.dataId),r=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,u=n.data.get(r.dataId).values,d=n.data.get(i.dataId).values;for(let a=0;a<u.length;a++){const e=u[a],t=d[a];s[a]=Math.hypot(e,t)}return n.makeOutput(s,t.shape,"float32")}}},66423:function(e,t,n){n.d(t,{AC:function(){return u},oN:function(){return i},sG:function(){return r}});var a=n(9495),s=n(45705),o=n(21694);const r=(0,s.o)((e=>Math.exp(e))),i=(0,o.F)(a.Exp,r),u={kernelName:a.Exp,backendName:"cpu",kernelFunc:i}},69034:function(e,t,n){n.d(t,{D:function(){return s}});var a=n(9495);const s={kernelName:a.Dilation2D,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:o}=e,{strides:r,pad:i,dilations:u}=n,d=t,c=d.data.get(s.dataId).values,l=s.shape.length,p=d.data.get(o.dataId).values,h=o.shape.length,{batchSize:f,inHeight:m,inWidth:k,inChannels:g,outHeight:b,outWidth:I,padInfo:v,strideHeight:y,strideWidth:x,filterHeight:N,filterWidth:S,dilationHeight:F,dilationWidth:C,outShape:M}=a.backend_util.computeDilation2DInfo(s.shape,o.shape,r,i,"NHWC",u),D=a.util.sizeFromShape(M),T=M.length,A=a.util.getArrayFromDType(s.dtype,D);for(let _=0;_<f;++_)for(let e=0;e<b;++e){const t=e*y-v.top;for(let n=0;n<I;++n){const r=n*x-v.left;for(let i=0;i<g;++i){let u=Number.MIN_SAFE_INTEGER;for(let e=0;e<N;++e){const n=t+e*F;if(n>=0&&n<m)for(let t=0;t<S;++t){const d=r+t*C;if(d>=0&&d<k){const r=a.util.locToIndex([_,n,d,i],l,a.util.computeStrides(s.shape)),f=a.util.locToIndex([e,t,i],h,a.util.computeStrides(o.shape)),m=c[r]+p[f];m>u&&(u=m)}}}A[a.util.locToIndex([_,e,n,i],T,a.util.computeStrides(M))]=u}}}return{dataId:d.write(a.util.toTypedArray(A,s.dtype),M,s.dtype),shape:M,dtype:s.dtype}}}},70583:function(e,t,n){n.d(t,{i:function(){return o}});var a=n(9495),s=n(97870);const o={kernelName:a.Conv3D,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{x:r,filter:i}=t,{strides:u,pad:d,dilations:c}=o;(0,s.C)([r,i],"conv3d");const l=a.backend_util.computeConv3DInfo(r.shape,i.shape,u,c,d),{filterDepth:p,filterHeight:h,filterWidth:f,dilationDepth:m,dilationHeight:k,dilationWidth:g,padInfo:b}=l,I=b.front,v=b.left,y=b.top,x=new a.TensorBuffer(l.outShape,r.dtype),N=n.data.get(r.dataId).values,S=n.data.get(i.dataId).values,F=x.values,C=a.util.computeStrides(r.shape),M=a.util.computeStrides(i.shape);for(let a=0;a<l.batchSize;++a){const e=a*C[0],t=a*x.strides[0];for(let n=0;n<l.outDepth;++n){const a=t+n*x.strides[1],s=n*l.strideDepth-I;for(let t=0;t<p;++t){const n=s+t*m;if(n<0||n>=l.inDepth)continue;const o=t*M[0],r=e+n*C[1];for(let e=0;e<l.outHeight;++e){const t=a+e*x.strides[2],n=e*l.strideHeight-y;for(let e=0;e<h;++e){const a=n+e*k;if(a<0||a>=l.inHeight)continue;const s=o+e*M[1],i=r+a*C[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,a=e*l.strideWidth-v;for(let e=0;e<f;++e){const t=a+e*g;if(t<0||t>=l.inWidth)continue;const o=s+e*M[2],r=i+t*l.inChannels;let u=o;for(let e=0;e<l.inChannels;++e){const t=N[r+e];for(let e=0;e<l.outChannels;++e)F[n+e]+=t*S[u+e];u+=l.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}}},75304:function(e,t,n){n.d(t,{z:function(){return o}});var a=n(9495);const s=(0,n(21694).v)(a.ClipByValue,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),o={kernelName:a.ClipByValue,backendName:"cpu",kernelFunc:s}},78140:function(e,t,n){n.d(t,{N:function(){return r},X:function(){return i}});var a=n(9495),s=n(97870),o=n(14590);function r(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:u}=t,{transposeA:d,transposeB:c}=r;(0,s.C)([i,u],"matMul");const l=i.shape.length,p=u.shape.length,h=d?i.shape[l-2]:i.shape[l-1],f=c?u.shape[p-1]:u.shape[p-2],m=d?i.shape[l-1]:i.shape[l-2],k=c?u.shape[p-2]:u.shape[p-1],g=i.shape.slice(0,-2),b=u.shape.slice(0,-2),I=a.util.sizeFromShape(g),v=a.util.sizeFromShape(b),y=I===v||1===I||1===v;a.util.assert(l>=2&&p>=2&&y,(()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${g}) and (${b}).`));const x=(I>v?i.shape.slice(0,-2):u.shape.slice(0,-2)).concat([m,k]);a.util.assert(h===f,(()=>`Error in matMul: inner shapes (${h}) and (${f}) of Tensors with shapes ${i.shape} and ${u.shape} and transposeA=${d} and transposeB=${c} must match.`));const N=d?[I,h,m]:[I,m,h],S=c?[v,k,f]:[v,f,k],F=(0,o.t)({inputs:{x:i},backend:n,attrs:{shape:N}}),C=(0,o.t)({inputs:{x:u},backend:n,attrs:{shape:S}}),M=d?F.shape[1]:F.shape[2],D=d?F.shape[2]:F.shape[1],T=c?C.shape[1]:C.shape[2],A=Math.max(I,v),_=n.data.get(F.dataId).values,W=n.data.get(C.dataId).values,H=a.util.computeStrides(F.shape),w=a.util.computeStrides(C.shape),[E,z,B]=d?[H[0],1,H[1]]:[H[0],H[1],1],[P,R,$]=c?[1,w[1],w[0]]:[w[1],1,w[0]],O=D*T,G=(0,a.buffer)([A,D,T],F.dtype),V=G.values,q=n.blockSize;for(let a=0;a<A;a++)for(let e=0;e<D;e+=q)for(let t=0;t<T;t+=q)for(let n=0;n<M;n+=q){const s=Math.min(e+q,D),o=Math.min(t+q,T),r=Math.min(n+q,M);for(let i=e;i<s;i++)for(let e=t;e<o;e++){let t=0;for(let s=n;s<r;s++){const n=Math.min(a,I-1)*E,o=Math.min(a,v-1)*$;t+=_[n+i*z+s*B]*W[s*P+e*R+o]}V[a*O+(i*T+e)]+=t}}return n.disposeIntermediateTensorInfo(F),n.disposeIntermediateTensorInfo(C),n.makeTensorInfo(x,G.dtype,G.values)}const i={kernelName:a.BatchMatMul,backendName:"cpu",kernelFunc:r}},85046:function(e,t,n){n.d(t,{V:function(){return o}});var a=n(9495),s=n(97870);const o={kernelName:a.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:r,filter:i}=t,{strides:u,dilations:d,pad:c,dimRoundingMode:l,inputShape:p}=o;(0,s.C)([r,i],"depthwiseConv2DNativeBackpropInput");const h=a.util.computeStrides(r.shape),f=a.util.computeStrides(i.shape),m=a.backend_util.computeConv2DInfo(p,i.shape,u,d,c,l,!0),k=new a.TensorBuffer(m.inShape,"float32"),g=k.values,[b,I,v]=k.strides,y=n.data.get(r.dataId).values,[x,N,S]=h,F=n.data.get(i.dataId).values,[C,M,D]=f,{batchSize:T,filterHeight:A,filterWidth:_,inChannels:W,inHeight:H,inWidth:w,outChannels:E,outHeight:z,outWidth:B,strideHeight:P,strideWidth:R}=m,$=A-1-m.padInfo.top,O=_-1-m.padInfo.left,G=E/W;for(let a=0;a<T;++a)for(let e=0;e<W;++e)for(let t=0;t<H;++t){const n=t-$,s=Math.max(0,Math.ceil(n/P)),o=Math.min(z,(A+n)/P);for(let r=0;r<w;++r){const i=r-O,u=Math.max(0,Math.ceil(i/R)),d=Math.min(B,(_+i)/R);let c=0;for(let t=s;t<o;++t){const s=t*P-n;for(let n=u;n<d;++n){const o=x*a+N*t+S*n,r=C*(A-1-s)+M*(_-1-(n*R-i))+D*e;for(let t=0;t<G;++t){c+=y[o+(e*G+t)]*F[r+t]}}}g[b*a+I*t+v*r+e]=c}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}}},86995:function(e,t,n){n.d(t,{N:function(){return o},X:function(){return s}});var a=n(9495);function s(e,t,n,s,o){const r=a.util.sizeFromShape(s),i=a.util.makeZerosTypedArray(o,n);for(let a=0;a<e.length;a++){const n=e[a];if(n<0)throw new Error("Input x must be non-negative!");n>=o||(i[n]+=r>0?t[a]:1)}return i}function o(e,t,n,s=!1){const o=e.shape[0],r=e.shape[1],i=(0,a.buffer)([o,n],t.dtype);for(let a=0;a<o;a++)for(let o=0;o<r;o++){const r=e.get(a,o);if(r<0)throw new Error("Input x must be non-negative!");r>=n||(s?i.set(1,a,r):t.size>0?i.set(i.get(a,r)+t.get(a,o),a,r):i.set(i.get(a,r)+1,a,r))}return i}},87105:function(e,t,n){n.d(t,{m:function(){return o}});var a=n(9495),s=n(97870);const o={kernelName:a.AvgPool3DGrad,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{dy:r,input:i}=t,{filterSize:u,strides:d,pad:c,dimRoundingMode:l}=o;(0,s.C)([r,i],"avgPool3DGrad");const p=a.backend_util.computePool3DInfo(i.shape,u,d,1,c,l),h=p.strideDepth,f=p.strideHeight,m=p.strideWidth,k=p.filterDepth,g=p.filterHeight,b=p.filterWidth,I=p.dilationDepth,v=p.dilationHeight,y=p.dilationWidth,x=p.effectiveFilterDepth,N=p.effectiveFilterHeight,S=p.effectiveFilterWidth,F=x-1-p.padInfo.front,C=S-1-p.padInfo.left,M=N-1-p.padInfo.top,D=(0,a.buffer)(i.shape,"float32"),T=1/(k*g*b),A=n.bufferSync(r);for(let a=0;a<p.batchSize;++a)for(let e=0;e<p.inChannels;++e)for(let t=0;t<p.inDepth;++t)for(let n=0;n<p.inHeight;++n)for(let s=0;s<p.inWidth;++s){const o=t-F,r=n-M,i=s-C;let u=0;for(let t=0;t<x;t+=I){const n=(o+t)/h;if(!(n<0||n>=p.outDepth||Math.floor(n)!==n))for(let t=0;t<N;t+=v){const s=(r+t)/f;if(!(s<0||s>=p.outHeight||Math.floor(s)!==s))for(let t=0;t<S;t+=y){const o=(i+t)/m;if(o<0||o>=p.outWidth||Math.floor(o)!==o)continue;u+=A.get(a,n,s,o,e)}}}D.set(u*T,a,t,n,s,e)}return n.makeTensorInfo(D.shape,D.dtype,D.values)}}},87994:function(e,t,n){n.d(t,{n:function(){return o},v:function(){return r}});var a=n(9495),s=n(97870);function o(e){const{inputs:t,backend:n,attrs:o}=e,{x:r,filter:i}=t,{strides:u,pad:d,dilations:c,dimRoundingMode:l}=o;(0,s.C)([r,i],"depthwiseConv2DNative");const p=a.util.computeStrides(r.shape),h=a.util.computeStrides(i.shape);let f=c;null==f&&(f=[1,1]),a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(u,f),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${f}'`));const m=a.backend_util.computeConv2DInfo(r.shape,i.shape,u,f,d,l,!0),{filterHeight:k,filterWidth:g,dilationHeight:b,dilationWidth:I,padInfo:v}=m,y=v.left,x=v.top,N=m.outChannels/m.inChannels,S=new a.TensorBuffer(m.outShape,r.dtype),F=n.data.get(r.dataId).values,C=n.data.get(i.dataId).values,M=S.values;for(let a=0;a<m.batchSize;++a){const e=a*p[0],t=a*S.strides[0];for(let n=0;n<m.outHeight;++n){const a=t+n*S.strides[1],s=n*m.strideHeight-x;for(let t=0;t<k;++t){const n=s+t*b;if(n<0||n>=m.inHeight)continue;const o=t*h[0],r=e+n*p[1];for(let e=0;e<m.outWidth;++e){const t=a+e*S.strides[2],n=e*m.strideWidth-y;for(let e=0;e<g;++e){const a=n+e*I;if(a<0||a>=m.inWidth)continue;const s=o+e*h[1],i=r+a*m.inChannels;let u=t,d=s;for(let e=0;e<m.inChannels;++e){const t=F[i+e];for(let e=0;e<N;++e)M[u+e]+=t*C[d+e];u+=N,d+=N}}}}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const r={kernelName:a.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:o}},89436:function(e,t,n){function a(e){const{inputs:t,backend:n}=e,{real:a,imag:s}=t,o=n.data.get(a.dataId).values,r=n.data.get(s.dataId).values,i=n.makeTensorInfo(a.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",o),imag:n.makeTensorInfo(s.shape,"float32",r)},i}n.d(t,{f:function(){return a},v:function(){return s}});const s={kernelName:n(9495).Complex,backendName:"cpu",kernelFunc:a}},91601:function(e,t,n){n.d(t,{y:function(){return o}});var a=n(9495),s=n(97870);const o={kernelName:a.AddN,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,o=t;(0,s.C)(t,"addN");const r=o.map((e=>n.data.get(e.dataId).values)),i=(0,a.buffer)(o[0].shape,o[0].dtype),u=i.values;for(let a=0;a<o.length;a++){const e=r[a];for(let t=0;t<u.length;t++)u[t]+=e[t]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}}},94505:function(e,t,n){n.d(t,{O:function(){return s}});var a=n(9495);const s={kernelName:a.Diag,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,o=a.util.sizeFromShape(s.shape),r=n.data.get(s.dataId).values,i=(0,a.buffer)([o,o],s.dtype),u=i.values;for(let a=0;a<r.length;a++)u[a*o+a]=r[a];const d=[...s.shape,...s.shape];return n.makeTensorInfo(d,i.dtype,i.values)}}},95315:function(e,t,n){n.d(t,{UK:function(){return d},WQ:function(){return u},mx:function(){return r}});var a=n(9495),s=n(8195),o=n(98880);const r=(0,s.Z)(((e,t)=>e+t)),i=(0,o.B)(((e,t,n,a)=>({real:e+n,imag:t+a}))),u=(0,o.j)(a.Add,r,i),d={kernelName:a.Add,backendName:"cpu",kernelFunc:u}},96708:function(e,t,n){n.d(t,{t:function(){return o}});var a=n(9495);const s=(0,n(21694).v)(a.Acos,(e=>Math.acos(e))),o={kernelName:a.Acos,backendName:"cpu",kernelFunc:s}},97763:function(e,t,n){n.d(t,{h:function(){return s}});var a=n(9495);function s(e,t,n,s){const o=a.util.getArrayFromDType(n,a.util.sizeFromShape(t));if(s&&"string"!==n){let t=0;e.forEach((e=>{const n=a.util.sizeFromShape(e.shape);o.set(e.vals,t),t+=n}))}else{let s=0;e.forEach((e=>{const r="string"===n?a.backend_util.fromUint8ToStringArray(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const a=n*t[1]+s;for(let t=0;t<e.shape[1];++t)o[a+t]=r[i++]}s+=e.shape[1]}))}return o}},97870:function(e,t,n){n.d(t,{C:function(){return s}});var a=n(9495);function s(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&a.util.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}},98342:function(e,t,n){n.d(t,{V:function(){return l},x:function(){return c}});var a=n(9495),s=n(89436),o=n(97763),r=n(46936),i=n(18944),u=n(85806),d=n(14590);function c(e){const{inputs:t,backend:n,attrs:l}=e,{axis:p}=l,h=a.util.parseAxisParam(p,t[0].shape)[0];let f=a.backend_util.computeOutShape(t.map((e=>e.shape)),h);if(0===a.util.sizeFromShape(f))return n.makeTensorInfo(f,t[0].dtype,[]);const m=t.filter((e=>a.util.sizeFromShape(e.shape)>0));if(1===m.length)return(0,r.D)({inputs:{x:m[0]},backend:n});const k=m.map((e=>e.shape));if(a.backend_util.assertParamsConsistent(k,h),"complex64"===m[0].dtype){const e=m.map((e=>(0,u.x)({inputs:{input:e},backend:n}))),t=m.map((e=>(0,i.n)({inputs:{input:e},backend:n}))),a=c({inputs:e,backend:n,attrs:{axis:h}}),o=c({inputs:t,backend:n,attrs:{axis:h}}),r=(0,s.f)({inputs:{real:a,imag:o},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),r}const g=m.map((e=>{const t=[-1,a.util.sizeFromShape(e.shape.slice(h))];return(0,d.t)({inputs:{x:e},backend:n,attrs:{shape:t}})})),b=g.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));f=a.backend_util.computeOutShape(g.map((e=>e.shape)),1);const I=1===g[0].shape[0],v=(0,o.h)(b,f,t[0].dtype,I),y=a.backend_util.computeOutShape(m.map((e=>e.shape)),h),x=n.makeTensorInfo(y,t[0].dtype,v);return g.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}const l={kernelName:a.Concat,backendName:"cpu",kernelFunc:c}},98828:function(e,t,n){n.d(t,{n:function(){return r}});var a=n(9495),s=n(97870),o=n(85655);const r={kernelName:a.ArgMax,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:u}=r;(0,s.C)(i,"argMax");let d=a.util.parseAxisParam(u,i.shape);const c=a.backend_util.getAxesPermutation(d,i.shape.length);let l=i;const p=[];null!=c&&(l=(0,o.m)({inputs:{x:i},backend:n,attrs:{perm:c}}),p.push(l),d=a.backend_util.getInnerMostAxes(d.length,l.shape.length)),d=[d[0]],a.backend_util.assertAxesAreInnerMostDims("argMax",d,l.shape.length);const[h,f]=a.backend_util.computeOutAndReduceShapes(l.shape,d),m=a.util.sizeFromShape(h),k=a.util.makeZerosTypedArray(m,"int32"),g=a.util.sizeFromShape(f),b=n.data.get(l.dataId).values;for(let a=0;a<k.length;++a){const e=a*g;let t=b[e],n=0;for(let a=0;a<g;++a){const s=b[e+a];s>t&&(t=s,n=a)}k[a]=n}return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(h,"int32",k)}}},99292:function(e,t,n){n.d(t,{LC:function(){return i},RY:function(){return u}});var a=n(9495),s=n(8195),o=n(98880);const r=(0,s.Z)(((e,t)=>e===t?1:0)),i=(0,o.j)(a.Equal,r,null,"bool"),u={kernelName:a.Equal,backendName:"cpu",kernelFunc:i}}}]);
//# sourceMappingURL=stylist-vendors-539d3e59.02cb9be64a29ed9efff9.js.map