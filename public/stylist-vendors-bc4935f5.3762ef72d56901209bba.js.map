{"version":3,"file":"stylist-vendors-bc4935f5.3762ef72d56901209bba.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/multinomial_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/mulmat_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/mean_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/onehot_gpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\n/**\n * Example shader code for\n * `mirrorPad(tf.tensor1d([1, 2, 3], 'int32'), [[2, 2]], 'reflect')`\n * ```\n *    const int start = int(2);\n *    const int end = int(5);\n *\n *    void main() {\n *       int outputLoc = getOutputCoords();\n *       vec4 result = vec4(0.);\n *\n *       int rc = outputLoc;\n *\n *       int source = rc;\n *       if (source < start) {\n *         source = start * 2 - source - 0;\n *       } else if (source >= end) {\n *         source = (end - 1) * 2 - source + 0;\n *       }\n *       source -= start;\n *\n *       result[0] = getChannel(getX(source), source);\n *       rc += 1;\n *       if(rc < 6) {\n *          int source = rc;\n *          if (source < start) {\n *            source = start * 2 - source - 0;\n *          } else if (source >= end) {\n *            source = (end - 1) * 2 - source + 0;\n *          }\n *          source -= start;\n *\n *         result[1] = getChannel(getX(source), source);\n *       }\n *\n *       setOutput(result);\n *     }\n * ```\n */\nexport class MirrorPadPackedProgram {\n    constructor(xShape, paddings, mode) {\n        this.variableNames = ['x'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const dtype = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const coords = getChannels('rc', rank);\n        const source = getChannels('source', rank);\n        const cLimit = `${coords[rank - 1]} < ${this.outputShape[rank - 1]}`;\n        const innerDims = rank === 1 ? 'source' : `vec2(${source.slice(-2).join()})`;\n        const offset = mode === 'reflect' ? 0 : 1;\n        let mainLoop = '';\n        if (rank === 1) {\n            const padSetup = `\n        ${dtype} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${offset};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${offset};\n        }\n        source -= start;\n      `;\n            mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n      `;\n        }\n        else {\n            const padSetup = `\n        ${dtype} source = rc;\n        ${dtype} lt = ${dtype}(lessThan(source, start));\n        ${dtype} gte = ${dtype}(greaterThanEqual(source, end));\n        ${dtype} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${offset}) +\n                gte * ((end - 1) * 2 - source + ${offset});\n        source -= start;\n      `;\n            mainLoop = `\n        ${dtype} rc = outputLoc;\n        ${padSetup}\n        result[0] = getChannel(getX(${source.join()}), ${innerDims});\n        ${coords[rank - 1]} += 1;\n        if(${cLimit}) {\n          ${padSetup}\n          result[1] = getChannel(getX(${source.join()}), ${innerDims});\n        }\n        rc = outputLoc;\n        ${coords[rank - 2]} += 1;\n        if(${coords[rank - 2]} < ${this.outputShape[rank - 2]}) {\n          ${padSetup}\n          result[2] = getChannel(getX(${source.join()}), ${innerDims});\n          ${coords[rank - 1]} += 1;\n          if(${cLimit}) {\n            ${padSetup}\n            result[3] = getChannel(getX(${source.join()}), ${innerDims});\n          }\n        }\n      `;\n        }\n        this.userCode = `\n      const ${dtype} start = ${dtype}(${start});\n      const ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${mainLoop}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=mirror_pad_packed_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class MultinomialProgram {\n    constructor(batchSize, numOutcomes, numSamples) {\n        this.variableNames = ['probs'];\n        this.outputShape = [batchSize, numSamples];\n        this.userCode = `\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${numOutcomes - 1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${numOutcomes - 1}));\n      }\n    `;\n    }\n    getCustomSetupFunc(seed) {\n        return (gpgpu, webGLProgram) => {\n            if (this.seedLoc == null) {\n                this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');\n            }\n            gpgpu.gl.uniform1f(this.seedLoc, seed);\n        };\n    }\n}\n//# sourceMappingURL=multinomial_gpu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getCoordsDataType } from './shader_compiler';\nexport class MirrorPadProgram {\n    constructor(xShape, paddings, mode) {\n        this.variableNames = ['x'];\n        this.outputShape = paddings.map((p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n        const rank = xShape.length;\n        const dtype = getCoordsDataType(rank);\n        const start = paddings.map(p => p[0]).join(',');\n        const end = paddings.map((p, i) => p[0] + xShape[i]).join(',');\n        const unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);\n        const offset = mode === 'reflect' ? 0 : 1;\n        if (rank === 1) {\n            this.userCode = `\n        int start = ${start};\n        int end = ${end};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${offset};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${offset};\n          }\n          setOutput(getX(outC - start));\n        }\n      `;\n            return;\n        }\n        this.userCode = `\n      ${dtype} start = ${dtype}(${start});\n      ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outC = getOutputCoords();\n        for (int i = 0; i < ${rank}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${offset};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${offset};\n          }\n        }\n        ${dtype} coords = outC - start;\n        setOutput(getX(${unpackedCoords}));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=mirror_pad_gpu.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class MatMulPackedProgram {\n    constructor(aShape, bShape, outputShape, transposeA = false, transposeB = false, addBias = false, activation = null, hasPreluActivation = false, hasLeakyreluActivation = false) {\n        this.variableNames = ['matrixA', 'matrixB'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = outputShape;\n        const sharedDim = transposeA ? aShape[1] : aShape[2];\n        const sharedDimensionPacked = Math.ceil(sharedDim / 2);\n        const aSample = transposeA ? 'i * 2, rc.y' : 'rc.y, i * 2';\n        const bSample = transposeB ? 'rc.z, i * 2' : 'i * 2, rc.z';\n        const aSwizzle = transposeA ? ['a.xxyy', 'a.zzww'] : ['a.xxzz', 'a.yyww'];\n        const bSwizzle = transposeB ? ['b.xzxz', 'b.ywyw'] : ['b.xyxy', 'b.zwzw'];\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyreluActivation) {\n                activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `vec4 activation(vec4 x) {\n          ${activation}\n        }`;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyreluActivation) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        let batchASnippet = 'rc.x';\n        let batchBSnippet = 'rc.x';\n        if (aShape[0] < bShape[0]) {\n            batchASnippet = `int(min(float(rc.x), ${aShape[0] - 1}.))`;\n        }\n        else if (bShape[0] < aShape[0]) {\n            batchBSnippet = `int(min(float(rc.x), ${bShape[0] - 1}.))`;\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const float sharedDimension = ${sharedDimensionPacked}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${sharedDimensionPacked}; i++) {\n          int batchA = ${batchASnippet};\n          int batchB = ${batchBSnippet};\n          vec4 a = getMatrixA(batchA, ${aSample});\n          vec4 b = getMatrixB(batchB, ${bSample});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${aSwizzle[0]} * ${bSwizzle[0]});\n          result += (${aSwizzle[1]} * ${bSwizzle[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${addBiasSnippet}\n\n        ${applyActivationSnippet}\n\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=mulmat_packed_gpu.js.map","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport class MeanProgram {\n    constructor(reduceInfo, divisor) {\n        this.variableNames = ['x'];\n        const { windowSize, batchSize, inSize, outSize } = reduceInfo;\n        this.outputShape = [batchSize, outSize];\n        const windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;\n        const windowSizeVec4Remainder = windowSize % 4;\n        let updateSnippet = `sumValue += dot(values, ones);`;\n        if (divisor != null) {\n            const denominator = 1 / divisor;\n            updateSnippet = `sumValue += dot(values * ${util.isInt(denominator) ? denominator.toPrecision(2) :\n                denominator}, ones);`;\n        }\n        let checkOutOfBounds = '';\n        if (inSize % windowSize > 0) {\n            checkOutOfBounds = `\n        if (inIdx < 0 || inIdx >= ${inSize}) {\n          return 0.0;\n        }\n      `;\n        }\n        this.userCode = `\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${checkOutOfBounds}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${windowSize};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${windowSizeNearestVec4}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${updateSnippet}\n        }\n\n        int inIdx = inOffset + ${windowSizeNearestVec4};\n        if (${windowSizeVec4Remainder === 1}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 2}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${updateSnippet}\n        } else if (${windowSizeVec4Remainder === 3}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${updateSnippet}\n        }\n        setOutput(sumValue);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=mean_gpu.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class OneHotProgram {\n    constructor(numIndices, depth, onValue, offValue) {\n        this.variableNames = ['indices'];\n        this.outputShape = [numIndices, depth];\n        this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${offValue}), float(${onValue}),\n                      float(index == coords.y)));\n      }\n    `;\n    }\n}\n//# sourceMappingURL=onehot_gpu.js.map"],"names":["MirrorPadPackedProgram","constructor","xShape","paddings","mode","this","variableNames","packedInputs","packedOutput","outputShape","map","p","i","rank","length","dtype","start","join","end","coords","source","cLimit","innerDims","slice","offset","mainLoop","padSetup","userCode","MultinomialProgram","batchSize","numOutcomes","numSamples","getCustomSetupFunc","seed","gpgpu","webGLProgram","seedLoc","getUniformLocation","gl","uniform1f","MirrorPadProgram","unpackedCoords","MatMulPackedProgram","aShape","bShape","transposeA","transposeB","addBias","activation","hasPreluActivation","hasLeakyreluActivation","sharedDim","sharedDimensionPacked","Math","ceil","aSample","bSample","aSwizzle","bSwizzle","activationSnippet","applyActivationSnippet","addBiasSnippet","push","batchASnippet","batchBSnippet","MeanProgram","reduceInfo","divisor","windowSize","inSize","outSize","windowSizeNearestVec4","floor","windowSizeVec4Remainder","updateSnippet","denominator","util","toPrecision","checkOutOfBounds","OneHotProgram","numIndices","depth","onValue","offValue"],"sourceRoot":""}