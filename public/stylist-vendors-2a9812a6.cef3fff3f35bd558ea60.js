"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[7305],{7580:function(t,i,s){var e=s(9495),n=s(59885),a=s(47661),r=s(87504),l=s(79730),o=s(15841),u=s(59351),h=s(84379),c=s(44813),p=s(73072),g=s(63057);class d extends l.Wd{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const i=t.shape,s=[];for(let e=0;e<this.noiseShape.length;++e)s.push(null==this.noiseShape[e]?i[e]:this.noiseShape[e]);return s}call(t,i){return(0,e.tidy)((()=>{this.invokeCallHook(t,i);const s=(0,g.un)(t);if(0<this.rate&&this.rate<1){const t=null!=i.training&&i.training,e=this.getNoiseShape(s);return a.Ls((()=>a.EZ(s,this.rate,e,this.seed)),(()=>s),t)}return t}))}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},i=super.getConfig();return Object.assign(t,i),t}dispose(){return super.dispose()}}d.className="Dropout",e.serialization.registerClass(d);class m extends d{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const i=t.shape;return[i[0],1,i[2]]}}m.className="SpatialDropout1D",e.serialization.registerClass(m);class k extends l.Wd{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let i=null;null!=t.batchSize&&(i=t.batchSize),this.batchInputShape=[i,t.inputDim]}this.units=t.units,(0,c.oo)(this.units,"units"),this.activation=(0,n.b_)(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=(0,u.Fe)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=(0,u.Fe)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=(0,r.YZ)(t.kernelConstraint),this.biasConstraint=(0,r.YZ)(t.biasConstraint),this.kernelRegularizer=(0,h.Bm)(t.kernelRegularizer),this.biasRegularizer=(0,h.Bm)(t.biasRegularizer),this.activityRegularizer=(0,h.Bm)(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const i=(t=(0,g.U$)(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[i,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:i}}],this.built=!0}computeOutputShape(t){const i=(t=(0,g.U$)(t)).slice();return i[i.length-1]=this.units,i}call(t,i){return(0,e.tidy)((()=>{this.invokeCallHook(t,i);const s=(0,g.un)(t),e=(0,c.Cd)(this.activation.getClassName());let n;return null!=e?n=a.Om(s,this.kernel.read(),e,this.bias?this.bias.read():null):(n=a.Om(s,this.kernel.read()),null!=this.bias&&(n=a.ni(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n}))}getConfig(){const t={units:this.units,activation:(0,n.Bu)(this.activation),useBias:this.useBias,kernelInitializer:(0,u.zo)(this.kernelInitializer),biasInitializer:(0,u.zo)(this.biasInitializer),kernelRegularizer:(0,h.R9)(this.kernelRegularizer),biasRegularizer:(0,h.R9)(this.biasRegularizer),activityRegularizer:(0,h.R9)(this.activityRegularizer),kernelConstraint:(0,r.uH)(this.kernelConstraint),biasConstraint:(0,r.uH)(this.biasConstraint)},i=super.getConfig();return Object.assign(t,i),t}}k.className="Dense",e.serialization.registerClass(k);class f extends l.Wd{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=(0,g.U$)(t);for(const i of t.slice(1))if(null==i)throw new o.Qp(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],(0,p.no)(t,1)]}call(t,i){return(0,e.tidy)((()=>{this.invokeCallHook(t,i);let s=(0,g.un)(t);if("channelsFirst"===this.dataFormat&&s.rank>1){const t=[0];for(let i=2;i<s.rank;++i)t.push(i);t.push(1),s=(0,e.transpose)(s,t)}return a.PS(s)}))}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const i=super.getConfig();return Object.assign(t,i),t}}f.className="Flatten",e.serialization.registerClass(f);class C extends l.Wd{constructor(t){super(t),this.supportsMasking=!0,this.activation=(0,n.b_)(t.activation)}call(t,i){return(0,e.tidy)((()=>{this.invokeCallHook(t,i);const s=(0,g.un)(t);return this.activation.apply(s)}))}getConfig(){const t={activation:(0,n.Bu)(this.activation)},i=super.getConfig();return Object.assign(t,i),t}}C.className="Activation",e.serialization.registerClass(C);class S extends l.Wd{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,i){return(0,e.tidy)((()=>(t=(0,g.un)(t),a.ux(t,this.n))))}getConfig(){const t={n:this.n},i=super.getConfig();return Object.assign(t,i),t}}S.className="RepeatVector",e.serialization.registerClass(S);class b extends l.Wd{constructor(t){super(t),this.targetShape=t.targetShape;for(let i=0;i<this.targetShape.length;++i)this.isUnknown(this.targetShape[i])&&(this.targetShape[i]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,i){const s="Total size of new array must be unchanged.",e=i.slice();let n=1,a=null;for(let l=0;l<e.length;++l){const t=e[l];if(this.isUnknown(t)){if(null!==a)throw new o.Qp("Can only specifiy one unknown dimension.");a=l}else n*=t}const r=(0,p.no)(t);if(null!==a){if(0===n||r%n!==0)throw new o.Qp(s);e[a]=r/n}else if(r!==n)throw new o.Qp(s);return e}computeOutputShape(t){let i=!1;for(let s=0;s<t.length;++s)if(this.isUnknown(t[s])){i=!0;break}return i?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,i){return(0,e.tidy)((()=>{this.invokeCallHook(t,i);const s=(0,g.un)(t),n=s.shape,a=n.slice(0,1).concat(this.fixUnknownDimension(n.slice(1),this.targetShape));return(0,e.reshape)(s,a)}))}getConfig(){const t={targetShape:this.targetShape},i=super.getConfig();return Object.assign(t,i),t}}b.className="Reshape",e.serialization.registerClass(b);class z extends l.Wd{constructor(t){if(super(t),null==t.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const i=(0,p.y1)(1,t.dims.length+1);if(!e.util.arraysEqual(t.dims.slice().sort(),i))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new l.eO({ndim:this.dims.length+1})]}computeOutputShape(t){const i=(t=(0,g.U$)(t)).slice();return this.dims.forEach(((s,e)=>{i[e+1]=t[s]})),i}call(t,i){return(0,e.transpose)((0,g.un)(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},i=super.getConfig();return Object.assign(t,i),t}}z.className="Permute",e.serialization.registerClass(z);class I extends l.Wd{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),i={maskValue:this.maskValue};return Object.assign(i,t),i}computeMask(t,i){const s=(0,g.un)(t);return(0,e.any)((0,e.notEqual)(s,this.maskValue),-1)}call(t,i){return(0,e.tidy)((()=>{this.invokeCallHook(t,i);const s=(0,g.un)(t),n=(0,e.any)((0,e.notEqual)(s,this.maskValue),-1,!0);return(0,e.mul)(s,(0,e.cast)(n,s.dtype))}))}}I.className="Masking",e.serialization.registerClass(I)}}]);
//# sourceMappingURL=stylist-vendors-2a9812a6.cef3fff3f35bd558ea60.js.map