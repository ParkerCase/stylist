{"version":3,"file":"stylist-vendors-d083abec.68c0a8b5b56dbe175bd4.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Range.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedGather_impl.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedTensorToTensor.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedRange_impl.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/Range_impl.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedGather.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedTensorToTensor_impl.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/RaggedRange.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Range } from '@tensorflow/tfjs-core';\nimport { rangeImpl } from './Range_impl';\nexport function range(args) {\n    const { backend, attrs } = args;\n    const { start, stop, dtype, step } = attrs;\n    const values = rangeImpl(start, stop, step, dtype);\n    return backend.makeTensorInfo([values.length], dtype, values);\n}\nexport const rangeConfig = {\n    kernelName: Range,\n    backendName: 'cpu',\n    kernelFunc: range\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFuZ2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtY3B1L3NyYy9rZXJuZWxzL1JhbmdlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBMkIsS0FBSyxFQUF5QixNQUFNLHVCQUF1QixDQUFDO0FBRzlGLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFFdkMsTUFBTSxVQUFVLEtBQUssQ0FBQyxJQUFrRDtJQUV0RSxNQUFNLEVBQUMsT0FBTyxFQUFFLEtBQUssRUFBQyxHQUFHLElBQUksQ0FBQztJQUM5QixNQUFNLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFDLEdBQUcsS0FBSyxDQUFDO0lBRXpDLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNuRCxPQUFPLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ2hFLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxXQUFXLEdBQWlCO0lBQ3ZDLFVBQVUsRUFBRSxLQUFLO0lBQ2pCLFdBQVcsRUFBRSxLQUFLO0lBQ2xCLFVBQVUsRUFBRSxLQUE4QjtDQUMzQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0tlcm5lbENvbmZpZywgS2VybmVsRnVuYywgUmFuZ2UsIFJhbmdlQXR0cnMsIFRlbnNvckluZm99IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7TWF0aEJhY2tlbmRDUFV9IGZyb20gJy4uL2JhY2tlbmRfY3B1JztcbmltcG9ydCB7cmFuZ2VJbXBsfSBmcm9tICcuL1JhbmdlX2ltcGwnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2UoYXJnczoge2JhY2tlbmQ6IE1hdGhCYWNrZW5kQ1BVLCBhdHRyczogUmFuZ2VBdHRyc30pOlxuICAgIFRlbnNvckluZm8ge1xuICBjb25zdCB7YmFja2VuZCwgYXR0cnN9ID0gYXJncztcbiAgY29uc3Qge3N0YXJ0LCBzdG9wLCBkdHlwZSwgc3RlcH0gPSBhdHRycztcblxuICBjb25zdCB2YWx1ZXMgPSByYW5nZUltcGwoc3RhcnQsIHN0b3AsIHN0ZXAsIGR0eXBlKTtcbiAgcmV0dXJuIGJhY2tlbmQubWFrZVRlbnNvckluZm8oW3ZhbHVlcy5sZW5ndGhdLCBkdHlwZSwgdmFsdWVzKTtcbn1cblxuZXhwb3J0IGNvbnN0IHJhbmdlQ29uZmlnOiBLZXJuZWxDb25maWcgPSB7XG4gIGtlcm5lbE5hbWU6IFJhbmdlLFxuICBiYWNrZW5kTmFtZTogJ2NwdScsXG4gIGtlcm5lbEZ1bmM6IHJhbmdlIGFzIHVua25vd24gYXMgS2VybmVsRnVuY1xufTtcbiJdfQ==","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nfunction validateIndices(indices, indicesShape, numParams) {\n    indices.forEach((index, i) => {\n        if (index < 0 || index >= numParams) {\n            const locString = util.indexToLoc(i, indicesShape.length, util.computeStrides(indicesShape))\n                .join(',');\n            throw new Error(`indices[${locString}] = ${index} is not in [0, ${numParams})`);\n        }\n    });\n}\nfunction validateSplits(paramsNestedSplits, numParamsDenseValues) {\n    // Validate\n    for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n        const splits = paramsNestedSplits[dim];\n        const lastSplit = (dim === paramsNestedSplits.length - 1) ?\n            numParamsDenseValues :\n            paramsNestedSplits[dim + 1].length;\n        if (splits.length === 0) {\n            throw new Error('Ragged splits may not be empty');\n        }\n        if (splits[0] < 0) {\n            throw new Error('Ragged splits must be non-negative');\n        }\n        if (splits[splits.length - 1] > lastSplit) {\n            throw new Error('Ragged splits must not point past values');\n        }\n        for (let i = 1; i < splits.length; ++i) {\n            if (splits[i - 1] > splits[i]) {\n                throw new Error('Ragged splits must be sorted in ascending order');\n            }\n        }\n    }\n}\n// Construct the `splits` output tensors, encoded using a nested vector.\n// Also find the slices of values that need to be copied, and store them\n// in `valueSlices`.  The total number of values that will be copied (which\n// we need for allocating the output values tensor) is stored in `numValues`.\nfunction makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues) {\n    const valueSlices = [];\n    let numValues = 0;\n    const numSplits = indicesShape.length - 1 + paramsNestedSplits.length;\n    const outSplits = new Array(numSplits).fill(null).map(() => [0]);\n    validateSplits(paramsNestedSplits, numParamsDenseValues);\n    // Add `splits` that come from all but the last dimension of the dense\n    // Tensor `indices`.  In particular, for each dimension D, we add a\n    // splits tensor whose values are:\n    //   range(reduceProd(splits.shape[:D]) + 1) * splits.shape[D+1]\n    // E.g., if indices.shape=[2, 3, 4] then we will add splits tensors:\n    //   [0, 3, 6]                    # length=2+1, stride=3\n    //   [0, 4, 8, 12, 16, 20, 24]    # length=2*3+1, stride=4\n    let nrows = 1;\n    for (let dim = 0; dim < indicesShape.length - 1; ++dim) {\n        nrows *= indicesShape[dim];\n        const rowLength = indicesShape[dim + 1];\n        for (let i = 1; i < nrows + 1; ++i) {\n            outSplits[dim].push(i * rowLength);\n        }\n    }\n    // Add `splits` that come from `paramsNestedSplits`.  Starting with the\n    // outermost ragged dimension (i.e., the first `splits` tensor), we work\n    // our way in, finding the range of values that should be copied.  As we\n    // go, we update the output `splits` for each dimension with the appropriate\n    // values.  In particular, the *lengths* of the slices from `param_splits`\n    // should be copied to generate corresponding slice lengths in the output\n    // splits.  E.g., if we are copying a ragged row with length 4, then we\n    // should add a new split point to outSplits that is 4 greater than the\n    // previous split point in outSplits.\n    for (let i = 0; i < indices.length; ++i) {\n        let start = indices[i];\n        let limit = indices[i] + 1;\n        // Copy splits.\n        for (let dim = 0; dim < paramsNestedSplits.length; ++dim) {\n            const splits = paramsNestedSplits[dim];\n            const outDim = dim + indicesShape.length - 1;\n            if (outDim >= 0) {\n                const outSplitsOutDim = outSplits[outDim];\n                const delta = outSplitsOutDim[outSplitsOutDim.length - 1] - splits[start];\n                for (let j = start; j < limit; ++j) {\n                    outSplits[outDim].push(splits[j + 1] + delta);\n                }\n            }\n            start = splits[start];\n            limit = splits[limit];\n        }\n        if (limit !== start) {\n            valueSlices.push([start, limit]);\n            numValues += limit - start;\n        }\n    }\n    return { outSplits, valueSlices, numValues };\n}\nfunction getSplits(outSplits) {\n    const splitsOut = [];\n    for (let i = 0; i < outSplits.length; ++i) {\n        const numSplits = outSplits[i].length;\n        const splits = util.getArrayFromDType('int32', numSplits);\n        splitsOut.push(splits);\n        outSplits[i].forEach((value, j) => splits[j] = value);\n    }\n    return splitsOut;\n}\nfunction computeFlatOuterDims(orig, numOutDims) {\n    const outDims = orig.slice(0, numOutDims);\n    while (outDims.length < numOutDims) {\n        outDims.push(1);\n    }\n    for (let inDim = numOutDims; inDim < orig.length; inDim++) {\n        outDims[numOutDims - 1] *= orig[inDim];\n    }\n    return outDims;\n}\n// For each slice in `(start, limit)` in `valueSlices`, append\n// `paramsDenseValues[start,...,limit] to `values`.  `valueSize` indicates\n// the number of scalars contained in each value paramsDenseValues[i].\nfunction writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, values, valuesShape) {\n    const denseM = computeFlatOuterDims(paramsDenseValuesShape, 2)[1];\n    const valuesM = computeFlatOuterDims(valuesShape, 2)[1];\n    let outPos = 0;\n    for (const slice of valueSlices) {\n        for (let i = slice[0]; i < slice[1]; ++i) {\n            for (let j = 0; j < valueSize; ++j) {\n                values[outPos * valuesM + j] = paramsDenseValues[i * denseM + j];\n            }\n            ++outPos;\n        }\n    }\n}\nfunction getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues) {\n    const valuesShape = paramsDenseValuesShape.slice();\n    valuesShape[0] = numValues;\n    const valuesOut = util.getArrayFromDType(paramsDenseValuesDType, util.sizeFromShape(valuesShape));\n    const numElements = paramsDenseValues.length;\n    const valueSize = numElements === 0 ? 0 : (numElements / paramsDenseValuesShape[0]);\n    writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, valuesOut, valuesShape);\n    return [valuesOut, valuesShape];\n}\nexport function raggedGatherImpl(paramsNestedSplits, paramsNestedSplitsShapes, paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, indices, indicesShape, outputRaggedRank) {\n    if (paramsNestedSplits.length === 0) {\n        throw new Error('paramsNestedSplits must be non empty');\n    }\n    if (paramsNestedSplitsShapes[0].length === 0) {\n        throw new Error('Split tensors must not be scalars');\n    }\n    const numParams = paramsNestedSplitsShapes[0][0] - 1;\n    validateIndices(indices, indicesShape, numParams);\n    if (paramsDenseValuesShape.length === 0) {\n        throw new Error('params.rank must be nonzero');\n    }\n    const numParamsDenseValues = paramsDenseValuesShape[0];\n    // Calculate the `splits`, and store the value slices that we need to\n    // copy in `valueSlices`.\n    const { outSplits, valueSlices, numValues } = makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues);\n    // Write the output tensors.\n    const outputNestedSplits = getSplits(outSplits);\n    const outputDenseValues = getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues);\n    return [outputNestedSplits, outputDenseValues[0], outputDenseValues[1]];\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFnZ2VkR2F0aGVyX2ltcGwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtY3B1L3NyYy9rZXJuZWxzL1JhZ2dlZEdhdGhlcl9pbXBsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBdUIsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFakUsU0FBUyxlQUFlLENBQ3BCLE9BQW1CLEVBQUUsWUFBc0IsRUFBRSxTQUFpQjtJQUNoRSxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBYSxFQUFFLENBQVMsRUFBRSxFQUFFO1FBQzNDLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxLQUFLLElBQUksU0FBUyxFQUFFO1lBQ25DLE1BQU0sU0FBUyxHQUNYLElBQUksQ0FBQyxVQUFVLENBQ1AsQ0FBQyxFQUFFLFlBQVksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQztpQkFDN0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ25CLE1BQU0sSUFBSSxLQUFLLENBQ1gsV0FBVyxTQUFTLE9BQU8sS0FBSyxrQkFBa0IsU0FBUyxHQUFHLENBQUMsQ0FBQztTQUNyRTtJQUNILENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELFNBQVMsY0FBYyxDQUNuQixrQkFBZ0MsRUFBRSxvQkFBNEI7SUFDaEUsV0FBVztJQUNYLEtBQUssSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsRUFBRSxHQUFHLEVBQUU7UUFDeEQsTUFBTSxNQUFNLEdBQUcsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdkMsTUFBTSxTQUFTLEdBQUcsQ0FBQyxHQUFHLEtBQUssa0JBQWtCLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdkQs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TUFBTSxrQkFBa0IsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDaEQsTUFBTSxpQkFBaUIsR0FBRyxTQUFTLENBQy9CLGlCQUFpQixFQUFFLHNCQUFzQixFQUFFLHNCQUFzQixFQUNqRSxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFFNUIsT0FBTyxDQUFDLGtCQUFrQixFQUFFLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxFQUFFLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtEYXRhVHlwZSwgVHlwZWRBcnJheSwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuZnVuY3Rpb24gdmFsaWRhdGVJbmRpY2VzKFxuICAgIGluZGljZXM6IFR5cGVkQXJyYXksIGluZGljZXNTaGFwZTogbnVtYmVyW10sIG51bVBhcmFtczogbnVtYmVyKSB7XG4gIGluZGljZXMuZm9yRWFjaCgoaW5kZXg6IG51bWJlciwgaTogbnVtYmVyKSA9PiB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBudW1QYXJhbXMpIHtcbiAgICAgIGNvbnN0IGxvY1N0cmluZyA9XG4gICAgICAgICAgdXRpbC5pbmRleFRvTG9jKFxuICAgICAgICAgICAgICAgICAgaSwgaW5kaWNlc1NoYXBlLmxlbmd0aCwgdXRpbC5jb21wdXRlU3RyaWRlcyhpbmRpY2VzU2hhcGUpKVxuICAgICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBpbmRpY2VzWyR7bG9jU3RyaW5nfV0gPSAke2luZGV4fSBpcyBub3QgaW4gWzAsICR7bnVtUGFyYW1zfSlgKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVNwbGl0cyhcbiAgICBwYXJhbXNOZXN0ZWRTcGxpdHM6IFR5cGVkQXJyYXlbXSwgbnVtUGFyYW1zRGVuc2VWYWx1ZXM6IG51bWJlcikge1xuICAvLyBWYWxpZGF0ZVxuICBmb3IgKGxldCBkaW0gPSAwOyBkaW0gPCBwYXJhbXNOZXN0ZWRTcGxpdHMubGVuZ3RoOyArK2RpbSkge1xuICAgIGNvbnN0IHNwbGl0cyA9IHBhcmFtc05lc3RlZFNwbGl0c1tkaW1dO1xuICAgIGNvbnN0IGxhc3RTcGxpdCA9IChkaW0gPT09IHBhcmFtc05lc3RlZFNwbGl0cy5sZW5ndGggLSAxKSA/XG4gICAgICAgIG51bVBhcmFtc0RlbnNlVmFsdWVzIDpcbiAgICAgICAgcGFyYW1zTmVzdGVkU3BsaXRzW2RpbSArIDFdLmxlbmd0aDtcbiAgICBpZiAoc3BsaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYWdnZWQgc3BsaXRzIG1heSBub3QgYmUgZW1wdHknKTtcbiAgICB9XG4gICAgaWYgKHNwbGl0c1swXSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmFnZ2VkIHNwbGl0cyBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xuICAgIH1cbiAgICBpZiAoc3BsaXRzW3NwbGl0cy5sZW5ndGggLSAxXSA+IGxhc3RTcGxpdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYWdnZWQgc3BsaXRzIG11c3Qgbm90IHBvaW50IHBhc3QgdmFsdWVzJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3BsaXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoc3BsaXRzW2kgLSAxXSA+IHNwbGl0c1tpXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JhZ2dlZCBzcGxpdHMgbXVzdCBiZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIENvbnN0cnVjdCB0aGUgYHNwbGl0c2Agb3V0cHV0IHRlbnNvcnMsIGVuY29kZWQgdXNpbmcgYSBuZXN0ZWQgdmVjdG9yLlxuLy8gQWxzbyBmaW5kIHRoZSBzbGljZXMgb2YgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSBjb3BpZWQsIGFuZCBzdG9yZSB0aGVtXG4vLyBpbiBgdmFsdWVTbGljZXNgLiAgVGhlIHRvdGFsIG51bWJlciBvZiB2YWx1ZXMgdGhhdCB3aWxsIGJlIGNvcGllZCAod2hpY2hcbi8vIHdlIG5lZWQgZm9yIGFsbG9jYXRpbmcgdGhlIG91dHB1dCB2YWx1ZXMgdGVuc29yKSBpcyBzdG9yZWQgaW4gYG51bVZhbHVlc2AuXG5mdW5jdGlvbiBtYWtlU3BsaXRzKFxuICAgIGluZGljZXM6IFR5cGVkQXJyYXksIGluZGljZXNTaGFwZTogbnVtYmVyW10sXG4gICAgcGFyYW1zTmVzdGVkU3BsaXRzOiBUeXBlZEFycmF5W10sIG51bVBhcmFtc0RlbnNlVmFsdWVzOiBudW1iZXIpIHtcbiAgY29uc3QgdmFsdWVTbGljZXM6IEFycmF5PFtudW1iZXIsIG51bWJlcl0+ID0gW107XG4gIGxldCBudW1WYWx1ZXMgPSAwO1xuXG4gIGNvbnN0IG51bVNwbGl0cyA9IGluZGljZXNTaGFwZS5sZW5ndGggLSAxICsgcGFyYW1zTmVzdGVkU3BsaXRzLmxlbmd0aDtcbiAgY29uc3Qgb3V0U3BsaXRzID0gbmV3IEFycmF5KG51bVNwbGl0cykuZmlsbChudWxsKS5tYXAoKCkgPT4gWzBdKTtcblxuICB2YWxpZGF0ZVNwbGl0cyhwYXJhbXNOZXN0ZWRTcGxpdHMsIG51bVBhcmFtc0RlbnNlVmFsdWVzKTtcblxuICAvLyBBZGQgYHNwbGl0c2AgdGhhdCBjb21lIGZyb20gYWxsIGJ1dCB0aGUgbGFzdCBkaW1lbnNpb24gb2YgdGhlIGRlbnNlXG4gIC8vIFRlbnNvciBgaW5kaWNlc2AuICBJbiBwYXJ0aWN1bGFyLCBmb3IgZWFjaCBkaW1lbnNpb24gRCwgd2UgYWRkIGFcbiAgLy8gc3BsaXRzIHRlbnNvciB3aG9zZSB2YWx1ZXMgYXJlOlxuICAvLyAgIHJhbmdlKHJlZHVjZVByb2Qoc3BsaXRzLnNoYXBlWzpEXSkgKyAxKSAqIHNwbGl0cy5zaGFwZVtEKzFdXG4gIC8vIEUuZy4sIGlmIGluZGljZXMuc2hhcGU9WzIsIDMsIDRdIHRoZW4gd2Ugd2lsbCBhZGQgc3BsaXRzIHRlbnNvcnM6XG4gIC8vICAgWzAsIDMsIDZdICAgICAgICAgICAgICAgICAgICAjIGxlbmd0aD0yKzEsIHN0cmlkZT0zXG4gIC8vICAgWzAsIDQsIDgsIDEyLCAxNiwgMjAsIDI0XSAgICAjIGxlbmd0aD0yKjMrMSwgc3RyaWRlPTRcbiAgbGV0IG5yb3dzID0gMTtcbiAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgaW5kaWNlc1NoYXBlLmxlbmd0aCAtIDE7ICsrZGltKSB7XG4gICAgbnJvd3MgKj0gaW5kaWNlc1NoYXBlW2RpbV07XG4gICAgY29uc3Qgcm93TGVuZ3RoID0gaW5kaWNlc1NoYXBlW2RpbSArIDFdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnJvd3MgKyAxOyArK2kpIHtcbiAgICAgIG91dFNwbGl0c1tkaW1dLnB1c2goaSAqIHJvd0xlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIGBzcGxpdHNgIHRoYXQgY29tZSBmcm9tIGBwYXJhbXNOZXN0ZWRTcGxpdHNgLiAgU3RhcnRpbmcgd2l0aCB0aGVcbiAgLy8gb3V0ZXJtb3N0IHJhZ2dlZCBkaW1lbnNpb24gKGkuZS4sIHRoZSBmaXJzdCBgc3BsaXRzYCB0ZW5zb3IpLCB3ZSB3b3JrXG4gIC8vIG91ciB3YXkgaW4sIGZpbmRpbmcgdGhlIHJhbmdlIG9mIHZhbHVlcyB0aGF0IHNob3VsZCBiZSBjb3BpZWQuICBBcyB3ZVxuICAvLyBnbywgd2UgdXBkYXRlIHRoZSBvdXRwdXQgYHNwbGl0c2AgZm9yIGVhY2ggZGltZW5zaW9uIHdpdGggdGhlIGFwcHJvcHJpYXRlXG4gIC8vIHZhbHVlcy4gIEluIHBhcnRpY3VsYXIsIHRoZSAqbGVuZ3Rocyogb2YgdGhlIHNsaWNlcyBmcm9tIGBwYXJhbV9zcGxpdHNgXG4gIC8vIHNob3VsZCBiZSBjb3BpZWQgdG8gZ2VuZXJhdGUgY29ycmVzcG9uZGluZyBzbGljZSBsZW5ndGhzIGluIHRoZSBvdXRwdXRcbiAgLy8gc3BsaXRzLiAgRS5nLiwgaWYgd2UgYXJlIGNvcHlpbmcgYSByYWdnZWQgcm93IHdpdGggbGVuZ3RoIDQsIHRoZW4gd2VcbiAgLy8gc2hvdWxkIGFkZCBhIG5ldyBzcGxpdCBwb2ludCB0byBvdXRTcGxpdHMgdGhhdCBpcyA0IGdyZWF0ZXIgdGhhbiB0aGVcbiAgLy8gcHJldmlvdXMgc3BsaXQgcG9pbnQgaW4gb3V0U3BsaXRzLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgc3RhcnQgPSBpbmRpY2VzW2ldO1xuICAgIGxldCBsaW1pdCA9IGluZGljZXNbaV0gKyAxO1xuXG4gICAgLy8gQ29weSBzcGxpdHMuXG4gICAgZm9yIChsZXQgZGltID0gMDsgZGltIDwgcGFyYW1zTmVzdGVkU3BsaXRzLmxlbmd0aDsgKytkaW0pIHtcbiAgICAgIGNvbnN0IHNwbGl0cyA9IHBhcmFtc05lc3RlZFNwbGl0c1tkaW1dO1xuICAgICAgY29uc3Qgb3V0RGltID0gZGltICsgaW5kaWNlc1NoYXBlLmxlbmd0aCAtIDE7XG4gICAgICBpZiAob3V0RGltID49IDApIHtcbiAgICAgICAgY29uc3Qgb3V0U3BsaXRzT3V0RGltID0gb3V0U3BsaXRzW291dERpbV07XG4gICAgICAgIGNvbnN0IGRlbHRhID1cbiAgICAgICAgICAgIG91dFNwbGl0c091dERpbVtvdXRTcGxpdHNPdXREaW0ubGVuZ3RoIC0gMV0gLSBzcGxpdHNbc3RhcnRdO1xuICAgICAgICBmb3IgKGxldCBqID0gc3RhcnQ7IGogPCBsaW1pdDsgKytqKSB7XG4gICAgICAgICAgb3V0U3BsaXRzW291dERpbV0ucHVzaChzcGxpdHNbaiArIDFdICsgZGVsdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFydCA9IHNwbGl0c1tzdGFydF07XG4gICAgICBsaW1pdCA9IHNwbGl0c1tsaW1pdF07XG4gICAgfVxuICAgIGlmIChsaW1pdCAhPT0gc3RhcnQpIHtcbiAgICAgIHZhbHVlU2xpY2VzLnB1c2goW3N0YXJ0LCBsaW1pdF0pO1xuICAgICAgbnVtVmFsdWVzICs9IGxpbWl0IC0gc3RhcnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtvdXRTcGxpdHMsIHZhbHVlU2xpY2VzLCBudW1WYWx1ZXN9O1xufVxuXG5mdW5jdGlvbiBnZXRTcGxpdHMob3V0U3BsaXRzOiBudW1iZXJbXVtdKSB7XG4gIGNvbnN0IHNwbGl0c091dDogVHlwZWRBcnJheVtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0U3BsaXRzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgbnVtU3BsaXRzID0gb3V0U3BsaXRzW2ldLmxlbmd0aDtcbiAgICBjb25zdCBzcGxpdHMgPSB1dGlsLmdldEFycmF5RnJvbURUeXBlKCdpbnQzMicsIG51bVNwbGl0cykgYXMgVHlwZWRBcnJheTtcbiAgICBzcGxpdHNPdXQucHVzaChzcGxpdHMpO1xuXG4gICAgb3V0U3BsaXRzW2ldLmZvckVhY2goKHZhbHVlLCBqOiBudW1iZXIpID0+IHNwbGl0c1tqXSA9IHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBzcGxpdHNPdXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVGbGF0T3V0ZXJEaW1zKG9yaWc6IG51bWJlcltdLCBudW1PdXREaW1zOiBudW1iZXIpIHtcbiAgY29uc3Qgb3V0RGltcyA9IG9yaWcuc2xpY2UoMCwgbnVtT3V0RGltcyk7XG4gIHdoaWxlIChvdXREaW1zLmxlbmd0aCA8IG51bU91dERpbXMpIHtcbiAgICBvdXREaW1zLnB1c2goMSk7XG4gIH1cblxuICBmb3IgKGxldCBpbkRpbSA9IG51bU91dERpbXM7IGluRGltIDwgb3JpZy5sZW5ndGg7IGluRGltKyspIHtcbiAgICBvdXREaW1zW251bU91dERpbXMgLSAxXSAqPSBvcmlnW2luRGltXTtcbiAgfVxuXG4gIHJldHVybiBvdXREaW1zO1xufVxuLy8gRm9yIGVhY2ggc2xpY2UgaW4gYChzdGFydCwgbGltaXQpYCBpbiBgdmFsdWVTbGljZXNgLCBhcHBlbmRcbi8vIGBwYXJhbXNEZW5zZVZhbHVlc1tzdGFydCwuLi4sbGltaXRdIHRvIGB2YWx1ZXNgLiAgYHZhbHVlU2l6ZWAgaW5kaWNhdGVzXG4vLyB0aGUgbnVtYmVyIG9mIHNjYWxhcnMgY29udGFpbmVkIGluIGVhY2ggdmFsdWUgcGFyYW1zRGVuc2VWYWx1ZXNbaV0uXG5mdW5jdGlvbiB3cml0ZVZhbHVlU2xpY2VzKFxuICAgIHBhcmFtc0RlbnNlVmFsdWVzOiBUeXBlZEFycmF5LCBwYXJhbXNEZW5zZVZhbHVlc1NoYXBlOiBudW1iZXJbXSxcbiAgICB2YWx1ZVNsaWNlczogQXJyYXk8W251bWJlciwgbnVtYmVyXT4sIHZhbHVlU2l6ZTogbnVtYmVyLCB2YWx1ZXM6IFR5cGVkQXJyYXksXG4gICAgdmFsdWVzU2hhcGU6IG51bWJlcltdKSB7XG4gIGNvbnN0IGRlbnNlTSA9IGNvbXB1dGVGbGF0T3V0ZXJEaW1zKHBhcmFtc0RlbnNlVmFsdWVzU2hhcGUsIDIpWzFdO1xuICBjb25zdCB2YWx1ZXNNID0gY29tcHV0ZUZsYXRPdXRlckRpbXModmFsdWVzU2hhcGUsIDIpWzFdO1xuXG4gIGxldCBvdXRQb3MgPSAwO1xuICBmb3IgKGNvbnN0IHNsaWNlIG9mIHZhbHVlU2xpY2VzKSB7XG4gICAgZm9yIChsZXQgaSA9IHNsaWNlWzBdOyBpIDwgc2xpY2VbMV07ICsraSkge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZVNpemU7ICsraikge1xuICAgICAgICB2YWx1ZXNbb3V0UG9zICogdmFsdWVzTSArIGpdID0gcGFyYW1zRGVuc2VWYWx1ZXNbaSAqIGRlbnNlTSArIGpdO1xuICAgICAgfVxuICAgICAgKytvdXRQb3M7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlcyhcbiAgICBwYXJhbXNEZW5zZVZhbHVlczogVHlwZWRBcnJheSwgcGFyYW1zRGVuc2VWYWx1ZXNTaGFwZTogbnVtYmVyW10sXG4gICAgcGFyYW1zRGVuc2VWYWx1ZXNEVHlwZTogRGF0YVR5cGUsIHZhbHVlU2xpY2VzOiBBcnJheTxbbnVtYmVyLCBudW1iZXJdPixcbiAgICBudW1WYWx1ZXM6IG51bWJlcik6IFtUeXBlZEFycmF5LCBudW1iZXJbXV0ge1xuICBjb25zdCB2YWx1ZXNTaGFwZSA9IHBhcmFtc0RlbnNlVmFsdWVzU2hhcGUuc2xpY2UoKTtcbiAgdmFsdWVzU2hhcGVbMF0gPSBudW1WYWx1ZXM7XG5cbiAgY29uc3QgdmFsdWVzT3V0ID0gdXRpbC5nZXRBcnJheUZyb21EVHlwZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc0RlbnNlVmFsdWVzRFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodmFsdWVzU2hhcGUpKSBhcyBUeXBlZEFycmF5O1xuXG4gIGNvbnN0IG51bUVsZW1lbnRzID0gcGFyYW1zRGVuc2VWYWx1ZXMubGVuZ3RoO1xuICBjb25zdCB2YWx1ZVNpemUgPVxuICAgICAgbnVtRWxlbWVudHMgPT09IDAgPyAwIDogKG51bUVsZW1lbnRzIC8gcGFyYW1zRGVuc2VWYWx1ZXNTaGFwZVswXSk7XG4gIHdyaXRlVmFsdWVTbGljZXMoXG4gICAgICBwYXJhbXNEZW5zZVZhbHVlcywgcGFyYW1zRGVuc2VWYWx1ZXNTaGFwZSwgdmFsdWVTbGljZXMsIHZhbHVlU2l6ZSxcbiAgICAgIHZhbHVlc091dCwgdmFsdWVzU2hhcGUpO1xuXG4gIHJldHVybiBbdmFsdWVzT3V0LCB2YWx1ZXNTaGFwZV07XG59XG5leHBvcnQgZnVuY3Rpb24gcmFnZ2VkR2F0aGVySW1wbChcbiAgICBwYXJhbXNOZXN0ZWRTcGxpdHM6IFR5cGVkQXJyYXlbXSwgcGFyYW1zTmVzdGVkU3BsaXRzU2hhcGVzOiBudW1iZXJbXVtdLFxuICAgIHBhcmFtc0RlbnNlVmFsdWVzOiBUeXBlZEFycmF5LCBwYXJhbXNEZW5zZVZhbHVlc1NoYXBlOiBudW1iZXJbXSxcbiAgICBwYXJhbXNEZW5zZVZhbHVlc0RUeXBlOiBEYXRhVHlwZSwgaW5kaWNlczogVHlwZWRBcnJheSxcbiAgICBpbmRpY2VzU2hhcGU6IG51bWJlcltdLFxuICAgIG91dHB1dFJhZ2dlZFJhbms6IG51bWJlcik6IFtUeXBlZEFycmF5W10sIFR5cGVkQXJyYXksIG51bWJlcltdXSB7XG4gIGlmIChwYXJhbXNOZXN0ZWRTcGxpdHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXJhbXNOZXN0ZWRTcGxpdHMgbXVzdCBiZSBub24gZW1wdHknKTtcbiAgfVxuXG4gIGlmIChwYXJhbXNOZXN0ZWRTcGxpdHNTaGFwZXNbMF0ubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTcGxpdCB0ZW5zb3JzIG11c3Qgbm90IGJlIHNjYWxhcnMnKTtcbiAgfVxuICBjb25zdCBudW1QYXJhbXMgPSBwYXJhbXNOZXN0ZWRTcGxpdHNTaGFwZXNbMF1bMF0gLSAxO1xuICB2YWxpZGF0ZUluZGljZXMoaW5kaWNlcywgaW5kaWNlc1NoYXBlLCBudW1QYXJhbXMpO1xuXG4gIGlmIChwYXJhbXNEZW5zZVZhbHVlc1NoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigncGFyYW1zLnJhbmsgbXVzdCBiZSBub256ZXJvJyk7XG4gIH1cbiAgY29uc3QgbnVtUGFyYW1zRGVuc2VWYWx1ZXMgPSBwYXJhbXNEZW5zZVZhbHVlc1NoYXBlWzBdO1xuXG4gIC8vIENhbGN1bGF0ZSB0aGUgYHNwbGl0c2AsIGFuZCBzdG9yZSB0aGUgdmFsdWUgc2xpY2VzIHRoYXQgd2UgbmVlZCB0b1xuICAvLyBjb3B5IGluIGB2YWx1ZVNsaWNlc2AuXG4gIGNvbnN0IHtvdXRTcGxpdHMsIHZhbHVlU2xpY2VzLCBudW1WYWx1ZXN9ID0gbWFrZVNwbGl0cyhcbiAgICAgIGluZGljZXMsIGluZGljZXNTaGFwZSwgcGFyYW1zTmVzdGVkU3BsaXRzLCBudW1QYXJhbXNEZW5zZVZhbHVlcyk7XG5cbiAgLy8gV3JpdGUgdGhlIG91dHB1dCB0ZW5zb3JzLlxuICBjb25zdCBvdXRwdXROZXN0ZWRTcGxpdHMgPSBnZXRTcGxpdHMob3V0U3BsaXRzKTtcbiAgY29uc3Qgb3V0cHV0RGVuc2VWYWx1ZXMgPSBnZXRWYWx1ZXMoXG4gICAgICBwYXJhbXNEZW5zZVZhbHVlcywgcGFyYW1zRGVuc2VWYWx1ZXNTaGFwZSwgcGFyYW1zRGVuc2VWYWx1ZXNEVHlwZSxcbiAgICAgIHZhbHVlU2xpY2VzLCBudW1WYWx1ZXMpO1xuXG4gIHJldHVybiBbb3V0cHV0TmVzdGVkU3BsaXRzLCBvdXRwdXREZW5zZVZhbHVlc1swXSwgb3V0cHV0RGVuc2VWYWx1ZXNbMV1dO1xufVxuIl19","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { RaggedTensorToTensor } from '@tensorflow/tfjs-core';\nimport { raggedTensorToTensorImpl } from './RaggedTensorToTensor_impl';\nexport function raggedTensorToTensor(args) {\n    const { inputs, backend, attrs } = args;\n    const { shape, values, defaultValue, rowPartitionTensors } = inputs;\n    const { rowPartitionTypes } = attrs;\n    const $shape = backend.data.get(shape.dataId).values;\n    const $values = backend.data.get(values.dataId).values;\n    const $defaultValue = backend.data.get(defaultValue.dataId).values;\n    const $rowPartitionValues = rowPartitionTensors.map(t => backend.data.get(t.dataId).values);\n    const rowPartitionValuesShapes = rowPartitionTensors.map(t => t.shape);\n    const [outputShape, output] = raggedTensorToTensorImpl($shape, shape.shape, $values, values.shape, values.dtype, $defaultValue, defaultValue.shape, $rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes);\n    return backend.makeTensorInfo(outputShape, values.dtype, output);\n}\nexport const raggedTensorToTensorConfig = {\n    kernelName: RaggedTensorToTensor,\n    backendName: 'cpu',\n    kernelFunc: raggedTensorToTensor,\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFnZ2VkVGVuc29yVG9UZW5zb3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtY3B1L3NyYy9rZXJuZWxzL1JhZ2dlZFRlbnNvclRvVGVuc29yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBMkIsb0JBQW9CLEVBQWdGLE1BQU0sdUJBQXVCLENBQUM7QUFJcEssT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sNkJBQTZCLENBQUM7QUFFckUsTUFBTSxVQUFVLG9CQUFvQixDQUFDLElBSXBDO0lBQ0MsTUFBTSxFQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFDLEdBQUcsSUFBSSxDQUFDO0lBQ3RDLE1BQU0sRUFBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxtQkFBbUIsRUFBQyxHQUFHLE1BQU0sQ0FBQztJQUNsRSxNQUFNLEVBQUMsaUJBQWlCLEVBQUMsR0FBRyxLQUFLLENBQUM7SUFFbEMsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQW9CLENBQUM7SUFDbkUsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQW9CLENBQUM7SUFDckUsTUFBTSxhQUFhLEdBQ2YsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQW9CLENBQUM7SUFDL0QsTUFBTSxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQyxHQUFHLENBQy9DLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQW9CLENBQUMsQ0FBQztJQUMxRCxNQUFNLHdCQUF3QixHQUFHLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUV2RSxNQUFNLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxHQUFHLHdCQUF3QixDQUNsRCxNQUFNLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLGFBQWEsRUFDdkUsWUFBWSxDQUFDLEtBQUssRUFBRSxtQkFBbUIsRUFBRSx3QkFBd0IsRUFDakUsaUJBQWlCLENBQUMsQ0FBQztJQUN2QixPQUFPLE9BQU8sQ0FBQyxjQUFjLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDbkUsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLDBCQUEwQixHQUFpQjtJQUN0RCxVQUFVLEVBQUUsb0JBQW9CO0lBQ2hDLFdBQVcsRUFBRSxLQUFLO0lBQ2xCLFVBQVUsRUFBRSxvQkFBNkM7Q0FDMUQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtLZXJuZWxDb25maWcsIEtlcm5lbEZ1bmMsIFJhZ2dlZFRlbnNvclRvVGVuc29yLCBSYWdnZWRUZW5zb3JUb1RlbnNvckF0dHJzLCBSYWdnZWRUZW5zb3JUb1RlbnNvcklucHV0cywgVGVuc29ySW5mbywgVHlwZWRBcnJheX0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtNYXRoQmFja2VuZENQVX0gZnJvbSAnLi4vYmFja2VuZF9jcHUnO1xuXG5pbXBvcnQge3JhZ2dlZFRlbnNvclRvVGVuc29ySW1wbH0gZnJvbSAnLi9SYWdnZWRUZW5zb3JUb1RlbnNvcl9pbXBsJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJhZ2dlZFRlbnNvclRvVGVuc29yKGFyZ3M6IHtcbiAgaW5wdXRzOiBSYWdnZWRUZW5zb3JUb1RlbnNvcklucHV0cyxcbiAgYmFja2VuZDogTWF0aEJhY2tlbmRDUFUsXG4gIGF0dHJzOiBSYWdnZWRUZW5zb3JUb1RlbnNvckF0dHJzXG59KTogVGVuc29ySW5mbyB7XG4gIGNvbnN0IHtpbnB1dHMsIGJhY2tlbmQsIGF0dHJzfSA9IGFyZ3M7XG4gIGNvbnN0IHtzaGFwZSwgdmFsdWVzLCBkZWZhdWx0VmFsdWUsIHJvd1BhcnRpdGlvblRlbnNvcnN9ID0gaW5wdXRzO1xuICBjb25zdCB7cm93UGFydGl0aW9uVHlwZXN9ID0gYXR0cnM7XG5cbiAgY29uc3QgJHNoYXBlID0gYmFja2VuZC5kYXRhLmdldChzaGFwZS5kYXRhSWQpLnZhbHVlcyBhcyBUeXBlZEFycmF5O1xuICBjb25zdCAkdmFsdWVzID0gYmFja2VuZC5kYXRhLmdldCh2YWx1ZXMuZGF0YUlkKS52YWx1ZXMgYXMgVHlwZWRBcnJheTtcbiAgY29uc3QgJGRlZmF1bHRWYWx1ZSA9XG4gICAgICBiYWNrZW5kLmRhdGEuZ2V0KGRlZmF1bHRWYWx1ZS5kYXRhSWQpLnZhbHVlcyBhcyBUeXBlZEFycmF5O1xuICBjb25zdCAkcm93UGFydGl0aW9uVmFsdWVzID0gcm93UGFydGl0aW9uVGVuc29ycy5tYXAoXG4gICAgICB0ID0+IGJhY2tlbmQuZGF0YS5nZXQodC5kYXRhSWQpLnZhbHVlcyBhcyBUeXBlZEFycmF5KTtcbiAgY29uc3Qgcm93UGFydGl0aW9uVmFsdWVzU2hhcGVzID0gcm93UGFydGl0aW9uVGVuc29ycy5tYXAodCA9PiB0LnNoYXBlKTtcblxuICBjb25zdCBbb3V0cHV0U2hhcGUsIG91dHB1dF0gPSByYWdnZWRUZW5zb3JUb1RlbnNvckltcGwoXG4gICAgICAkc2hhcGUsIHNoYXBlLnNoYXBlLCAkdmFsdWVzLCB2YWx1ZXMuc2hhcGUsIHZhbHVlcy5kdHlwZSwgJGRlZmF1bHRWYWx1ZSxcbiAgICAgIGRlZmF1bHRWYWx1ZS5zaGFwZSwgJHJvd1BhcnRpdGlvblZhbHVlcywgcm93UGFydGl0aW9uVmFsdWVzU2hhcGVzLFxuICAgICAgcm93UGFydGl0aW9uVHlwZXMpO1xuICByZXR1cm4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhvdXRwdXRTaGFwZSwgdmFsdWVzLmR0eXBlLCBvdXRwdXQpO1xufVxuXG5leHBvcnQgY29uc3QgcmFnZ2VkVGVuc29yVG9UZW5zb3JDb25maWc6IEtlcm5lbENvbmZpZyA9IHtcbiAga2VybmVsTmFtZTogUmFnZ2VkVGVuc29yVG9UZW5zb3IsXG4gIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAga2VybmVsRnVuYzogcmFnZ2VkVGVuc29yVG9UZW5zb3IgYXMgdW5rbm93biBhcyBLZXJuZWxGdW5jLFxufTtcbiJdfQ==","/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nconst INT32_MAX = 2147483647;\nexport function raggedRangeImpl(starts, startsShape, startsDType, limits, limitsShape, deltas, deltasShape) {\n    // Check input tensor shapes.\n    if (startsShape.length > 1) {\n        throw new Error('starts must be a scalar or vector');\n    }\n    if (limitsShape.length > 1) {\n        throw new Error('limits must be a scalar or vector');\n    }\n    if (deltasShape.length > 1) {\n        throw new Error('deltas must be a scalar or vector');\n    }\n    // Determine which tensors we need to broadcast.\n    const broadcastStarts = startsShape.length === 0;\n    const broadcastLimits = limitsShape.length === 0;\n    const broadcastDeltas = deltasShape.length === 0;\n    // nRows (number of output rows) is the size of the non-broadcast inputs,\n    // or 1 if all inputs are scalars.\n    const inSizes = [];\n    if (!broadcastStarts) {\n        inSizes.push(startsShape[0]);\n    }\n    if (!broadcastLimits) {\n        inSizes.push(limitsShape[0]);\n    }\n    if (!broadcastDeltas) {\n        inSizes.push(deltasShape[0]);\n    }\n    for (let i = 1; i < inSizes.length; ++i) {\n        if (inSizes[i] !== inSizes[i - 1]) {\n            throw new Error('starts, limits, and deltas must have the same shape');\n        }\n    }\n    const nRows = inSizes.length === 0 ? 1 : inSizes[0];\n    // Construct the rtNestedSplits tensor.\n    const rtNestedSplits = util.getArrayFromDType('int32', nRows + 1);\n    rtNestedSplits[0] = 0;\n    for (let row = 0; row < nRows; ++row) {\n        const start = broadcastStarts ? starts[0] : starts[row];\n        const limit = broadcastLimits ? limits[0] : limits[row];\n        const delta = broadcastDeltas ? deltas[0] : deltas[row];\n        if (delta === 0) {\n            throw new Error('Requires delta != 0');\n        }\n        let size; // The number of elements in the specified range.\n        if (((delta > 0) && (limit < start)) || ((delta < 0) && (limit > start))) {\n            size = 0;\n        }\n        else {\n            size = Math.ceil(Math.abs((limit - start) / delta));\n            if (size > INT32_MAX) {\n                throw new Error(`Requires ((limit - start) / delta) <= ${INT32_MAX}`);\n            }\n        }\n        rtNestedSplits[row + 1] = rtNestedSplits[row] + size;\n    }\n    const nVals = rtNestedSplits[nRows];\n    // Construct the rtDenseValues tensor.\n    const rtDenseValues = util.getArrayFromDType(startsDType, nVals);\n    let valueIndex = 0;\n    for (let row = 0; row < nRows; ++row) {\n        const rowSize = rtNestedSplits[row + 1] - rtNestedSplits[row];\n        let value = broadcastStarts ? starts[0] : starts[row];\n        const delta = broadcastDeltas ? deltas[0] : deltas[row];\n        for (let i = 0; i < rowSize; ++i) {\n            rtDenseValues[valueIndex++] = value;\n            value += delta;\n        }\n    }\n    return [rtNestedSplits, rtDenseValues];\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFnZ2VkUmFuZ2VfaW1wbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC1jcHUvc3JjL2tlcm5lbHMvUmFnZ2VkUmFuZ2VfaW1wbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQXVCLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRWpFLE1BQU0sU0FBUyxHQUFHLFVBQVUsQ0FBQztBQUU3QixNQUFNLFVBQVUsZUFBZSxDQUMzQixNQUFrQixFQUFFLFdBQXFCLEVBQUUsV0FBcUIsRUFDaEUsTUFBa0IsRUFBRSxXQUFxQixFQUFFLE1BQWtCLEVBQzdELFdBQXFCO0lBQ3ZCLDZCQUE2QjtJQUM3QixJQUFJLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQzFCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQztLQUN0RDtJQUNELElBQUksV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO0tBQ3REO0lBQ0QsSUFBSSxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUM7S0FDdEQ7SUFFRCxnREFBZ0Q7SUFDaEQsTUFBTSxlQUFlLEdBQUcsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7SUFDakQsTUFBTSxlQUFlLEdBQUcsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7SUFDakQsTUFBTSxlQUFlLEdBQUcsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7SUFFakQseUVBQXlFO0lBQ3pFLGtDQUFrQztJQUNsQyxNQUFNLE9BQU8sR0FBYSxFQUFFLENBQUM7SUFDN0IsSUFBSSxDQUFDLGVBQWUsRUFBRTtRQUNwQixPQUFP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LEdBQUcsQ0FBQyxFQUFFLEdBQUcsR0FBRyxLQUFLLEVBQUUsRUFBRSxHQUFHLEVBQUU7UUFDcEMsTUFBTSxPQUFPLEdBQUcsY0FBYyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUQsSUFBSSxLQUFLLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN0RCxNQUFNLEtBQUssR0FBRyxlQUFlLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLEVBQUUsRUFBRSxDQUFDLEVBQUU7WUFDaEMsYUFBYSxDQUFDLFVBQVUsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDO1lBQ3BDLEtBQUssSUFBSSxLQUFLLENBQUM7U0FDaEI7S0FDRjtJQUVELE9BQU8sQ0FBQyxjQUFjLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFDekMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtEYXRhVHlwZSwgVHlwZWRBcnJheSwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuY29uc3QgSU5UMzJfTUFYID0gMjE0NzQ4MzY0NztcblxuZXhwb3J0IGZ1bmN0aW9uIHJhZ2dlZFJhbmdlSW1wbChcbiAgICBzdGFydHM6IFR5cGVkQXJyYXksIHN0YXJ0c1NoYXBlOiBudW1iZXJbXSwgc3RhcnRzRFR5cGU6IERhdGFUeXBlLFxuICAgIGxpbWl0czogVHlwZWRBcnJheSwgbGltaXRzU2hhcGU6IG51bWJlcltdLCBkZWx0YXM6IFR5cGVkQXJyYXksXG4gICAgZGVsdGFzU2hhcGU6IG51bWJlcltdKTogW1R5cGVkQXJyYXksIFR5cGVkQXJyYXldIHtcbiAgLy8gQ2hlY2sgaW5wdXQgdGVuc29yIHNoYXBlcy5cbiAgaWYgKHN0YXJ0c1NoYXBlLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0cyBtdXN0IGJlIGEgc2NhbGFyIG9yIHZlY3RvcicpO1xuICB9XG4gIGlmIChsaW1pdHNTaGFwZS5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsaW1pdHMgbXVzdCBiZSBhIHNjYWxhciBvciB2ZWN0b3InKTtcbiAgfVxuICBpZiAoZGVsdGFzU2hhcGUubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGVsdGFzIG11c3QgYmUgYSBzY2FsYXIgb3IgdmVjdG9yJyk7XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgd2hpY2ggdGVuc29ycyB3ZSBuZWVkIHRvIGJyb2FkY2FzdC5cbiAgY29uc3QgYnJvYWRjYXN0U3RhcnRzID0gc3RhcnRzU2hhcGUubGVuZ3RoID09PSAwO1xuICBjb25zdCBicm9hZGNhc3RMaW1pdHMgPSBsaW1pdHNTaGFwZS5sZW5ndGggPT09IDA7XG4gIGNvbnN0IGJyb2FkY2FzdERlbHRhcyA9IGRlbHRhc1NoYXBlLmxlbmd0aCA9PT0gMDtcblxuICAvLyBuUm93cyAobnVtYmVyIG9mIG91dHB1dCByb3dzKSBpcyB0aGUgc2l6ZSBvZiB0aGUgbm9uLWJyb2FkY2FzdCBpbnB1dHMsXG4gIC8vIG9yIDEgaWYgYWxsIGlucHV0cyBhcmUgc2NhbGFycy5cbiAgY29uc3QgaW5TaXplczogbnVtYmVyW10gPSBbXTtcbiAgaWYgKCFicm9hZGNhc3RTdGFydHMpIHtcbiAgICBpblNpemVzLnB1c2goc3RhcnRzU2hhcGVbMF0pO1xuICB9XG4gIGlmICghYnJvYWRjYXN0TGltaXRzKSB7XG4gICAgaW5TaXplcy5wdXNoKGxpbWl0c1NoYXBlWzBdKTtcbiAgfVxuICBpZiAoIWJyb2FkY2FzdERlbHRhcykge1xuICAgIGluU2l6ZXMucHVzaChkZWx0YXNTaGFwZVswXSk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMTsgaSA8IGluU2l6ZXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaW5TaXplc1tpXSAhPT0gaW5TaXplc1tpIC0gMV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnRzLCBsaW1pdHMsIGFuZCBkZWx0YXMgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlJyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5Sb3dzID0gaW5TaXplcy5sZW5ndGggPT09IDAgPyAxIDogaW5TaXplc1swXTtcblxuICAvLyBDb25zdHJ1Y3QgdGhlIHJ0TmVzdGVkU3BsaXRzIHRlbnNvci5cbiAgY29uc3QgcnROZXN0ZWRTcGxpdHMgPVxuICAgICAgdXRpbC5nZXRBcnJheUZyb21EVHlwZSgnaW50MzInLCBuUm93cyArIDEpIGFzIFR5cGVkQXJyYXk7XG4gIHJ0TmVzdGVkU3BsaXRzWzBdID0gMDtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgblJvd3M7ICsrcm93KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBicm9hZGNhc3RTdGFydHMgPyBzdGFydHNbMF0gOiBzdGFydHNbcm93XTtcbiAgICBjb25zdCBsaW1pdCA9IGJyb2FkY2FzdExpbWl0cyA/IGxpbWl0c1swXSA6IGxpbWl0c1tyb3ddO1xuICAgIGNvbnN0IGRlbHRhID0gYnJvYWRjYXN0RGVsdGFzID8gZGVsdGFzWzBdIDogZGVsdGFzW3Jvd107XG4gICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVzIGRlbHRhICE9IDAnKTtcbiAgICB9XG4gICAgbGV0IHNpemU6IG51bWJlcjsgIC8vIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNwZWNpZmllZCByYW5nZS5cbiAgICBpZiAoKChkZWx0YSA+IDApICYmIChsaW1pdCA8IHN0YXJ0KSkgfHwgKChkZWx0YSA8IDApICYmIChsaW1pdCA+IHN0YXJ0KSkpIHtcbiAgICAgIHNpemUgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5jZWlsKE1hdGguYWJzKChsaW1pdCAtIHN0YXJ0KSAvIGRlbHRhKSk7XG5cbiAgICAgIGlmIChzaXplID4gSU5UMzJfTUFYKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWlyZXMgKChsaW1pdCAtIHN0YXJ0KSAvIGRlbHRhKSA8PSAke0lOVDMyX01BWH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcnROZXN0ZWRTcGxpdHNbcm93ICsgMV0gPSBydE5lc3RlZFNwbGl0c1tyb3ddICsgc2l6ZTtcbiAgfVxuXG4gIGNvbnN0IG5WYWxzID0gcnROZXN0ZWRTcGxpdHNbblJvd3NdO1xuXG4gIC8vIENvbnN0cnVjdCB0aGUgcnREZW5zZVZhbHVlcyB0ZW5zb3IuXG4gIGNvbnN0IHJ0RGVuc2VWYWx1ZXMgPVxuICAgICAgdXRpbC5nZXRBcnJheUZyb21EVHlwZShzdGFydHNEVHlwZSwgblZhbHMpIGFzIFR5cGVkQXJyYXk7XG5cbiAgbGV0IHZhbHVlSW5kZXggPSAwO1xuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBuUm93czsgKytyb3cpIHtcbiAgICBjb25zdCByb3dTaXplID0gcnROZXN0ZWRTcGxpdHNbcm93ICsgMV0gLSBydE5lc3RlZFNwbGl0c1tyb3ddO1xuICAgIGxldCB2YWx1ZSA9IGJyb2FkY2FzdFN0YXJ0cyA/IHN0YXJ0c1swXSA6IHN0YXJ0c1tyb3ddO1xuICAgIGNvbnN0IGRlbHRhID0gYnJvYWRjYXN0RGVsdGFzID8gZGVsdGFzWzBdIDogZGVsdGFzW3Jvd107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dTaXplOyArK2kpIHtcbiAgICAgIHJ0RGVuc2VWYWx1ZXNbdmFsdWVJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgdmFsdWUgKz0gZGVsdGE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtydE5lc3RlZFNwbGl0cywgcnREZW5zZVZhbHVlc107XG59XG4iXX0=","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nexport function rangeImpl(start, stop, step, dtype) {\n    const sameStartStop = start === stop;\n    const increasingRangeNegativeStep = start < stop && step < 0;\n    const decreasingRangePositiveStep = stop < start && step > 1;\n    if (sameStartStop || increasingRangeNegativeStep ||\n        decreasingRangePositiveStep) {\n        return util.makeZerosTypedArray(0, dtype);\n    }\n    const numElements = Math.abs(Math.ceil((stop - start) / step));\n    const values = util.makeZerosTypedArray(numElements, dtype);\n    if (stop < start && step === 1) {\n        // Auto adjust the step's sign if it hasn't been set\n        // (or was set to 1)\n        step = -1;\n    }\n    values[0] = start;\n    for (let i = 1; i < values.length; i++) {\n        values[i] = values[i - 1] + step;\n    }\n    return values;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFuZ2VfaW1wbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC1jcHUvc3JjL2tlcm5lbHMvUmFuZ2VfaW1wbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQWMsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFeEQsTUFBTSxVQUFVLFNBQVMsQ0FDckIsS0FBYSxFQUFFLElBQVksRUFBRSxJQUFZLEVBQ3pDLEtBQXdCO0lBQzFCLE1BQU0sYUFBYSxHQUFHLEtBQUssS0FBSyxJQUFJLENBQUM7SUFDckMsTUFBTSwyQkFBMkIsR0FBRyxLQUFLLEdBQUcsSUFBSSxJQUFJLElBQUksR0FBRyxDQUFDLENBQUM7SUFDN0QsTUFBTSwyQkFBMkIsR0FBRyxJQUFJLEdBQUcsS0FBSyxJQUFJLElBQUksR0FBRyxDQUFDLENBQUM7SUFFN0QsSUFBSSxhQUFhLElBQUksMkJBQTJCO1FBQzVDLDJCQUEyQixFQUFFO1FBQy9CLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztLQUMzQztJQUVELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksR0FBRyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQy9ELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFFNUQsSUFBSSxJQUFJLEdBQUcsS0FBSyxJQUFJLElBQUksS0FBSyxDQUFDLEVBQUU7UUFDOUIsb0RBQW9EO1FBQ3BELG9CQUFvQjtRQUNwQixJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7S0FDWDtJQUVELE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDbEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDdEMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO0tBQ2xDO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtEYXRhVHlwZU1hcCwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlSW1wbChcbiAgICBzdGFydDogbnVtYmVyLCBzdG9wOiBudW1iZXIsIHN0ZXA6IG51bWJlcixcbiAgICBkdHlwZTogJ2Zsb2F0MzInfCdpbnQzMicpOiBEYXRhVHlwZU1hcFsnZmxvYXQzMicgfCAnaW50MzInXSB7XG4gIGNvbnN0IHNhbWVTdGFydFN0b3AgPSBzdGFydCA9PT0gc3RvcDtcbiAgY29uc3QgaW5jcmVhc2luZ1JhbmdlTmVnYXRpdmVTdGVwID0gc3RhcnQgPCBzdG9wICYmIHN0ZXAgPCAwO1xuICBjb25zdCBkZWNyZWFzaW5nUmFuZ2VQb3NpdGl2ZVN0ZXAgPSBzdG9wIDwgc3RhcnQgJiYgc3RlcCA+IDE7XG5cbiAgaWYgKHNhbWVTdGFydFN0b3AgfHwgaW5jcmVhc2luZ1JhbmdlTmVnYXRpdmVTdGVwIHx8XG4gICAgICBkZWNyZWFzaW5nUmFuZ2VQb3NpdGl2ZVN0ZXApIHtcbiAgICByZXR1cm4gdXRpbC5tYWtlWmVyb3NUeXBlZEFycmF5KDAsIGR0eXBlKTtcbiAgfVxuXG4gIGNvbnN0IG51bUVsZW1lbnRzID0gTWF0aC5hYnMoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCkpO1xuICBjb25zdCB2YWx1ZXMgPSB1dGlsLm1ha2VaZXJvc1R5cGVkQXJyYXkobnVtRWxlbWVudHMsIGR0eXBlKTtcblxuICBpZiAoc3RvcCA8IHN0YXJ0ICYmIHN0ZXAgPT09IDEpIHtcbiAgICAvLyBBdXRvIGFkanVzdCB0aGUgc3RlcCdzIHNpZ24gaWYgaXQgaGFzbid0IGJlZW4gc2V0XG4gICAgLy8gKG9yIHdhcyBzZXQgdG8gMSlcbiAgICBzdGVwID0gLTE7XG4gIH1cblxuICB2YWx1ZXNbMF0gPSBzdGFydDtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZXNbaV0gPSB2YWx1ZXNbaSAtIDFdICsgc3RlcDtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuIl19","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { RaggedGather } from '@tensorflow/tfjs-core';\nimport { raggedGatherImpl } from './RaggedGather_impl';\nexport function raggedGather(args) {\n    const { inputs, backend, attrs } = args;\n    const { paramsNestedSplits, paramsDenseValues, indices } = inputs;\n    const { outputRaggedRank } = attrs;\n    const $paramsNestedSplits = paramsNestedSplits.map(t => backend.data.get(t.dataId).values);\n    const $paramsNestedSplitsShapes = paramsNestedSplits.map(t => t.shape);\n    const $paramsDenseValues = backend.data.get(paramsDenseValues.dataId).values;\n    const $indices = backend.data.get(indices.dataId).values;\n    const [outputNestedSplits, outputDenseValues, outputDenseValuesShape] = raggedGatherImpl($paramsNestedSplits, $paramsNestedSplitsShapes, $paramsDenseValues, paramsDenseValues.shape, paramsDenseValues.dtype, $indices, indices.shape, outputRaggedRank);\n    const outputNestedSplitsTensors = outputNestedSplits.map((splits) => backend.makeTensorInfo([splits.length], 'int32', splits));\n    const outputDenseValuesTensor = backend.makeTensorInfo(outputDenseValuesShape, paramsDenseValues.dtype, outputDenseValues);\n    return outputNestedSplitsTensors.concat([outputDenseValuesTensor]);\n}\nexport const raggedGatherConfig = {\n    kernelName: RaggedGather,\n    backendName: 'cpu',\n    kernelFunc: raggedGather,\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFnZ2VkR2F0aGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1iYWNrZW5kLWNwdS9zcmMva2VybmVscy9SYWdnZWRHYXRoZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUEyQixZQUFZLEVBQWdFLE1BQU0sdUJBQXVCLENBQUM7QUFJNUksT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFFckQsTUFBTSxVQUFVLFlBQVksQ0FBQyxJQUk1QjtJQUNDLE1BQU0sRUFBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBQyxHQUFHLElBQUksQ0FBQztJQUN0QyxNQUFNLEVBQUMsa0JBQWtCLEVBQUUsaUJBQWlCLEVBQUUsT0FBTyxFQUFDLEdBQUcsTUFBTSxDQUFDO0lBQ2hFLE1BQU0sRUFBQyxnQkFBZ0IsRUFBQyxHQUFHLEtBQUssQ0FBQztJQUVqQyxNQUFNLG1CQUFtQixHQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FDOUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBb0IsQ0FBQyxDQUFDO0lBQzFELE1BQU0seUJBQXlCLEdBQUcsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3ZFLE1BQU0sa0JBQWtCLEdBQ3BCLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQW9CLENBQUM7SUFDcEUsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQW9CLENBQUM7SUFFdkUsTUFBTSxDQUFDLGtCQUFrQixFQUFFLGlCQUFpQixFQUFFLHNCQUFzQixDQUFDLEdBQ2pFLGdCQUFnQixDQUNaLG1CQUFtQixFQUFFLHlCQUF5QixFQUFFLGtCQUFrQixFQUNsRSxpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFDMUQsT0FBTyxDQUFDLEtBQUssRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0lBRXpDLE1BQU0seUJBQXlCLEdBQUcsa0JBQWtCLENBQUMsR0FBRyxDQUNwRCxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUUxRSxNQUFNLHVCQUF1QixHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQ2xELHNCQUFzQixFQUFFLGlCQUFpQixDQUFDLEtBQUssRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0lBRXhFLE9BQU8seUJBQXlCLENBQUMsTUFBTSxDQUFDLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxDQUFDO0FBQ3JFLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxrQkFBa0IsR0FBaUI7SUFDOUMsVUFBVSxFQUFFLFlBQVk7SUFDeEIsV0FBVyxFQUFFLEtBQUs7SUFDbEIsVUFBVSxFQUFFLFlBQXFDO0NBQ2xELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7S2VybmVsQ29uZmlnLCBLZXJuZWxGdW5jLCBSYWdnZWRHYXRoZXIsIFJhZ2dlZEdhdGhlckF0dHJzLCBSYWdnZWRHYXRoZXJJbnB1dHMsIFRlbnNvckluZm8sIFR5cGVkQXJyYXl9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7TWF0aEJhY2tlbmRDUFV9IGZyb20gJy4uL2JhY2tlbmRfY3B1JztcblxuaW1wb3J0IHtyYWdnZWRHYXRoZXJJbXBsfSBmcm9tICcuL1JhZ2dlZEdhdGhlcl9pbXBsJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJhZ2dlZEdhdGhlcihhcmdzOiB7XG4gIGlucHV0czogUmFnZ2VkR2F0aGVySW5wdXRzLFxuICBiYWNrZW5kOiBNYXRoQmFja2VuZENQVSxcbiAgYXR0cnM6IFJhZ2dlZEdhdGhlckF0dHJzXG59KTogVGVuc29ySW5mb1tdIHtcbiAgY29uc3Qge2lucHV0cywgYmFja2VuZCwgYXR0cnN9ID0gYXJncztcbiAgY29uc3Qge3BhcmFtc05lc3RlZFNwbGl0cywgcGFyYW1zRGVuc2VWYWx1ZXMsIGluZGljZXN9ID0gaW5wdXRzO1xuICBjb25zdCB7b3V0cHV0UmFnZ2VkUmFua30gPSBhdHRycztcblxuICBjb25zdCAkcGFyYW1zTmVzdGVkU3BsaXRzID0gcGFyYW1zTmVzdGVkU3BsaXRzLm1hcChcbiAgICAgIHQgPT4gYmFja2VuZC5kYXRhLmdldCh0LmRhdGFJZCkudmFsdWVzIGFzIFR5cGVkQXJyYXkpO1xuICBjb25zdCAkcGFyYW1zTmVzdGVkU3BsaXRzU2hhcGVzID0gcGFyYW1zTmVzdGVkU3BsaXRzLm1hcCh0ID0+IHQuc2hhcGUpO1xuICBjb25zdCAkcGFyYW1zRGVuc2VWYWx1ZXMgPVxuICAgICAgYmFja2VuZC5kYXRhLmdldChwYXJhbXNEZW5zZVZhbHVlcy5kYXRhSWQpLnZhbHVlcyBhcyBUeXBlZEFycmF5O1xuICBjb25zdCAkaW5kaWNlcyA9IGJhY2tlbmQuZGF0YS5nZXQoaW5kaWNlcy5kYXRhSWQpLnZhbHVlcyBhcyBUeXBlZEFycmF5O1xuXG4gIGNvbnN0IFtvdXRwdXROZXN0ZWRTcGxpdHMsIG91dHB1dERlbnNlVmFsdWVzLCBvdXRwdXREZW5zZVZhbHVlc1NoYXBlXSA9XG4gICAgICByYWdnZWRHYXRoZXJJbXBsKFxuICAgICAgICAgICRwYXJhbXNOZXN0ZWRTcGxpdHMsICRwYXJhbXNOZXN0ZWRTcGxpdHNTaGFwZXMsICRwYXJhbXNEZW5zZVZhbHVlcyxcbiAgICAgICAgICBwYXJhbXNEZW5zZVZhbHVlcy5zaGFwZSwgcGFyYW1zRGVuc2VWYWx1ZXMuZHR5cGUsICRpbmRpY2VzLFxuICAgICAgICAgIGluZGljZXMuc2hhcGUsIG91dHB1dFJhZ2dlZFJhbmspO1xuXG4gIGNvbnN0IG91dHB1dE5lc3RlZFNwbGl0c1RlbnNvcnMgPSBvdXRwdXROZXN0ZWRTcGxpdHMubWFwKFxuICAgICAgKHNwbGl0cykgPT4gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhbc3BsaXRzLmxlbmd0aF0sICdpbnQzMicsIHNwbGl0cykpO1xuXG4gIGNvbnN0IG91dHB1dERlbnNlVmFsdWVzVGVuc29yID0gYmFja2VuZC5tYWtlVGVuc29ySW5mbyhcbiAgICAgIG91dHB1dERlbnNlVmFsdWVzU2hhcGUsIHBhcmFtc0RlbnNlVmFsdWVzLmR0eXBlLCBvdXRwdXREZW5zZVZhbHVlcyk7XG5cbiAgcmV0dXJuIG91dHB1dE5lc3RlZFNwbGl0c1RlbnNvcnMuY29uY2F0KFtvdXRwdXREZW5zZVZhbHVlc1RlbnNvcl0pO1xufVxuXG5leHBvcnQgY29uc3QgcmFnZ2VkR2F0aGVyQ29uZmlnOiBLZXJuZWxDb25maWcgPSB7XG4gIGtlcm5lbE5hbWU6IFJhZ2dlZEdhdGhlcixcbiAgYmFja2VuZE5hbWU6ICdjcHUnLFxuICBrZXJuZWxGdW5jOiByYWdnZWRHYXRoZXIgYXMgdW5rbm93biBhcyBLZXJuZWxGdW5jLFxufTtcbiJdfQ==","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, broadcastTo, reshape, tidy, util } from '@tensorflow/tfjs-core';\nvar RowPartitionType = backend_util.RowPartitionType;\n// Based on\n// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc\nclass RaggedTensorToTensorOp {\n    constructor(shape, shapeShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypeStrings) {\n        this.shape = shape;\n        this.shapeShape = shapeShape;\n        this.values = values;\n        this.valuesShape = valuesShape;\n        this.valuesDType = valuesDType;\n        this.defaultValue = defaultValue;\n        this.defaultValueShape = defaultValueShape;\n        this.rowPartitionValues = rowPartitionValues;\n        this.rowPartitionValuesShapes = rowPartitionValuesShapes;\n        this.rowPartitionTypes =\n            backend_util.getRowPartitionTypesHelper(rowPartitionTypeStrings);\n        this.raggedRank = backend_util.getRaggedRank(this.rowPartitionTypes);\n    }\n    getRowPartitionTypeByDimension(dimension) {\n        if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n            return this.rowPartitionTypes[dimension + 1];\n        }\n        else {\n            return this.rowPartitionTypes[dimension];\n        }\n    }\n    // Returns the relationship between dimension and dimension + 1.\n    getRowPartitionTensor(dimension) {\n        if (this.rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n            return this.rowPartitionValues[dimension + 1];\n        }\n        else {\n            return this.rowPartitionValues[dimension];\n        }\n    }\n    getMaxWidth(dimension) {\n        const rowPartitionTensor = this.getRowPartitionTensor(dimension - 1);\n        switch (this.getRowPartitionTypeByDimension(dimension - 1)) {\n            case RowPartitionType.VALUE_ROWIDS:\n                return RaggedTensorToTensorOp.getMaxWidthValueRowID(rowPartitionTensor);\n            case RowPartitionType.ROW_SPLITS:\n                return RaggedTensorToTensorOp.getMaxWidthRowSplit(rowPartitionTensor);\n            default:\n                throw new Error(`Cannot handle partition type ${RowPartitionType[this.getRowPartitionTypeByDimension(dimension - 1)]}`);\n        }\n    }\n    static getMaxWidthRowSplit(rowSplit) {\n        const tensorLength = rowSplit.length;\n        if (tensorLength === 0 || tensorLength === 1) {\n            return 0;\n        }\n        let maxWidth = 0;\n        for (let i = 0; i < tensorLength - 1; ++i) {\n            const currentWidth = rowSplit[i + 1] - rowSplit[i];\n            if (currentWidth > maxWidth) {\n                maxWidth = currentWidth;\n            }\n        }\n        return maxWidth;\n    }\n    static getMaxWidthValueRowID(valueRowIds) {\n        const indexLength = valueRowIds.length;\n        if (indexLength === 0) {\n            return 0;\n        }\n        let firstEqualIndex = 0;\n        let firstEqualIndexValue = valueRowIds[0];\n        let maxWidth = 0;\n        for (let i = 1; i < indexLength; ++i) {\n            const value = valueRowIds[i];\n            if (value !== firstEqualIndexValue) {\n                firstEqualIndexValue = value;\n                maxWidth = Math.max(i - firstEqualIndex, maxWidth);\n                firstEqualIndex = i;\n            }\n        }\n        return Math.max(indexLength - firstEqualIndex, maxWidth);\n    }\n    tensorShapeFromTensor(t, tShape, isPartial = true) {\n        if (tShape.length === 0) {\n            if (t[0] === -1) {\n                return [];\n            }\n            throw new Error(`The only valid scalar shape tensor is the fully unknown shape specified as -1.`);\n        }\n        // MakePartialShape/MakeShapeHelper.\n        return makeShape(t, isPartial);\n    }\n    calculateOutputSize(firstDim) {\n        const valueShape = this.valuesShape;\n        const defaultValueShape = this.defaultValueShape;\n        backend_util.validateDefaultValueShape(defaultValueShape, valueShape);\n        const shape = this.tensorShapeFromTensor(this.shape, this.shapeShape);\n        const outputShape = backend_util.combineRaggedTensorToTensorShapes(this.raggedRank, shape, valueShape);\n        const result = outputShape;\n        if (result[0] < 0) {\n            result[0] = firstDim;\n        }\n        for (let i = 1; i <= this.raggedRank; ++i) {\n            if (result[i] < 0) {\n                result[i] = this.getMaxWidth(i);\n            }\n        }\n        return result;\n    }\n    /**\n     * The outputIndex represents the index in the output tensor\n     * where the first element of a particular dimension would be written.\n     * If it is -1, it indicates that the index is out of scope.\n     * Example, given firstDimension = 10, firstDimensionOutput = 6,\n     * and outputIndexMultiplier = 100:\n     * result = [0 100 200 300 400 500 -1 -1 -1 -1]\n     * If firstDimensionOutput = 11 instead, then:\n     * result = [0 100 200 300 400 500 600 700 800 900]\n     */\n    calculateFirstParentOutputIndex(firstDimension, outputIndexMultiplier, firstDimensionOutput) {\n        const minDimension = Math.min(firstDimension, firstDimensionOutput);\n        const result = [];\n        let currentOutputIndex = 0;\n        for (let i = 0; i < minDimension; ++i, currentOutputIndex += outputIndexMultiplier) {\n            result.push(currentOutputIndex);\n        }\n        for (let i = minDimension; i < firstDimension; ++i) {\n            result.push(-1);\n        }\n        util.assert(result.length === firstDimension, () => 'Final length of result must be equal to firstDimension.');\n        return result;\n    }\n    calculateOutputIndexRowSplit(rowSplit, parentOutputIndex, outputIndexMultiplier, outputSize) {\n        const rowSplitSize = rowSplit.length;\n        const result = [];\n        for (let i = 0; i < rowSplitSize - 1; ++i) {\n            const rowLength = rowSplit[i + 1] - rowSplit[i];\n            let realLength = Math.min(outputSize, rowLength);\n            let parentOutputIndexCurrent = parentOutputIndex[i];\n            if (parentOutputIndexCurrent === -1) {\n                realLength = 0;\n            }\n            for (let j = 0; j < realLength; ++j) {\n                result.push(parentOutputIndexCurrent);\n                parentOutputIndexCurrent += outputIndexMultiplier;\n            }\n            for (let j = 0; j < rowLength - realLength; ++j) {\n                result.push(-1);\n            }\n        }\n        if (rowSplitSize > 0 && result.length !== rowSplit[rowSplitSize - 1]) {\n            throw new Error('Invalid row split size.');\n        }\n        return result;\n    }\n    // Calculate the output index of the first element of a list.\n    // The parentOutputIndex is the same computation for the previous list.\n    // -1 indicates an element or list that is out of range.\n    // The outputIndexMultiplier is the number of output indices one moves\n    // forward for each column.\n    // E.g., given:\n    // valueRowIds:[0 1 2 2 2 3 5 5 6]\n    // parentOutputIndex:[1000 1100 2000 2100 -1 3000 4000]\n    // outputIndexMultiplier: 10\n    // outputSize: 2\n    // You get:\n    // result = [1000 1100 2000 2010 -1 2100 -1 -1 3000]\n    // result[0] = parentOutputIndex[valueRowIds[0]]\n    // result[1] = parentOutputIndex[valueRowIds[1]]\n    // result[2] = parentOutputIndex[valueRowIds[2]]\n    // result[3] = parentOutputIndex[valueRowIds[2] + 10]\n    // result[4] = -1 because it is the third element the size is 2.\n    // result[5] = parentOutputIndex[valueRowIds[3]]\n    // result[6] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n    // result[7] = -1 because parentOutputIndex[valueRowIds[6]] == -1\n    // result[8] = parentOutputIndex[valueRowIds[7]]\n    calculateOutputIndexValueRowID(valueRowIds, parentOutputIndex, outputIndexMultiplier, outputSize) {\n        const indexSize = valueRowIds.length;\n        const result = [];\n        if (indexSize === 0) {\n            return [];\n        }\n        let currentOutputColumn = 0;\n        let currentValueRowId = valueRowIds[0];\n        if (currentValueRowId >= parentOutputIndex.length) {\n            throw new Error(`Got currentValueRowId=${currentValueRowId}, which is not less than ${parentOutputIndex.length}`);\n        }\n        let currentOutputIndex = parentOutputIndex[currentValueRowId];\n        result.push(currentOutputIndex);\n        for (let i = 1; i < indexSize; ++i) {\n            const nextValueRowId = valueRowIds[i];\n            if (nextValueRowId === currentValueRowId) {\n                if (currentOutputIndex >= 0) {\n                    ++currentOutputColumn;\n                    if (currentOutputColumn < outputSize) {\n                        currentOutputIndex += outputIndexMultiplier;\n                    }\n                    else {\n                        currentOutputIndex = -1;\n                    }\n                }\n            }\n            else {\n                currentOutputColumn = 0;\n                currentValueRowId = nextValueRowId;\n                if (nextValueRowId >= parentOutputIndex.length) {\n                    throw new Error(`Got nextValueRowId=${nextValueRowId} which is not less than ${parentOutputIndex.length}`);\n                }\n                currentOutputIndex = parentOutputIndex[nextValueRowId];\n            }\n            result.push(currentOutputIndex);\n        }\n        if (result.length !== valueRowIds.length) {\n            throw new Error('Invalid row ids.');\n        }\n        return result;\n    }\n    calculateOutputIndex(dimension, parentOutputIndex, outputIndexMultiplier, outputSize) {\n        const rowPartitionTensor = this.getRowPartitionTensor(dimension);\n        const partitionType = this.getRowPartitionTypeByDimension(dimension);\n        switch (partitionType) {\n            case RowPartitionType.VALUE_ROWIDS:\n                return this.calculateOutputIndexValueRowID(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n            case RowPartitionType.ROW_SPLITS:\n                if (rowPartitionTensor.length - 1 > parentOutputIndex.length) {\n                    throw new Error(`Row partition size is greater than output size: ${rowPartitionTensor.length - 1} > ${parentOutputIndex.length}`);\n                }\n                return this.calculateOutputIndexRowSplit(rowPartitionTensor, parentOutputIndex, outputIndexMultiplier, outputSize);\n            default:\n                throw new Error(`Unsupported partition type: ${RowPartitionType[partitionType]}`);\n        }\n    }\n    getFirstDimensionSize() {\n        const firstPartitionTensor = this.rowPartitionValues[0];\n        if (this.rowPartitionTypes.length === 0) {\n            throw new Error('No row_partition_types given.');\n        }\n        const firstPartitionType = this.rowPartitionTypes[0];\n        switch (firstPartitionType) {\n            case RowPartitionType.FIRST_DIM_SIZE:\n                return firstPartitionTensor[0];\n            case RowPartitionType.VALUE_ROWIDS:\n                throw new Error('Cannot handle VALUE_ROWIDS in first dimension.');\n            case RowPartitionType.ROW_SPLITS:\n                return this.rowPartitionValuesShapes[0][0] - 1;\n            default:\n                throw new Error(`Cannot handle type ${RowPartitionType[firstPartitionType]}`);\n        }\n    }\n    compute() {\n        const firstPartitionTensor = this.rowPartitionValues[0];\n        if (firstPartitionTensor.length <= 0) {\n            throw new Error('Invalid first partition input. ' +\n                'Tensor requires at least one element.');\n        }\n        const firstDimension = this.getFirstDimensionSize();\n        const outputSize = this.calculateOutputSize(firstDimension);\n        const multiplier = new Array(this.raggedRank + 1);\n        multiplier[multiplier.length - 1] = 1;\n        for (let i = multiplier.length - 2; i >= 0; --i) {\n            multiplier[i] = multiplier[i + 1] * outputSize[i + 1];\n        }\n        // Full size of the tensor.\n        const outputShape = makeShape(outputSize, false);\n        const outputTensor = util.getArrayFromDType(this.valuesDType, util.sizeFromShape(outputShape));\n        const fullSize = multiplier[0] * outputSize[0];\n        if (fullSize > 0) {\n            let outputIndex = this.calculateFirstParentOutputIndex(firstDimension, multiplier[0], outputSize[0]);\n            for (let i = 1; i <= this.raggedRank; ++i) {\n                const newOutputIndex = this.calculateOutputIndex(i - 1, outputIndex, multiplier[i], outputSize[i]);\n                outputIndex = newOutputIndex;\n            }\n            this.setOutput(this.raggedRank, outputIndex, outputTensor, outputShape);\n        }\n        return [outputShape, outputTensor];\n    }\n    setOutput(raggedRank, outputIndex, outputTensor, outputShape) {\n        if (outputTensor.length === 0) {\n            return;\n        }\n        const valuesBase = this.values;\n        const outputBase = outputTensor;\n        let elementShape = outputShape.slice();\n        elementShape = elementShape.slice(raggedRank + 1);\n        const valueElementSize = util.sizeFromShape(elementShape);\n        const outputIndexSize = outputIndex.length;\n        // Broadcast the default value to value_element_size.  (We can skip this\n        // if defaultValueTensor.size == 1, since we use fill when that's true.)\n        let defaultValue = this.defaultValue;\n        if (defaultValue.length !== valueElementSize && defaultValue.length !== 1) {\n            const srcShape = this.defaultValueShape;\n            tidy(() => {\n                const defaultValueTensor = reshape(defaultValue, srcShape);\n                const bCastDefault = broadcastTo(defaultValueTensor, elementShape);\n                defaultValue = bCastDefault.dataSync();\n            });\n        }\n        // Loop through the outputIndex array, finding contiguous regions that\n        // should be copied.  Once we find the end of a contiguous region, copy it\n        // and add any necessary padding (with defaultValue).\n        let srcStart = 0; // Start of contiguous region (in values)\n        let dstStart = 0; // Destination for contiguous region (in output)\n        let dstEnd = 0; // Destination for contiguous region (in output)\n        for (let srcI = 0; srcI <= outputIndexSize; ++srcI) {\n            // dstI is the destination where the value at srcI should be copied.\n            let dstI = srcI < outputIndexSize ? outputIndex[srcI] : -1;\n            // If we're still in a contiguous region, then update dstEnd go to the\n            // next srcI.\n            if (dstI === dstEnd) {\n                ++dstEnd;\n                continue;\n            }\n            // We found the end of contiguous region.  This can be because we found\n            // a gap (dstI > dstEnd), or a source value that shouldn't be copied\n            // because it's out-of-bounds (dstI == -1), or the end of the tensor\n            // (dstI === -1).\n            if (dstStart < dstEnd) {\n                // Copy the contiguous region.\n                const src = valuesBase.subarray(srcStart * valueElementSize);\n                const dst = outputBase.subarray(dstStart * valueElementSize);\n                const nVals = (dstEnd - dstStart) * valueElementSize;\n                copyArray(dst, src, nVals);\n            }\n            // Add any necessary padding (w/ defaultValue).\n            if (srcI >= outputIndexSize) {\n                // We reached the end of values: pad to the end of output.\n                const outputSize = outputTensor.length;\n                dstI = Math.floor(outputSize / valueElementSize);\n            }\n            if (dstI > dstEnd) {\n                if (this.defaultValue.length === 1) {\n                    outputBase\n                        .subarray(dstEnd * valueElementSize, dstI * valueElementSize)\n                        .fill(this.defaultValue[0]);\n                    dstEnd = dstI;\n                }\n                else {\n                    while (dstI > dstEnd) {\n                        const dst = outputBase.slice(dstEnd * valueElementSize);\n                        copyArray(dst, defaultValue, valueElementSize);\n                        ++dstEnd;\n                    }\n                }\n            }\n            // Update indices.\n            if (dstI < 0) {\n                // srcI should be skipped -- leave it out of the contiguous region.\n                srcStart = srcI + 1;\n                dstStart = dstEnd;\n            }\n            else {\n                // srcI should be copied -- include it in the contiguous region.\n                srcStart = srcI;\n                dstStart = dstEnd;\n                dstEnd = dstStart + 1;\n            }\n        }\n    }\n}\nfunction copyArray(dst, src, size) {\n    for (let i = 0; i < size; i++) {\n        dst[i] = src[i];\n    }\n}\nfunction makeShape(shape, isPartial) {\n    const out = [];\n    for (let dim of shape) {\n        if (dim < 0) {\n            if (!isPartial) {\n                throw new Error(`Dimension ${dim} must be >= 0`);\n            }\n            if (dim < -1) {\n                throw new Error(`Dimension ${dim} must be >= -1`);\n            }\n            dim = -1;\n        }\n        out.push(dim);\n    }\n    return out;\n}\nexport function raggedTensorToTensorImpl(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes) {\n    return new RaggedTensorToTensorOp(shape, shapesShape, values, valuesShape, valuesDType, defaultValue, defaultValueShape, rowPartitionValues, rowPartitionValuesShapes, rowPartitionTypes)\n        .compute();\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFnZ2VkVGVuc29yVG9UZW5zb3JfaW1wbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC1jcHUvc3JjL2tlcm5lbHMvUmFnZ2VkVGVuc29yVG9UZW5zb3JfaW1wbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsWUFBWSxFQUFFLFdBQVcsRUFBWSxPQUFPLEVBQUUsSUFBSSxFQUFjLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRTNHLElBQU8sZ0JBQWdCLEdBQUcsWUFBWSxDQUFDLGdCQUFnQixDQUFDO0FBQ3hELFdBQVc7QUFDWCw2R0FBNkc7QUFDN0csTUFBTSxzQkFBc0I7SUFHMUIsWUFDWSxLQUFpQixFQUFVLFVBQW9CLEVBQy9DLE1BQWtCLEVBQVUsV0FBcUIsRUFDakQsV0FBcUIsRUFBVSxZQUF3QixFQUN2RCxpQkFBMkIsRUFDbEIsa0JBQWdDLEVBQ2hDLHdCQUFvQyxFQUNyRCx1QkFBaUM7UUFOekIsVUFBSyxHQUFMLEtBQUssQ0FBWTtRQUFVLGVBQVUsR0FBVixVQUFVLENBQVU7UUFDL0MsV0FBTSxHQUFOLE1BQU0sQ0FBWTtRQUFVLGdCQUFXLEdBQVgsV0FBVyxDQUFVO1FBQ2pELGdCQUFXLEdBQVgsV0FBVyxDQUFVO1FBQVUsaUJBQVksR0FBWixZQUFZLENBQVk7UUFDdkQsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFVO1FBQ2xCLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBYztRQUNoQyw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQVk7UUFFdkQsSUFBSSxDQUFDLGlCQUFpQjtZQUNsQixZQUFZLENBQUMsMEJBQTBCLENBQUMsdUJBQXVCLENBQUMsQ0FBQztRQUNyRSxJQUFJLENBQUMsVUFBVSxHQUFHLFlBQVksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDdkUsQ0FBQztJ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QUVELE1BQU0sVUFBVSx3QkFBd0IsQ0FDcEMsS0FBaUIsRUFBRSxXQUFxQixFQUFFLE1BQWtCLEVBQzVELFdBQXFCLEVBQUUsV0FBcUIsRUFBRSxZQUF3QixFQUN0RSxpQkFBMkIsRUFBRSxrQkFBZ0MsRUFDN0Qsd0JBQW9DLEVBQ3BDLGlCQUEyQjtJQUM3QixPQUFPLElBQUksc0JBQXNCLENBQ3RCLEtBQUssRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUNsRSxpQkFBaUIsRUFBRSxrQkFBa0IsRUFBRSx3QkFBd0IsRUFDL0QsaUJBQWlCLENBQUM7U0FDeEIsT0FBTyxFQUFFLENBQUM7QUFDakIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtiYWNrZW5kX3V0aWwsIGJyb2FkY2FzdFRvLCBEYXRhVHlwZSwgcmVzaGFwZSwgdGlkeSwgVHlwZWRBcnJheSwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IFJvd1BhcnRpdGlvblR5cGUgPSBiYWNrZW5kX3V0aWwuUm93UGFydGl0aW9uVHlwZTtcbi8vIEJhc2VkIG9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGVuc29yZmxvdy90ZW5zb3JmbG93L2Jsb2IvbWFzdGVyL3RlbnNvcmZsb3cvY29yZS9rZXJuZWxzL3JhZ2dlZF90ZW5zb3JfdG9fdGVuc29yX29wLmNjXG5jbGFzcyBSYWdnZWRUZW5zb3JUb1RlbnNvck9wIHtcbiAgcHJpdmF0ZSByZWFkb25seSByb3dQYXJ0aXRpb25UeXBlczogUm93UGFydGl0aW9uVHlwZVtdO1xuICBwcml2YXRlIHJlYWRvbmx5IHJhZ2dlZFJhbms6IG51bWJlcjtcbiAgY29uc3RydWN0b3IoXG4gICAgICBwcml2YXRlIHNoYXBlOiBUeXBlZEFycmF5LCBwcml2YXRlIHNoYXBlU2hhcGU6IG51bWJlcltdLFxuICAgICAgcHJpdmF0ZSB2YWx1ZXM6IFR5cGVkQXJyYXksIHByaXZhdGUgdmFsdWVzU2hhcGU6IG51bWJlcltdLFxuICAgICAgcHJpdmF0ZSB2YWx1ZXNEVHlwZTogRGF0YVR5cGUsIHByaXZhdGUgZGVmYXVsdFZhbHVlOiBUeXBlZEFycmF5LFxuICAgICAgcHJpdmF0ZSBkZWZhdWx0VmFsdWVTaGFwZTogbnVtYmVyW10sXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IHJvd1BhcnRpdGlvblZhbHVlczogVHlwZWRBcnJheVtdLFxuICAgICAgcHJpdmF0ZSByZWFkb25seSByb3dQYXJ0aXRpb25WYWx1ZXNTaGFwZXM6IG51bWJlcltdW10sXG4gICAgICByb3dQYXJ0aXRpb25UeXBlU3RyaW5nczogc3RyaW5nW10pIHtcbiAgICB0aGlzLnJvd1BhcnRpdGlvblR5cGVzID1cbiAgICAgICAgYmFja2VuZF91dGlsLmdldFJvd1BhcnRpdGlvblR5cGVzSGVscGVyKHJvd1BhcnRpdGlvblR5cGVTdHJpbmdzKTtcbiAgICB0aGlzLnJhZ2dlZFJhbmsgPSBiYWNrZW5kX3V0aWwuZ2V0UmFnZ2VkUmFuayh0aGlzLnJvd1BhcnRpdGlvblR5cGVzKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Um93UGFydGl0aW9uVHlwZUJ5RGltZW5zaW9uKGRpbWVuc2lvbjogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMucm93UGFydGl0aW9uVHlwZXNbMF0gPT09IFJvd1BhcnRpdGlvblR5cGUuRklSU1RfRElNX1NJWkUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvd1BhcnRpdGlvblR5cGVzW2RpbWVuc2lvbiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yb3dQYXJ0aXRpb25UeXBlc1tkaW1lbnNpb25dO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGRpbWVuc2lvbiBhbmQgZGltZW5zaW9uICsgMS5cbiAgcHJpdmF0ZSBnZXRSb3dQYXJ0aXRpb25UZW5zb3IoZGltZW5zaW9uOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5yb3dQYXJ0aXRpb25UeXBlc1swXSA9PT0gUm93UGFydGl0aW9uVHlwZS5GSVJTVF9ESU1fU0laRSkge1xuICAgICAgcmV0dXJuIHRoaXMucm93UGFydGl0aW9uVmFsdWVzW2RpbWVuc2lvbiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yb3dQYXJ0aXRpb25WYWx1ZXNbZGltZW5zaW9uXTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldE1heFdpZHRoKGRpbWVuc2lvbjogbnVtYmVyKSB7XG4gICAgY29uc3Qgcm93UGFydGl0aW9uVGVuc29yID0gdGhpcy5nZXRSb3dQYXJ0aXRpb25UZW5zb3IoZGltZW5zaW9uIC0gMSk7XG4gICAgc3dpdGNoICh0aGlzLmdldFJvd1BhcnRpdGlvblR5cGVCeURpbWVuc2lvbihkaW1lbnNpb24gLSAxKSkge1xuICAgICAgY2FzZSBSb3dQYXJ0aXRpb25UeXBlLlZBTFVFX1JPV0lEUzpcbiAgICAgICAgcmV0dXJuIFJhZ2dlZFRlbnNvclRvVGVuc29yT3AuZ2V0TWF4V2lkdGhWYWx1ZVJvd0lEKHJvd1BhcnRpdGlvblRlbnNvcik7XG4gICAgICBjYXNlIFJvd1BhcnRpdGlvblR5cGUuUk9XX1NQTElUUzpcbiAgICAgICAgcmV0dXJuIFJhZ2dlZFRlbnNvclRvVGVuc29yT3AuZ2V0TWF4V2lkdGhSb3dTcGxpdChyb3dQYXJ0aXRpb25UZW5zb3IpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaGFuZGxlIHBhcnRpdGlvbiB0eXBlICR7XG4gICAgICAgICAgICBSb3dQYXJ0aXRpb25UeXBlW3RoaXMuZ2V0Um93UGFydGl0aW9uVHlwZUJ5RGltZW5zaW9uKFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbiAtIDEpXX1gKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0TWF4V2lkdGhSb3dTcGxpdChyb3dTcGxpdDogVHlwZWRBcnJheSkge1xuICAgIGNvbnN0IHRlbnNvckxlbmd0aCA9IHJvd1NwbGl0Lmxlbmd0aDtcbiAgICBpZiAodGVuc29yTGVuZ3RoID09PSAwIHx8IHRlbnNvckxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBtYXhXaWR0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW5zb3JMZW5ndGggLSAxOyArK2kpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IHJvd1NwbGl0W2kgKyAxXSAtIHJvd1NwbGl0W2ldO1xuICAgICAgaWYgKGN1cnJlbnRXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgIG1heFdpZHRoID0gY3VycmVudFdpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4V2lkdGg7XG4gIH1cblxuICBzdGF0aWMgZ2V0TWF4V2lkdGhWYWx1ZVJvd0lEKHZhbHVlUm93SWRzOiBUeXBlZEFycmF5KSB7XG4gICAgY29uc3QgaW5kZXhMZW5ndGggPSB2YWx1ZVJvd0lkcy5sZW5ndGg7XG4gICAgaWYgKGluZGV4TGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgbGV0IGZpcnN0RXF1YWxJbmRleCA9IDA7XG4gICAgbGV0IGZpcnN0RXF1YWxJbmRleFZhbHVlID0gdmFsdWVSb3dJZHNbMF07XG4gICAgbGV0IG1heFdpZHRoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGluZGV4TGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVSb3dJZHNbaV07XG4gICAgICBpZiAodmFsdWUgIT09IGZpcnN0RXF1YWxJbmRleFZhbHVlKSB7XG4gICAgICAgIGZpcnN0RXF1YWxJbmRleFZhbHVlID0gdmFsdWU7XG4gICAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgoaSAtIGZpcnN0RXF1YWxJbmRleCwgbWF4V2lkdGgpO1xuICAgICAgICBmaXJzdEVxdWFsSW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoaW5kZXhMZW5ndGggLSBmaXJzdEVxdWFsSW5kZXgsIG1heFdpZHRoKTtcbiAgfVxuXG4gIHByaXZhdGUgdGVuc29yU2hhcGVGcm9tVGVuc29yKFxuICAgICAgdDogVHlwZWRBcnJheSwgdFNoYXBlOiBudW1iZXJbXSwgaXNQYXJ0aWFsID0gdHJ1ZSkge1xuICAgIGlmICh0U2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodFswXSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBUaGUgb25seSB2YWxpZCBzY2FsYXIgc2hhcGUgdGVuc29yIGlzIHRoZSBmdWxseSB1bmtub3duIHNoYXBlIHNwZWNpZmllZCBhcyAtMS5gKTtcbiAgICB9XG4gICAgLy8gTWFrZVBhcnRpYWxTaGFwZS9NYWtlU2hhcGVIZWxwZXIuXG4gICAgcmV0dXJuIG1ha2VTaGFwZSh0LCBpc1BhcnRpYWwpO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVPdXRwdXRTaXplKGZpcnN0RGltOiBudW1iZXIpIHtcbiAgICBjb25zdCB2YWx1ZVNoYXBlID0gdGhpcy52YWx1ZXNTaGFwZTtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVTaGFwZSA9IHRoaXMuZGVmYXVsdFZhbHVlU2hhcGU7XG5cbiAgICBiYWNrZW5kX3V0aWwudmFsaWRhdGVEZWZhdWx0VmFsdWVTaGFwZShkZWZhdWx0VmFsdWVTaGFwZSwgdmFsdWVTaGFwZSk7XG5cbiAgICBjb25zdCBzaGFwZSA9IHRoaXMudGVuc29yU2hhcGVGcm9tVGVuc29yKHRoaXMuc2hhcGUsIHRoaXMuc2hhcGVTaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBiYWNrZW5kX3V0aWwuY29tYmluZVJhZ2dlZFRlbnNvclRvVGVuc29yU2hhcGVzKFxuICAgICAgICB0aGlzLnJhZ2dlZFJhbmssIHNoYXBlLCB2YWx1ZVNoYXBlKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IG91dHB1dFNoYXBlO1xuXG4gICAgaWYgKHJlc3VsdFswXSA8IDApIHtcbiAgICAgIHJlc3VsdFswXSA9IGZpcnN0RGltO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLnJhZ2dlZFJhbms7ICsraSkge1xuICAgICAgaWYgKHJlc3VsdFtpXSA8IDApIHtcbiAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5nZXRNYXhXaWR0aChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvdXRwdXRJbmRleCByZXByZXNlbnRzIHRoZSBpbmRleCBpbiB0aGUgb3V0cHV0IHRlbnNvclxuICAgKiB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBvZiBhIHBhcnRpY3VsYXIgZGltZW5zaW9uIHdvdWxkIGJlIHdyaXR0ZW4uXG4gICAqIElmIGl0IGlzIC0xLCBpdCBpbmRpY2F0ZXMgdGhhdCB0aGUgaW5kZXggaXMgb3V0IG9mIHNjb3BlLlxuICAgKiBFeGFtcGxlLCBnaXZlbiBmaXJzdERpbWVuc2lvbiA9IDEwLCBmaXJzdERpbWVuc2lvbk91dHB1dCA9IDYsXG4gICAqIGFuZCBvdXRwdXRJbmRleE11bHRpcGxpZXIgPSAxMDA6XG4gICAqIHJlc3VsdCA9IFswIDEwMCAyMDAgMzAwIDQwMCA1MDAgLTEgLTEgLTEgLTFdXG4gICAqIElmIGZpcnN0RGltZW5zaW9uT3V0cHV0ID0gMTEgaW5zdGVhZCwgdGhlbjpcbiAgICogcmVzdWx0ID0gWzAgMTAwIDIwMCAzMDAgNDAwIDUwMCA2MDAgNzAwIDgwMCA5MDBdXG4gICAqL1xuICBwcml2YXRlIGNhbGN1bGF0ZUZpcnN0UGFyZW50T3V0cHV0SW5kZXgoXG4gICAgICBmaXJzdERpbWVuc2lvbjogbnVtYmVyLCBvdXRwdXRJbmRleE11bHRpcGxpZXI6IG51bWJlcixcbiAgICAgIGZpcnN0RGltZW5zaW9uT3V0cHV0OiBudW1iZXIpIHtcbiAgICBjb25zdCBtaW5EaW1lbnNpb24gPSBNYXRoLm1pbihmaXJzdERpbWVuc2lvbiwgZmlyc3REaW1lbnNpb25PdXRwdXQpO1xuICAgIGNvbnN0IHJlc3VsdDogbnVtYmVyW10gPSBbXTtcbiAgICBsZXQgY3VycmVudE91dHB1dEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pbkRpbWVuc2lvbjtcbiAgICAgICAgICsraSwgY3VycmVudE91dHB1dEluZGV4ICs9IG91dHB1dEluZGV4TXVsdGlwbGllcikge1xuICAgICAgcmVzdWx0LnB1c2goY3VycmVudE91dHB1dEluZGV4KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IG1pbkRpbWVuc2lvbjsgaSA8IGZpcnN0RGltZW5zaW9uOyArK2kpIHtcbiAgICAgIHJlc3VsdC5wdXNoKC0xKTtcbiAgICB9XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIHJlc3VsdC5sZW5ndGggPT09IGZpcnN0RGltZW5zaW9uLFxuICAgICAgICAoKSA9PiAnRmluYWwgbGVuZ3RoIG9mIHJlc3VsdCBtdXN0IGJlIGVxdWFsIHRvIGZpcnN0RGltZW5zaW9uLicpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlT3V0cHV0SW5kZXhSb3dTcGxpdChcbiAgICAgIHJvd1NwbGl0OiBUeXBlZEFycmF5LCBwYXJlbnRPdXRwdXRJbmRleDogbnVtYmVyW10sXG4gICAgICBvdXRwdXRJbmRleE11bHRpcGxpZXI6IG51bWJlciwgb3V0cHV0U2l6ZTogbnVtYmVyKSB7XG4gICAgY29uc3Qgcm93U3BsaXRTaXplID0gcm93U3BsaXQubGVuZ3RoO1xuICAgIGNvbnN0IHJlc3VsdDogbnVtYmVyW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd1NwbGl0U2l6ZSAtIDE7ICsraSkge1xuICAgICAgY29uc3Qgcm93TGVuZ3RoID0gcm93U3BsaXRbaSArIDFdIC0gcm93U3BsaXRbaV07XG4gICAgICBsZXQgcmVhbExlbmd0aCA9IE1hdGgubWluKG91dHB1dFNpemUsIHJvd0xlbmd0aCk7XG4gICAgICBsZXQgcGFyZW50T3V0cHV0SW5kZXhDdXJyZW50ID0gcGFyZW50T3V0cHV0SW5kZXhbaV07XG5cbiAgICAgIGlmIChwYXJlbnRPdXRwdXRJbmRleEN1cnJlbnQgPT09IC0xKSB7XG4gICAgICAgIHJlYWxMZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWFsTGVuZ3RoOyArK2opIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocGFyZW50T3V0cHV0SW5kZXhDdXJyZW50KTtcbiAgICAgICAgcGFyZW50T3V0cHV0SW5kZXhDdXJyZW50ICs9IG91dHB1dEluZGV4TXVsdGlwbGllcjtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93TGVuZ3RoIC0gcmVhbExlbmd0aDsgKytqKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJvd1NwbGl0U2l6ZSA+IDAgJiYgcmVzdWx0Lmxlbmd0aCAhPT0gcm93U3BsaXRbcm93U3BsaXRTaXplIC0gMV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByb3cgc3BsaXQgc2l6ZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBvdXRwdXQgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYSBsaXN0LlxuICAvLyBUaGUgcGFyZW50T3V0cHV0SW5kZXggaXMgdGhlIHNhbWUgY29tcHV0YXRpb24gZm9yIHRoZSBwcmV2aW91cyBsaXN0LlxuICAvLyAtMSBpbmRpY2F0ZXMgYW4gZWxlbWVudCBvciBsaXN0IHRoYXQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyBUaGUgb3V0cHV0SW5kZXhNdWx0aXBsaWVyIGlzIHRoZSBudW1iZXIgb2Ygb3V0cHV0IGluZGljZXMgb25lIG1vdmVzXG4gIC8vIGZvcndhcmQgZm9yIGVhY2ggY29sdW1uLlxuICAvLyBFLmcuLCBnaXZlbjpcbiAgLy8gdmFsdWVSb3dJZHM6WzAgMSAyIDIgMiAzIDUgNSA2XVxuICAvLyBwYXJlbnRPdXRwdXRJbmRleDpbMTAwMCAxMTAwIDIwMDAgMjEwMCAtMSAzMDAwIDQwMDBdXG4gIC8vIG91dHB1dEluZGV4TXVsdGlwbGllcjogMTBcbiAgLy8gb3V0cHV0U2l6ZTogMlxuICAvLyBZb3UgZ2V0OlxuICAvLyByZXN1bHQgPSBbMTAwMCAxMTAwIDIwMDAgMjAxMCAtMSAyMTAwIC0xIC0xIDMwMDBdXG4gIC8vIHJlc3VsdFswXSA9IHBhcmVudE91dHB1dEluZGV4W3ZhbHVlUm93SWRzWzBdXVxuICAvLyByZXN1bHRbMV0gPSBwYXJlbnRPdXRwdXRJbmRleFt2YWx1ZVJvd0lkc1sxXV1cbiAgLy8gcmVzdWx0WzJdID0gcGFyZW50T3V0cHV0SW5kZXhbdmFsdWVSb3dJZHNbMl1dXG4gIC8vIHJlc3VsdFszXSA9IHBhcmVudE91dHB1dEluZGV4W3ZhbHVlUm93SWRzWzJdICsgMTBdXG4gIC8vIHJlc3VsdFs0XSA9IC0xIGJlY2F1c2UgaXQgaXMgdGhlIHRoaXJkIGVsZW1lbnQgdGhlIHNpemUgaXMgMi5cbiAgLy8gcmVzdWx0WzVdID0gcGFyZW50T3V0cHV0SW5kZXhbdmFsdWVSb3dJZHNbM11dXG4gIC8vIHJlc3VsdFs2XSA9IC0xIGJlY2F1c2UgcGFyZW50T3V0cHV0SW5kZXhbdmFsdWVSb3dJZHNbNl1dID09IC0xXG4gIC8vIHJlc3VsdFs3XSA9IC0xIGJlY2F1c2UgcGFyZW50T3V0cHV0SW5kZXhbdmFsdWVSb3dJZHNbNl1dID09IC0xXG4gIC8vIHJlc3VsdFs4XSA9IHBhcmVudE91dHB1dEluZGV4W3ZhbHVlUm93SWRzWzddXVxuICBwcml2YXRlIGNhbGN1bGF0ZU91dHB1dEluZGV4VmFsdWVSb3dJRChcbiAgICAgIHZhbHVlUm93SWRzOiBUeXBlZEFycmF5LCBwYXJlbnRPdXRwdXRJbmRleDogbnVtYmVyW10sXG4gICAgICBvdXRwdXRJbmRleE11bHRpcGxpZXI6IG51bWJlciwgb3V0cHV0U2l6ZTogbnVtYmVyKSB7XG4gICAgY29uc3QgaW5kZXhTaXplID0gdmFsdWVSb3dJZHMubGVuZ3RoO1xuICAgIGNvbnN0IHJlc3VsdDogbnVtYmVyW10gPSBbXTtcbiAgICBpZiAoaW5kZXhTaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnRPdXRwdXRDb2x1bW4gPSAwO1xuICAgIGxldCBjdXJyZW50VmFsdWVSb3dJZCA9IHZhbHVlUm93SWRzWzBdO1xuXG4gICAgaWYgKGN1cnJlbnRWYWx1ZVJvd0lkID49IHBhcmVudE91dHB1dEluZGV4Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBHb3QgY3VycmVudFZhbHVlUm93SWQ9JHtjdXJyZW50VmFsdWVSb3dJZH0sIHdoaWNoIGlzIG5vdCBsZXNzIHRoYW4gJHtcbiAgICAgICAgICAgICAgcGFyZW50T3V0cHV0SW5kZXgubGVuZ3RofWApO1xuICAgIH1cblxuICAgIGxldCBjdXJyZW50T3V0cHV0SW5kZXggPSBwYXJlbnRPdXRwdXRJbmRleFtjdXJyZW50VmFsdWVSb3dJZF07XG4gICAgcmVzdWx0LnB1c2goY3VycmVudE91dHB1dEluZGV4KTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGluZGV4U2l6ZTsgKytpKSB7XG4gICAgICBjb25zdCBuZXh0VmFsdWVSb3dJZCA9IHZhbHVlUm93SWRzW2ldO1xuICAgICAgaWYgKG5leHRWYWx1ZVJvd0lkID09PSBjdXJyZW50VmFsdWVSb3dJZCkge1xuICAgICAgICBpZiAoY3VycmVudE91dHB1dEluZGV4ID49IDApIHtcbiAgICAgICAgICArK2N1cnJlbnRPdXRwdXRDb2x1bW47XG4gICAgICAgICAgaWYgKGN1cnJlbnRPdXRwdXRDb2x1bW4gPCBvdXRwdXRTaXplKSB7XG4gICAgICAgICAgICBjdXJyZW50T3V0cHV0SW5kZXggKz0gb3V0cHV0SW5kZXhNdWx0aXBsaWVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50T3V0cHV0SW5kZXggPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRPdXRwdXRDb2x1bW4gPSAwO1xuICAgICAgICBjdXJyZW50VmFsdWVSb3dJZCA9IG5leHRWYWx1ZVJvd0lkO1xuXG4gICAgICAgIGlmIChuZXh0VmFsdWVSb3dJZCA+PSBwYXJlbnRPdXRwdXRJbmRleC5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBHb3QgbmV4dFZhbHVlUm93SWQ9JHtuZXh0VmFsdWVSb3dJZH0gd2hpY2ggaXMgbm90IGxlc3MgdGhhbiAke1xuICAgICAgICAgICAgICAgICAgcGFyZW50T3V0cHV0SW5kZXgubGVuZ3RofWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudE91dHB1dEluZGV4ID0gcGFyZW50T3V0cHV0SW5kZXhbbmV4dFZhbHVlUm93SWRdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goY3VycmVudE91dHB1dEluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gdmFsdWVSb3dJZHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcm93IGlkcy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVPdXRwdXRJbmRleChcbiAgICAgIGRpbWVuc2lvbjogbnVtYmVyLCBwYXJlbnRPdXRwdXRJbmRleDogbnVtYmVyW10sXG4gICAgICBvdXRwdXRJbmRleE11bHRpcGxpZXI6IG51bWJlciwgb3V0cHV0U2l6ZTogbnVtYmVyKSB7XG4gICAgY29uc3Qgcm93UGFydGl0aW9uVGVuc29yID0gdGhpcy5nZXRSb3dQYXJ0aXRpb25UZW5zb3IoZGltZW5zaW9uKTtcbiAgICBjb25zdCBwYXJ0aXRpb25UeXBlID0gdGhpcy5nZXRSb3dQYXJ0aXRpb25UeXBlQnlEaW1lbnNpb24oZGltZW5zaW9uKTtcbiAgICBzd2l0Y2ggKHBhcnRpdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgUm93UGFydGl0aW9uVHlwZS5WQUxVRV9ST1dJRFM6XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZU91dHB1dEluZGV4VmFsdWVSb3dJRChcbiAgICAgICAgICAgIHJvd1BhcnRpdGlvblRlbnNvciwgcGFyZW50T3V0cHV0SW5kZXgsIG91dHB1dEluZGV4TXVsdGlwbGllcixcbiAgICAgICAgICAgIG91dHB1dFNpemUpO1xuICAgICAgY2FzZSBSb3dQYXJ0aXRpb25UeXBlLlJPV19TUExJVFM6XG4gICAgICAgIGlmIChyb3dQYXJ0aXRpb25UZW5zb3IubGVuZ3RoIC0gMSA+IHBhcmVudE91dHB1dEluZGV4Lmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUm93IHBhcnRpdGlvbiBzaXplIGlzIGdyZWF0ZXIgdGhhbiBvdXRwdXQgc2l6ZTogJHtcbiAgICAgICAgICAgICAgcm93UGFydGl0aW9uVGVuc29yLmxlbmd0aCAtIDF9ID4gJHtwYXJlbnRPdXRwdXRJbmRleC5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlT3V0cHV0SW5kZXhSb3dTcGxpdChcbiAgICAgICAgICAgIHJvd1BhcnRpdGlvblRlbnNvciwgcGFyZW50T3V0cHV0SW5kZXgsIG91dHB1dEluZGV4TXVsdGlwbGllcixcbiAgICAgICAgICAgIG91dHB1dFNpemUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFVuc3VwcG9ydGVkIHBhcnRpdGlvbiB0eXBlOiAke1Jvd1BhcnRpdGlvblR5cGVbcGFydGl0aW9uVHlwZV19YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRGaXJzdERpbWVuc2lvblNpemUoKSB7XG4gICAgY29uc3QgZmlyc3RQYXJ0aXRpb25UZW5zb3IgPSB0aGlzLnJvd1BhcnRpdGlvblZhbHVlc1swXTtcbiAgICBpZiAodGhpcy5yb3dQYXJ0aXRpb25UeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcm93X3BhcnRpdGlvbl90eXBlcyBnaXZlbi4nKTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQYXJ0aXRpb25UeXBlID0gdGhpcy5yb3dQYXJ0aXRpb25UeXBlc1swXTtcbiAgICBzd2l0Y2ggKGZpcnN0UGFydGl0aW9uVHlwZSkge1xuICAgICAgY2FzZSBSb3dQYXJ0aXRpb25UeXBlLkZJUlNUX0RJTV9TSVpFOlxuICAgICAgICByZXR1cm4gZmlyc3RQYXJ0aXRpb25UZW5zb3JbMF07XG4gICAgICBjYXNlIFJvd1BhcnRpdGlvblR5cGUuVkFMVUVfUk9XSURTOlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYW5kbGUgVkFMVUVfUk9XSURTIGluIGZpcnN0IGRpbWVuc2lvbi4nKTtcbiAgICAgIGNhc2UgUm93UGFydGl0aW9uVHlwZS5ST1dfU1BMSVRTOlxuICAgICAgICByZXR1cm4gdGhpcy5yb3dQYXJ0aXRpb25WYWx1ZXNTaGFwZXNbMF1bMF0gLSAxO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBoYW5kbGUgdHlwZSAke1Jvd1BhcnRpdGlvblR5cGVbZmlyc3RQYXJ0aXRpb25UeXBlXX1gKTtcbiAgICB9XG4gIH1cblxuICBjb21wdXRlKCk6IFtudW1iZXJbXSwgVHlwZWRBcnJheV0ge1xuICAgIGNvbnN0IGZpcnN0UGFydGl0aW9uVGVuc29yID0gdGhpcy5yb3dQYXJ0aXRpb25WYWx1ZXNbMF07XG4gICAgaWYgKGZpcnN0UGFydGl0aW9uVGVuc29yLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgZmlyc3QgcGFydGl0aW9uIGlucHV0LiAnICtcbiAgICAgICAgICAnVGVuc29yIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBlbGVtZW50LicpO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdERpbWVuc2lvbiA9IHRoaXMuZ2V0Rmlyc3REaW1lbnNpb25TaXplKCk7XG4gICAgY29uc3Qgb3V0cHV0U2l6ZSA9IHRoaXMuY2FsY3VsYXRlT3V0cHV0U2l6ZShmaXJzdERpbWVuc2lvbik7XG4gICAgY29uc3QgbXVsdGlwbGllcjogbnVtYmVyW10gPSBuZXcgQXJyYXkodGhpcy5yYWdnZWRSYW5rICsgMSk7XG5cbiAgICBtdWx0aXBsaWVyW211bHRpcGxpZXIubGVuZ3RoIC0gMV0gPSAxO1xuICAgIGZvciAobGV0IGkgPSBtdWx0aXBsaWVyLmxlbmd0aCAtIDI7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtdWx0aXBsaWVyW2ldID0gbXVsdGlwbGllcltpICsgMV0gKiBvdXRwdXRTaXplW2kgKyAxXTtcbiAgICB9XG4gICAgLy8gRnVsbCBzaXplIG9mIHRoZSB0ZW5zb3IuXG4gICAgY29uc3Qgb3V0cHV0U2hhcGU6IG51bWJlcltdID0gbWFrZVNoYXBlKG91dHB1dFNpemUsIGZhbHNlKTtcbiAgICBjb25zdCBvdXRwdXRUZW5zb3IgPVxuICAgICAgICB1dGlsLmdldEFycmF5RnJvbURUeXBlKFxuICAgICAgICAgICAgdGhpcy52YWx1ZXNEVHlwZSwgdXRpbC5zaXplRnJvbVNoYXBlKG91dHB1dFNoYXBlKSkgYXMgVHlwZWRBcnJheTtcblxuICAgIGNvbnN0IGZ1bGxTaXplID0gbXVsdGlwbGllclswXSAqIG91dHB1dFNpemVbMF07XG4gICAgaWYgKGZ1bGxTaXplID4gMCkge1xuICAgICAgbGV0IG91dHB1dEluZGV4ID0gdGhpcy5jYWxjdWxhdGVGaXJzdFBhcmVudE91dHB1dEluZGV4KFxuICAgICAgICAgIGZpcnN0RGltZW5zaW9uLCBtdWx0aXBsaWVyWzBdLCBvdXRwdXRTaXplWzBdKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMucmFnZ2VkUmFuazsgKytpKSB7XG4gICAgICAgIGNvbnN0IG5ld091dHB1dEluZGV4ID0gdGhpcy5jYWxjdWxhdGVPdXRwdXRJbmRleChcbiAgICAgICAgICAgIGkgLSAxLCBvdXRwdXRJbmRleCwgbXVsdGlwbGllcltpXSwgb3V0cHV0U2l6ZVtpXSk7XG4gICAgICAgIG91dHB1dEluZGV4ID0gbmV3T3V0cHV0SW5kZXg7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0T3V0cHV0KHRoaXMucmFnZ2VkUmFuaywgb3V0cHV0SW5kZXgsIG91dHB1dFRlbnNvciwgb3V0cHV0U2hhcGUpO1xuICAgIH1cblxuICAgIHJldHVybiBbb3V0cHV0U2hhcGUsIG91dHB1dFRlbnNvcl07XG4gIH1cbiAgc2V0T3V0cHV0KFxuICAgICAgcmFnZ2VkUmFuazogbnVtYmVyLCBvdXRwdXRJbmRleDogbnVtYmVyW10sIG91dHB1dFRlbnNvcjogVHlwZWRBcnJheSxcbiAgICAgIG91dHB1dFNoYXBlOiBudW1iZXJbXSkge1xuICAgIGlmIChvdXRwdXRUZW5zb3IubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWVzQmFzZSA9IHRoaXMudmFsdWVzO1xuICAgIGNvbnN0IG91dHB1dEJhc2UgPSBvdXRwdXRUZW5zb3I7XG5cbiAgICBsZXQgZWxlbWVudFNoYXBlID0gb3V0cHV0U2hhcGUuc2xpY2UoKTtcbiAgICBlbGVtZW50U2hhcGUgPSBlbGVtZW50U2hhcGUuc2xpY2UocmFnZ2VkUmFuayArIDEpO1xuICAgIGNvbnN0IHZhbHVlRWxlbWVudFNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoZWxlbWVudFNoYXBlKTtcbiAgICBjb25zdCBvdXRwdXRJbmRleFNpemUgPSBvdXRwdXRJbmRleC5sZW5ndGg7XG5cbiAgICAvLyBCcm9hZGNhc3QgdGhlIGRlZmF1bHQgdmFsdWUgdG8gdmFsdWVfZWxlbWVudF9zaXplLiAgKFdlIGNhbiBza2lwIHRoaXNcbiAgICAvLyBpZiBkZWZhdWx0VmFsdWVUZW5zb3Iuc2l6ZSA9PSAxLCBzaW5jZSB3ZSB1c2UgZmlsbCB3aGVuIHRoYXQncyB0cnVlLilcbiAgICBsZXQgZGVmYXVsdFZhbHVlID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gICAgaWYgKGRlZmF1bHRWYWx1ZS5sZW5ndGggIT09IHZhbHVlRWxlbWVudFNpemUgJiYgZGVmYXVsdFZhbHVlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgY29uc3Qgc3JjU2hhcGUgPSB0aGlzLmRlZmF1bHRWYWx1ZVNoYXBlO1xuICAgICAgdGlkeSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZVRlbnNvciA9IHJlc2hhcGUoZGVmYXVsdFZhbHVlLCBzcmNTaGFwZSk7XG4gICAgICAgIGNvbnN0IGJDYXN0RGVmYXVsdCA9IGJyb2FkY2FzdFRvKGRlZmF1bHRWYWx1ZVRlbnNvciwgZWxlbWVudFNoYXBlKTtcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gYkNhc3REZWZhdWx0LmRhdGFTeW5jKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBMb29wIHRocm91Z2ggdGhlIG91dHB1dEluZGV4IGFycmF5LCBmaW5kaW5nIGNvbnRpZ3VvdXMgcmVnaW9ucyB0aGF0XG4gICAgLy8gc2hvdWxkIGJlIGNvcGllZC4gIE9uY2Ugd2UgZmluZCB0aGUgZW5kIG9mIGEgY29udGlndW91cyByZWdpb24sIGNvcHkgaXRcbiAgICAvLyBhbmQgYWRkIGFueSBuZWNlc3NhcnkgcGFkZGluZyAod2l0aCBkZWZhdWx0VmFsdWUpLlxuICAgIGxldCBzcmNTdGFydCA9IDA7ICAvLyBTdGFydCBvZiBjb250aWd1b3VzIHJlZ2lvbiAoaW4gdmFsdWVzKVxuICAgIGxldCBkc3RTdGFydCA9IDA7ICAvLyBEZXN0aW5hdGlvbiBmb3IgY29udGlndW91cyByZWdpb24gKGluIG91dHB1dClcbiAgICBsZXQgZHN0RW5kID0gMDsgICAgLy8gRGVzdGluYXRpb24gZm9yIGNvbnRpZ3VvdXMgcmVnaW9uIChpbiBvdXRwdXQpXG4gICAgZm9yIChsZXQgc3JjSSA9IDA7IHNyY0kgPD0gb3V0cHV0SW5kZXhTaXplOyArK3NyY0kpIHtcbiAgICAgIC8vIGRzdEkgaXMgdGhlIGRlc3RpbmF0aW9uIHdoZXJlIHRoZSB2YWx1ZSBhdCBzcmNJIHNob3VsZCBiZSBjb3BpZWQuXG4gICAgICBsZXQgZHN0SSA9IHNyY0kgPCBvdXRwdXRJbmRleFNpemUgPyBvdXRwdXRJbmRleFtzcmNJXSA6IC0xO1xuXG4gICAgICAvLyBJZiB3ZSdyZSBzdGlsbCBpbiBhIGNvbnRpZ3VvdXMgcmVnaW9uLCB0aGVuIHVwZGF0ZSBkc3RFbmQgZ28gdG8gdGhlXG4gICAgICAvLyBuZXh0IHNyY0kuXG4gICAgICBpZiAoZHN0SSA9PT0gZHN0RW5kKSB7XG4gICAgICAgICsrZHN0RW5kO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiBjb250aWd1b3VzIHJlZ2lvbi4gIFRoaXMgY2FuIGJlIGJlY2F1c2Ugd2UgZm91bmRcbiAgICAgIC8vIGEgZ2FwIChkc3RJID4gZHN0RW5kKSwgb3IgYSBzb3VyY2UgdmFsdWUgdGhhdCBzaG91bGRuJ3QgYmUgY29waWVkXG4gICAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0LW9mLWJvdW5kcyAoZHN0SSA9PSAtMSksIG9yIHRoZSBlbmQgb2YgdGhlIHRlbnNvclxuICAgICAgLy8gKGRzdEkgPT09IC0xKS5cbiAgICAgIGlmIChkc3RTdGFydCA8IGRzdEVuZCkge1xuICAgICAgICAvLyBDb3B5IHRoZSBjb250aWd1b3VzIHJlZ2lvbi5cbiAgICAgICAgY29uc3Qgc3JjID0gdmFsdWVzQmFzZS5zdWJhcnJheShzcmNTdGFydCAqIHZhbHVlRWxlbWVudFNpemUpO1xuICAgICAgICBjb25zdCBkc3QgPSBvdXRwdXRCYXNlLnN1YmFycmF5KGRzdFN0YXJ0ICogdmFsdWVFbGVtZW50U2l6ZSk7XG4gICAgICAgIGNvbnN0IG5WYWxzID0gKGRzdEVuZCAtIGRzdFN0YXJ0KSAqIHZhbHVlRWxlbWVudFNpemU7XG4gICAgICAgIGNvcHlBcnJheShkc3QsIHNyYywgblZhbHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYW55IG5lY2Vzc2FyeSBwYWRkaW5nICh3LyBkZWZhdWx0VmFsdWUpLlxuICAgICAgaWYgKHNyY0kgPj0gb3V0cHV0SW5kZXhTaXplKSB7XG4gICAgICAgIC8vIFdlIHJlYWNoZWQgdGhlIGVuZCBvZiB2YWx1ZXM6IHBhZCB0byB0aGUgZW5kIG9mIG91dHB1dC5cbiAgICAgICAgY29uc3Qgb3V0cHV0U2l6ZSA9IG91dHB1dFRlbnNvci5sZW5ndGg7XG4gICAgICAgIGRzdEkgPSBNYXRoLmZsb29yKG91dHB1dFNpemUgLyB2YWx1ZUVsZW1lbnRTaXplKTtcbiAgICAgIH1cbiAgICAgIGlmIChkc3RJID4gZHN0RW5kKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRWYWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBvdXRwdXRCYXNlXG4gICAgICAgICAgICAgIC5zdWJhcnJheShkc3RFbmQgKiB2YWx1ZUVsZW1lbnRTaXplLCBkc3RJICogdmFsdWVFbGVtZW50U2l6ZSlcbiAgICAgICAgICAgICAgLmZpbGwodGhpcy5kZWZhdWx0VmFsdWVbMF0pO1xuICAgICAgICAgIGRzdEVuZCA9IGRzdEk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hpbGUgKGRzdEkgPiBkc3RFbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRzdCA9IG91dHB1dEJhc2Uuc2xpY2UoZHN0RW5kICogdmFsdWVFbGVtZW50U2l6ZSk7XG4gICAgICAgICAgICBjb3B5QXJyYXkoZHN0LCBkZWZhdWx0VmFsdWUsIHZhbHVlRWxlbWVudFNpemUpO1xuICAgICAgICAgICAgKytkc3RFbmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBpbmRpY2VzLlxuICAgICAgaWYgKGRzdEkgPCAwKSB7XG4gICAgICAgIC8vIHNyY0kgc2hvdWxkIGJlIHNraXBwZWQgLS0gbGVhdmUgaXQgb3V0IG9mIHRoZSBjb250aWd1b3VzIHJlZ2lvbi5cbiAgICAgICAgc3JjU3RhcnQgPSBzcmNJICsgMTtcbiAgICAgICAgZHN0U3RhcnQgPSBkc3RFbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzcmNJIHNob3VsZCBiZSBjb3BpZWQgLS0gaW5jbHVkZSBpdCBpbiB0aGUgY29udGlndW91cyByZWdpb24uXG4gICAgICAgIHNyY1N0YXJ0ID0gc3JjSTtcbiAgICAgICAgZHN0U3RhcnQgPSBkc3RFbmQ7XG4gICAgICAgIGRzdEVuZCA9IGRzdFN0YXJ0ICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUFycmF5KGRzdDogVHlwZWRBcnJheSwgc3JjOiBUeXBlZEFycmF5LCBzaXplOiBudW1iZXIpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBkc3RbaV0gPSBzcmNbaV07XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZVNoYXBlKHNoYXBlOiBudW1iZXJbXXxUeXBlZEFycmF5LCBpc1BhcnRpYWw6IGJvb2xlYW4pIHtcbiAgY29uc3Qgb3V0OiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCBkaW0gb2Ygc2hhcGUpIHtcbiAgICBpZiAoZGltIDwgMCkge1xuICAgICAgaWYgKCFpc1BhcnRpYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaW1lbnNpb24gJHtkaW19IG11c3QgYmUgPj0gMGApO1xuICAgICAgfVxuICAgICAgaWYgKGRpbSA8IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGltZW5zaW9uICR7ZGltfSBtdXN0IGJlID49IC0xYCk7XG4gICAgICB9XG4gICAgICBkaW0gPSAtMTtcbiAgICB9XG4gICAgb3V0LnB1c2goZGltKTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYWdnZWRUZW5zb3JUb1RlbnNvckltcGwoXG4gICAgc2hhcGU6IFR5cGVkQXJyYXksIHNoYXBlc1NoYXBlOiBudW1iZXJbXSwgdmFsdWVzOiBUeXBlZEFycmF5LFxuICAgIHZhbHVlc1NoYXBlOiBudW1iZXJbXSwgdmFsdWVzRFR5cGU6IERhdGFUeXBlLCBkZWZhdWx0VmFsdWU6IFR5cGVkQXJyYXksXG4gICAgZGVmYXVsdFZhbHVlU2hhcGU6IG51bWJlcltdLCByb3dQYXJ0aXRpb25WYWx1ZXM6IFR5cGVkQXJyYXlbXSxcbiAgICByb3dQYXJ0aXRpb25WYWx1ZXNTaGFwZXM6IG51bWJlcltdW10sXG4gICAgcm93UGFydGl0aW9uVHlwZXM6IHN0cmluZ1tdKTogW251bWJlcltdLCBUeXBlZEFycmF5XSB7XG4gIHJldHVybiBuZXcgUmFnZ2VkVGVuc29yVG9UZW5zb3JPcChcbiAgICAgICAgICAgICBzaGFwZSwgc2hhcGVzU2hhcGUsIHZhbHVlcywgdmFsdWVzU2hhcGUsIHZhbHVlc0RUeXBlLCBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgZGVmYXVsdFZhbHVlU2hhcGUsIHJvd1BhcnRpdGlvblZhbHVlcywgcm93UGFydGl0aW9uVmFsdWVzU2hhcGVzLFxuICAgICAgICAgICAgIHJvd1BhcnRpdGlvblR5cGVzKVxuICAgICAgLmNvbXB1dGUoKTtcbn1cbiJdfQ==","/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { RaggedRange } from '@tensorflow/tfjs-core';\nimport { raggedRangeImpl } from './RaggedRange_impl';\nexport function raggedRange(args) {\n    const { inputs, backend } = args;\n    const { starts, limits, deltas } = inputs;\n    const $starts = backend.data.get(starts.dataId).values;\n    const $limits = backend.data.get(limits.dataId).values;\n    const $deltas = backend.data.get(deltas.dataId).values;\n    const [rtNestedSplitsData, rtDenseValuesData] = raggedRangeImpl($starts, starts.shape, starts.dtype, $limits, limits.shape, $deltas, deltas.shape);\n    const rtNestedSplits = backend.makeTensorInfo([rtNestedSplitsData.length], 'int32', rtNestedSplitsData);\n    const rtDenseValues = backend.makeTensorInfo([rtDenseValuesData.length], starts.dtype, rtDenseValuesData);\n    return [rtNestedSplits, rtDenseValues];\n}\nexport const raggedRangeConfig = {\n    kernelName: RaggedRange,\n    backendName: 'cpu',\n    kernelFunc: raggedRange,\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFnZ2VkUmFuZ2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtY3B1L3NyYy9rZXJuZWxzL1JhZ2dlZFJhbmdlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBMkIsV0FBVyxFQUE0QyxNQUFNLHVCQUF1QixDQUFDO0FBSXZILE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUVuRCxNQUFNLFVBQVUsV0FBVyxDQUN2QixJQUEwRDtJQUU1RCxNQUFNLEVBQUMsTUFBTSxFQUFFLE9BQU8sRUFBQyxHQUFHLElBQUksQ0FBQztJQUMvQixNQUFNLEVBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUMsR0FBRyxNQUFNLENBQUM7SUFFeEMsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQW9CLENBQUM7SUFDckUsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQW9CLENBQUM7SUFDckUsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQW9CLENBQUM7SUFFckUsTUFBTSxDQUFDLGtCQUFrQixFQUFFLGlCQUFpQixDQUFDLEdBQUcsZUFBZSxDQUMzRCxPQUFPLEVBQUUsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFDbkUsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRWxCLE1BQU0sY0FBYyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQ3pDLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLEVBQUUsT0FBTyxFQUFFLGtCQUFrQixDQUFDLENBQUM7SUFDOUQsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FDeEMsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsRUFBRSxNQUFNLENBQUMsS0FBSyxFQUFFLGlCQUFpQixDQUFDLENBQUM7SUFFakUsT0FBTyxDQUFDLGNBQWMsRUFBRSxhQUFhLENBQUMsQ0FBQztBQUN6QyxDQUFDO0FBRUQsTUFBTSxDQUFDLE1BQU0saUJBQWlCLEdBQWlCO0lBQzdDLFVBQVUsRUFBRSxXQUFXO0lBQ3ZCLFdBQVcsRUFBRSxLQUFLO0lBQ2xCLFVBQVUsRUFBRSxXQUFvQztDQUNqRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0tlcm5lbENvbmZpZywgS2VybmVsRnVuYywgUmFnZ2VkUmFuZ2UsIFJhZ2dlZFJhbmdlSW5wdXRzLCBUZW5zb3JJbmZvLCBUeXBlZEFycmF5fSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge01hdGhCYWNrZW5kQ1BVfSBmcm9tICcuLi9iYWNrZW5kX2NwdSc7XG5cbmltcG9ydCB7cmFnZ2VkUmFuZ2VJbXBsfSBmcm9tICcuL1JhZ2dlZFJhbmdlX2ltcGwnO1xuXG5leHBvcnQgZnVuY3Rpb24gcmFnZ2VkUmFuZ2UoXG4gICAgYXJnczoge2lucHV0czogUmFnZ2VkUmFuZ2VJbnB1dHMsIGJhY2tlbmQ6IE1hdGhCYWNrZW5kQ1BVfSk6XG4gICAgW1RlbnNvckluZm8sIFRlbnNvckluZm9dIHtcbiAgY29uc3Qge2lucHV0cywgYmFja2VuZH0gPSBhcmdzO1xuICBjb25zdCB7c3RhcnRzLCBsaW1pdHMsIGRlbHRhc30gPSBpbnB1dHM7XG5cbiAgY29uc3QgJHN0YXJ0cyA9IGJhY2tlbmQuZGF0YS5nZXQoc3RhcnRzLmRhdGFJZCkudmFsdWVzIGFzIFR5cGVkQXJyYXk7XG4gIGNvbnN0ICRsaW1pdHMgPSBiYWNrZW5kLmRhdGEuZ2V0KGxpbWl0cy5kYXRhSWQpLnZhbHVlcyBhcyBUeXBlZEFycmF5O1xuICBjb25zdCAkZGVsdGFzID0gYmFja2VuZC5kYXRhLmdldChkZWx0YXMuZGF0YUlkKS52YWx1ZXMgYXMgVHlwZWRBcnJheTtcblxuICBjb25zdCBbcnROZXN0ZWRTcGxpdHNEYXRhLCBydERlbnNlVmFsdWVzRGF0YV0gPSByYWdnZWRSYW5nZUltcGwoXG4gICAgICAkc3RhcnRzLCBzdGFydHMuc2hhcGUsIHN0YXJ0cy5kdHlwZSwgJGxpbWl0cywgbGltaXRzLnNoYXBlLCAkZGVsdGFzLFxuICAgICAgZGVsdGFzLnNoYXBlKTtcblxuICBjb25zdCBydE5lc3RlZFNwbGl0cyA9IGJhY2tlbmQubWFrZVRlbnNvckluZm8oXG4gICAgICBbcnROZXN0ZWRTcGxpdHNEYXRhLmxlbmd0aF0sICdpbnQzMicsIHJ0TmVzdGVkU3BsaXRzRGF0YSk7XG4gIGNvbnN0IHJ0RGVuc2VWYWx1ZXMgPSBiYWNrZW5kLm1ha2VUZW5zb3JJbmZvKFxuICAgICAgW3J0RGVuc2VWYWx1ZXNEYXRhLmxlbmd0aF0sIHN0YXJ0cy5kdHlwZSwgcnREZW5zZVZhbHVlc0RhdGEpO1xuXG4gIHJldHVybiBbcnROZXN0ZWRTcGxpdHMsIHJ0RGVuc2VWYWx1ZXNdO1xufVxuXG5leHBvcnQgY29uc3QgcmFnZ2VkUmFuZ2VDb25maWc6IEtlcm5lbENvbmZpZyA9IHtcbiAga2VybmVsTmFtZTogUmFnZ2VkUmFuZ2UsXG4gIGJhY2tlbmROYW1lOiAnY3B1JyxcbiAga2VybmVsRnVuYzogcmFnZ2VkUmFuZ2UgYXMgdW5rbm93biBhcyBLZXJuZWxGdW5jLFxufTtcbiJdfQ=="],"names":["rangeConfig","kernelName","Range","backendName","kernelFunc","args","backend","attrs","start","stop","dtype","step","values","makeTensorInfo","length","makeSplits","indices","indicesShape","paramsNestedSplits","numParamsDenseValues","valueSlices","numValues","numSplits","outSplits","Array","fill","map","dim","splits","lastSplit","Error","i","validateSplits","nrows","rowLength","push","limit","outDim","outSplitsOutDim","delta","j","computeFlatOuterDims","orig","numOutDims","outDims","slice","inDim","getValues","paramsDenseValues","paramsDenseValuesShape","paramsDenseValuesDType","valuesShape","valuesOut","util","numElements","valueSize","denseM","valuesM","outPos","writeValueSlices","raggedGatherImpl","paramsNestedSplitsShapes","outputRaggedRank","numParams","forEach","index","locString","join","validateIndices","outputNestedSplits","splitsOut","value","getSplits","outputDenseValues","raggedTensorToTensorConfig","RaggedTensorToTensor","inputs","shape","defaultValue","rowPartitionTensors","rowPartitionTypes","$shape","data","get","dataId","$values","$defaultValue","$rowPartitionValues","t","rowPartitionValuesShapes","outputShape","output","INT32_MAX","raggedRangeImpl","starts","startsShape","startsDType","limits","limitsShape","deltas","deltasShape","broadcastStarts","broadcastLimits","broadcastDeltas","inSizes","nRows","rtNestedSplits","row","size","Math","ceil","abs","nVals","rtDenseValues","valueIndex","rowSize","rangeImpl","raggedGatherConfig","RaggedGather","$paramsNestedSplits","$paramsNestedSplitsShapes","$paramsDenseValues","$indices","outputDenseValuesShape","outputNestedSplitsTensors","outputDenseValuesTensor","concat","RowPartitionType","backend_util","RaggedTensorToTensorOp","constructor","shapeShape","valuesDType","defaultValueShape","rowPartitionValues","rowPartitionTypeStrings","this","raggedRank","getRowPartitionTypeByDimension","dimension","FIRST_DIM_SIZE","getRowPartitionTensor","getMaxWidth","rowPartitionTensor","VALUE_ROWIDS","getMaxWidthValueRowID","ROW_SPLITS","getMaxWidthRowSplit","rowSplit","tensorLength","maxWidth","currentWidth","valueRowIds","indexLength","firstEqualIndex","firstEqualIndexValue","max","tensorShapeFromTensor","tShape","isPartial","makeShape","calculateOutputSize","firstDim","valueShape","result","calculateFirstParentOutputIndex","firstDimension","outputIndexMultiplier","firstDimensionOutput","minDimension","min","currentOutputIndex","calculateOutputIndexRowSplit","parentOutputIndex","outputSize","rowSplitSize","realLength","parentOutputIndexCurrent","calculateOutputIndexValueRowID","indexSize","currentOutputColumn","currentValueRowId","nextValueRowId","calculateOutputIndex","partitionType","getFirstDimensionSize","firstPartitionTensor","firstPartitionType","compute","multiplier","outputTensor","outputIndex","setOutput","valuesBase","outputBase","elementShape","valueElementSize","outputIndexSize","srcShape","tidy","defaultValueTensor","reshape","bCastDefault","broadcastTo","dataSync","srcStart","dstStart","dstEnd","srcI","dstI","src","subarray","copyArray","floor","dst","out","raggedTensorToTensorImpl","shapesShape","raggedRangeConfig","RaggedRange","$starts","$limits","$deltas","rtNestedSplitsData","rtDenseValuesData"],"sourceRoot":""}