"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[7113],{5340:function(t,e,a){a.d(e,{Q:function(){return h}});var n=a(67897),s=a(35287),i=a(37523),r=a(9258),c=a(45702),o=a(55537),l=a(79559),u=a(37930);class h extends u.S{constructor(t,e,a=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=a,this.accumulations=[],this.m=(0,c.d)(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const c=n.T2.registeredVariables[e];if(null==this.accumulations[a]){const t=!1;this.accumulations[a]={originalName:`${e}/momentum`,variable:(0,s.DZ)((()=>(0,o.P)(c).variable(t)))}}const l=this.accumulations[a].variable,u=Array.isArray(t)?t[a].tensor:t[e];null!=u&&(0,s.DZ)((()=>{let t;const e=(0,i.W)((0,r.l)(this.m,l),u);t=this.useNesterov?(0,i.W)((0,r.l)(this.c,(0,i.W)(u,(0,r.l)(e,this.m))),c):(0,i.W)((0,r.l)(this.c,e),c),l.assign(e),c.assign(t)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,s.AS)(this.accumulations.map((t=>t.variable)))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}h.className="Momentum",(0,l.registerClass)(h)},7703:function(t,e,a){a.d(e,{m:function(){return c}});var n=a(67897),s=a(15441),i=a(28189),r=a(45119);const c=(0,a(70929).op)({transpose_:function(t,e){const a=(0,i.YT)(t,"x","transpose");if(null==e&&(e=a.shape.map(((t,e)=>e)).reverse()),r.vA(a.rank===e.length,(()=>`Error in transpose: rank of input ${a.rank} must match length of perm ${e}.`)),e.forEach((t=>{r.vA(t>=0&&t<a.rank,(()=>"All entries in 'perm' must be between 0 and "+(a.rank-1)+` but got ${e}`))})),a.rank<=1)return a.clone();const c={x:a},o={perm:e};return n.T2.runKernel(s.wx,c,o)}})},12151:function(t,e,a){a.d(e,{_:function(){return o}});var n=a(67897),s=a(15441),i=a(28189),r=a(63567),c=a(62198);const o=(0,a(70929).op)({where_:function(t,e,a){const o=(0,i.YT)(e,"a","where"),l=(0,i.YT)(a,"b","where"),u=(0,i.YT)(t,"condition","where","bool"),h=(0,c.Ky)((0,c.Ky)(u.shape,o.shape),l.shape),m={condition:(0,r.h)(u,h),t:(0,r.h)(o,h),e:(0,r.h)(l,h)};return n.T2.runKernel(s.l6,m)}})},15618:function(t,e,a){a(66652);var n=a(46574),s=a(30522),i=a(76745),r=a(66235);class c{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}}if((0,n._K)().get("IS_BROWSER")){(0,n._K)().setPlatform("browser",new c);try{r.dy.registerManager(i.ZT.URL_SCHEME,new i.Cd)}catch(o){}try{r.dy.registerManager(s.mn.URL_SCHEME,new s.lQ)}catch(o){}}},21190:function(t,e,a){a.d(e,{r:function(){return r}});var n=a(67897),s=a(15441),i=a(28189);const r=(0,a(70929).op)({topk_:function(t,e=1,a=!0){const r=(0,i.YT)(t,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const c=r.shape[r.shape.length-1];if(e>c)throw new Error(`'k' passed to topk() must be <= the last dimension (${c}) but got ${e}`);const o={x:r},l={k:e,sorted:a},[u,h]=n.T2.runKernel(s.TB,o,l);return{values:u,indices:h}}})},25727:function(t,e,a){a.d(e,{P:function(){return g}});var n=a(67897),s=a(35287),i=a(37523),r=a(89359),c=a(9258),o=a(79348),l=a(45793),u=a(77126),h=a(55537),m=a(79559),d=a(64403);class g extends d.E{constructor(t,e=.9,a=0,s=null,i=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=a,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,null==s&&(this.epsilon=n.T2.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const m=n.T2.registeredVariables[e],d=!1;null==this.accumulatedMeanSquares[a]&&(this.accumulatedMeanSquares[a]={originalName:`${e}/rms`,variable:(0,s.DZ)((()=>(0,h.P)(m).variable(d)))}),null==this.accumulatedMoments[a]&&(this.accumulatedMoments[a]={originalName:`${e}/momentum`,variable:(0,s.DZ)((()=>(0,h.P)(m).variable(d)))}),null==this.accumulatedMeanGrads[a]&&this.centered&&(this.accumulatedMeanGrads[a]={originalName:`${e}/mg`,variable:(0,s.DZ)((()=>(0,h.P)(m).variable(d)))});const g=Array.isArray(t)?t[a].tensor:t[e];if(null==g)return;const p=this.accumulatedMeanSquares[a].variable,f=this.accumulatedMoments[a].variable;(0,s.DZ)((()=>{const t=(0,i.W)((0,c.l)(p,this.decay),(0,c.l)((0,l.E)(g),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[a].variable,n=(0,i.W)((0,c.l)(e,this.decay),(0,c.l)(g,1-this.decay)),s=(0,r.y)((0,c.l)(g,this.learningRate),(0,o.R)((0,u.j)(t,(0,i.W)((0,l.E)(n),this.epsilon)))),h=(0,i.W)((0,c.l)(f,this.momentum),s);p.assign(t),e.assign(n),f.assign(h);const d=(0,u.j)(m,h);m.assign(d)}else{const t=(0,i.W)((0,c.l)(p,this.decay),(0,c.l)((0,l.E)(g),1-this.decay)),e=(0,i.W)((0,c.l)(f,this.momentum),(0,r.y)((0,c.l)(g,this.learningRate),(0,o.R)((0,i.W)(t,this.epsilon))));p.assign(t),f.assign(e);const a=(0,u.j)(m,e);m.assign(a)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,s.AS)(this.accumulatedMeanSquares.map((t=>t.variable))),null!=this.accumulatedMeanGrads&&this.centered&&(0,s.AS)(this.accumulatedMeanGrads.map((t=>t.variable))),null!=this.accumulatedMoments&&(0,s.AS)(this.accumulatedMoments.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,a=!1;this.accumulatedMeanSquares=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)}))),this.accumulatedMoments=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)}))),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}g.className="RMSProp",(0,m.registerClass)(g)},37930:function(t,e,a){a.d(e,{S:function(){return u}});var n=a(67897),s=a(35287),i=a(37523),r=a(9258),c=a(45702),o=a(79559),l=a(64403);class u extends l.E{constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const c=Array.isArray(t)?t[a].tensor:t[e];if(null==c)return;const o=n.T2.registeredVariables[e];(0,s.DZ)((()=>{const t=(0,i.W)((0,r.l)(this.c,c),o);o.assign(t)}))})),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=(0,s.aC)((0,c.d)(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}u.className="SGD",(0,o.registerClass)(u)},42855:function(t,e,a){a.d(e,{U:function(){return r}});var n=a(67897),s=a(45119),i=a(37148);function r(t,e="float32"){if("complex64"===e){const e=r(t,"float32"),a=r(t,"float32");return(0,i.f)(e,a)}const a=(0,s.Ty)((0,s.Ze)(t),e);return n.T2.makeTensor(a,t,e)}},44271:function(t,e,a){a.d(e,{Y:function(){return i}});var n=a(54411),s=a(28189);const i=async function(t){const e=(0,s.YT)(t,"condition","whereAsync","bool"),a=await e.data(),i=(0,n.Y)(e.shape,a);return t!==e&&e.dispose(),i}},55537:function(t,e,a){a.d(e,{P:function(){return r}});var n=a(67897),s=a(15441),i=a(28189);const r=(0,a(70929).op)({zerosLike_:function(t){const e={x:(0,i.YT)(t,"x","zerosLike")};return n.T2.runKernel(s.xJ,e)}})},64403:function(t,e,a){a.d(e,{E:function(){return c}});var n=a(35287),s=a(31830),i=a(45702),r=a(79559);class c extends r.Serializable{minimize(t,e=!1,a){const{value:s,grads:i}=this.computeGradients(t,a);if(null!=a){const t=a.map((t=>({name:t.name,tensor:i[t.name]})));this.applyGradients(t)}else this.applyGradients(i);return(0,n.AS)(i),e?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return(0,s.y7)(t,e)}dispose(){null!=this.iterations_&&(0,n.AS)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,i.d)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(c,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients})},64826:function(t,e,a){a.d(e,{V:function(){return c}});var n=a(67897),s=a(15441),i=a(28189),r=a(45119);const c=(0,a(70929).op)({tile_:function(t,e){const a=(0,i.YT)(t,"x","tile","string_or_numeric");r.vA(a.rank===e.length,(()=>`Error in transpose: rank of input ${a.rank} must match length of reps ${e}.`));const c={x:a},o={reps:e};return n.T2.runKernel(s.FA,c,o)}})},66126:function(t,e,a){a.d(e,{b:function(){return s}});var n=a(67897);function s(t,e=!0,a,s){return n.T2.makeVariable(t,e,a,s)}},67261:function(t,e,a){a.d(e,{K:function(){return c}});var n=a(67897),s=a(15441),i=a(28189),r=a(45119);const c=(0,a(70929).op)({unstack_:function(t,e=0){const a=(0,i.YT)(t,"x","unstack","string_or_numeric");r.vA(e>=-a.shape.length&&e<a.shape.length,(()=>`Axis = ${e} is not in [-${a.shape.length}, ${a.shape.length})`));const c={value:a},o={axis:e};return n.T2.runKernel(s.dX,c,o)}})},73937:function(t,e,a){a.d(e,{A:function(){return c}});var n=a(67897),s=a(15441),i=a(28189),r=a(45119);const c=(0,a(70929).op)({unique_:function(t,e=0){const a=(0,i.YT)(t,"x","unique","string_or_numeric");(0,r.vA)(a.rank>0,(()=>"The input tensor must be at least 1D"));const c={x:a},o={axis:e},[l,u]=n.T2.runKernel(s.Ew,c,o);return{values:l,indices:u}}})},81409:function(t,e,a){a.d(e,{F:function(){return f}});var n=a(67897),s=a(35287),i=a(37523),r=a(89359),c=a(9258),o=a(98990),l=a(45702),u=a(79348),h=a(45793),m=a(77126),d=a(55537),g=a(79559),p=a(64403);class f extends p.E{constructor(t,e,a,i=null){super(),this.learningRate=t,this.beta1=e,this.beta2=a,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,s.DZ)((()=>{this.accBeta1=(0,l.d)(e).variable(),this.accBeta2=(0,l.d)(a).variable()})),null==i&&(this.epsilon=n.T2.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);(0,s.DZ)((()=>{const a=(0,m.j)(1,this.accBeta1),o=(0,m.j)(1,this.accBeta2);e.forEach(((e,l)=>{const m=n.T2.registeredVariables[e],g=!1;null==this.accumulatedFirstMoment[l]&&(this.accumulatedFirstMoment[l]={originalName:`${e}/m`,variable:(0,s.DZ)((()=>(0,d.P)(m).variable(g)))}),null==this.accumulatedSecondMoment[l]&&(this.accumulatedSecondMoment[l]={originalName:`${e}/v`,variable:(0,s.DZ)((()=>(0,d.P)(m).variable(g)))});const p=Array.isArray(t)?t[l].tensor:t[e];if(null==p)return;const f=this.accumulatedFirstMoment[l].variable,b=this.accumulatedSecondMoment[l].variable,v=(0,i.W)((0,c.l)(f,this.beta1),(0,c.l)(p,1-this.beta1)),y=(0,i.W)((0,c.l)(b,this.beta2),(0,c.l)((0,h.E)(p),1-this.beta2)),w=(0,r.y)(v,a),A=(0,r.y)(y,o);f.assign(v),b.assign(y);const W=(0,i.W)((0,c.l)((0,r.y)(w,(0,i.W)((0,u.R)(A),this.epsilon)),-this.learningRate),m);m.assign(W)})),this.accBeta1.assign((0,c.l)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,c.l)(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,s.AS)(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedSecondMoment&&(0,s.AS)(this.accumulatedSecondMoment.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),(0,s.DZ)((()=>{this.accBeta1.assign((0,o.n)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,o.n)(this.beta2,this.iterations_+1))}));const e=t.length/2,a=!1;this.accumulatedFirstMoment=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)}))),this.accumulatedSecondMoment=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}f.className="Adam",(0,g.registerClass)(f)},83335:function(t,e,a){a.d(e,{L:function(){return u}});var n=a(99696),s=a(85316),i=a(81409),r=a(98544),c=a(5340),o=a(25727),l=a(37930);class u{static sgd(t){return new l.S(t)}static momentum(t,e,a=!1){return new c.Q(t,e,a)}static rmsprop(t,e=.9,a=0,n=null,s=!1){return new o.P(t,e,a,n,s)}static adam(t=.001,e=.9,a=.999,n=null){return new i.F(t,e,a,n)}static adadelta(t=.001,e=.95,a=null){return new n.K(t,e,a)}static adamax(t=.002,e=.9,a=.999,n=null,s=0){return new r.o(t,e,a,n,s)}static adagrad(t,e=.1){return new s.a(t,e)}}},83672:function(t,e,a){var n=a(46574),s=a(65606);const i=()=>a(85817);let r;class c{constructor(){this.util=a(18590),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=(0,n._K)().global.fetch?(0,n._K)().global.fetch(t,e):(null==r&&(r=i()),r(t,e))}now(){const t=s.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}}(0,n._K)().get("IS_NODE")&&(0,n._K)().setPlatform("node",new c)},85316:function(t,e,a){a.d(e,{a:function(){return d}});var n=a(67897),s=a(35287),i=a(37523),r=a(89359),c=a(96111),o=a(9258),l=a(79348),u=a(45793),h=a(79559),m=a(64403);class d extends m.E{constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const h=n.T2.registeredVariables[e];if(null==this.accumulatedGrads[a]){const t=!1;this.accumulatedGrads[a]={originalName:`${e}/accumulator`,variable:(0,s.DZ)((()=>(0,c.G)(h.shape,this.initialAccumulatorValue).variable(t)))}}const m=Array.isArray(t)?t[a].tensor:t[e];if(null==m)return;const d=this.accumulatedGrads[a].variable;(0,s.DZ)((()=>{const t=(0,i.W)(d,(0,u.E)(m));d.assign(t);const e=(0,i.W)((0,o.l)((0,r.y)(m,(0,l.R)((0,i.W)(t,n.T2.backend.epsilon()))),-this.learningRate),h);h.assign(e)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,s.AS)(this.accumulatedGrads.map((t=>t.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}d.className="Adagrad",(0,h.registerClass)(d)},97706:function(t,e,a){a.d(e,{z:function(){return c}});var n=a(67897),s=a(15441),i=a(28189),r=a(45119);const c=(0,a(70929).op)({unsortedSegmentSum_:function(t,e,a){const c=(0,i.YT)(t,"x","unsortedSegmentSum"),o=(0,i.YT)(e,"segmentIds","unsortedSegmentSum","int32");(0,r.vA)((0,r.E6)(a),(()=>"numSegments must be of dtype int"));const l={x:c,segmentIds:o},u={numSegments:a};return n.T2.runKernel(s.pP,l,u)}})},97858:function(t,e,a){a.d(e,{e:function(){return r}});var n=a(448),s=a(70929),i=a(89748);const r=(0,s.op)({truncatedNormal_:function(t,e=0,a=1,s,r){if(null!=s&&"bool"===s)throw new Error("Unsupported data type $ { dtype }");const c=new i.ai(e,a,s,!0,r),o=(0,n.r)(t,s);for(let n=0;n<o.values.length;n++)o.values[n]=c.nextValue();return o.toTensor()}})},98544:function(t,e,a){a.d(e,{o:function(){return p}});var n=a(67897),s=a(35287),i=a(4888),r=a(37523),c=a(89359),o=a(30178),l=a(9258),u=a(45702),h=a(77126),m=a(55537),d=a(79559),g=a(64403);class p extends g.E{constructor(t,e,a,i=null,r=0){super(),this.learningRate=t,this.beta1=e,this.beta2=a,this.epsilon=i,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,s.DZ)((()=>{this.iteration=(0,u.d)(0).variable(),this.accBeta1=(0,u.d)(e).variable()})),null==i&&(this.epsilon=n.T2.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);(0,s.DZ)((()=>{const a=(0,h.j)(1,this.accBeta1),s=(0,c.y)(-this.learningRate,(0,r.W)((0,l.l)(this.iteration,this.decay),1));e.forEach(((e,u)=>{const h=n.T2.registeredVariables[e],d=!1;null==this.accumulatedFirstMoment[u]&&(this.accumulatedFirstMoment[u]={originalName:`${e}/m`,variable:(0,m.P)(h).variable(d)}),null==this.accumulatedWeightedInfNorm[u]&&(this.accumulatedWeightedInfNorm[u]={originalName:`${e}/v`,variable:(0,m.P)(h).variable(d)});const g=Array.isArray(t)?t[u].tensor:t[e];if(null==g)return;const p=this.accumulatedFirstMoment[u].variable,f=this.accumulatedWeightedInfNorm[u].variable,b=(0,r.W)((0,l.l)(p,this.beta1),(0,l.l)(g,1-this.beta1)),v=(0,l.l)(f,this.beta2),y=(0,i.t)(g),w=(0,o.P)(v,y);p.assign(b),f.assign(w);const A=(0,r.W)((0,l.l)((0,c.y)(s,a),(0,c.y)(b,(0,r.W)(w,this.epsilon))),h);h.assign(A)})),this.iteration.assign((0,r.W)(this.iteration,1)),this.accBeta1.assign((0,l.l)(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,s.AS)(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedWeightedInfNorm&&(0,s.AS)(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}p.className="Adamax",(0,d.registerClass)(p)},99696:function(t,e,a){a.d(e,{K:function(){return d}});var n=a(67897),s=a(35287),i=a(37523),r=a(89359),c=a(9258),o=a(79348),l=a(45793),u=a(55537),h=a(79559),m=a(64403);class d extends m.E{constructor(t,e,a=null){super(),this.learningRate=t,this.rho=e,this.epsilon=a,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==a&&(this.epsilon=n.T2.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const h=n.T2.registeredVariables[e],m=!1;null==this.accumulatedGrads[a]&&(this.accumulatedGrads[a]={originalName:`${e}/accum_grad`,variable:(0,s.DZ)((()=>(0,u.P)(h).variable(m)))}),null==this.accumulatedUpdates[a]&&(this.accumulatedUpdates[a]={originalName:`${e}/accum_var`,variable:(0,s.DZ)((()=>(0,u.P)(h).variable(m)))});const d=Array.isArray(t)?t[a].tensor:t[e];if(null==d)return;const g=this.accumulatedGrads[a].variable,p=this.accumulatedUpdates[a].variable;(0,s.DZ)((()=>{const t=(0,i.W)((0,c.l)(g,this.rho),(0,c.l)((0,l.E)(d),1-this.rho)),e=(0,c.l)((0,r.y)((0,o.R)((0,i.W)(p,this.epsilon)),(0,o.R)((0,i.W)(g,this.epsilon))),d),a=(0,i.W)((0,c.l)(p,this.rho),(0,c.l)((0,l.E)(e),1-this.rho));g.assign(t),p.assign(a);const n=(0,i.W)((0,c.l)(e,-this.learningRate),h);h.assign(n)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,s.AS)(this.accumulatedGrads.map((t=>t.variable))),(0,s.AS)(this.accumulatedUpdates.map((t=>t.variable))))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2,a=!1;this.accumulatedGrads=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)}))),this.accumulatedUpdates=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}d.className="Adadelta",(0,h.registerClass)(d)}}]);
//# sourceMappingURL=stylist-vendors-4f68e0f9.8b946eb58f25cdef348c.js.map