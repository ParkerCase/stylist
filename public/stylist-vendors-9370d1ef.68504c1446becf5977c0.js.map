{"version":3,"file":"stylist-vendors-9370d1ef.68504c1446becf5977c0.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/utils/layer_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/utils/executor_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/optimizers.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/utils/generic_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/utils/variable_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/utils/types_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/utils/conv_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/utils/math_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/regularizers.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/utils/serialization_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/user_defined_metadata.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { countParamsInWeights } from './variable_utils';\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\nexport function printSummary(model, lineLength, positions, \n// tslint:disable-next-line:no-any\nprintFn = console.log) {\n    const sequentialLike = isModelSequentialLike(model);\n    // Header names for different log elements.\n    const toDisplay = ['Layer (type)', 'Input Shape', 'Output shape', 'Param #'];\n    if (sequentialLike) {\n        lineLength = lineLength || 90;\n        positions = positions || [0.32, 0.61, 0.89, 1];\n    }\n    else {\n        lineLength = lineLength || 115;\n        positions = positions || [0.24, 0.48, 0.70, 0.80, 1];\n        // Header names for different log elements.\n    }\n    if (positions[positions.length - 1] <= 1) {\n        // `positions` is relative. Convert it to absolute positioning.\n        positions = positions.map(p => Math.floor(lineLength * p));\n    }\n    let relevantNodes;\n    if (!sequentialLike) {\n        toDisplay.push('Receives inputs');\n        relevantNodes = [];\n        for (const depth in model.nodesByDepth) {\n            relevantNodes.push(...model.nodesByDepth[depth]);\n        }\n    }\n    printFn('_'.repeat(lineLength));\n    printRow(toDisplay, positions, printFn);\n    printFn('='.repeat(lineLength));\n    const layers = model.layers;\n    for (let i = 0; i < layers.length; ++i) {\n        if (sequentialLike) {\n            printLayerSummary(layers[i], positions, printFn);\n        }\n        else {\n            printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);\n        }\n        printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n    }\n    // tslint:disable-next-line:no-any\n    model.checkTrainableWeightsConsistency();\n    const trainableCount = countTrainableParams(model);\n    const nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n    printFn(`Total params: ${trainableCount + nonTrainableCount}`);\n    printFn(`Trainable params: ${trainableCount}`);\n    printFn(`Non-trainable params: ${nonTrainableCount}`);\n    printFn('_'.repeat(lineLength));\n}\nfunction countTrainableParams(model) {\n    let trainableCount;\n    // tslint:disable:no-any\n    if (model.collectedTrainableWeights != null) {\n        trainableCount =\n            countParamsInWeights(model.collectedTrainableWeights);\n    }\n    else {\n        trainableCount = countParamsInWeights(model.trainableWeights);\n    }\n    // tslint:enable:no-any\n    return trainableCount;\n}\nfunction isModelSequentialLike(model) {\n    let sequentialLike = true;\n    const nodesByDepth = [];\n    const nodes = [];\n    for (const depth in model.nodesByDepth) {\n        nodesByDepth.push(model.nodesByDepth[depth]);\n    }\n    for (const depthNodes of nodesByDepth) {\n        if (depthNodes.length > 1 ||\n            depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n            sequentialLike = false;\n            break;\n        }\n        nodes.push(...depthNodes);\n    }\n    if (sequentialLike) {\n        // Search for shared layers.\n        for (const layer of model.layers) {\n            let flag = false;\n            for (const node of layer.inboundNodes) {\n                if (nodes.indexOf(node) !== -1) {\n                    if (flag) {\n                        sequentialLike = false;\n                        break;\n                    }\n                    else {\n                        flag = true;\n                    }\n                }\n            }\n            if (!sequentialLike) {\n                break;\n            }\n        }\n    }\n    return sequentialLike;\n}\nfunction printRow(fields, positions, \n// tslint:disable-next-line:no-any\nprintFn = console.log) {\n    let line = '';\n    for (let i = 0; i < fields.length; ++i) {\n        if (i > 0) {\n            line = line.slice(0, line.length - 1) + ' ';\n        }\n        line += fields[i];\n        line = line.slice(0, positions[i]);\n        line += ' '.repeat(positions[i] - line.length);\n    }\n    printFn(line);\n}\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\nfunction printLayerSummary(layer, positions, \n// tslint:disable-next-line:no-any\nprintFn) {\n    let outputShape;\n    let inputShape;\n    try {\n        inputShape = (layer.inboundNodes.map(x => JSON.stringify(x.inputShapes))).join(',');\n    }\n    catch (err) {\n        inputShape = 'multiple';\n    }\n    try {\n        outputShape = JSON.stringify(layer.outputShape);\n    }\n    catch (err) {\n        outputShape = 'multiple';\n    }\n    const name = layer.name;\n    const className = layer.getClassName();\n    const fields = [`${name} (${className})`, inputShape,\n        outputShape, layer.countParams().toString()];\n    printRow(fields, positions, printFn);\n}\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\nfunction printLayerSummaryWithConnections(layer, positions, relevantNodes, \n// tslint:disable-next-line:no-any\nprintFn) {\n    let outputShape;\n    let inputShape;\n    try {\n        inputShape = (layer.inboundNodes.map(x => JSON.stringify(x.inputShapes))).join(',');\n    }\n    catch (err) {\n        inputShape = 'multiple';\n    }\n    try {\n        outputShape = JSON.stringify(layer.outputShape);\n    }\n    catch (err) {\n        outputShape = 'multiple';\n    }\n    const connections = [];\n    for (const node of layer.inboundNodes) {\n        if (relevantNodes != null && relevantNodes.length > 0 &&\n            relevantNodes.indexOf(node) === -1) {\n            continue;\n        }\n        for (let i = 0; i < node.inboundLayers.length; ++i) {\n            const inboundLayer = node.inboundLayers[i].name;\n            const inboundLayerIndex = node.nodeIndices[i];\n            const inboundTensorIndex = node.tensorIndices[i];\n            connections.push(`${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);\n        }\n    }\n    const name = layer.name;\n    const className = layer.getClassName();\n    const firstConnection = connections.length === 0 ? '' : connections[0];\n    const fields = [\n        `${name} (${className})`, inputShape,\n        outputShape, layer.countParams().toString(),\n        firstConnection\n    ];\n    printRow(fields, positions, printFn);\n    for (let i = 1; i < connections.length; ++i) {\n        printRow(['', '', '', '', connections[i]], positions, printFn);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF5ZXJfdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvdXRpbHMvbGF5ZXJfdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFJSCxPQUFPLEVBQUMsb0JBQW9CLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUV0RDs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUNILE1BQU0sVUFBVSxZQUFZLENBQ3hCLEtBQWdCLEVBQUUsVUFBbUIsRUFBRSxTQUFvQjtBQUMzRCxrQ0FBa0M7QUFDbEMsVUFDSSxPQUFPLENBQUMsR0FBRztJQUNqQixNQUFNLGNBQWMsR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUVwRCwyQ0FBMkM7SUFDM0MsTUFBTSxTQUFTLEdBQWEsQ0FBQyxjQUFjLEVBQUUsYUFBYSxFQUFFLGNBQWMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN2RixJQUFJLGNBQWMsRUFBRTtRQUNsQixVQUFVLEdBQUcsVUFBVSxJQUFJLEVBQUUsQ0FBQztRQUM5QixTQUFTLEdBQUcsU0FBUyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDaEQ7U0FBTTtRQUNMLFVBQVUsR0FBRyxVQUFVLElBQUksR0FBRyxDQUFDO1FBQy9CLFNBQVMsR0FBRyxTQUFTLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDckQsMkNBQTJDO0tBQzVDO0lBRUQsSUFBSSxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDeEMsK0RBQStEO1FBQy9ELFNBQVMsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdB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ICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtDb250YWluZXJ9IGZyb20gJy4uL2VuZ2luZS9jb250YWluZXInO1xuaW1wb3J0IHtMYXllciwgTm9kZX0gZnJvbSAnLi4vZW5naW5lL3RvcG9sb2d5JztcbmltcG9ydCB7Y291bnRQYXJhbXNJbldlaWdodHN9IGZyb20gJy4vdmFyaWFibGVfdXRpbHMnO1xuXG4vKipcbiAqIFByaW50IHRoZSBzdW1tYXJ5IG9mIGEgTGF5ZXJzTW9kZWwgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBtb2RlbCB0Zi5MYXllcnNNb2RlbCBpbnN0YW5jZS5cbiAqIEBwYXJhbSBsaW5lTGVuZ3RoIFRvdGFsIGxlbmd0aCBvZiBwcmludGVkIGxpbmVzLiBTZXQgdGhpcyB0byBhZGFwdCB0byB0aGVcbiAqICAgZGlzcGxheSB0byBkaWZmZXJlbnQgdGVybWluYWwgb3IgY29uc29sZSBzaXplcy5cbiAqIEBwYXJhbSBwb3NpdGlvbnMgUmVsYXRpdmUgb3IgYWJzb2x1dGUgcG9zaXRpb25zIG9mIGxvZyBlbGVtZW50cyBpbiBlYWNoXG4gKiAgIGxpbmUuIEVhY2ggbnVtYmVyIGNvcnJlc3BvbmRzIHRvIHJpZ2h0LW1vc3QgKGkuZS4sIGVuZGluZykgcG9zaXRpb24gb2YgYVxuICogICBjb2x1bW4uXG4gKiAgIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gYFswLjQ1LCAwLjg1LCAxXWAgZm9yIHNlcXVlbnRpYWwtbGlrZVxuICogICBtb2RlbHMgYW5kIGBbMC4zMywgMC41NSwgMC42NywgMV1gIGZvciBub24tc2VxdWVudGlhbCBsaWtlIG1vZGVscy5cbiAqIEBwYXJhbSBwcmludEZuIFByaW50IGZ1bmN0aW9uIHRvIHVzZS5cbiAqICAgSXQgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCBsaW5lIG9mIHRoZSBzdW1tYXJ5LiBZb3UgY2FuIHByb3ZpZGUgYSBjdXN0b21cbiAqICAgZnVuY3Rpb24gaW4gb3JkZXIgdG8gY2FwdHVyZSB0aGUgc3RyaW5nIHN1bW1hcnkuIERlZmF1bHRzIHRvIGBjb25zb2xlLmxvZ2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludFN1bW1hcnkoXG4gICAgbW9kZWw6IENvbnRhaW5lciwgbGluZUxlbmd0aD86IG51bWJlciwgcG9zaXRpb25zPzogbnVtYmVyW10sXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIHByaW50Rm46IChtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pID0+IHZvaWQgPVxuICAgICAgICBjb25zb2xlLmxvZyk6IHZvaWQge1xuICBjb25zdCBzZXF1ZW50aWFsTGlrZSA9IGlzTW9kZWxTZXF1ZW50aWFsTGlrZShtb2RlbCk7XG5cbiAgLy8gSGVhZGVyIG5hbWVzIGZvciBkaWZmZXJlbnQgbG9nIGVsZW1lbnRzLlxuICBjb25zdCB0b0Rpc3BsYXk6IHN0cmluZ1tdID0gWydMYXllciAodHlwZSknLCAnSW5wdXQgU2hhcGUnLCAnT3V0cHV0IHNoYXBlJywgJ1BhcmFtICMnXTtcbiAgaWYgKHNlcXVlbnRpYWxMaWtlKSB7XG4gICAgbGluZUxlbmd0aCA9IGxpbmVMZW5ndGggfHwgOTA7XG4gICAgcG9zaXRpb25zID0gcG9zaXRpb25zIHx8IFswLjMyLCAwLjYxLCAwLjg5LCAxXTtcbiAgfSBlbHNlIHtcbiAgICBsaW5lTGVuZ3RoID0gbGluZUxlbmd0aCB8fCAxMTU7XG4gICAgcG9zaXRpb25zID0gcG9zaXRpb25zIHx8IFswLjI0LCAwLjQ4LCAwLjcwLCAwLjgwLCAxXTtcbiAgICAvLyBIZWFkZXIgbmFtZXMgZm9yIGRpZmZlcmVudCBsb2cgZWxlbWVudHMuXG4gIH1cblxuICBpZiAocG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXSA8PSAxKSB7XG4gICAgLy8gYHBvc2l0aW9uc2AgaXMgcmVsYXRpdmUuIENvbnZlcnQgaXQgdG8gYWJzb2x1dGUgcG9zaXRpb25pbmcuXG4gICAgcG9zaXRpb25zID0gcG9zaXRpb25zLm1hcChwID0+IE1hdGguZmxvb3IobGluZUxlbmd0aCAqIHApKTtcbiAgfVxuXG4gIGxldCByZWxldmFudE5vZGVzOiBOb2RlW107XG4gIGlmICghc2VxdWVudGlhbExpa2UpIHtcbiAgICB0b0Rpc3BsYXkucHVzaCgnUmVjZWl2ZXMgaW5wdXRzJyk7XG4gICAgcmVsZXZhbnROb2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZGVwdGggaW4gbW9kZWwubm9kZXNCeURlcHRoKSB7XG4gICAgICByZWxldmFudE5vZGVzLnB1c2goLi4ubW9kZWwubm9kZXNCeURlcHRoW2RlcHRoXSk7XG4gICAgfVxuICB9XG5cbiAgcHJpbnRGbignXycucmVwZWF0KGxpbmVMZW5ndGgpKTtcbiAgcHJpbnRSb3codG9EaXNwbGF5LCBwb3NpdGlvbnMsIHByaW50Rm4pO1xuICBwcmludEZuKCc9Jy5yZXBlYXQobGluZUxlbmd0aCkpO1xuXG4gIGNvbnN0IGxheWVycyA9IG1vZGVsLmxheWVycztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoc2VxdWVudGlhbExpa2UpIHtcbiAgICAgIHByaW50TGF5ZXJTdW1tYXJ5KGxheWVyc1tpXSwgcG9zaXRpb25zLCBwcmludEZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpbnRMYXllclN1bW1hcnlXaXRoQ29ubmVjdGlvbnMoXG4gICAgICAgICAgbGF5ZXJzW2ldLCBwb3NpdGlvbnMsIHJlbGV2YW50Tm9kZXMsIHByaW50Rm4pO1xuICAgIH1cbiAgICBwcmludEZuKChpID09PSBsYXllcnMubGVuZ3RoIC0gMSA/ICc9JyA6ICdfJykucmVwZWF0KGxpbmVMZW5ndGgpKTtcbiAgfVxuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgKG1vZGVsIGFzIGFueSkuY2hlY2tUcmFpbmFibGVXZWlnaHRzQ29uc2lzdGVuY3koKTtcblxuICBjb25zdCB0cmFpbmFibGVDb3VudCA9IGNvdW50VHJhaW5hYmxlUGFyYW1zKG1vZGVsKTtcbiAgY29uc3Qgbm9uVHJhaW5hYmxlQ291bnQgPSBjb3VudFBhcmFtc0luV2VpZ2h0cyhtb2RlbC5ub25UcmFpbmFibGVXZWlnaHRzKTtcblxuICBwcmludEZuKGBUb3RhbCBwYXJhbXM6ICR7dHJhaW5hYmxlQ291bnQgKyBub25UcmFpbmFibGVDb3VudH1gKTtcbiAgcHJpbnRGbihgVHJhaW5hYmxlIHBhcmFtczogJHt0cmFpbmFibGVDb3VudH1gKTtcbiAgcHJpbnRGbihgTm9uLXRyYWluYWJsZSBwYXJhbXM6ICR7bm9uVHJhaW5hYmxlQ291bnR9YCk7XG4gIHByaW50Rm4oJ18nLnJlcGVhdChsaW5lTGVuZ3RoKSk7XG59XG5cbmZ1bmN0aW9uIGNvdW50VHJhaW5hYmxlUGFyYW1zKG1vZGVsOiBDb250YWluZXIpOiBudW1iZXIge1xuICBsZXQgdHJhaW5hYmxlQ291bnQ6IG51bWJlcjtcbiAgLy8gdHNsaW50OmRpc2FibGU6bm8tYW55XG4gIGlmICgobW9kZWwgYXMgYW55KS5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzICE9IG51bGwpIHtcbiAgICB0cmFpbmFibGVDb3VudCA9XG4gICAgICAgIGNvdW50UGFyYW1zSW5XZWlnaHRzKChtb2RlbCBhcyBhbnkpLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMpO1xuICB9IGVsc2Uge1xuICAgIHRyYWluYWJsZUNvdW50ID0gY291bnRQYXJhbXNJbldlaWdodHMobW9kZWwudHJhaW5hYmxlV2VpZ2h0cyk7XG4gIH1cbiAgLy8gdHNsaW50OmVuYWJsZTpuby1hbnlcbiAgcmV0dXJuIHRyYWluYWJsZUNvdW50O1xufVxuXG5mdW5jdGlvbiBpc01vZGVsU2VxdWVudGlhbExpa2UobW9kZWw6IENvbnRhaW5lcik6IGJvb2xlYW4ge1xuICBsZXQgc2VxdWVudGlhbExpa2UgPSB0cnVlO1xuICBjb25zdCBub2Rlc0J5RGVwdGg6IE5vZGVbXVtdID0gW107XG4gIGNvbnN0IG5vZGVzOiBOb2RlW10gPSBbXTtcbiAgZm9yIChjb25zdCBkZXB0aCBpbiBtb2RlbC5ub2Rlc0J5RGVwdGgpIHtcbiAgICBub2Rlc0J5RGVwdGgucHVzaChtb2RlbC5ub2Rlc0J5RGVwdGhbZGVwdGhdKTtcbiAgfVxuICBmb3IgKGNvbnN0IGRlcHRoTm9kZXMgb2Ygbm9kZXNCeURlcHRoKSB7XG4gICAgaWYgKGRlcHRoTm9kZXMubGVuZ3RoID4gMSB8fFxuICAgICAgICBkZXB0aE5vZGVzLmxlbmd0aCA9PT0gMSAmJiBkZXB0aE5vZGVzWzBdLmluYm91bmRMYXllcnMubGVuZ3RoID4gMSkge1xuICAgICAgc2VxdWVudGlhbExpa2UgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBub2Rlcy5wdXNoKC4uLmRlcHRoTm9kZXMpO1xuICB9XG4gIGlmIChzZXF1ZW50aWFsTGlrZSkge1xuICAgIC8vIFNlYXJjaCBmb3Igc2hhcmVkIGxheWVycy5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIG1vZGVsLmxheWVycykge1xuICAgICAgbGV0IGZsYWcgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBsYXllci5pbmJvdW5kTm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgIHNlcXVlbnRpYWxMaWtlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXNlcXVlbnRpYWxMaWtlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2VxdWVudGlhbExpa2U7XG59XG5cbmZ1bmN0aW9uIHByaW50Um93KFxuICAgIGZpZWxkczogc3RyaW5nW10sIHBvc2l0aW9uczogbnVtYmVyW10sXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIHByaW50Rm46IChtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pID0+IHZvaWQgPSBjb25zb2xlLmxvZykge1xuICBsZXQgbGluZSA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpID4gMCkge1xuICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgbGluZS5sZW5ndGggLSAxKSArICcgJztcbiAgICB9XG4gICAgbGluZSArPSBmaWVsZHNbaV07XG4gICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgcG9zaXRpb25zW2ldKTtcbiAgICBsaW5lICs9ICcgJy5yZXBlYXQocG9zaXRpb25zW2ldIC0gbGluZS5sZW5ndGgpO1xuICB9XG4gIHByaW50Rm4obGluZSk7XG59XG5cbi8qKlxuICogUHJpbnRzIGEgc3VtbWFyeSBmb3IgYSBzaW5nbGUgTGF5ZXIsIHdpdGhvdXQgY29ubmVjdGl2aXR5IGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSBsYXllcjogTGF5ZXIgaW5zdGFuY2UgdG8gcHJpbnQuXG4gKi9cbmZ1bmN0aW9uIHByaW50TGF5ZXJTdW1tYXJ5KFxuICAgIGxheWVyOiBMYXllciwgcG9zaXRpb25zOiBudW1iZXJbXSxcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgcHJpbnRGbjogKG1lc3NhZ2U/OiBhbnksIC4uLm9wdGlvbmFsUGFyYW1zOiBhbnlbXSkgPT4gdm9pZCkge1xuICBsZXQgb3V0cHV0U2hhcGU6IHN0cmluZztcbiAgbGV0IGlucHV0U2hhcGU6IHN0cmluZztcblxuICB0cnkge1xuICAgIGlucHV0U2hhcGUgPSAobGF5ZXIuaW5ib3VuZE5vZGVzLm1hcChcbiAgICAgIHggPT4gSlNPTi5zdHJpbmdpZnkoeC5pbnB1dFNoYXBlcylcbiAgICApKS5qb2luKCcsJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlucHV0U2hhcGUgPSAnbXVsdGlwbGUnO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBvdXRwdXRTaGFwZSA9IEpTT04uc3RyaW5naWZ5KGxheWVyLm91dHB1dFNoYXBlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgb3V0cHV0U2hhcGUgPSAnbXVsdGlwbGUnO1xuICB9XG5cbiAgY29uc3QgbmFtZSA9IGxheWVyLm5hbWU7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IGxheWVyLmdldENsYXNzTmFtZSgpO1xuICBjb25zdCBmaWVsZHM6IHN0cmluZ1tdID1cbiAgICAgIFtgJHtuYW1lfSAoJHtjbGFzc05hbWV9KWAsIGlucHV0U2hhcGUsXG4gICAgICBvdXRwdXRTaGFwZSwgbGF5ZXIuY291bnRQYXJhbXMoKS50b1N0cmluZygpXTtcbiAgcHJpbnRSb3coZmllbGRzLCBwb3NpdGlvbnMsIHByaW50Rm4pO1xufVxuXG4vKipcbiAqIFByaW50cyBhIHN1bW1hcnkgZm9yIGEgc2luZ2xlIExheWVyLCB3aXRoIGNvbm5lY3Rpdml0eSBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gcHJpbnRMYXllclN1bW1hcnlXaXRoQ29ubmVjdGlvbnMoXG4gICAgbGF5ZXI6IExheWVyLCBwb3NpdGlvbnM6IG51bWJlcltdLCByZWxldmFudE5vZGVzOiBOb2RlW10sXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIHByaW50Rm46IChtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pID0+IHZvaWQpIHtcbiAgbGV0IG91dHB1dFNoYXBlOiBzdHJpbmc7XG4gIGxldCBpbnB1dFNoYXBlOiBzdHJpbmc7XG5cbiAgdHJ5IHtcbiAgICBpbnB1dFNoYXBlID0gKGxheWVyLmluYm91bmROb2Rlcy5tYXAoXG4gICAgICB4ID0+IEpTT04uc3RyaW5naWZ5KHguaW5wdXRTaGFwZXMpXG4gICAgKSkuam9pbignLCcpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpbnB1dFNoYXBlID0gJ211bHRpcGxlJztcbiAgfVxuXG4gIHRyeSB7XG4gICAgb3V0cHV0U2hhcGUgPSBKU09OLnN0cmluZ2lmeShsYXllci5vdXRwdXRTaGFwZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIG91dHB1dFNoYXBlID0gJ211bHRpcGxlJztcbiAgfVxuXG4gIGNvbnN0IGNvbm5lY3Rpb25zOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgbGF5ZXIuaW5ib3VuZE5vZGVzKSB7XG4gICAgaWYgKHJlbGV2YW50Tm9kZXMgIT0gbnVsbCAmJiByZWxldmFudE5vZGVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgcmVsZXZhbnROb2Rlcy5pbmRleE9mKG5vZGUpID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBpbmJvdW5kTGF5ZXIgPSBub2RlLmluYm91bmRMYXllcnNbaV0ubmFtZTtcbiAgICAgIGNvbnN0IGluYm91bmRMYXllckluZGV4ID0gbm9kZS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgIGNvbnN0IGluYm91bmRUZW5zb3JJbmRleCA9IG5vZGUudGVuc29ySW5kaWNlc1tpXTtcbiAgICAgIGNvbm5lY3Rpb25zLnB1c2goXG4gICAgICAgICAgYCR7aW5ib3VuZExheWVyfVske2luYm91bmRMYXllckluZGV4fV1bJHtpbmJvdW5kVGVuc29ySW5kZXh9XWApO1xuICAgIH1cbiAgfVxuICBjb25zdCBuYW1lID0gbGF5ZXIubmFtZTtcbiAgY29uc3QgY2xhc3NOYW1lID0gbGF5ZXIuZ2V0Q2xhc3NOYW1lKCk7XG4gIGNvbnN0IGZpcnN0Q29ubmVjdGlvbiA9IGNvbm5lY3Rpb25zLmxlbmd0aCA9PT0gMCA/ICcnIDogY29ubmVjdGlvbnNbMF07XG4gIGNvbnN0IGZpZWxkczogc3RyaW5nW10gPSBbXG4gICAgYCR7bmFtZX0gKCR7Y2xhc3NOYW1lfSlgLCBpbnB1dFNoYXBlLFxuICAgIG91dHB1dFNoYXBlLCBsYXllci5jb3VudFBhcmFtcygpLnRvU3RyaW5nKCksXG4gICAgZmlyc3RDb25uZWN0aW9uXG4gIF07XG5cbiAgcHJpbnRSb3coZmllbGRzLCBwb3NpdGlvbnMsIHByaW50Rm4pO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbm5lY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgcHJpbnRSb3coWycnLCAnJywgJycsICcnLCBjb25uZWN0aW9uc1tpXV0sIHBvc2l0aW9ucywgcHJpbnRGbik7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * LruCache: A mapping from the String to T. If the number of the entries is\n * exceeding the `maxEntries`, the LruCache will delete the least recently\n * used entry.\n */\nexport class LruCache {\n    constructor(maxEntries) {\n        this.maxEntries = maxEntries || 100;\n        this.cache = new Map();\n    }\n    /**\n     * Get the entry for the key and mark it as used recently.\n     */\n    get(key) {\n        let entry;\n        if (this.cache.has(key)) {\n            entry = this.cache.get(key);\n            this.cache.delete(key);\n            this.cache.set(key, entry);\n        }\n        return entry;\n    }\n    /**\n     * Put the entry into the cache. If the key already existed, mark the key as\n     * used recently.\n     */\n    put(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.delete(key);\n        }\n        else if (this.cache.size >= this.maxEntries) {\n            const keyToDelete = this.cache.keys().next().value;\n            this.cache.delete(keyToDelete);\n        }\n        this.cache.set(key, value);\n    }\n    /**\n     * Get the MaxEntries of the cache.\n     */\n    getMaxEntries() {\n        return this.maxEntries;\n    }\n    /**\n     * Set the MaxEntries of the cache. If the maxEntries is decreased, reduce\n     * entries in the cache.\n     */\n    setMaxEntries(maxEntries) {\n        if (maxEntries < 0) {\n            throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${maxEntries}.`);\n        }\n        if (this.maxEntries > maxEntries) {\n            for (let i = 0; i < this.maxEntries - maxEntries; i++) {\n                const keyToDelete = this.cache.keys().next().value;\n                this.cache.delete(keyToDelete);\n            }\n        }\n        this.maxEntries = maxEntries;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhlY3V0b3JfdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvdXRpbHMvZXhlY3V0b3JfdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFDSDs7OztHQUlHO0FBRUgsTUFBTSxPQUFPLFFBQVE7SUFJbkIsWUFBWSxVQUFtQjtRQUM3QixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsSUFBSSxHQUFHLENBQUM7UUFDcEMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLEdBQUcsRUFBYSxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7T0FFRztJQUNJLEdBQUcsQ0FBQyxHQUFXO1FBQ3BCLElBQUksS0FBUSxDQUFDO1FBQ2IsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUN2QixLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDNUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzVCO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksR0FBRyxDQUFDLEdBQVcsRUFBRSxLQUFRO1FBQzlCLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDdkIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDeEI7YUFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDN0MsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUM7WUFDbkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDaEM7UUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVEOztPQUVHO0lBQ0ksYUFBYTtRQUNsQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7T0FHRztJQUNJLGFBQWEsQ0FBQyxVQUFrQjtRQUNyQyxJQUFJLFVBQVUsR0FBRyxDQUFDLEVBQUU7WUFDbEIsTUFBTSxJQUFJLEtBQUssQ0FDWCw0REFDSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO1NBQ3hCO1FBRUQsSUFBSSxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsRUFBRTtZQUNoQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3JELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDO2dCQUNuRCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNoQztTQUNGO1FBRUQsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7SUFDL0IsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogTHJ1Q2FjaGU6IEEgbWFwcGluZyBmcm9tIHRoZSBTdHJpbmcgdG8gVC4gSWYgdGhlIG51bWJlciBvZiB0aGUgZW50cmllcyBpc1xuICogZXhjZWVkaW5nIHRoZSBgbWF4RW50cmllc2AsIHRoZSBMcnVDYWNoZSB3aWxsIGRlbGV0ZSB0aGUgbGVhc3QgcmVjZW50bHlcbiAqIHVzZWQgZW50cnkuXG4gKi9cblxuZXhwb3J0IGNsYXNzIExydUNhY2hlPFQ+IHtcbiAgcHJpdmF0ZSBjYWNoZTogTWFwPHN0cmluZywgVD47XG4gIHByaXZhdGUgbWF4RW50cmllczogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKG1heEVudHJpZXM/OiBudW1iZXIpIHtcbiAgICB0aGlzLm1heEVudHJpZXMgPSBtYXhFbnRyaWVzIHx8IDEwMDtcbiAgICB0aGlzLmNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIFQ+KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlbnRyeSBmb3IgdGhlIGtleSBhbmQgbWFyayBpdCBhcyB1c2VkIHJlY2VudGx5LlxuICAgKi9cbiAgcHVibGljIGdldChrZXk6IHN0cmluZyk6IFQge1xuICAgIGxldCBlbnRyeTogVDtcbiAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgZW50cnkgPSB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgZW50cnkpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnk7XG4gIH1cblxuICAvKipcbiAgICogUHV0IHRoZSBlbnRyeSBpbnRvIHRoZSBjYWNoZS4gSWYgdGhlIGtleSBhbHJlYWR5IGV4aXN0ZWQsIG1hcmsgdGhlIGtleSBhc1xuICAgKiB1c2VkIHJlY2VudGx5LlxuICAgKi9cbiAgcHVibGljIHB1dChrZXk6IHN0cmluZywgdmFsdWU6IFQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2FjaGUuc2l6ZSA+PSB0aGlzLm1heEVudHJpZXMpIHtcbiAgICAgIGNvbnN0IGtleVRvRGVsZXRlID0gdGhpcy5jYWNoZS5rZXlzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5VG9EZWxldGUpO1xuICAgIH1cbiAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIE1heEVudHJpZXMgb2YgdGhlIGNhY2hlLlxuICAgKi9cbiAgcHVibGljIGdldE1heEVudHJpZXMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5tYXhFbnRyaWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgTWF4RW50cmllcyBvZiB0aGUgY2FjaGUuIElmIHRoZSBtYXhFbnRyaWVzIGlzIGRlY3JlYXNlZCwgcmVkdWNlXG4gICAqIGVudHJpZXMgaW4gdGhlIGNhY2hlLlxuICAgKi9cbiAgcHVibGljIHNldE1heEVudHJpZXMobWF4RW50cmllczogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKG1heEVudHJpZXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFRoZSBtYXhFbnRyaWVzIG9mIExSVSBjYWNoZXMgbXVzdCBiZSBhdCBsZWFzdCAwLCBidXQgZ290ICR7XG4gICAgICAgICAgICAgIG1heEVudHJpZXN9LmApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1heEVudHJpZXMgPiBtYXhFbnRyaWVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF4RW50cmllcyAtIG1heEVudHJpZXM7IGkrKykge1xuICAgICAgICBjb25zdCBrZXlUb0RlbGV0ZSA9IHRoaXMuY2FjaGUua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5VG9EZWxldGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWF4RW50cmllcyA9IG1heEVudHJpZXM7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Optimizers.\n */\nimport { train } from '@tensorflow/tfjs-core';\nimport { epsilon } from './backend/common';\nimport { ValueError } from './errors';\n// Add (de)serialize()\n// Porting note: This diverges from the PyKeras implementation and may need to\n// change based on (de)serialization requirements.\nexport function getOptimizer(identifier) {\n    const optimizerMap = {\n        'Adagrad': () => train.adagrad(0.01),\n        'Adadelta': () => train.adadelta(1, 0.95, epsilon()),\n        'Adam': () => train.adam(0.001, 0.9, 0.999, epsilon()),\n        'Adamax': () => train.adamax(0.002, 0.9, 0.999, epsilon(), 0),\n        'RMSProp': () => train.rmsprop(0.001, 0.9, 0, epsilon()),\n        'SGD': () => train.sgd(0.01)\n    };\n    optimizerMap['adagrad'] = optimizerMap['Adagrad'];\n    optimizerMap['adadelta'] = optimizerMap['Adadelta'];\n    optimizerMap['adam'] = optimizerMap['Adam'];\n    optimizerMap['adamax'] = optimizerMap['Adamax'];\n    optimizerMap['rmsprop'] = optimizerMap['RMSProp'];\n    optimizerMap['sgd'] = optimizerMap['SGD'];\n    if (identifier in optimizerMap) {\n        return optimizerMap[identifier]();\n    }\n    throw new ValueError(`Unknown Optimizer ${identifier}`);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3B0aW1pemVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9vcHRpbWl6ZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUg7O0dBRUc7QUFFSCxPQUFPLEVBQVksS0FBSyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFdkQsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLGtCQUFrQixDQUFDO0FBRXpDLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFFcEMsc0JBQXNCO0FBRXRCLDhFQUE4RTtBQUM5RSxrREFBa0Q7QUFDbEQsTUFBTSxVQUFVLFlBQVksQ0FBQyxVQUFrQjtJQUM3QyxNQUFNLFlBQVksR0FBK0M7UUFDL0QsU0FBUyxFQUFFLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQ3BDLFVBQVUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLENBQUM7UUFDcEQsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUM7UUFDdEQsUUFBUSxFQUFFLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzdELFNBQVMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDO1FBQ3hELEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztLQUM3QixDQUFDO0lBQ0YsWUFBWSxDQUFDLFNBQVMsQ0FBQyxHQUFHLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNsRCxZQUFZLENBQUMsVUFBVSxDQUFDLEdBQUcsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3BELFlBQVksQ0FBQyxNQUFNLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDNUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxHQUFHLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNoRCxZQUFZLENBQUMsU0FBUyxDQUFDLEdBQUcsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ2xELFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFMUMsSUFBSSxVQUFVLElBQUksWUFBWSxFQUFFO1FBQzlCLE9BQU8sWUFBWSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7S0FDbkM7SUFDRCxNQUFNLElBQUksVUFBVSxDQUFDLHFCQUFxQixVQUFVLEVBQUUsQ0FBQyxDQUFDO0FBQzFELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIE9wdGltaXplcnMuXG4gKi9cblxuaW1wb3J0IHtPcHRpbWl6ZXIsIHRyYWlufSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge2Vwc2lsb259IGZyb20gJy4vYmFja2VuZC9jb21tb24nO1xuXG5pbXBvcnQge1ZhbHVlRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcblxuLy8gQWRkIChkZSlzZXJpYWxpemUoKVxuXG4vLyBQb3J0aW5nIG5vdGU6IFRoaXMgZGl2ZXJnZXMgZnJvbSB0aGUgUHlLZXJhcyBpbXBsZW1lbnRhdGlvbiBhbmQgbWF5IG5lZWQgdG9cbi8vIGNoYW5nZSBiYXNlZCBvbiAoZGUpc2VyaWFsaXphdGlvbiByZXF1aXJlbWVudHMuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3B0aW1pemVyKGlkZW50aWZpZXI6IHN0cmluZyk6IE9wdGltaXplciB7XG4gIGNvbnN0IG9wdGltaXplck1hcDoge1tvcHRpbWl6ZXJOYW1lOiBzdHJpbmddOiAoKSA9PiBPcHRpbWl6ZXJ9ID0ge1xuICAgICdBZGFncmFkJzogKCkgPT4gdHJhaW4uYWRhZ3JhZCgwLjAxKSxcbiAgICAnQWRhZGVsdGEnOiAoKSA9PiB0cmFpbi5hZGFkZWx0YSgxLCAwLjk1LCBlcHNpbG9uKCkpLFxuICAgICdBZGFtJzogKCkgPT4gdHJhaW4uYWRhbSgwLjAwMSwgMC45LCAwLjk5OSwgZXBzaWxvbigpKSxcbiAgICAnQWRhbWF4JzogKCkgPT4gdHJhaW4uYWRhbWF4KDAuMDAyLCAwLjksIDAuOTk5LCBlcHNpbG9uKCksIDApLFxuICAgICdSTVNQcm9wJzogKCkgPT4gdHJhaW4ucm1zcHJvcCgwLjAwMSwgMC45LCAwLCBlcHNpbG9uKCkpLFxuICAgICdTR0QnOiAoKSA9PiB0cmFpbi5zZ2QoMC4wMSlcbiAgfTtcbiAgb3B0aW1pemVyTWFwWydhZGFncmFkJ10gPSBvcHRpbWl6ZXJNYXBbJ0FkYWdyYWQnXTtcbiAgb3B0aW1pemVyTWFwWydhZGFkZWx0YSddID0gb3B0aW1pemVyTWFwWydBZGFkZWx0YSddO1xuICBvcHRpbWl6ZXJNYXBbJ2FkYW0nXSA9IG9wdGltaXplck1hcFsnQWRhbSddO1xuICBvcHRpbWl6ZXJNYXBbJ2FkYW1heCddID0gb3B0aW1pemVyTWFwWydBZGFtYXgnXTtcbiAgb3B0aW1pemVyTWFwWydybXNwcm9wJ10gPSBvcHRpbWl6ZXJNYXBbJ1JNU1Byb3AnXTtcbiAgb3B0aW1pemVyTWFwWydzZ2QnXSA9IG9wdGltaXplck1hcFsnU0dEJ107XG5cbiAgaWYgKGlkZW50aWZpZXIgaW4gb3B0aW1pemVyTWFwKSB7XG4gICAgcmV0dXJuIG9wdGltaXplck1hcFtpZGVudGlmaWVyXSgpO1xuICB9XG4gIHRocm93IG5ldyBWYWx1ZUVycm9yKGBVbmtub3duIE9wdGltaXplciAke2lkZW50aWZpZXJ9YCk7XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: utils/generic_utils.py */\nimport { util } from '@tensorflow/tfjs-core';\nimport { AssertionError, ValueError } from '../errors';\n// tslint:enable\n/**\n * If `value` is an Array, equivalent to Python's `value * numValues`.\n * If `value` is not an Array, equivalent to Python's `[value] * numValues`\n */\n// tslint:disable-next-line:no-any\nexport function pyListRepeat(value, numValues) {\n    if (Array.isArray(value)) {\n        // tslint:disable-next-line:no-any\n        let newArray = [];\n        for (let i = 0; i < numValues; i++) {\n            newArray = newArray.concat(value);\n        }\n        return newArray;\n    }\n    else {\n        const newArray = new Array(numValues);\n        newArray.fill(value);\n        return newArray;\n    }\n}\nexport function assert(val, message) {\n    if (!val) {\n        throw new AssertionError(message);\n    }\n}\n/**\n * Count the number of elements of the `array` that are equal to `reference`.\n */\nexport function count(array, refernce) {\n    let counter = 0;\n    for (const item of array) {\n        if (item === refernce) {\n            counter++;\n        }\n    }\n    return counter;\n}\n/**\n * If an array is of length 1, just return the first element. Otherwise, return\n * the full array.\n * @param tensors\n */\nexport function singletonOrArray(xs) {\n    if (xs.length === 1) {\n        return xs[0];\n    }\n    return xs;\n}\n/**\n * Normalizes a list/tensor into a list.\n *\n * If a tensor is passed, we return\n * a list of size 1 containing the tensor.\n *\n * @param x target object to be normalized.\n */\n// tslint:disable-next-line:no-any\nexport function toList(x) {\n    if (Array.isArray(x)) {\n        return x;\n    }\n    return [x];\n}\n/**\n * Generate a UID for a list\n */\n// tslint:disable-next-line:no-any\nexport function objectListUid(objs) {\n    const objectList = toList(objs);\n    let retVal = '';\n    for (const obj of objectList) {\n        if (obj.id == null) {\n            throw new ValueError(`Object ${obj} passed to objectListUid without an id`);\n        }\n        if (retVal !== '') {\n            retVal = retVal + ', ';\n        }\n        retVal = `${retVal}${Math.abs(obj.id)}`;\n    }\n    return retVal;\n}\n/**\n * Converts string to snake-case.\n * @param name\n */\nexport function toSnakeCase(name) {\n    const intermediate = name.replace(/(.)([A-Z][a-z0-9]+)/g, '$1_$2');\n    const insecure = intermediate.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();\n    /*\n     If the class is private the name starts with \"_\" which is not secure\n     for creating scopes. We prefix the name with \"private\" in this case.\n     */\n    if (insecure[0] !== '_') {\n        return insecure;\n    }\n    return 'private' + insecure;\n}\nexport function toCamelCase(identifier) {\n    // quick return for empty string or single character strings\n    if (identifier.length <= 1) {\n        return identifier;\n    }\n    // Check for the underscore indicating snake_case\n    if (identifier.indexOf('_') === -1) {\n        return identifier;\n    }\n    return identifier.replace(/[_]+(\\w|$)/g, (m, p1) => p1.toUpperCase());\n}\n// tslint:disable-next-line:no-any\nlet _GLOBAL_CUSTOM_OBJECTS = {};\nexport function serializeKerasObject(instance) {\n    if (instance === null || instance === undefined) {\n        return null;\n    }\n    const dict = {};\n    dict['className'] = instance.getClassName();\n    dict['config'] = instance.getConfig();\n    return dict;\n}\n/**\n * Replace ndarray-style scalar objects in serialization objects with numbers.\n *\n * Background: In some versions of tf.keras, certain scalar values in the HDF5\n * model save file can be serialized as: `{'type': 'ndarray', 'value': num}`,\n * where in `num` is a plain number. This method converts such serialization\n * to a `number`.\n *\n * @param config The keras-format serialization object to be processed\n *   (in place).\n */\nfunction convertNDArrayScalarsInConfig(config) {\n    if (config == null || typeof config !== 'object') {\n        return;\n    }\n    else if (Array.isArray(config)) {\n        config.forEach(configItem => convertNDArrayScalarsInConfig(configItem));\n    }\n    else {\n        const fields = Object.keys(config);\n        for (const field of fields) {\n            const value = config[field];\n            if (value != null && typeof value === 'object') {\n                if (!Array.isArray(value) && value['type'] === 'ndarray' &&\n                    typeof value['value'] === 'number') {\n                    config[field] = value['value'];\n                }\n                else {\n                    convertNDArrayScalarsInConfig(value);\n                }\n            }\n        }\n    }\n}\n/**\n * Deserialize a saved Keras Object\n * @param identifier either a string ID or a saved Keras dictionary\n * @param moduleObjects a list of Python class names to object constructors\n * @param customObjects a list of Python class names to object constructors\n * @param printableModuleName debug text for the object being reconstituted\n * @param fastWeightInit Optional flag to use fast weight initialization\n *   during deserialization. This is applicable to cases in which\n *   the initialization will be immediately overwritten by loaded weight\n *   values. Default: `false`.\n * @returns a TensorFlow.js Layers object\n */\n// tslint:disable:no-any\nexport function deserializeKerasObject(identifier, moduleObjects = {}, customObjects = {}, printableModuleName = 'object', fastWeightInit = false) {\n    // tslint:enable\n    if (typeof identifier === 'string') {\n        const functionName = identifier;\n        let fn;\n        if (functionName in customObjects) {\n            fn = customObjects[functionName];\n        }\n        else if (functionName in _GLOBAL_CUSTOM_OBJECTS) {\n            fn = _GLOBAL_CUSTOM_OBJECTS[functionName];\n        }\n        else {\n            fn = moduleObjects[functionName];\n            if (fn == null) {\n                throw new ValueError(`Unknown ${printableModuleName}: ${identifier}. ` +\n                    `This may be due to one of the following reasons:\\n` +\n                    `1. The ${printableModuleName} is defined in Python, in which ` +\n                    `case it needs to be ported to TensorFlow.js or your JavaScript ` +\n                    `code.\\n` +\n                    `2. The custom ${printableModuleName} is defined in JavaScript, ` +\n                    `but is not registered properly with ` +\n                    `tf.serialization.registerClass().`);\n                // TODO(cais): Add link to tutorial page on custom layers.\n            }\n        }\n        return fn;\n    }\n    else {\n        // In this case we are dealing with a Keras config dictionary.\n        const config = identifier;\n        if (config['className'] == null || config['config'] == null) {\n            throw new ValueError(`${printableModuleName}: Improper config format: ` +\n                `${JSON.stringify(config)}.\\n` +\n                `'className' and 'config' must set.`);\n        }\n        const className = config['className'];\n        let cls, fromConfig;\n        if (className in customObjects) {\n            [cls, fromConfig] = customObjects[className];\n        }\n        else if (className in _GLOBAL_CUSTOM_OBJECTS) {\n            [cls, fromConfig] = _GLOBAL_CUSTOM_OBJECTS['className'];\n        }\n        else if (className in moduleObjects) {\n            [cls, fromConfig] = moduleObjects[className];\n        }\n        if (cls == null) {\n            throw new ValueError(`Unknown ${printableModuleName}: ${className}. ` +\n                `This may be due to one of the following reasons:\\n` +\n                `1. The ${printableModuleName} is defined in Python, in which ` +\n                `case it needs to be ported to TensorFlow.js or your JavaScript ` +\n                `code.\\n` +\n                `2. The custom ${printableModuleName} is defined in JavaScript, ` +\n                `but is not registered properly with ` +\n                `tf.serialization.registerClass().`);\n            // TODO(cais): Add link to tutorial page on custom layers.\n        }\n        if (fromConfig != null) {\n            // Porting notes: Instead of checking to see whether fromConfig accepts\n            // customObjects, we create a customObjects dictionary and tack it on to\n            // config['config'] as config['config'].customObjects. Objects can use it,\n            // if they want.\n            // tslint:disable-next-line:no-any\n            const customObjectsCombined = {};\n            for (const key of Object.keys(_GLOBAL_CUSTOM_OBJECTS)) {\n                customObjectsCombined[key] = _GLOBAL_CUSTOM_OBJECTS[key];\n            }\n            for (const key of Object.keys(customObjects)) {\n                customObjectsCombined[key] = customObjects[key];\n            }\n            // Add the customObjects to config\n            const nestedConfig = config['config'];\n            nestedConfig['customObjects'] = customObjectsCombined;\n            const backupCustomObjects = Object.assign({}, _GLOBAL_CUSTOM_OBJECTS);\n            for (const key of Object.keys(customObjects)) {\n                _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];\n            }\n            convertNDArrayScalarsInConfig(config['config']);\n            const returnObj = fromConfig(cls, config['config'], customObjects, fastWeightInit);\n            _GLOBAL_CUSTOM_OBJECTS = Object.assign({}, backupCustomObjects);\n            return returnObj;\n        }\n        else {\n            // Then `cls` may be a function returning a class.\n            // In this case by convention `config` holds\n            // the kwargs of the function.\n            const backupCustomObjects = Object.assign({}, _GLOBAL_CUSTOM_OBJECTS);\n            for (const key of Object.keys(customObjects)) {\n                _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];\n            }\n            // In python this is **config['config'], for tfjs-layers we require\n            // classes that use this fall-through construction method to take\n            // a config interface that mimics the expansion of named parameters.\n            const returnObj = new cls(config['config']);\n            _GLOBAL_CUSTOM_OBJECTS = Object.assign({}, backupCustomObjects);\n            return returnObj;\n        }\n    }\n}\n/**\n * Compares two numbers for sorting.\n * @param a\n * @param b\n */\nexport function numberCompare(a, b) {\n    return (a < b) ? -1 : ((a > b) ? 1 : 0);\n}\n/**\n * Comparison of two numbers for reverse sorting.\n * @param a\n * @param b\n */\nexport function reverseNumberCompare(a, b) {\n    return -1 * numberCompare(a, b);\n}\n/**\n * Convert a string into the corresponding DType.\n * @param dtype\n * @returns An instance of DType.\n */\nexport function stringToDType(dtype) {\n    switch (dtype) {\n        case 'float32':\n            return 'float32';\n        default:\n            throw new ValueError(`Invalid dtype: ${dtype}`);\n    }\n}\n/**\n * Test the element-by-element equality of two Arrays of strings.\n * @param xs First array of strings.\n * @param ys Second array of strings.\n * @returns Wether the two arrays are all equal, element by element.\n */\nexport function stringsEqual(xs, ys) {\n    if (xs == null || ys == null) {\n        return xs === ys;\n    }\n    if (xs.length !== ys.length) {\n        return false;\n    }\n    for (let i = 0; i < xs.length; ++i) {\n        if (xs[i] !== ys[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Get the unique elements of an array.\n * @param xs Array.\n * @returns An Array consisting of the unique elements in `xs`.\n */\nexport function unique(xs) {\n    if (xs == null) {\n        return xs;\n    }\n    const out = [];\n    // TODO(cais): Maybe improve performance by sorting.\n    for (const x of xs) {\n        if (out.indexOf(x) === -1) {\n            out.push(x);\n        }\n    }\n    return out;\n}\n/**\n * Determine if an Object is empty (i.e., does not have own properties).\n * @param obj Object\n * @returns Whether the Object is empty.\n * @throws ValueError: If object is `null` or `undefined`.\n */\nexport function isObjectEmpty(obj) {\n    if (obj == null) {\n        throw new ValueError(`Invalid value in obj: ${JSON.stringify(obj)}`);\n    }\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Helper function used to build type union/enum run-time checkers.\n * @param values The list of allowed values.\n * @param label A string name for the type\n * @param value The value to test.\n * @throws ValueError: If the value is not in values nor `undefined`/`null`.\n */\nexport function checkStringTypeUnionValue(values, label, value) {\n    if (value == null) {\n        return;\n    }\n    if (values.indexOf(value) < 0) {\n        throw new ValueError(`${value} is not a valid ${label}.  Valid values are ${values} or null/undefined.`);\n    }\n}\n/**\n * Helper function for verifying the types of inputs.\n *\n * Ensures that the elements of `x` are all of type `expectedType`.\n * Also verifies that the length of `x` is within bounds.\n *\n * @param x Object to test.\n * @param expectedType The string expected type of all of the elements in the\n * Array.\n * @param minLength Return false if x.length is less than this.\n * @param maxLength Return false if x.length is greater than this.\n * @returns true if and only if `x` is an `Array<expectedType>` with\n * length >= `minLength` and <= `maxLength`.\n */\n// tslint:disable:no-any\nexport function checkArrayTypeAndLength(x, expectedType, minLength = 0, maxLength = Infinity) {\n    assert(minLength >= 0);\n    assert(maxLength >= minLength);\n    return (Array.isArray(x) && x.length >= minLength && x.length <= maxLength &&\n        x.every(e => typeof e === expectedType));\n}\n// tslint:enable:no-any\n/**\n * Assert that a value or an array of value are positive integer.\n *\n * @param value The value being asserted on. May be a single number or an array\n *   of numbers.\n * @param name Name of the value, used to make the error message.\n */\nexport function assertPositiveInteger(value, name) {\n    if (Array.isArray(value)) {\n        util.assert(value.length > 0, () => `${name} is unexpectedly an empty array.`);\n        value.forEach((v, i) => assertPositiveInteger(v, `element ${i + 1} of ${name}`));\n    }\n    else {\n        util.assert(Number.isInteger(value) && value > 0, () => `Expected ${name} to be a positive integer, but got ` +\n            `${formatAsFriendlyString(value)}.`);\n    }\n}\n/**\n * Format a value into a display-friendly, human-readable fashion.\n *\n * - `null` is formatted as `'null'`\n * - Strings are formated with flanking pair of quotes.\n * - Arrays are formatted with flanking pair of square brackets.\n *\n * @param value The value to display.\n * @return Formatted string.\n */\n// tslint:disable-next-line:no-any\nexport function formatAsFriendlyString(value) {\n    if (value === null) {\n        return 'null';\n    }\n    else if (Array.isArray(value)) {\n        return '[' + value.map(v => formatAsFriendlyString(v)).join(',') + ']';\n    }\n    else if (typeof value === 'string') {\n        return `\"${value}\"`;\n    }\n    else {\n        return `${value}`;\n    }\n}\n/**\n * Returns a function `f2` (decorator) which wraps the original function\n * `f`. `f2` guarantees that `f` can be called at most once\n * every `waitMs` ms. If `f2` is called more often, it will return\n * the last returned result of `f`.\n *\n * @param f The original function `f` to wrap.\n * @param waitMs The time between two consecutive calls to `f` in ms.\n */\nexport function debounce(f, waitMs, nowFunc) {\n    let lastTime = nowFunc != null ? nowFunc() : util.now();\n    let lastResult;\n    const f2 = (...args) => {\n        const now = nowFunc != null ? nowFunc() : util.now();\n        if (now - lastTime < waitMs) {\n            return lastResult;\n        }\n        lastTime = now;\n        lastResult = f(...args);\n        return lastResult;\n    };\n    return f2;\n}\n/**\n * Returns the fusable activation given a layers identifier.\n *\n * @param activationName The layers identifier string.\n * @return The name of the fusable activation.\n */\nexport function mapActivationToFusedKernel(activationName) {\n    if (activationName === 'relu') {\n        return 'relu';\n    }\n    if (activationName === 'linear') {\n        return 'linear';\n    }\n    if (activationName === 'elu') {\n        return 'elu';\n    }\n    return null;\n}\n/**\n * Returns the cartesian product of sets of values.\n * This works the same as itertools.product in Python.\n *\n * Example:\n *\n * filters = [128, 256, 512]\n * paddings = ['same', 'valid']\n *\n * product = [ [128, 'same'], [128, 'valid'], [256, 'same'], [256, 'valid'],\n * [512, 'same'], [512, 'valid']]\n *\n * @param arrayOfValues List/array of values.\n * @return The cartesian product.\n */\nexport function getCartesianProductOfValues(...arrayOfValues) {\n    assert(arrayOfValues.length > 0, 'arrayOfValues is empty');\n    for (const values of arrayOfValues) {\n        assert(Array.isArray(values), 'one of the values is not an array');\n        assert(values.length > 0, 'one of the values is empty');\n    }\n    return arrayOfValues.reduce((products, values) => {\n        if (products.length === 0) {\n            return values.map(value => [value]);\n        }\n        return values\n            .map(value => {\n            return products.map((prevValue) => [...prevValue, value]);\n        })\n            .reduce((flattenedProduct, unflattenedProduct) => {\n            return flattenedProduct.concat(unflattenedProduct);\n        }, []);\n    }, []);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJpY191dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy91dGlscy9nZW5lcmljX3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsNkNBQTZDO0FBRTdDLE9BQU8sRUFBaUMsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFM0UsT0FBTyxFQUFDLGNBQWMsRUFBRSxVQUFVLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFFckQsZ0JBQWdCO0FBRWhCOzs7R0FHRztBQUNILGtDQUFrQztBQUNsQyxNQUFNLFVBQVUsWUFBWSxDQUFDLEtBQVUsRUFBRSxTQUFpQjtJQUN4RCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDeEIsa0NBQWtDO1FBQ2xDLElBQUksUUFBUSxHQUFVLEVBQUUsQ0FBQztRQUN6QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2xDLFFBQVEsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ25DO1FBQ0QsT0FBTyxRQUFRLENBQUM7S0FDakI7U0FBTTtRQUNMLE1BQU0sUUFBUSxHQUFHLElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3RDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckIsT0FBTyxRQUFRLENBQUM7S0FDakI7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVLE1BQU0sQ0FBQyxHQUFZLEVBQUUsT0FBZ0I7SUFDbkQsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNSLE1BQU0sSUFBSSxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDbkM7QUFDSCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLFVBQVUsS0FBSyxDQUFJLEtBQVUsRUFBRSxR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QyxDQUFDO1NBQ3JDO1FBRUQsT0FBTyxNQUFNO2FBQ1IsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ1gsT0FBTyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDNUQsQ0FBQyxDQUFDO2FBQ0QsTUFBTSxDQUFDLENBQUMsZ0JBQWdCLEVBQUUsa0JBQWtCLEVBQUUsRUFBRTtZQUMvQyxPQUFPLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQ3JELENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNiLENBQUMsRUFBRSxFQUFvQixDQUFDLENBQUM7QUFDM0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qIE9yaWdpbmFsIHNvdXJjZTogdXRpbHMvZ2VuZXJpY191dGlscy5weSAqL1xuXG5pbXBvcnQge0RhdGFUeXBlLCBmdXNlZCwgc2VyaWFsaXphdGlvbiwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtBc3NlcnRpb25FcnJvciwgVmFsdWVFcnJvcn0gZnJvbSAnLi4vZXJyb3JzJztcblxuLy8gdHNsaW50OmVuYWJsZVxuXG4vKipcbiAqIElmIGB2YWx1ZWAgaXMgYW4gQXJyYXksIGVxdWl2YWxlbnQgdG8gUHl0aG9uJ3MgYHZhbHVlICogbnVtVmFsdWVzYC5cbiAqIElmIGB2YWx1ZWAgaXMgbm90IGFuIEFycmF5LCBlcXVpdmFsZW50IHRvIFB5dGhvbidzIGBbdmFsdWVdICogbnVtVmFsdWVzYFxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG5leHBvcnQgZnVuY3Rpb24gcHlMaXN0UmVwZWF0KHZhbHVlOiBhbnksIG51bVZhbHVlczogbnVtYmVyKTogYW55W10ge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgbGV0IG5ld0FycmF5OiBhbnlbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmFsdWVzOyBpKyspIHtcbiAgICAgIG5ld0FycmF5ID0gbmV3QXJyYXkuY29uY2F0KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gbmV3IEFycmF5KG51bVZhbHVlcyk7XG4gICAgbmV3QXJyYXkuZmlsbCh2YWx1ZSk7XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodmFsOiBib29sZWFuLCBtZXNzYWdlPzogc3RyaW5nKTogdm9pZCB7XG4gIGlmICghdmFsKSB7XG4gICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiB0aGUgYGFycmF5YCB0aGF0IGFyZSBlcXVhbCB0byBgcmVmZXJlbmNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvdW50PFQ+KGFycmF5OiBUW10sIHJlZmVybmNlOiBUKSB7XG4gIGxldCBjb3VudGVyID0gMDtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGFycmF5KSB7XG4gICAgaWYgKGl0ZW0gPT09IHJlZmVybmNlKSB7XG4gICAgICBjb3VudGVyKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudGVyO1xufVxuXG4vKipcbiAqIElmIGFuIGFycmF5IGlzIG9mIGxlbmd0aCAxLCBqdXN0IHJldHVybiB0aGUgZmlyc3QgZWxlbWVudC4gT3RoZXJ3aXNlLCByZXR1cm5cbiAqIHRoZSBmdWxsIGFycmF5LlxuICogQHBhcmFtIHRlbnNvcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpbmdsZXRvbk9yQXJyYXk8VD4oeHM6IFRbXSk6IFR8VFtdIHtcbiAgaWYgKHhzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB4c1swXTtcbiAgfVxuICByZXR1cm4geHM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIGxpc3QvdGVuc29yIGludG8gYSBsaXN0LlxuICpcbiAqIElmIGEgdGVuc29yIGlzIHBhc3NlZCwgd2UgcmV0dXJuXG4gKiBhIGxpc3Qgb2Ygc2l6ZSAxIGNvbnRhaW5pbmcgdGhlIHRlbnNvci5cbiAqXG4gKiBAcGFyYW0geCB0YXJnZXQgb2JqZWN0IHRvIGJlIG5vcm1hbGl6ZWQuXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbmV4cG9ydCBmdW5jdGlvbiB0b0xpc3Q8VD4oeDogVHxUW10pOiBUW10ge1xuICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgIHJldHVybiB4O1xuICB9XG4gIHJldHVybiBbeF07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBVSUQgZm9yIGEgbGlzdFxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0TGlzdFVpZChvYmpzOiBhbnl8YW55W10pOiBzdHJpbmcge1xuICBjb25zdCBvYmplY3RMaXN0ID0gdG9MaXN0KG9ianMpO1xuICBsZXQgcmV0VmFsID0gJyc7XG4gIGZvciAoY29uc3Qgb2JqIG9mIG9iamVjdExpc3QpIHtcbiAgICBpZiAob2JqLmlkID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBPYmplY3QgJHtvYmp9IHBhc3NlZCB0byBvYmplY3RMaXN0VWlkIHdpdGhvdXQgYW4gaWRgKTtcbiAgICB9XG4gICAgaWYgKHJldFZhbCAhPT0gJycpIHtcbiAgICAgIHJldFZhbCA9IHJldFZhbCArICcsICc7XG4gICAgfVxuICAgIHJldFZhbCA9IGAke3JldFZhbH0ke01hdGguYWJzKG9iai5pZCl9YDtcbiAgfVxuICByZXR1cm4gcmV0VmFsO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8gc25ha2UtY2FzZS5cbiAqIEBwYXJhbSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1NuYWtlQ2FzZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBpbnRlcm1lZGlhdGUgPSBuYW1lLnJlcGxhY2UoLyguKShbQS1aXVthLXowLTldKykvZywgJyQxXyQyJyk7XG4gIGNvbnN0IGluc2VjdXJlID1cbiAgICAgIGludGVybWVkaWF0ZS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDFfJDInKS50b0xvd2VyQ2FzZSgpO1xuICAvKlxuICAgSWYgdGhlIGNsYXNzIGlzIHByaXZhdGUgdGhlIG5hbWUgc3RhcnRzIHdpdGggXCJfXCIgd2hpY2ggaXMgbm90IHNlY3VyZVxuICAgZm9yIGNyZWF0aW5nIHNjb3Blcy4gV2UgcHJlZml4IHRoZSBuYW1lIHdpdGggXCJwcml2YXRlXCIgaW4gdGhpcyBjYXNlLlxuICAgKi9cbiAgaWYgKGluc2VjdXJlWzBdICE9PSAnXycpIHtcbiAgICByZXR1cm4gaW5zZWN1cmU7XG4gIH1cbiAgcmV0dXJuICdwcml2YXRlJyArIGluc2VjdXJlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9DYW1lbENhc2UoaWRlbnRpZmllcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gcXVpY2sgcmV0dXJuIGZvciBlbXB0eSBzdHJpbmcgb3Igc2luZ2xlIGNoYXJhY3RlciBzdHJpbmdzXG4gIGlmIChpZGVudGlmaWVyLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIHRoZSB1bmRlcnNjb3JlIGluZGljYXRpbmcgc25ha2VfY2FzZVxuICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCdfJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXIucmVwbGFjZSgvW19dKyhcXHd8JCkvZywgKG0sIHAxKSA9PiBwMS50b1VwcGVyQ2FzZSgpKTtcbn1cblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxubGV0IF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMgPSB7fSBhcyB7W29iak5hbWU6IHN0cmluZ106IGFueX07XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVLZXJhc09iamVjdChpbnN0YW5jZTogc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUpOlxuICAgIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdFZhbHVlIHtcbiAgaWYgKGluc3RhbmNlID09PSBudWxsIHx8IGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkaWN0OiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3RWYWx1ZSA9IHt9O1xuICBkaWN0WydjbGFzc05hbWUnXSA9IGluc3RhbmNlLmdldENsYXNzTmFtZSgpO1xuICBkaWN0Wydjb25maWcnXSA9IGluc3RhbmNlLmdldENvbmZpZygpO1xuICByZXR1cm4gZGljdDtcbn1cblxuLyoqXG4gKiBSZXBsYWNlIG5kYXJyYXktc3R5bGUgc2NhbGFyIG9iamVjdHMgaW4gc2VyaWFsaXphdGlvbiBvYmplY3RzIHdpdGggbnVtYmVycy5cbiAqXG4gKiBCYWNrZ3JvdW5kOiBJbiBzb21lIHZlcnNpb25zIG9mIHRmLmtlcmFzLCBjZXJ0YWluIHNjYWxhciB2YWx1ZXMgaW4gdGhlIEhERjVcbiAqIG1vZGVsIHNhdmUgZmlsZSBjYW4gYmUgc2VyaWFsaXplZCBhczogYHsndHlwZSc6ICduZGFycmF5JywgJ3ZhbHVlJzogbnVtfWAsXG4gKiB3aGVyZSBpbiBgbnVtYCBpcyBhIHBsYWluIG51bWJlci4gVGhpcyBtZXRob2QgY29udmVydHMgc3VjaCBzZXJpYWxpemF0aW9uXG4gKiB0byBhIGBudW1iZXJgLlxuICpcbiAqIEBwYXJhbSBjb25maWcgVGhlIGtlcmFzLWZvcm1hdCBzZXJpYWxpemF0aW9uIG9iamVjdCB0byBiZSBwcm9jZXNzZWRcbiAqICAgKGluIHBsYWNlKS5cbiAqL1xuZnVuY3Rpb24gY29udmVydE5EQXJyYXlTY2FsYXJzSW5Db25maWcoY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3RWYWx1ZSk6XG4gICAgdm9pZCB7XG4gIGlmIChjb25maWcgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICBjb25maWcuZm9yRWFjaChjb25maWdJdGVtID0+IGNvbnZlcnROREFycmF5U2NhbGFyc0luQ29uZmlnKGNvbmZpZ0l0ZW0pKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmaWVsZHMgPSBPYmplY3Qua2V5cyhjb25maWcpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZ1tmaWVsZF07XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWVbJ3R5cGUnXSA9PT0gJ25kYXJyYXknICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWVbJ3ZhbHVlJ10gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29uZmlnW2ZpZWxkXSA9IHZhbHVlWyd2YWx1ZSddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnZlcnROREFycmF5U2NhbGFyc0luQ29uZmlnKHZhbHVlIGFzIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZXNlcmlhbGl6ZSBhIHNhdmVkIEtlcmFzIE9iamVjdFxuICogQHBhcmFtIGlkZW50aWZpZXIgZWl0aGVyIGEgc3RyaW5nIElEIG9yIGEgc2F2ZWQgS2VyYXMgZGljdGlvbmFyeVxuICogQHBhcmFtIG1vZHVsZU9iamVjdHMgYSBsaXN0IG9mIFB5dGhvbiBjbGFzcyBuYW1lcyB0byBvYmplY3QgY29uc3RydWN0b3JzXG4gKiBAcGFyYW0gY3VzdG9tT2JqZWN0cyBhIGxpc3Qgb2YgUHl0aG9uIGNsYXNzIG5hbWVzIHRvIG9iamVjdCBjb25zdHJ1Y3RvcnNcbiAqIEBwYXJhbSBwcmludGFibGVNb2R1bGVOYW1lIGRlYnVnIHRleHQgZm9yIHRoZSBvYmplY3QgYmVpbmcgcmVjb25zdGl0dXRlZFxuICogQHBhcmFtIGZhc3RXZWlnaHRJbml0IE9wdGlvbmFsIGZsYWcgdG8gdXNlIGZhc3Qgd2VpZ2h0IGluaXRpYWxpemF0aW9uXG4gKiAgIGR1cmluZyBkZXNlcmlhbGl6YXRpb24uIFRoaXMgaXMgYXBwbGljYWJsZSB0byBjYXNlcyBpbiB3aGljaFxuICogICB0aGUgaW5pdGlhbGl6YXRpb24gd2lsbCBiZSBpbW1lZGlhdGVseSBvdmVyd3JpdHRlbiBieSBsb2FkZWQgd2VpZ2h0XG4gKiAgIHZhbHVlcy4gRGVmYXVsdDogYGZhbHNlYC5cbiAqIEByZXR1cm5zIGEgVGVuc29yRmxvdy5qcyBMYXllcnMgb2JqZWN0XG4gKi9cbi8vIHRzbGludDpkaXNhYmxlOm5vLWFueVxuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplS2VyYXNPYmplY3QoXG4gICAgaWRlbnRpZmllcjogc3RyaW5nfHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCxcbiAgICBtb2R1bGVPYmplY3RzID0ge30gYXMge1tvYmpOYW1lOiBzdHJpbmddOiBhbnl9LFxuICAgIGN1c3RvbU9iamVjdHMgPSB7fSBhcyB7W29iak5hbWU6IHN0cmluZ106IGFueX0sXG4gICAgcHJpbnRhYmxlTW9kdWxlTmFtZSA9ICdvYmplY3QnLCBmYXN0V2VpZ2h0SW5pdCA9IGZhbHNlKTogYW55IHtcbiAgLy8gdHNsaW50OmVuYWJsZVxuICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gaWRlbnRpZmllcjtcbiAgICBsZXQgZm47XG4gICAgaWYgKGZ1bmN0aW9uTmFtZSBpbiBjdXN0b21PYmplY3RzKSB7XG4gICAgICBmbiA9IGN1c3RvbU9iamVjdHNbZnVuY3Rpb25OYW1lXTtcbiAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uTmFtZSBpbiBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKSB7XG4gICAgICBmbiA9IF9HTE9CQUxfQ1VTVE9NX09CSkVDVFNbZnVuY3Rpb25OYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4gPSBtb2R1bGVPYmplY3RzW2Z1bmN0aW9uTmFtZV07XG4gICAgICBpZiAoZm4gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBVbmtub3duICR7cHJpbnRhYmxlTW9kdWxlTmFtZX06ICR7aWRlbnRpZmllcn0uIGAgK1xuICAgICAgICAgICAgYFRoaXMgbWF5IGJlIGR1ZSB0byBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbmAgK1xuICAgICAgICAgICAgYDEuIFRoZSAke3ByaW50YWJsZU1vZHVsZU5hbWV9IGlzIGRlZmluZWQgaW4gUHl0aG9uLCBpbiB3aGljaCBgICtcbiAgICAgICAgICAgIGBjYXNlIGl0IG5lZWRzIHRvIGJlIHBvcnRlZCB0byBUZW5zb3JGbG93LmpzIG9yIHlvdXIgSmF2YVNjcmlwdCBgICtcbiAgICAgICAgICAgIGBjb2RlLlxcbmAgK1xuICAgICAgICAgICAgYDIuIFRoZSBjdXN0b20gJHtwcmludGFibGVNb2R1bGVOYW1lfSBpcyBkZWZpbmVkIGluIEphdmFTY3JpcHQsIGAgK1xuICAgICAgICAgICAgYGJ1dCBpcyBub3QgcmVnaXN0ZXJlZCBwcm9wZXJseSB3aXRoIGAgK1xuICAgICAgICAgICAgYHRmLnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcygpLmApO1xuICAgICAgICAvLyBUT0RPKGNhaXMpOiBBZGQgbGluayB0byB0dXRvcmlhbCBwYWdlIG9uIGN1c3RvbSBsYXllcnMuXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiB0aGlzIGNhc2Ugd2UgYXJlIGRlYWxpbmcgd2l0aCBhIEtlcmFzIGNvbmZpZyBkaWN0aW9uYXJ5LlxuICAgIGNvbnN0IGNvbmZpZyA9IGlkZW50aWZpZXI7XG4gICAgaWYgKGNvbmZpZ1snY2xhc3NOYW1lJ10gPT0gbnVsbCB8fCBjb25maWdbJ2NvbmZpZyddID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGAke3ByaW50YWJsZU1vZHVsZU5hbWV9OiBJbXByb3BlciBjb25maWcgZm9ybWF0OiBgICtcbiAgICAgICAgICBgJHtKU09OLnN0cmluZ2lmeShjb25maWcpfS5cXG5gICtcbiAgICAgICAgICBgJ2NsYXNzTmFtZScgYW5kICdjb25maWcnIG11c3Qgc2V0LmApO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc05hbWUgPSBjb25maWdbJ2NsYXNzTmFtZSddIGFzIHN0cmluZztcbiAgICBsZXQgY2xzLCBmcm9tQ29uZmlnO1xuICAgIGlmIChjbGFzc05hbWUgaW4gY3VzdG9tT2JqZWN0cykge1xuICAgICAgW2NscywgZnJvbUNvbmZpZ10gPSBjdXN0b21PYmplY3RzW2NsYXNzTmFtZV07XG4gICAgfSBlbHNlIGlmIChjbGFzc05hbWUgaW4gX0dMT0JBTF9DVVNUT01fT0JKRUNUUykge1xuICAgICAgW2NscywgZnJvbUNvbmZpZ10gPSBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTWydjbGFzc05hbWUnXTtcbiAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSBpbiBtb2R1bGVPYmplY3RzKSB7XG4gICAgICBbY2xzLCBmcm9tQ29uZmlnXSA9IG1vZHVsZU9iamVjdHNbY2xhc3NOYW1lXTtcbiAgICB9XG4gICAgaWYgKGNscyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgVW5rbm93biAke3ByaW50YWJsZU1vZHVsZU5hbWV9OiAke2NsYXNzTmFtZX0uIGAgK1xuICAgICAgICAgIGBUaGlzIG1heSBiZSBkdWUgdG8gb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG5gICtcbiAgICAgICAgICBgMS4gVGhlICR7cHJpbnRhYmxlTW9kdWxlTmFtZX0gaXMgZGVmaW5lZCBpbiBQeXRob24sIGluIHdoaWNoIGAgK1xuICAgICAgICAgIGBjYXNlIGl0IG5lZWRzIHRvIGJlIHBvcnRlZCB0byBUZW5zb3JGbG93LmpzIG9yIHlvdXIgSmF2YVNjcmlwdCBgICtcbiAgICAgICAgICBgY29kZS5cXG5gICtcbiAgICAgICAgICBgMi4gVGhlIGN1c3RvbSAke3ByaW50YWJsZU1vZHVsZU5hbWV9IGlzIGRlZmluZWQgaW4gSmF2YVNjcmlwdCwgYCArXG4gICAgICAgICAgYGJ1dCBpcyBub3QgcmVnaXN0ZXJlZCBwcm9wZXJseSB3aXRoIGAgK1xuICAgICAgICAgIGB0Zi5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoKS5gKTtcbiAgICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCBsaW5rIHRvIHR1dG9yaWFsIHBhZ2Ugb24gY3VzdG9tIGxheWVycy5cbiAgICB9XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgLy8gUG9ydGluZyBub3RlczogSW5zdGVhZCBvZiBjaGVja2luZyB0byBzZWUgd2hldGhlciBmcm9tQ29uZmlnIGFjY2VwdHNcbiAgICAgIC8vIGN1c3RvbU9iamVjdHMsIHdlIGNyZWF0ZSBhIGN1c3RvbU9iamVjdHMgZGljdGlvbmFyeSBhbmQgdGFjayBpdCBvbiB0b1xuICAgICAgLy8gY29uZmlnWydjb25maWcnXSBhcyBjb25maWdbJ2NvbmZpZyddLmN1c3RvbU9iamVjdHMuIE9iamVjdHMgY2FuIHVzZSBpdCxcbiAgICAgIC8vIGlmIHRoZXkgd2FudC5cblxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgY29uc3QgY3VzdG9tT2JqZWN0c0NvbWJpbmVkID0ge30gYXMge1tvYmpOYW1lOiBzdHJpbmddOiBhbnl9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoX0dMT0JBTF9DVVNUT01fT0JKRUNUUykpIHtcbiAgICAgICAgY3VzdG9tT2JqZWN0c0NvbWJpbmVkW2tleV0gPSBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTW2tleV07XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjdXN0b21PYmplY3RzKSkge1xuICAgICAgICBjdXN0b21PYmplY3RzQ29tYmluZWRba2V5XSA9IGN1c3RvbU9iamVjdHNba2V5XTtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCB0aGUgY3VzdG9tT2JqZWN0cyB0byBjb25maWdcbiAgICAgIGNvbnN0IG5lc3RlZENvbmZpZyA9IGNvbmZpZ1snY29uZmlnJ10gYXMgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0O1xuICAgICAgbmVzdGVkQ29uZmlnWydjdXN0b21PYmplY3RzJ10gPSBjdXN0b21PYmplY3RzQ29tYmluZWQ7XG5cbiAgICAgIGNvbnN0IGJhY2t1cEN1c3RvbU9iamVjdHMgPSB7Li4uX0dMT0JBTF9DVVNUT01fT0JKRUNUU307XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjdXN0b21PYmplY3RzKSkge1xuICAgICAgICBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTW2tleV0gPSBjdXN0b21PYmplY3RzW2tleV07XG4gICAgICB9XG4gICAgICBjb252ZXJ0TkRBcnJheVNjYWxhcnNJbkNvbmZpZyhjb25maWdbJ2NvbmZpZyddKTtcbiAgICAgIGNvbnN0IHJldHVybk9iaiA9XG4gICAgICAgICAgZnJvbUNvbmZpZyhjbHMsIGNvbmZpZ1snY29uZmlnJ10sIGN1c3RvbU9iamVjdHMsIGZhc3RXZWlnaHRJbml0KTtcbiAgICAgIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMgPSB7Li4uYmFja3VwQ3VzdG9tT2JqZWN0c307XG5cbiAgICAgIHJldHVybiByZXR1cm5PYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZW4gYGNsc2AgbWF5IGJlIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgY2xhc3MuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UgYnkgY29udmVudGlvbiBgY29uZmlnYCBob2xkc1xuICAgICAgLy8gdGhlIGt3YXJncyBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICBjb25zdCBiYWNrdXBDdXN0b21PYmplY3RzID0gey4uLl9HTE9CQUxfQ1VTVE9NX09CSkVDVFN9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY3VzdG9tT2JqZWN0cykpIHtcbiAgICAgICAgX0dMT0JBTF9DVVNUT01fT0JKRUNUU1trZXldID0gY3VzdG9tT2JqZWN0c1trZXldO1xuICAgICAgfVxuICAgICAgLy8gSW4gcHl0aG9uIHRoaXMgaXMgKipjb25maWdbJ2NvbmZpZyddLCBmb3IgdGZqcy1sYXllcnMgd2UgcmVxdWlyZVxuICAgICAgLy8gY2xhc3NlcyB0aGF0IHVzZSB0aGlzIGZhbGwtdGhyb3VnaCBjb25zdHJ1Y3Rpb24gbWV0aG9kIHRvIHRha2VcbiAgICAgIC8vIGEgY29uZmlnIGludGVyZmFjZSB0aGF0IG1pbWljcyB0aGUgZXhwYW5zaW9uIG9mIG5hbWVkIHBhcmFtZXRlcnMuXG4gICAgICBjb25zdCByZXR1cm5PYmogPSBuZXcgY2xzKGNvbmZpZ1snY29uZmlnJ10pO1xuICAgICAgX0dMT0JBTF9DVVNUT01fT0JKRUNUUyA9IHsuLi5iYWNrdXBDdXN0b21PYmplY3RzfTtcbiAgICAgIHJldHVybiByZXR1cm5PYmo7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIG51bWJlcnMgZm9yIHNvcnRpbmcuXG4gKiBAcGFyYW0gYVxuICogQHBhcmFtIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlckNvbXBhcmUoYTogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgcmV0dXJuIChhIDwgYikgPyAtMSA6ICgoYSA+IGIpID8gMSA6IDApO1xufVxuXG4vKipcbiAqIENvbXBhcmlzb24gb2YgdHdvIG51bWJlcnMgZm9yIHJldmVyc2Ugc29ydGluZy5cbiAqIEBwYXJhbSBhXG4gKiBAcGFyYW0gYlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZU51bWJlckNvbXBhcmUoYTogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgcmV0dXJuIC0xICogbnVtYmVyQ29tcGFyZShhLCBiKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgRFR5cGUuXG4gKiBAcGFyYW0gZHR5cGVcbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIERUeXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9EVHlwZShkdHlwZTogc3RyaW5nKTogRGF0YVR5cGUge1xuICBzd2l0Y2ggKGR0eXBlKSB7XG4gICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICByZXR1cm4gJ2Zsb2F0MzInO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgSW52YWxpZCBkdHlwZTogJHtkdHlwZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFRlc3QgdGhlIGVsZW1lbnQtYnktZWxlbWVudCBlcXVhbGl0eSBvZiB0d28gQXJyYXlzIG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0geHMgRmlyc3QgYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSB5cyBTZWNvbmQgYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEByZXR1cm5zIFdldGhlciB0aGUgdHdvIGFycmF5cyBhcmUgYWxsIGVxdWFsLCBlbGVtZW50IGJ5IGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdzRXF1YWwoeHM6IHN0cmluZ1tdLCB5czogc3RyaW5nW10pOiBib29sZWFuIHtcbiAgaWYgKHhzID09IG51bGwgfHwgeXMgPT0gbnVsbCkge1xuICAgIHJldHVybiB4cyA9PT0geXM7XG4gIH1cbiAgaWYgKHhzLmxlbmd0aCAhPT0geXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoeHNbaV0gIT09IHlzW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdW5pcXVlIGVsZW1lbnRzIG9mIGFuIGFycmF5LlxuICogQHBhcmFtIHhzIEFycmF5LlxuICogQHJldHVybnMgQW4gQXJyYXkgY29uc2lzdGluZyBvZiB0aGUgdW5pcXVlIGVsZW1lbnRzIGluIGB4c2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWU8VD4oeHM6IFRbXSk6IFRbXSB7XG4gIGlmICh4cyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHhzO1xuICB9XG4gIGNvbnN0IG91dDogVFtdID0gW107XG4gIC8vIFRPRE8oY2Fpcyk6IE1heWJlIGltcHJvdmUgcGVyZm9ybWFuY2UgYnkgc29ydGluZy5cbiAgZm9yIChjb25zdCB4IG9mIHhzKSB7XG4gICAgaWYgKG91dC5pbmRleE9mKHgpID09PSAtMSkge1xuICAgICAgb3V0LnB1c2goeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIE9iamVjdCBpcyBlbXB0eSAoaS5lLiwgZG9lcyBub3QgaGF2ZSBvd24gcHJvcGVydGllcykuXG4gKiBAcGFyYW0gb2JqIE9iamVjdFxuICogQHJldHVybnMgV2hldGhlciB0aGUgT2JqZWN0IGlzIGVtcHR5LlxuICogQHRocm93cyBWYWx1ZUVycm9yOiBJZiBvYmplY3QgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmo6IHt9KTogYm9vbGVhbiB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBJbnZhbGlkIHZhbHVlIGluIG9iajogJHtKU09OLnN0cmluZ2lmeShvYmopfWApO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0byBidWlsZCB0eXBlIHVuaW9uL2VudW0gcnVuLXRpbWUgY2hlY2tlcnMuXG4gKiBAcGFyYW0gdmFsdWVzIFRoZSBsaXN0IG9mIGFsbG93ZWQgdmFsdWVzLlxuICogQHBhcmFtIGxhYmVsIEEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAdGhyb3dzIFZhbHVlRXJyb3I6IElmIHRoZSB2YWx1ZSBpcyBub3QgaW4gdmFsdWVzIG5vciBgdW5kZWZpbmVkYC9gbnVsbGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFxuICAgIHZhbHVlczogc3RyaW5nW10sIGxhYmVsOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlcy5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgdmFsaWQgJHtsYWJlbH0uICBWYWxpZCB2YWx1ZXMgYXJlICR7XG4gICAgICAgIHZhbHVlc30gb3IgbnVsbC91bmRlZmluZWQuYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHZlcmlmeWluZyB0aGUgdHlwZXMgb2YgaW5wdXRzLlxuICpcbiAqIEVuc3VyZXMgdGhhdCB0aGUgZWxlbWVudHMgb2YgYHhgIGFyZSBhbGwgb2YgdHlwZSBgZXhwZWN0ZWRUeXBlYC5cbiAqIEFsc28gdmVyaWZpZXMgdGhhdCB0aGUgbGVuZ3RoIG9mIGB4YCBpcyB3aXRoaW4gYm91bmRzLlxuICpcbiAqIEBwYXJhbSB4IE9iamVjdCB0byB0ZXN0LlxuICogQHBhcmFtIGV4cGVjdGVkVHlwZSBUaGUgc3RyaW5nIGV4cGVjdGVkIHR5cGUgb2YgYWxsIG9mIHRoZSBlbGVtZW50cyBpbiB0aGVcbiAqIEFycmF5LlxuICogQHBhcmFtIG1pbkxlbmd0aCBSZXR1cm4gZmFsc2UgaWYgeC5sZW5ndGggaXMgbGVzcyB0aGFuIHRoaXMuXG4gKiBAcGFyYW0gbWF4TGVuZ3RoIFJldHVybiBmYWxzZSBpZiB4Lmxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhpcy5cbiAqIEByZXR1cm5zIHRydWUgaWYgYW5kIG9ubHkgaWYgYHhgIGlzIGFuIGBBcnJheTxleHBlY3RlZFR5cGU+YCB3aXRoXG4gKiBsZW5ndGggPj0gYG1pbkxlbmd0aGAgYW5kIDw9IGBtYXhMZW5ndGhgLlxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1hbnlcbmV4cG9ydCBmdW5jdGlvbiBjaGVja0FycmF5VHlwZUFuZExlbmd0aChcbiAgICB4OiBhbnksIGV4cGVjdGVkVHlwZTogc3RyaW5nLCBtaW5MZW5ndGggPSAwLFxuICAgIG1heExlbmd0aCA9IEluZmluaXR5KTogYm9vbGVhbiB7XG4gIGFzc2VydChtaW5MZW5ndGggPj0gMCk7XG4gIGFzc2VydChtYXhMZW5ndGggPj0gbWluTGVuZ3RoKTtcbiAgcmV0dXJuIChcbiAgICAgIEFycmF5LmlzQXJyYXkoeCkgJiYgeC5sZW5ndGggPj0gbWluTGVuZ3RoICYmIHgubGVuZ3RoIDw9IG1heExlbmd0aCAmJlxuICAgICAgeC5ldmVyeShlID0+IHR5cGVvZiBlID09PSBleHBlY3RlZFR5cGUpKTtcbn1cbi8vIHRzbGludDplbmFibGU6bm8tYW55XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBvciBhbiBhcnJheSBvZiB2YWx1ZSBhcmUgcG9zaXRpdmUgaW50ZWdlci5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIGJlaW5nIGFzc2VydGVkIG9uLiBNYXkgYmUgYSBzaW5nbGUgbnVtYmVyIG9yIGFuIGFycmF5XG4gKiAgIG9mIG51bWJlcnMuXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB2YWx1ZSwgdXNlZCB0byBtYWtlIHRoZSBlcnJvciBtZXNzYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKHZhbHVlOiBudW1iZXJ8bnVtYmVyW10sIG5hbWU6IHN0cmluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdmFsdWUubGVuZ3RoID4gMCwgKCkgPT4gYCR7bmFtZX0gaXMgdW5leHBlY3RlZGx5IGFuIGVtcHR5IGFycmF5LmApO1xuICAgIHZhbHVlLmZvckVhY2goXG4gICAgICAgICh2LCBpKSA9PiBhc3NlcnRQb3NpdGl2ZUludGVnZXIodiwgYGVsZW1lbnQgJHtpICsgMX0gb2YgJHtuYW1lfWApKTtcbiAgfSBlbHNlIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPiAwLFxuICAgICAgICAoKSA9PiBgRXhwZWN0ZWQgJHtuYW1lfSB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgYCArXG4gICAgICAgICAgICBgJHtmb3JtYXRBc0ZyaWVuZGx5U3RyaW5nKHZhbHVlKX0uYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3JtYXQgYSB2YWx1ZSBpbnRvIGEgZGlzcGxheS1mcmllbmRseSwgaHVtYW4tcmVhZGFibGUgZmFzaGlvbi5cbiAqXG4gKiAtIGBudWxsYCBpcyBmb3JtYXR0ZWQgYXMgYCdudWxsJ2BcbiAqIC0gU3RyaW5ncyBhcmUgZm9ybWF0ZWQgd2l0aCBmbGFua2luZyBwYWlyIG9mIHF1b3Rlcy5cbiAqIC0gQXJyYXlzIGFyZSBmb3JtYXR0ZWQgd2l0aCBmbGFua2luZyBwYWlyIG9mIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGRpc3BsYXkuXG4gKiBAcmV0dXJuIEZvcm1hdHRlZCBzdHJpbmcuXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBc0ZyaWVuZGx5U3RyaW5nKHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuICdbJyArIHZhbHVlLm1hcCh2ID0+IGZvcm1hdEFzRnJpZW5kbHlTdHJpbmcodikpLmpvaW4oJywnKSArICddJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGBmMmAgKGRlY29yYXRvcikgd2hpY2ggd3JhcHMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uXG4gKiBgZmAuIGBmMmAgZ3VhcmFudGVlcyB0aGF0IGBmYCBjYW4gYmUgY2FsbGVkIGF0IG1vc3Qgb25jZVxuICogZXZlcnkgYHdhaXRNc2AgbXMuIElmIGBmMmAgaXMgY2FsbGVkIG1vcmUgb2Z0ZW4sIGl0IHdpbGwgcmV0dXJuXG4gKiB0aGUgbGFzdCByZXR1cm5lZCByZXN1bHQgb2YgYGZgLlxuICpcbiAqIEBwYXJhbSBmIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiBgZmAgdG8gd3JhcC5cbiAqIEBwYXJhbSB3YWl0TXMgVGhlIHRpbWUgYmV0d2VlbiB0d28gY29uc2VjdXRpdmUgY2FsbHMgdG8gYGZgIGluIG1zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2U8VD4oXG4gICAgZjogKC4uLmFyZ3M6IEFycmF5PHt9PikgPT4gVCwgd2FpdE1zOiBudW1iZXIsXG4gICAgbm93RnVuYz86IEZ1bmN0aW9uKTogKC4uLmFyZ3M6IEFycmF5PHt9PikgPT4gVCB7XG4gIGxldCBsYXN0VGltZSA9IG5vd0Z1bmMgIT0gbnVsbCA/IG5vd0Z1bmMoKSA6IHV0aWwubm93KCk7XG4gIGxldCBsYXN0UmVzdWx0OiBUO1xuICBjb25zdCBmMiA9ICguLi5hcmdzOiBBcnJheTx7fT4pID0+IHtcbiAgICBjb25zdCBub3cgPSBub3dGdW5jICE9IG51bGwgPyBub3dGdW5jKCkgOiB1dGlsLm5vdygpO1xuICAgIGlmIChub3cgLSBsYXN0VGltZSA8IHdhaXRNcykge1xuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuICAgIGxhc3RUaW1lID0gbm93O1xuICAgIGxhc3RSZXN1bHQgPSBmKC4uLmFyZ3MpO1xuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9O1xuICByZXR1cm4gZjI7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnVzYWJsZSBhY3RpdmF0aW9uIGdpdmVuIGEgbGF5ZXJzIGlkZW50aWZpZXIuXG4gKlxuICogQHBhcmFtIGFjdGl2YXRpb25OYW1lIFRoZSBsYXllcnMgaWRlbnRpZmllciBzdHJpbmcuXG4gKiBAcmV0dXJuIFRoZSBuYW1lIG9mIHRoZSBmdXNhYmxlIGFjdGl2YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBBY3RpdmF0aW9uVG9GdXNlZEtlcm5lbChhY3RpdmF0aW9uTmFtZTogc3RyaW5nKTpcbiAgICBmdXNlZC5BY3RpdmF0aW9uIHtcbiAgaWYgKGFjdGl2YXRpb25OYW1lID09PSAncmVsdScpIHtcbiAgICByZXR1cm4gJ3JlbHUnO1xuICB9XG4gIGlmIChhY3RpdmF0aW9uTmFtZSA9PT0gJ2xpbmVhcicpIHtcbiAgICByZXR1cm4gJ2xpbmVhcic7XG4gIH1cbiAgaWYgKGFjdGl2YXRpb25OYW1lID09PSAnZWx1Jykge1xuICAgIHJldHVybiAnZWx1JztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxudHlwZSBQb3NzaWJsZVZhbHVlcyA9IEFycmF5PEFycmF5PGJvb2xlYW58c3RyaW5nfG51bWJlcj4+O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNhcnRlc2lhbiBwcm9kdWN0IG9mIHNldHMgb2YgdmFsdWVzLlxuICogVGhpcyB3b3JrcyB0aGUgc2FtZSBhcyBpdGVydG9vbHMucHJvZHVjdCBpbiBQeXRob24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBmaWx0ZXJzID0gWzEyOCwgMjU2LCA1MTJdXG4gKiBwYWRkaW5ncyA9IFsnc2FtZScsICd2YWxpZCddXG4gKlxuICogcHJvZHVjdCA9IFsgWzEyOCwgJ3NhbWUnXSwgWzEyOCwgJ3ZhbGlkJ10sIFsyNTYsICdzYW1lJ10sIFsyNTYsICd2YWxpZCddLFxuICogWzUxMiwgJ3NhbWUnXSwgWzUxMiwgJ3ZhbGlkJ11dXG4gKlxuICogQHBhcmFtIGFycmF5T2ZWYWx1ZXMgTGlzdC9hcnJheSBvZiB2YWx1ZXMuXG4gKiBAcmV0dXJuIFRoZSBjYXJ0ZXNpYW4gcHJvZHVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENhcnRlc2lhblByb2R1Y3RPZlZhbHVlcyguLi5hcnJheU9mVmFsdWVzOiBQb3NzaWJsZVZhbHVlcyk6XG4gICAgUG9zc2libGVWYWx1ZXMge1xuICBhc3NlcnQoYXJyYXlPZlZhbHVlcy5sZW5ndGggPiAwLCAnYXJyYXlPZlZhbHVlcyBpcyBlbXB0eScpO1xuXG4gIGZvciAoY29uc3QgdmFsdWVzIG9mIGFycmF5T2ZWYWx1ZXMpIHtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZXMpLCAnb25lIG9mIHRoZSB2YWx1ZXMgaXMgbm90IGFuIGFycmF5Jyk7XG4gICAgYXNzZXJ0KHZhbHVlcy5sZW5ndGggPiAwLCAnb25lIG9mIHRoZSB2YWx1ZXMgaXMgZW1wdHknKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheU9mVmFsdWVzLnJlZHVjZSgocHJvZHVjdHMsIHZhbHVlcykgPT4ge1xuICAgIGlmIChwcm9kdWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB2YWx1ZXMubWFwKHZhbHVlID0+IFt2YWx1ZV0pO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgLm1hcCh2YWx1ZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHByb2R1Y3RzLm1hcCgocHJldlZhbHVlKSA9PiBbLi4ucHJldlZhbHVlLCB2YWx1ZV0pO1xuICAgICAgICB9KVxuICAgICAgICAucmVkdWNlKChmbGF0dGVuZWRQcm9kdWN0LCB1bmZsYXR0ZW5lZFByb2R1Y3QpID0+IHtcbiAgICAgICAgICByZXR1cm4gZmxhdHRlbmVkUHJvZHVjdC5jb25jYXQodW5mbGF0dGVuZWRQcm9kdWN0KTtcbiAgICAgICAgfSwgW10pO1xuICB9LCBbXSBhcyBQb3NzaWJsZVZhbHVlcyk7XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Count the elements in an Array of LayerVariables.\n *\n * @param weights: The LayerVariables of which the constituent numbers are to\n *   be counted.\n * @returns A count of the elements in all the LayerVariables\n */\nexport function countParamsInWeights(weights) {\n    let count = 0;\n    for (const weight of weights) {\n        if (weight.shape.length === 0) {\n            count += 1;\n        }\n        else {\n            count += weight.shape.reduce((a, b) => a * b);\n        }\n    }\n    return count;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFyaWFibGVfdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvdXRpbHMvdmFyaWFibGVfdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFJSDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsT0FBd0I7SUFDM0QsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2QsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLEVBQUU7UUFDNUIsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDN0IsS0FBSyxJQUFJLENBQUMsQ0FBQztTQUNaO2FBQU07WUFDTCxLQUFLLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDL0M7S0FDRjtJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7TGF5ZXJWYXJpYWJsZX0gZnJvbSAnLi4vdmFyaWFibGVzJztcblxuLyoqXG4gKiBDb3VudCB0aGUgZWxlbWVudHMgaW4gYW4gQXJyYXkgb2YgTGF5ZXJWYXJpYWJsZXMuXG4gKlxuICogQHBhcmFtIHdlaWdodHM6IFRoZSBMYXllclZhcmlhYmxlcyBvZiB3aGljaCB0aGUgY29uc3RpdHVlbnQgbnVtYmVycyBhcmUgdG9cbiAqICAgYmUgY291bnRlZC5cbiAqIEByZXR1cm5zIEEgY291bnQgb2YgdGhlIGVsZW1lbnRzIGluIGFsbCB0aGUgTGF5ZXJWYXJpYWJsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvdW50UGFyYW1zSW5XZWlnaHRzKHdlaWdodHM6IExheWVyVmFyaWFibGVbXSk6IG51bWJlciB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAoY29uc3Qgd2VpZ2h0IG9mIHdlaWdodHMpIHtcbiAgICBpZiAod2VpZ2h0LnNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgKz0gd2VpZ2h0LnNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { ValueError } from '../errors';\n// tslint:enable\n/**\n * Determine whether the input is an Array of Shapes.\n */\nexport function isArrayOfShapes(x) {\n    return Array.isArray(x) && Array.isArray(x[0]);\n}\n/**\n * Special case of normalizing shapes to lists.\n *\n * @param x A shape or list of shapes to normalize into a list of Shapes.\n * @return A list of Shapes.\n */\nexport function normalizeShapeList(x) {\n    if (x.length === 0) {\n        return [];\n    }\n    if (!Array.isArray(x[0])) {\n        return [x];\n    }\n    return x;\n}\n/**\n * Helper function to obtain exactly one Tensor.\n * @param xs: A single `tf.Tensor` or an `Array` of `tf.Tensor`s.\n * @return A single `tf.Tensor`. If `xs` is an `Array`, return the first one.\n * @throws ValueError: If `xs` is an `Array` and its length is not 1.\n */\nexport function getExactlyOneTensor(xs) {\n    let x;\n    if (Array.isArray(xs)) {\n        if (xs.length !== 1) {\n            throw new ValueError(`Expected Tensor length to be 1; got ${xs.length}`);\n        }\n        x = xs[0];\n    }\n    else {\n        x = xs;\n    }\n    return x;\n}\n/**\n * Helper function to obtain exactly on instance of Shape.\n *\n * @param shapes Input single `Shape` or Array of `Shape`s.\n * @returns If input is a single `Shape`, return it unchanged. If the input is\n *   an `Array` containing exactly one instance of `Shape`, return the instance.\n *   Otherwise, throw a `ValueError`.\n * @throws ValueError: If input is an `Array` of `Shape`s, and its length is not\n *   1.\n */\nexport function getExactlyOneShape(shapes) {\n    if (Array.isArray(shapes) && Array.isArray(shapes[0])) {\n        if (shapes.length === 1) {\n            shapes = shapes;\n            return shapes[0];\n        }\n        else {\n            throw new ValueError(`Expected exactly 1 Shape; got ${shapes.length}`);\n        }\n    }\n    else {\n        return shapes;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXNfdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvdXRpbHMvdHlwZXNfdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFLSCxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBRXJDLGdCQUFnQjtBQUVoQjs7R0FFRztBQUNILE1BQU0sVUFBVSxlQUFlLENBQUMsQ0FBZ0I7SUFDOUMsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDakQsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLGtCQUFrQixDQUFDLENBQWdCO0lBQ2pELElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDbEIsT0FBTyxFQUFFLENBQUM7S0FDWDtJQUNELElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ3hCLE9BQU8sQ0FBQyxDQUFDLENBQVksQ0FBQztLQUN2QjtJQUNELE9BQU8sQ0FBWSxDQUFDO0FBQ3RCLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxFQUFtQjtJQUNyRCxJQUFJLENBQVMsQ0FBQztJQUNkLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUNyQixJQUFJLEVBQUUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ25CLE1BQU0sSUFBSSxVQUFVLENBQUMsdUNBQXVDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1NBQzFFO1FBQ0QsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNYO1NBQU07UUFDTCxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ1I7SUFDRCxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUM7QUFFRDs7Ozs7Ozs7O0dBU0c7QUFDSCxNQUFNLFVBQVUsa0JBQWtCLENBQUMsTUFBcUI7SUFDdEQsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDckQsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN2QixNQUFNLEdBQUcsTUFBaUIsQ0FBQztZQUMzQixPQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNsQjthQUFNO1lBQ0wsTUFBTSxJQUFJLFVBQVUsQ0FBQyxpQ0FBaUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7U0FDeEU7S0FDRjtTQUFNO1FBQ0wsT0FBTyxNQUFlLENBQUM7S0FDeEI7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyogT3JpZ2luYWwgc291cmNlOiB1dGlscy9nZW5lcmljX3V0aWxzLnB5ICovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtTaGFwZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L2NvbW1vbic7XG4vLyB0c2xpbnQ6ZW5hYmxlXG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGlucHV0IGlzIGFuIEFycmF5IG9mIFNoYXBlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlPZlNoYXBlcyh4OiBTaGFwZXxTaGFwZVtdKTogYm9vbGVhbiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHgpICYmIEFycmF5LmlzQXJyYXkoeFswXSk7XG59XG5cbi8qKlxuICogU3BlY2lhbCBjYXNlIG9mIG5vcm1hbGl6aW5nIHNoYXBlcyB0byBsaXN0cy5cbiAqXG4gKiBAcGFyYW0geCBBIHNoYXBlIG9yIGxpc3Qgb2Ygc2hhcGVzIHRvIG5vcm1hbGl6ZSBpbnRvIGEgbGlzdCBvZiBTaGFwZXMuXG4gKiBAcmV0dXJuIEEgbGlzdCBvZiBTaGFwZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTaGFwZUxpc3QoeDogU2hhcGV8U2hhcGVbXSk6IFNoYXBlW10ge1xuICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHhbMF0pKSB7XG4gICAgcmV0dXJuIFt4XSBhcyBTaGFwZVtdO1xuICB9XG4gIHJldHVybiB4IGFzIFNoYXBlW107XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIG9idGFpbiBleGFjdGx5IG9uZSBUZW5zb3IuXG4gKiBAcGFyYW0geHM6IEEgc2luZ2xlIGB0Zi5UZW5zb3JgIG9yIGFuIGBBcnJheWAgb2YgYHRmLlRlbnNvcmBzLlxuICogQHJldHVybiBBIHNpbmdsZSBgdGYuVGVuc29yYC4gSWYgYHhzYCBpcyBhbiBgQXJyYXlgLCByZXR1cm4gdGhlIGZpcnN0IG9uZS5cbiAqIEB0aHJvd3MgVmFsdWVFcnJvcjogSWYgYHhzYCBpcyBhbiBgQXJyYXlgIGFuZCBpdHMgbGVuZ3RoIGlzIG5vdCAxLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXhhY3RseU9uZVRlbnNvcih4czogVGVuc29yfFRlbnNvcltdKTogVGVuc29yIHtcbiAgbGV0IHg6IFRlbnNvcjtcbiAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgaWYgKHhzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYEV4cGVjdGVkIFRlbnNvciBsZW5ndGggdG8gYmUgMTsgZ290ICR7eHMubGVuZ3RofWApO1xuICAgIH1cbiAgICB4ID0geHNbMF07XG4gIH0gZWxzZSB7XG4gICAgeCA9IHhzO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBvYnRhaW4gZXhhY3RseSBvbiBpbnN0YW5jZSBvZiBTaGFwZS5cbiAqXG4gKiBAcGFyYW0gc2hhcGVzIElucHV0IHNpbmdsZSBgU2hhcGVgIG9yIEFycmF5IG9mIGBTaGFwZWBzLlxuICogQHJldHVybnMgSWYgaW5wdXQgaXMgYSBzaW5nbGUgYFNoYXBlYCwgcmV0dXJuIGl0IHVuY2hhbmdlZC4gSWYgdGhlIGlucHV0IGlzXG4gKiAgIGFuIGBBcnJheWAgY29udGFpbmluZyBleGFjdGx5IG9uZSBpbnN0YW5jZSBvZiBgU2hhcGVgLCByZXR1cm4gdGhlIGluc3RhbmNlLlxuICogICBPdGhlcndpc2UsIHRocm93IGEgYFZhbHVlRXJyb3JgLlxuICogQHRocm93cyBWYWx1ZUVycm9yOiBJZiBpbnB1dCBpcyBhbiBgQXJyYXlgIG9mIGBTaGFwZWBzLCBhbmQgaXRzIGxlbmd0aCBpcyBub3RcbiAqICAgMS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV4YWN0bHlPbmVTaGFwZShzaGFwZXM6IFNoYXBlfFNoYXBlW10pOiBTaGFwZSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNoYXBlcykgJiYgQXJyYXkuaXNBcnJheShzaGFwZXNbMF0pKSB7XG4gICAgaWYgKHNoYXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHNoYXBlcyA9IHNoYXBlcyBhcyBTaGFwZVtdO1xuICAgICAgcmV0dXJuIHNoYXBlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYEV4cGVjdGVkIGV4YWN0bHkgMSBTaGFwZTsgZ290ICR7c2hhcGVzLmxlbmd0aH1gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNoYXBlcyBhcyBTaGFwZTtcbiAgfVxufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { ValueError } from '../errors';\nimport { pyListRepeat } from './generic_utils';\nimport { isInteger, max } from './math_utils';\n/**\n * Transforms a single number of array of numbers into an array of numbers.\n * @param value\n * @param n: The size of the tuple to be returned.\n * @param name: Name of the parameter, used for generating error messages.\n * @returns An array of numbers.\n */\nexport function normalizeArray(value, n, name) {\n    if (typeof value === 'number') {\n        return pyListRepeat(value, n);\n    }\n    else {\n        if (value.length !== n) {\n            throw new ValueError(`The ${name} argument must be an integer or tuple of ${n} integers.` +\n                ` Received: ${value.length} elements.`);\n        }\n        for (let i = 0; i < n; ++i) {\n            const singleValue = value[i];\n            if (!isInteger(singleValue)) {\n                throw new ValueError(`The ${name} argument must be an integer or tuple of ${n}` +\n                    ` integers. Received: ${JSON.stringify(value)} including a` +\n                    ` non-integer number ${singleValue}`);\n            }\n        }\n        return value;\n    }\n}\n/**\n * Determines output length of a convolution given input length.\n * @param inputLength\n * @param filterSize\n * @param padding\n * @param stride\n * @param dilation: dilation rate.\n */\nexport function convOutputLength(inputLength, filterSize, padding, stride, dilation = 1) {\n    if (inputLength == null) {\n        return inputLength;\n    }\n    const dilatedFilterSize = filterSize + (filterSize - 1) * (dilation - 1);\n    let outputLength;\n    if (padding === 'same') {\n        outputLength = inputLength;\n    }\n    else { // VALID\n        outputLength = inputLength - dilatedFilterSize + 1;\n    }\n    return Math.floor((outputLength + stride - 1) / stride);\n}\nexport function deconvLength(dimSize, strideSize, kernelSize, padding) {\n    if (dimSize == null) {\n        return null;\n    }\n    if (padding === 'valid') {\n        dimSize = dimSize * strideSize + max([kernelSize - strideSize, 0]);\n    }\n    else if (padding === 'same') {\n        dimSize = dimSize * strideSize;\n    }\n    else {\n        throw new ValueError(`Unsupport padding mode: ${padding}.`);\n    }\n    return dimSize;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl91dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy91dGlscy9jb252X3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUdyQyxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDN0MsT0FBTyxFQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFFNUM7Ozs7OztHQU1HO0FBQ0gsTUFBTSxVQUFVLGNBQWMsQ0FDMUIsS0FBc0IsRUFBRSxDQUFTLEVBQUUsSUFBWTtJQUNqRCxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtRQUM3QixPQUFPLFlBQVksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDL0I7U0FBTTtRQUNMLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDdEIsTUFBTSxJQUFJLFVBQVUsQ0FDaEIsT0FBTyxJQUFJLDRDQUE0QyxDQUFDLFlBQVk7Z0JBQ3BFLGNBQWMsS0FBSyxDQUFDLE1BQU0sWUFBWSxDQUFDLENBQUM7U0FDN0M7UUFDRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQzFCLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM3QixJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxFQUFFO2dCQUMzQixNQUFNLElBQUksVUFBVSxDQUNoQixPQUFPLElBQUksNENBQTRDLENBQUMsRUFBRTtvQkFDMUQsd0JBQXdCLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLGNBQWM7b0JBQzNELHVCQUF1QixXQUFXLEVBQUUsQ0FBQyxDQUFDO2FBQzNDO1NBQ0Y7UUFDRCxPQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0gsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsZ0JBQWdCLENBQzVCLFdBQW1CLEVBQUUsVUFBa0IsRUFBRSxPQUFvQixFQUM3RCxNQUFjLEVBQUUsUUFBUSxHQUFHLENBQUM7SUFDOUIsSUFBSSxXQUFXLElBQUksSUFBSSxFQUFFO1FBQ3ZCLE9BQU8sV0FBVyxDQUFDO0tBQ3BCO0lBQ0QsTUFBTSxpQkFBaUIsR0FBRyxVQUFVLEdBQUcsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDekUsSUFBSSxZQUFvQixDQUFDO0lBQ3pCLElBQUksT0FBTyxLQUFLLE1BQU0sRUFBRTtRQUN0QixZQUFZLEdBQUcsV0FBVyxDQUFDO0tBQzVCO1NBQU0sRUFBRyxRQUFRO1FBQ2hCLFlBQVksR0FBRyxXQUFXLEdBQUcsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDO0tBQ3BEO0lBQ0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsWUFBWSxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztBQUMxRCxDQUFDO0FBRUQsTUFBTSxVQUFVLFlBQVksQ0FDeEIsT0FBZSxFQUFFLFVBQWtCLEVBQUUsVUFBa0IsRUFDdkQsT0FBb0I7SUFDdEIsSUFBSSxPQUFPLElBQUksSUFBSSxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCxJQUFJLE9BQU8sS0FBSyxPQUFPLEVBQUU7UUFDdkIsT0FBTyxHQUFHLE9BQU8sR0FBRyxVQUFVLEdBQUcsR0FBRyxDQUFDLENBQUMsVUFBVSxHQUFHLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3BFO1NBQU0sSUFBSSxPQUFPLEtBQUssTUFBTSxFQUFFO1FBQzdCLE9BQU8sR0FBRyxPQUFPLEdBQUcsVUFBVSxDQUFDO0tBQ2hDO1NBQU07UUFDTCxNQUFNLElBQUksVUFBVSxDQUFDLDJCQUEyQixPQUFPLEdBQUcsQ0FBQyxDQUFDO0tBQzdEO0lBQ0QsT0FBTyxPQUFPLENBQUM7QUFDakIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7VmFsdWVFcnJvcn0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7UGFkZGluZ01vZGV9IGZyb20gJy4uL2tlcmFzX2Zvcm1hdC9jb21tb24nO1xuXG5pbXBvcnQge3B5TGlzdFJlcGVhdH0gZnJvbSAnLi9nZW5lcmljX3V0aWxzJztcbmltcG9ydCB7aXNJbnRlZ2VyLCBtYXh9IGZyb20gJy4vbWF0aF91dGlscyc7XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIHNpbmdsZSBudW1iZXIgb2YgYXJyYXkgb2YgbnVtYmVycyBpbnRvIGFuIGFycmF5IG9mIG51bWJlcnMuXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBuOiBUaGUgc2l6ZSBvZiB0aGUgdHVwbGUgdG8gYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0gbmFtZTogTmFtZSBvZiB0aGUgcGFyYW1ldGVyLCB1c2VkIGZvciBnZW5lcmF0aW5nIGVycm9yIG1lc3NhZ2VzLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2YgbnVtYmVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KFxuICAgIHZhbHVlOiBudW1iZXJ8bnVtYmVyW10sIG46IG51bWJlciwgbmFtZTogc3RyaW5nKTogbnVtYmVyW10ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBweUxpc3RSZXBlYXQodmFsdWUsIG4pO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IG4pIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBUaGUgJHtuYW1lfSBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXIgb3IgdHVwbGUgb2YgJHtufSBpbnRlZ2Vycy5gICtcbiAgICAgICAgICBgIFJlY2VpdmVkOiAke3ZhbHVlLmxlbmd0aH0gZWxlbWVudHMuYCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBzaW5nbGVWYWx1ZSA9IHZhbHVlW2ldO1xuICAgICAgaWYgKCFpc0ludGVnZXIoc2luZ2xlVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYFRoZSAke25hbWV9IGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlciBvciB0dXBsZSBvZiAke259YCArXG4gICAgICAgICAgICBgIGludGVnZXJzLiBSZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IGluY2x1ZGluZyBhYCArXG4gICAgICAgICAgICBgIG5vbi1pbnRlZ2VyIG51bWJlciAke3NpbmdsZVZhbHVlfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIG91dHB1dCBsZW5ndGggb2YgYSBjb252b2x1dGlvbiBnaXZlbiBpbnB1dCBsZW5ndGguXG4gKiBAcGFyYW0gaW5wdXRMZW5ndGhcbiAqIEBwYXJhbSBmaWx0ZXJTaXplXG4gKiBAcGFyYW0gcGFkZGluZ1xuICogQHBhcmFtIHN0cmlkZVxuICogQHBhcmFtIGRpbGF0aW9uOiBkaWxhdGlvbiByYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udk91dHB1dExlbmd0aChcbiAgICBpbnB1dExlbmd0aDogbnVtYmVyLCBmaWx0ZXJTaXplOiBudW1iZXIsIHBhZGRpbmc6IFBhZGRpbmdNb2RlLFxuICAgIHN0cmlkZTogbnVtYmVyLCBkaWxhdGlvbiA9IDEpOiBudW1iZXIge1xuICBpZiAoaW5wdXRMZW5ndGggPT0gbnVsbCkge1xuICAgIHJldHVybiBpbnB1dExlbmd0aDtcbiAgfVxuICBjb25zdCBkaWxhdGVkRmlsdGVyU2l6ZSA9IGZpbHRlclNpemUgKyAoZmlsdGVyU2l6ZSAtIDEpICogKGRpbGF0aW9uIC0gMSk7XG4gIGxldCBvdXRwdXRMZW5ndGg6IG51bWJlcjtcbiAgaWYgKHBhZGRpbmcgPT09ICdzYW1lJykge1xuICAgIG91dHB1dExlbmd0aCA9IGlucHV0TGVuZ3RoO1xuICB9IGVsc2UgeyAgLy8gVkFMSURcbiAgICBvdXRwdXRMZW5ndGggPSBpbnB1dExlbmd0aCAtIGRpbGF0ZWRGaWx0ZXJTaXplICsgMTtcbiAgfVxuICByZXR1cm4gTWF0aC5mbG9vcigob3V0cHV0TGVuZ3RoICsgc3RyaWRlIC0gMSkgLyBzdHJpZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb252TGVuZ3RoKFxuICAgIGRpbVNpemU6IG51bWJlciwgc3RyaWRlU2l6ZTogbnVtYmVyLCBrZXJuZWxTaXplOiBudW1iZXIsXG4gICAgcGFkZGluZzogUGFkZGluZ01vZGUpOiBudW1iZXIge1xuICBpZiAoZGltU2l6ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocGFkZGluZyA9PT0gJ3ZhbGlkJykge1xuICAgIGRpbVNpemUgPSBkaW1TaXplICogc3RyaWRlU2l6ZSArIG1heChba2VybmVsU2l6ZSAtIHN0cmlkZVNpemUsIDBdKTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAnc2FtZScpIHtcbiAgICBkaW1TaXplID0gZGltU2l6ZSAqIHN0cmlkZVNpemU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYFVuc3VwcG9ydCBwYWRkaW5nIG1vZGU6ICR7cGFkZGluZ30uYCk7XG4gIH1cbiAgcmV0dXJuIGRpbVNpemU7XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Math utility functions.\n *\n * This file contains some frequently used math function that operates on\n * number[] or Float32Array and return a number. Many of these functions are\n * not-so-thick wrappers around TF.js Core functions. But they offer the\n * convenience of\n * 1) not having to convert the inputs into Tensors,\n * 2) not having to convert the returned Tensors to numbers.\n */\nimport { ValueError } from '../errors';\n/**\n * Determine if a number is an integer.\n */\nexport function isInteger(x) {\n    return x === parseInt(x.toString(), 10);\n}\n/**\n * Calculate the product of an array of numbers.\n * @param array The array to calculate the product over.\n * @param begin Beginning index, inclusive.\n * @param end Ending index, exclusive.\n * @return The product.\n */\nexport function arrayProd(array, begin, end) {\n    if (begin == null) {\n        begin = 0;\n    }\n    if (end == null) {\n        end = array.length;\n    }\n    let prod = 1;\n    for (let i = begin; i < end; ++i) {\n        prod *= array[i];\n    }\n    return prod;\n}\n/**\n * Compute minimum value.\n * @param array\n * @return minimum value.\n */\nexport function min(array) {\n    // same behavior as tf.min()\n    if (array.length === 0) {\n        return Number.NaN;\n    }\n    let min = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        if (value < min) {\n            min = value;\n        }\n    }\n    return min;\n}\n/**\n * Compute maximum value.\n * @param array\n * @return maximum value\n */\nexport function max(array) {\n    // same behavior as tf.max()\n    if (array.length === 0) {\n        return Number.NaN;\n    }\n    let max = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        if (value > max) {\n            max = value;\n        }\n    }\n    return max;\n}\n/**\n * Compute sum of array.\n * @param array\n * @return The sum.\n */\nexport function sum(array) {\n    let sum = 0;\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        sum += value;\n    }\n    return sum;\n}\n/**\n * Compute mean of array.\n * @param array\n * @return The mean.\n */\nexport function mean(array) {\n    return sum(array) / array.length;\n}\n/**\n * Compute variance of array.\n * @param array\n * @return The variance.\n */\nexport function variance(array) {\n    const meanValue = mean(array);\n    const demeaned = array.map((value) => value - meanValue);\n    let sumSquare = 0;\n    for (let i = 0; i < demeaned.length; i++) {\n        const value = demeaned[i];\n        sumSquare += value * value;\n    }\n    return sumSquare / array.length;\n}\n/**\n * Compute median of array.\n * @param array\n * @return The median value.\n */\nexport function median(array) {\n    const arraySorted = array.slice().sort((a, b) => a - b);\n    const lowIdx = Math.floor((arraySorted.length - 1) / 2);\n    const highIdx = Math.ceil((arraySorted.length - 1) / 2);\n    if (lowIdx === highIdx) {\n        return arraySorted[lowIdx];\n    }\n    return (arraySorted[lowIdx] + arraySorted[highIdx]) / 2;\n}\n/**\n * Generate an array of integers in [begin, end).\n * @param begin Beginning integer, inclusive.\n * @param end Ending integer, exclusive.\n * @returns Range array.\n * @throws ValueError, iff `end` < `begin`.\n */\nexport function range(begin, end) {\n    if (end < begin) {\n        throw new ValueError(`end (${end}) < begin (${begin}) is forbidden.`);\n    }\n    const out = [];\n    for (let i = begin; i < end; ++i) {\n        out.push(i);\n    }\n    return out;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0aF91dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy91dGlscy9tYXRoX3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUg7Ozs7Ozs7OztHQVNHO0FBRUgsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUlyQzs7R0FFRztBQUNILE1BQU0sVUFBVSxTQUFTLENBQUMsQ0FBUztJQUNqQyxPQUFPLENBQUMsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzFDLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsU0FBUyxDQUNyQixLQUEwQixFQUFFLEtBQWMsRUFBRSxHQUFZO0lBQzFELElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtRQUNqQixLQUFLLEdBQUcsQ0FBQyxDQUFDO0tBQ1g7SUFDRCxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUU7UUFDZixHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztLQUNwQjtJQUVELElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztJQUNiLEtBQUssSUFBSSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUU7UUFDaEMsSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNsQjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsR0FBRyxDQUFDLEtBQTRCO0lBQzlDLDRCQUE0QjtJQUM1QixJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3RCLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQztLQUNuQjtJQUNELElBQUksR0FBRyxHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQztJQUNu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TyxFQUFFO1FBQ3RCLE9BQU8sV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQzVCO0lBQ0QsT0FBTyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDMUQsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxLQUFLLENBQUMsS0FBYSxFQUFFLEdBQVc7SUFDOUMsSUFBSSxHQUFHLEdBQUcsS0FBSyxFQUFFO1FBQ2YsTUFBTSxJQUFJLFVBQVUsQ0FBQyxRQUFRLEdBQUcsY0FBYyxLQUFLLGlCQUFpQixDQUFDLENBQUM7S0FDdkU7SUFDRCxNQUFNLEdBQUcsR0FBYSxFQUFFLENBQUM7SUFDekIsS0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRTtRQUNoQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2I7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIE1hdGggdXRpbGl0eSBmdW5jdGlvbnMuXG4gKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHNvbWUgZnJlcXVlbnRseSB1c2VkIG1hdGggZnVuY3Rpb24gdGhhdCBvcGVyYXRlcyBvblxuICogbnVtYmVyW10gb3IgRmxvYXQzMkFycmF5IGFuZCByZXR1cm4gYSBudW1iZXIuIE1hbnkgb2YgdGhlc2UgZnVuY3Rpb25zIGFyZVxuICogbm90LXNvLXRoaWNrIHdyYXBwZXJzIGFyb3VuZCBURi5qcyBDb3JlIGZ1bmN0aW9ucy4gQnV0IHRoZXkgb2ZmZXIgdGhlXG4gKiBjb252ZW5pZW5jZSBvZlxuICogMSkgbm90IGhhdmluZyB0byBjb252ZXJ0IHRoZSBpbnB1dHMgaW50byBUZW5zb3JzLFxuICogMikgbm90IGhhdmluZyB0byBjb252ZXJ0IHRoZSByZXR1cm5lZCBUZW5zb3JzIHRvIG51bWJlcnMuXG4gKi9cblxuaW1wb3J0IHtWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5leHBvcnQgdHlwZSBBcnJheVR5cGVzID0gVWludDhBcnJheXxJbnQzMkFycmF5fEZsb2F0MzJBcnJheTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBudW1iZXIgaXMgYW4gaW50ZWdlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZWdlcih4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIHggPT09IHBhcnNlSW50KHgudG9TdHJpbmcoKSwgMTApO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgcHJvZHVjdCBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBjYWxjdWxhdGUgdGhlIHByb2R1Y3Qgb3Zlci5cbiAqIEBwYXJhbSBiZWdpbiBCZWdpbm5pbmcgaW5kZXgsIGluY2x1c2l2ZS5cbiAqIEBwYXJhbSBlbmQgRW5kaW5nIGluZGV4LCBleGNsdXNpdmUuXG4gKiBAcmV0dXJuIFRoZSBwcm9kdWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlQcm9kKFxuICAgIGFycmF5OiBudW1iZXJbXXxBcnJheVR5cGVzLCBiZWdpbj86IG51bWJlciwgZW5kPzogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKGJlZ2luID09IG51bGwpIHtcbiAgICBiZWdpbiA9IDA7XG4gIH1cbiAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgZW5kID0gYXJyYXkubGVuZ3RoO1xuICB9XG5cbiAgbGV0IHByb2QgPSAxO1xuICBmb3IgKGxldCBpID0gYmVnaW47IGkgPCBlbmQ7ICsraSkge1xuICAgIHByb2QgKj0gYXJyYXlbaV07XG4gIH1cbiAgcmV0dXJuIHByb2Q7XG59XG5cbi8qKlxuICogQ29tcHV0ZSBtaW5pbXVtIHZhbHVlLlxuICogQHBhcmFtIGFycmF5XG4gKiBAcmV0dXJuIG1pbmltdW0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaW4oYXJyYXk6IG51bWJlcltdfEZsb2F0MzJBcnJheSk6IG51bWJlciB7XG4gIC8vIHNhbWUgYmVoYXZpb3IgYXMgdGYubWluKClcbiAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBOdW1iZXIuTmFOO1xuICB9XG4gIGxldCBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IGFycmF5W2ldO1xuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgbWluID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW47XG59XG5cbi8qKlxuICogQ29tcHV0ZSBtYXhpbXVtIHZhbHVlLlxuICogQHBhcmFtIGFycmF5XG4gKiBAcmV0dXJuIG1heGltdW0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChhcnJheTogbnVtYmVyW118RmxvYXQzMkFycmF5KTogbnVtYmVyIHtcbiAgLy8gc2FtZSBiZWhhdmlvciBhcyB0Zi5tYXgoKVxuICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIE51bWJlci5OYU47XG4gIH1cbiAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG4gICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICBtYXggPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heDtcbn1cblxuLyoqXG4gKiBDb21wdXRlIHN1bSBvZiBhcnJheS5cbiAqIEBwYXJhbSBhcnJheVxuICogQHJldHVybiBUaGUgc3VtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VtKGFycmF5OiBudW1iZXJbXXxGbG9hdDMyQXJyYXkpOiBudW1iZXIge1xuICBsZXQgc3VtID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG4gICAgc3VtICs9IHZhbHVlO1xuICB9XG4gIHJldHVybiBzdW07XG59XG5cbi8qKlxuICogQ29tcHV0ZSBtZWFuIG9mIGFycmF5LlxuICogQHBhcmFtIGFycmF5XG4gKiBAcmV0dXJuIFRoZSBtZWFuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVhbihhcnJheTogbnVtYmVyW118RmxvYXQzMkFycmF5KTogbnVtYmVyIHtcbiAgcmV0dXJuIHN1bShhcnJheSkgLyBhcnJheS5sZW5ndGg7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB2YXJpYW5jZSBvZiBhcnJheS5cbiAqIEBwYXJhbSBhcnJheVxuICogQHJldHVybiBUaGUgdmFyaWFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYW5jZShhcnJheTogbnVtYmVyW118RmxvYXQzMkFycmF5KTogbnVtYmVyIHtcbiAgY29uc3QgbWVhblZhbHVlID0gbWVhbihhcnJheSk7XG4gIGNvbnN0IGRlbWVhbmVkID0gYXJyYXkubWFwKCh2YWx1ZTogbnVtYmVyKSA9PiB2YWx1ZSAtIG1lYW5WYWx1ZSk7XG4gIGxldCBzdW1TcXVhcmUgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbWVhbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdmFsdWUgPSBkZW1lYW5lZFtpXTtcbiAgICBzdW1TcXVhcmUgKz0gdmFsdWUgKiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gc3VtU3F1YXJlIC8gYXJyYXkubGVuZ3RoO1xufVxuXG4vKipcbiAqIENvbXB1dGUgbWVkaWFuIG9mIGFycmF5LlxuICogQHBhcmFtIGFycmF5XG4gKiBAcmV0dXJuIFRoZSBtZWRpYW4gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWRpYW4oYXJyYXk6IG51bWJlcltdfEZsb2F0MzJBcnJheSk6IG51bWJlciB7XG4gIGNvbnN0IGFycmF5U29ydGVkID0gYXJyYXkuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGNvbnN0IGxvd0lkeCA9IE1hdGguZmxvb3IoKGFycmF5U29ydGVkLmxlbmd0aCAtIDEpIC8gMik7XG4gIGNvbnN0IGhpZ2hJZHggPSBNYXRoLmNlaWwoKGFycmF5U29ydGVkLmxlbmd0aCAtIDEpIC8gMik7XG4gIGlmIChsb3dJZHggPT09IGhpZ2hJZHgpIHtcbiAgICByZXR1cm4gYXJyYXlTb3J0ZWRbbG93SWR4XTtcbiAgfVxuICByZXR1cm4gKGFycmF5U29ydGVkW2xvd0lkeF0gKyBhcnJheVNvcnRlZFtoaWdoSWR4XSkgLyAyO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGFuIGFycmF5IG9mIGludGVnZXJzIGluIFtiZWdpbiwgZW5kKS5cbiAqIEBwYXJhbSBiZWdpbiBCZWdpbm5pbmcgaW50ZWdlciwgaW5jbHVzaXZlLlxuICogQHBhcmFtIGVuZCBFbmRpbmcgaW50ZWdlciwgZXhjbHVzaXZlLlxuICogQHJldHVybnMgUmFuZ2UgYXJyYXkuXG4gKiBAdGhyb3dzIFZhbHVlRXJyb3IsIGlmZiBgZW5kYCA8IGBiZWdpbmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5nZShiZWdpbjogbnVtYmVyLCBlbmQ6IG51bWJlcik6IG51bWJlcltdIHtcbiAgaWYgKGVuZCA8IGJlZ2luKSB7XG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYGVuZCAoJHtlbmR9KSA8IGJlZ2luICgke2JlZ2lufSkgaXMgZm9yYmlkZGVuLmApO1xuICB9XG4gIGNvbnN0IG91dDogbnVtYmVyW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IGJlZ2luOyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQucHVzaChpKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* original source: keras/regularizers.py */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { abs, add, serialization, sum, tidy, zeros } from '@tensorflow/tfjs-core';\nimport * as K from './backend/tfjs_backend';\nimport { deserializeKerasObject, serializeKerasObject } from './utils/generic_utils';\nfunction assertObjectArgs(args) {\n    if (args != null && typeof args !== 'object') {\n        throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an ` +\n            `object, but received: ${args}`);\n    }\n}\n/**\n * Regularizer base class.\n */\nexport class Regularizer extends serialization.Serializable {\n}\nclass L1L2 extends Regularizer {\n    constructor(args) {\n        super();\n        assertObjectArgs(args);\n        this.l1 = args == null || args.l1 == null ? 0.01 : args.l1;\n        this.l2 = args == null || args.l2 == null ? 0.01 : args.l2;\n        this.hasL1 = this.l1 !== 0;\n        this.hasL2 = this.l2 !== 0;\n    }\n    /**\n     * Porting note: Renamed from __call__.\n     * @param x Variable of which to calculate the regularization score.\n     */\n    apply(x) {\n        return tidy(() => {\n            let regularization = zeros([1]);\n            if (this.hasL1) {\n                regularization = add(regularization, sum(tfc.mul(this.l1, abs(x))));\n            }\n            if (this.hasL2) {\n                regularization =\n                    add(regularization, sum(tfc.mul(this.l2, K.square(x))));\n            }\n            return tfc.reshape(regularization, []);\n        });\n    }\n    getConfig() {\n        return { 'l1': this.l1, 'l2': this.l2 };\n    }\n    /** @nocollapse */\n    static fromConfig(cls, config) {\n        return new cls({ l1: config['l1'], l2: config['l2'] });\n    }\n}\n/** @nocollapse */\nL1L2.className = 'L1L2';\nexport { L1L2 };\nserialization.registerClass(L1L2);\nexport function l1(args) {\n    assertObjectArgs(args);\n    return new L1L2({ l1: args != null ? args.l1 : null, l2: 0 });\n}\nexport function l2(args) {\n    assertObjectArgs(args);\n    return new L1L2({ l2: args != null ? args.l2 : null, l1: 0 });\n}\n// Maps the JavaScript-like identifier keys to the corresponding keras symbols.\nexport const REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {\n    'l1l2': 'L1L2'\n};\nexport function serializeRegularizer(constraint) {\n    return serializeKerasObject(constraint);\n}\nexport function deserializeRegularizer(config, customObjects = {}) {\n    return deserializeKerasObject(config, serialization.SerializationMap.getMap().classNameMap, customObjects, 'regularizer');\n}\nexport function getRegularizer(identifier) {\n    if (identifier == null) {\n        return null;\n    }\n    if (typeof identifier === 'string') {\n        const className = identifier in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ?\n            REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :\n            identifier;\n        const config = { className, config: {} };\n        return deserializeRegularizer(config);\n    }\n    else if (identifier instanceof Regularizer) {\n        return identifier;\n    }\n    else {\n        return deserializeRegularizer(identifier);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVndWxhcml6ZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL3JlZ3VsYXJpemVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVILDRDQUE0QztBQUU1QyxPQUFPLEtBQUssR0FBRyxNQUFNLHVCQUF1QixDQUFDO0FBQzdDLE9BQU8sRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFVLGFBQWEsRUFBRSxHQUFHLEVBQVUsSUFBSSxFQUFFLEtBQUssRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ2hHLE9BQU8sS0FBSyxDQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDNUMsT0FBTyxFQUFDLHNCQUFzQixFQUFFLG9CQUFvQixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFbkYsU0FBUyxnQkFBZ0IsQ0FBQyxJQUE0QjtJQUNwRCxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQzVDLE1BQU0sSUFBSSxLQUFLLENBQ1gsa0VBQWtFO1lBQ2xFLHlCQUF5QixJQUFJLEVBQUUsQ0FBQyxDQUFDO0tBQ3RDO0FBQ0gsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFnQixXQUFZLFNBQVEsYUFBYSxDQUFDLFlBQVk7Q0FFbkU7QUFtQkQsTUFBYSxJQUFLLFNBQVEsV0FBVztJQVFuQyxZQUFZLElBQWU7UUFDekIsS0FBSyxFQUFFLENBQUM7UUFFUixnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV2QixJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztRQUMzRCxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLEVBQUUs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RUFBRSxDQUFDLFlBQVksRUFDNUQsYUFBYSxFQUFFLGFBQWEsQ0FBQyxDQUFDO0FBQ3BDLENBQUM7QUFFRCxNQUFNLFVBQVUsY0FBYyxDQUFDLFVBRVc7SUFDeEMsSUFBSSxVQUFVLElBQUksSUFBSSxFQUFFO1FBQ3RCLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxJQUFJLE9BQU8sVUFBVSxLQUFLLFFBQVEsRUFBRTtRQUNsQyxNQUFNLFNBQVMsR0FBRyxVQUFVLElBQUksMENBQTBDLENBQUMsQ0FBQztZQUN4RSwwQ0FBMEMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ3hELFVBQVUsQ0FBQztRQUNmLE1BQU0sTUFBTSxHQUFHLEVBQUMsU0FBUyxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUMsQ0FBQztRQUN2QyxPQUFPLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ3ZDO1NBQU0sSUFBSSxVQUFVLFlBQVksV0FBVyxFQUFFO1FBQzVDLE9BQU8sVUFBVSxDQUFDO0tBQ25CO1NBQU07UUFDTCxPQUFPLHNCQUFzQixDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQzNDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qIG9yaWdpbmFsIHNvdXJjZToga2VyYXMvcmVndWxhcml6ZXJzLnB5ICovXG5cbmltcG9ydCAqIGFzIHRmYyBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHthYnMsIGFkZCwgU2NhbGFyLCBzZXJpYWxpemF0aW9uLCBzdW0sIFRlbnNvciwgdGlkeSwgemVyb3N9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQgKiBhcyBLIGZyb20gJy4vYmFja2VuZC90ZmpzX2JhY2tlbmQnO1xuaW1wb3J0IHtkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0LCBzZXJpYWxpemVLZXJhc09iamVjdH0gZnJvbSAnLi91dGlscy9nZW5lcmljX3V0aWxzJztcblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0QXJncyhhcmdzOiBMMUFyZ3N8TDJBcmdzfEwxTDJBcmdzKTogdm9pZCB7XG4gIGlmIChhcmdzICE9IG51bGwgJiYgdHlwZW9mIGFyZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQXJndW1lbnQgdG8gTDFMMiByZWd1bGFyaXplcidzIGNvbnN0cnVjdG9yIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGAgK1xuICAgICAgICBgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7YXJnc31gKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlZ3VsYXJpemVyIGJhc2UgY2xhc3MuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWd1bGFyaXplciBleHRlbmRzIHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlIHtcbiAgYWJzdHJhY3QgYXBwbHkoeDogVGVuc29yKTogU2NhbGFyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEwxTDJBcmdzIHtcbiAgLyoqIEwxIHJlZ3VsYXJpemF0aW9uIHJhdGUuIERlZmF1bHRzIHRvIDAuMDEuICovXG4gIGwxPzogbnVtYmVyO1xuICAvKiogTDIgcmVndWxhcml6YXRpb24gcmF0ZS4gRGVmYXVsdHMgdG8gMC4wMS4gKi9cbiAgbDI/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTDFBcmdzIHtcbiAgLyoqIEwxIHJlZ3VsYXJpemF0aW9uIHJhdGUuIERlZmF1bHRzIHRvIDAuMDEuICovXG4gIGwxOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTDJBcmdzIHtcbiAgLyoqIEwyIHJlZ3VsYXJpemF0aW9uIHJhdGUuIERlZmF1bHRzIHRvIDAuMDEuICovXG4gIGwyOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBMMUwyIGV4dGVuZHMgUmVndWxhcml6ZXIge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdMMUwyJztcblxuICBwcml2YXRlIHJlYWRvbmx5IGwxOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgbDI6IG51bWJlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBoYXNMMTogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBoYXNMMjogYm9vbGVhbjtcbiAgY29uc3RydWN0b3IoYXJncz86IEwxTDJBcmdzKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGFzc2VydE9iamVjdEFyZ3MoYXJncyk7XG5cbiAgICB0aGlzLmwxID0gYXJncyA9PSBudWxsIHx8IGFyZ3MubDEgPT0gbnVsbCA/IDAuMDEgOiBhcmdzLmwxO1xuICAgIHRoaXMubDIgPSBhcmdzID09IG51bGwgfHwgYXJncy5sMiA9PSBudWxsID8gMC4wMSA6IGFyZ3MubDI7XG4gICAgdGhpcy5oYXNMMSA9IHRoaXMubDEgIT09IDA7XG4gICAgdGhpcy5oYXNMMiA9IHRoaXMubDIgIT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUG9ydGluZyBub3RlOiBSZW5hbWVkIGZyb20gX19jYWxsX18uXG4gICAqIEBwYXJhbSB4IFZhcmlhYmxlIG9mIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgcmVndWxhcml6YXRpb24gc2NvcmUuXG4gICAqL1xuICBhcHBseSh4OiBUZW5zb3IpOiBTY2FsYXIge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGxldCByZWd1bGFyaXphdGlvbjogVGVuc29yID0gemVyb3MoWzFdKTtcbiAgICAgIGlmICh0aGlzLmhhc0wxKSB7XG4gICAgICAgIHJlZ3VsYXJpemF0aW9uID0gYWRkKHJlZ3VsYXJpemF0aW9uLCBzdW0odGZjLm11bCh0aGlzLmwxLCBhYnMoeCkpKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNMMikge1xuICAgICAgICByZWd1bGFyaXphdGlvbiA9XG4gICAgICAgICAgICBhZGQocmVndWxhcml6YXRpb24sIHN1bSh0ZmMubXVsKHRoaXMubDIsIEsuc3F1YXJlKHgpKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRmYy5yZXNoYXBlKHJlZ3VsYXJpemF0aW9uLCBbXSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICByZXR1cm4geydsMSc6IHRoaXMubDEsICdsMic6IHRoaXMubDJ9O1xuICB9XG5cbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBvdmVycmlkZSBmcm9tQ29uZmlnPFQgZXh0ZW5kcyBzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZT4oXG4gICAgICBjbHM6IHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlQ29uc3RydWN0b3I8VD4sXG4gICAgICBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCk6IFQge1xuICAgIHJldHVybiBuZXcgY2xzKHtsMTogY29uZmlnWydsMSddIGFzIG51bWJlciwgbDI6IGNvbmZpZ1snbDInXSBhcyBudW1iZXJ9KTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEwxTDIpO1xuXG5leHBvcnQgZnVuY3Rpb24gbDEoYXJncz86IEwxQXJncykge1xuICBhc3NlcnRPYmplY3RBcmdzKGFyZ3MpO1xuICByZXR1cm4gbmV3IEwxTDIoe2wxOiBhcmdzICE9IG51bGwgPyBhcmdzLmwxIDogbnVsbCwgbDI6IDB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGwyKGFyZ3M6IEwyQXJncykge1xuICBhc3NlcnRPYmplY3RBcmdzKGFyZ3MpO1xuICByZXR1cm4gbmV3IEwxTDIoe2wyOiBhcmdzICE9IG51bGwgPyBhcmdzLmwyIDogbnVsbCwgbDE6IDB9KTtcbn1cblxuLyoqIEBkb2NpbmxpbmUgKi9cbmV4cG9ydCB0eXBlIFJlZ3VsYXJpemVySWRlbnRpZmllciA9ICdsMWwyJ3xzdHJpbmc7XG5cbi8vIE1hcHMgdGhlIEphdmFTY3JpcHQtbGlrZSBpZGVudGlmaWVyIGtleXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcga2VyYXMgc3ltYm9scy5cbmV4cG9ydCBjb25zdCBSRUdVTEFSSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVA6XG4gICAge1tpZGVudGlmaWVyIGluIFJlZ3VsYXJpemVySWRlbnRpZmllcl06IHN0cmluZ30gPSB7XG4gICAgICAnbDFsMic6ICdMMUwyJ1xuICAgIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVSZWd1bGFyaXplcihjb25zdHJhaW50OiBSZWd1bGFyaXplcik6XG4gICAgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0VmFsdWUge1xuICByZXR1cm4gc2VyaWFsaXplS2VyYXNPYmplY3QoY29uc3RyYWludCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZVJlZ3VsYXJpemVyKFxuICAgIGNvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0LFxuICAgIGN1c3RvbU9iamVjdHM6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHt9KTogUmVndWxhcml6ZXIge1xuICByZXR1cm4gZGVzZXJpYWxpemVLZXJhc09iamVjdChcbiAgICAgIGNvbmZpZywgc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCxcbiAgICAgIGN1c3RvbU9iamVjdHMsICdyZWd1bGFyaXplcicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVndWxhcml6ZXIoaWRlbnRpZmllcjogUmVndWxhcml6ZXJJZGVudGlmaWVyfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWd1bGFyaXplcik6IFJlZ3VsYXJpemVyIHtcbiAgaWYgKGlkZW50aWZpZXIgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBpZGVudGlmaWVyIGluIFJFR1VMQVJJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUCA/XG4gICAgICAgIFJFR1VMQVJJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUFtpZGVudGlmaWVyXSA6XG4gICAgICAgIGlkZW50aWZpZXI7XG4gICAgY29uc3QgY29uZmlnID0ge2NsYXNzTmFtZSwgY29uZmlnOiB7fX07XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplUmVndWxhcml6ZXIoY29uZmlnKTtcbiAgfSBlbHNlIGlmIChpZGVudGlmaWVyIGluc3RhbmNlb2YgUmVndWxhcml6ZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVSZWd1bGFyaXplcihpZGVudGlmaWVyKTtcbiAgfVxufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport * as generic_utils from '../utils/generic_utils';\n// tslint:enable\n/**\n * Test whether a value in an array is the name of a LayersModel or Layer.\n * @param key The key name that the value is found under. Note that the key\n *   may not be at the level immediately above the value, if the value is in a\n *   nested array.\n * @param index Index of the value in the Array that it is found in.\n * @param value The value object.\n * @returns A boolean indicating whether value is a name.\n */\nfunction isArrayItemInputOrOutputName(key, index, value) {\n    return (key === 'inboundNodes' || key === 'outputLayers' ||\n        key === 'inputLayers') &&\n        index === 0 && typeof value === 'string';\n}\n/**\n * Convert a Pythonic config object to TypeScript config object.\n * @param pythonicConfig The config object to convert.\n * @param key Optional key name of the object being converted.\n * @returns Result of the conversion.\n */\nexport function convertPythonicToTs(pythonicConfig, key) {\n    if (pythonicConfig === null) {\n        return null;\n    }\n    else if (typeof pythonicConfig === 'string') {\n        return generic_utils.toCamelCase(pythonicConfig);\n    }\n    else if ((typeof pythonicConfig === 'number') ||\n        (typeof pythonicConfig === 'boolean')) {\n        return pythonicConfig;\n    }\n    else if (pythonicConfig instanceof Array) {\n        const tsArray = [];\n        const arrayLength = pythonicConfig.length;\n        for (let i = 0; i < arrayLength; ++i) {\n            const item = pythonicConfig[i];\n            if (isArrayItemInputOrOutputName(key, i, item)) {\n                tsArray.push(item);\n            }\n            else {\n                tsArray.push(convertPythonicToTs(item, key));\n            }\n        }\n        return tsArray;\n    }\n    else {\n        const tsDict = {};\n        for (const pythonicKey of Object.keys(pythonicConfig)) {\n            const pythonicValue = pythonicConfig[pythonicKey];\n            if (pythonicKey === 'name' && typeof pythonicValue === 'string') {\n                // Special case the 'name' key with a string value. Name values, such as\n                // the names of LayersModel and Layer instances, should not undergo the\n                // camel-case conversion.\n                tsDict[pythonicKey] = pythonicValue;\n            }\n            else {\n                const tsKey = generic_utils.toCamelCase(pythonicKey);\n                tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);\n            }\n        }\n        return tsDict;\n    }\n}\n/**\n * Convert a TypeScript config object to Python config object.\n * @param tsConfig The config object to convert.\n * @param key Optional key name of the object being converted.\n * @returns Result of the conversion.\n */\nexport function convertTsToPythonic(tsConfig, key) {\n    if (tsConfig === null || tsConfig === undefined) {\n        return null;\n    }\n    else if (typeof tsConfig === 'string') {\n        return generic_utils.toSnakeCase(tsConfig);\n    }\n    else if ((typeof tsConfig === 'number') || (typeof tsConfig === 'boolean')) {\n        return tsConfig;\n    }\n    else if (tsConfig instanceof Array) {\n        const pyArray = [];\n        const arrayLength = tsConfig.length;\n        for (let i = 0; i < arrayLength; ++i) {\n            const item = tsConfig[i];\n            if (isArrayItemInputOrOutputName(key, i, item)) {\n                pyArray.push(item);\n            }\n            else {\n                pyArray.push(convertTsToPythonic(item, key));\n            }\n        }\n        return pyArray;\n    }\n    else {\n        const pyDict = {};\n        for (const tsKey of Object.keys(tsConfig)) {\n            const tsValue = tsConfig[tsKey];\n            const pyKey = generic_utils.toSnakeCase(tsKey);\n            if ((tsKey === 'name' || tsKey === 'className') &&\n                typeof tsValue === 'string') {\n                // Special case the 'name' key with a string value. Name values, such as\n                // the names of LayersModel and Layer instances, should not undergo the\n                // snake-case conversion.\n                pyDict[pyKey] = tsValue;\n            }\n            else {\n                pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);\n            }\n        }\n        return pyDict;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VyaWFsaXphdGlvbl91dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy91dGlscy9zZXJpYWxpemF0aW9uX3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBVUgsT0FBTyxLQUFLLGFBQWEsTUFBTSx3QkFBd0IsQ0FBQztBQUN4RCxnQkFBZ0I7QUFFaEI7Ozs7Ozs7O0dBUUc7QUFDSCxTQUFTLDRCQUE0QixDQUNqQyxHQUFXLEVBQUUsS0FBYSxFQUFFLEtBQVE7SUFDdEMsT0FBTyxDQUFDLEdBQUcsS0FBSyxjQUFjLElBQUksR0FBRyxLQUFLLGNBQWM7UUFDaEQsR0FBRyxLQUFLLGFBQWEsQ0FBQztRQUMxQixLQUFLLEtBQUssQ0FBQyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQztBQUMvQyxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsbUJBQW1CLENBQy9CLGNBQTJCLEVBQUUsR0FBWTtJQUMzQyxJQUFJLGNBQWMsS0FBSyxJQUFJLEVBQUU7UUFDM0IsT0FBTyxJQUFJLENBQUM7S0FDYjtTQUFNLElBQUksT0FBTyxjQUFjLEtBQUssUUFBUSxFQUFFO1FBQzdDLE9BQU8sYUFBYSxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsQ0FBQztLQUNsRDtTQUFNLElBQ0gsQ0FBQyxPQUFPLGNBQWMsS0FBSyxRQUFRLENBQUM7UUFDcEMsQ0FBQyxPQUFPLGNBQWMsS0FBSyxTQUFTLENBQUMsRUFBRTtRQUN6QyxPQUFPLGNBQWMsQ0FBQztLQUN2QjtTQUFNLElBQUksY0FBYyxZQUFZLEtBQUssRUFBRTtRQUMxQyxNQUFNLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFDbkIsTUFBTSxXQUFXLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQztRQUMxQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQ3BDLE1BQU0sSUFBSSxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMvQixJQUFJLDRCQUE0QixDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUU7Z0JBQzlDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDcEI7aUJBQU07Z0JBQ0wsT0FBTyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUM5QztTQUNGO1FBQ0QsT0FBTyxPQUFPLENBQUM7S0FDaEI7U0FBTTtRQUNMLE1BQU0sTUFBTSxHQUE2QixFQUFFLENBQUM7UUFDNUMsS0FBSyxNQUFNLFdBQVcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFO1lBQ3JELE1BQU0sYUFBYSxHQUFHLGNBQWMsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUNsRCxJQUFJLFdBQVcsS0FBSyxNQUFNLElBQUksT0FBTyxhQUFhLEtBQUssUUFBUSxFQUFFO2dCQUMvRCx3RUFBd0U7Z0JBQ3hFLHVFQUF1RTtnQkFDdkUseUJBQXlCO2dCQUN6QixNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsYUFBYSxDQUFDO2FBQ3JDO2lCQUFNO2dCQUNMLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQ3JELE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxtQkFBbUIsQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUM7YUFDM0Q7U0FDRjtRQUNELE9BQU8sTUFBTSxDQUFDO0tBQ2Y7QUFDSCxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsbUJBQW1CLENBQy9CLFFBQXVDLEVBQUUsR0FBWTtJQUN2RCxJQUFJLFFBQVEsS0FBSyxJQUFJLElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtRQUMvQyxPQUFPLElBQUksQ0FBQztLQUNiO1NBQU0sSUFBSSxPQUFPLFFBQVEsS0FBSyxRQUFRLEVBQUU7UUFDdkMsT0FBTyxhQUFhLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQzVDO1NBQU0sSUFDSCxDQUFDLE9BQU8sUUFBUSxLQUFLLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxRQUFRLEtBQUssU0FBUyxDQUFDLEVBQUU7UUFDckUsT0FBTyxRQUFRLENBQUM7S0FDakI7U0FBTSxJQUFJLFFBQVEsWUFBWSxLQUFLLEVBQUU7UUFDcEMsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ25CLE1BQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUM7UUFDcEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsRUFBRSxFQUFFLENBQUMsRUFBRTtZQUNwQyxNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDekIsSUFBSSw0QkFBNEIsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxFQUFFO2dCQUM5QyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3BCO2lCQUFNO2dCQUNMLE9BQU8sQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDOUM7U0FDRjtRQUNELE9BQU8sT0FBTyxDQUFDO0tBQ2hCO1NBQU07UUFDTCxNQUFNLE1BQU0sR0FBNkIsRUFBRSxDQUFDO1FBQzVDLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUN6QyxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDaEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMvQyxJQUFJLENBQUMsS0FBSyxLQUFLLE1BQU0sSUFBSSxLQUFLLEtBQUssV0FBVyxDQUFDO2dCQUMzQyxPQUFPLE9BQU8sS0FBSyxRQUFRLEVBQUU7Z0JBQy9CLHdFQUF3RTtnQkFDeEUsdUVBQXVFO2dCQUN2RSx5QkFBeUI7Z0JBQ3pCLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxPQUFPLENBQUM7YUFDekI7aUJBQU07Z0JBQ0wsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQzthQUNyRDtTQUNGO1FBQ0QsT0FBTyxNQUFNLENBQUM7S0FDZjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBQb3J0aW5nIG5vdGU6IFRoaXMgZmlsZSBkb2Vzbid0IGV4aXN0IGluIFB5S2VyYXMuXG4vLyBJdHMgcHVycG9zZSBoZXJlIGlzIHRvIGNlbnRyYWxpemUgdGhlIGJvdW5kYXJ5IGxheWVyIGJldHdlZW5cbi8vIHRmanMtbGF5ZXJzJ3MgaW50ZXJuYWwgQ29uZmlnIFRTLUNlbnRyaWMgZm9ybWF0IGFuZCBQeUtlcmFzJ3Ncbi8vIHNlcmlhbGl6ZWQgUHl0aG9uIENvbmZpZyBmb3JtYXQuXG5cbmltcG9ydCB7c2VyaWFsaXphdGlvbn0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtQeUpzb25WYWx1ZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L3R5cGVzJztcbmltcG9ydCAqIGFzIGdlbmVyaWNfdXRpbHMgZnJvbSAnLi4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG4vLyB0c2xpbnQ6ZW5hYmxlXG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaW4gYW4gYXJyYXkgaXMgdGhlIG5hbWUgb2YgYSBMYXllcnNNb2RlbCBvciBMYXllci5cbiAqIEBwYXJhbSBrZXkgVGhlIGtleSBuYW1lIHRoYXQgdGhlIHZhbHVlIGlzIGZvdW5kIHVuZGVyLiBOb3RlIHRoYXQgdGhlIGtleVxuICogICBtYXkgbm90IGJlIGF0IHRoZSBsZXZlbCBpbW1lZGlhdGVseSBhYm92ZSB0aGUgdmFsdWUsIGlmIHRoZSB2YWx1ZSBpcyBpbiBhXG4gKiAgIG5lc3RlZCBhcnJheS5cbiAqIEBwYXJhbSBpbmRleCBJbmRleCBvZiB0aGUgdmFsdWUgaW4gdGhlIEFycmF5IHRoYXQgaXQgaXMgZm91bmQgaW4uXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIG9iamVjdC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYSBuYW1lLlxuICovXG5mdW5jdGlvbiBpc0FycmF5SXRlbUlucHV0T3JPdXRwdXROYW1lPFQ+KFxuICAgIGtleTogc3RyaW5nLCBpbmRleDogbnVtYmVyLCB2YWx1ZTogVCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKGtleSA9PT0gJ2luYm91bmROb2RlcycgfHwga2V5ID09PSAnb3V0cHV0TGF5ZXJzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ2lucHV0TGF5ZXJzJykgJiZcbiAgICAgIGluZGV4ID09PSAwICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogQ29udmVydCBhIFB5dGhvbmljIGNvbmZpZyBvYmplY3QgdG8gVHlwZVNjcmlwdCBjb25maWcgb2JqZWN0LlxuICogQHBhcmFtIHB5dGhvbmljQ29uZmlnIFRoZSBjb25maWcgb2JqZWN0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ga2V5IE9wdGlvbmFsIGtleSBuYW1lIG9mIHRoZSBvYmplY3QgYmVpbmcgY29udmVydGVkLlxuICogQHJldHVybnMgUmVzdWx0IG9mIHRoZSBjb252ZXJzaW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFB5dGhvbmljVG9UcyhcbiAgICBweXRob25pY0NvbmZpZzogUHlKc29uVmFsdWUsIGtleT86IHN0cmluZyk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdFZhbHVlIHtcbiAgaWYgKHB5dGhvbmljQ29uZmlnID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHB5dGhvbmljQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBnZW5lcmljX3V0aWxzLnRvQ2FtZWxDYXNlKHB5dGhvbmljQ29uZmlnKTtcbiAgfSBlbHNlIGlmIChcbiAgICAgICh0eXBlb2YgcHl0aG9uaWNDb25maWcgPT09ICdudW1iZXInKSB8fFxuICAgICAgKHR5cGVvZiBweXRob25pY0NvbmZpZyA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgIHJldHVybiBweXRob25pY0NvbmZpZztcbiAgfSBlbHNlIGlmIChweXRob25pY0NvbmZpZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgY29uc3QgdHNBcnJheSA9IFtdO1xuICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gcHl0aG9uaWNDb25maWcubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlMZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgaXRlbSA9IHB5dGhvbmljQ29uZmlnW2ldO1xuICAgICAgaWYgKGlzQXJyYXlJdGVtSW5wdXRPck91dHB1dE5hbWUoa2V5LCBpLCBpdGVtKSkge1xuICAgICAgICB0c0FycmF5LnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0c0FycmF5LnB1c2goY29udmVydFB5dGhvbmljVG9UcyhpdGVtLCBrZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRzQXJyYXk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdHNEaWN0OiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHB5dGhvbmljS2V5IG9mIE9iamVjdC5rZXlzKHB5dGhvbmljQ29uZmlnKSkge1xuICAgICAgY29uc3QgcHl0aG9uaWNWYWx1ZSA9IHB5dGhvbmljQ29uZmlnW3B5dGhvbmljS2V5XTtcbiAgICAgIGlmIChweXRob25pY0tleSA9PT0gJ25hbWUnICYmIHR5cGVvZiBweXRob25pY1ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdGhlICduYW1lJyBrZXkgd2l0aCBhIHN0cmluZyB2YWx1ZS4gTmFtZSB2YWx1ZXMsIHN1Y2ggYXNcbiAgICAgICAgLy8gdGhlIG5hbWVzIG9mIExheWVyc01vZGVsIGFuZCBMYXllciBpbnN0YW5jZXMsIHNob3VsZCBub3QgdW5kZXJnbyB0aGVcbiAgICAgICAgLy8gY2FtZWwtY2FzZSBjb252ZXJzaW9uLlxuICAgICAgICB0c0RpY3RbcHl0aG9uaWNLZXldID0gcHl0aG9uaWNWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRzS2V5ID0gZ2VuZXJpY191dGlscy50b0NhbWVsQ2FzZShweXRob25pY0tleSk7XG4gICAgICAgIHRzRGljdFt0c0tleV0gPSBjb252ZXJ0UHl0aG9uaWNUb1RzKHB5dGhvbmljVmFsdWUsIHRzS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRzRGljdDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBUeXBlU2NyaXB0IGNvbmZpZyBvYmplY3QgdG8gUHl0aG9uIGNvbmZpZyBvYmplY3QuXG4gKiBAcGFyYW0gdHNDb25maWcgVGhlIGNvbmZpZyBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBrZXkgT3B0aW9uYWwga2V5IG5hbWUgb2YgdGhlIG9iamVjdCBiZWluZyBjb252ZXJ0ZWQuXG4gKiBAcmV0dXJucyBSZXN1bHQgb2YgdGhlIGNvbnZlcnNpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VHNUb1B5dGhvbmljKFxuICAgIHRzQ29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3RWYWx1ZSwga2V5Pzogc3RyaW5nKTogUHlKc29uVmFsdWUge1xuICBpZiAodHNDb25maWcgPT09IG51bGwgfHwgdHNDb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0c0NvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZ2VuZXJpY191dGlscy50b1NuYWtlQ2FzZSh0c0NvbmZpZyk7XG4gIH0gZWxzZSBpZiAoXG4gICAgICAodHlwZW9mIHRzQ29uZmlnID09PSAnbnVtYmVyJykgfHwgKHR5cGVvZiB0c0NvbmZpZyA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgIHJldHVybiB0c0NvbmZpZztcbiAgfSBlbHNlIGlmICh0c0NvbmZpZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgY29uc3QgcHlBcnJheSA9IFtdO1xuICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gdHNDb25maWcubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlMZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgaXRlbSA9IHRzQ29uZmlnW2ldO1xuICAgICAgaWYgKGlzQXJyYXlJdGVtSW5wdXRPck91dHB1dE5hbWUoa2V5LCBpLCBpdGVtKSkge1xuICAgICAgICBweUFycmF5LnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBweUFycmF5LnB1c2goY29udmVydFRzVG9QeXRob25pYyhpdGVtLCBrZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHB5QXJyYXk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHlEaWN0OiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHRzS2V5IG9mIE9iamVjdC5rZXlzKHRzQ29uZmlnKSkge1xuICAgICAgY29uc3QgdHNWYWx1ZSA9IHRzQ29uZmlnW3RzS2V5XTtcbiAgICAgIGNvbnN0IHB5S2V5ID0gZ2VuZXJpY191dGlscy50b1NuYWtlQ2FzZSh0c0tleSk7XG4gICAgICBpZiAoKHRzS2V5ID09PSAnbmFtZScgfHwgdHNLZXkgPT09ICdjbGFzc05hbWUnKSAmJlxuICAgICAgICAgIHR5cGVvZiB0c1ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdGhlICduYW1lJyBrZXkgd2l0aCBhIHN0cmluZyB2YWx1ZS4gTmFtZSB2YWx1ZXMsIHN1Y2ggYXNcbiAgICAgICAgLy8gdGhlIG5hbWVzIG9mIExheWVyc01vZGVsIGFuZCBMYXllciBpbnN0YW5jZXMsIHNob3VsZCBub3QgdW5kZXJnbyB0aGVcbiAgICAgICAgLy8gc25ha2UtY2FzZSBjb252ZXJzaW9uLlxuICAgICAgICBweURpY3RbcHlLZXldID0gdHNWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB5RGljdFtweUtleV0gPSBjb252ZXJ0VHNUb1B5dGhvbmljKHRzVmFsdWUsIHRzS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHB5RGljdDtcbiAgfVxufVxuIl19","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/** Utility functions related to user-defined metadata. */\n// Maximum recommended serialized size for user-defined metadata.\n// Beyond this limit, a warning message will be printed during model loading and\n// saving.\nexport const MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH = 1 * 1024 * 1024;\n/**\n * Check validity of user-defined metadata.\n *\n * @param userDefinedMetadata\n * @param modelName Name of the model that the user-defined metadata belongs to.\n *   Used during construction of error messages.\n * @param checkSize Whether to check the size of the metadata is under\n *   recommended limit. Default: `false`. If `true`, will try stringify the\n *   JSON object and print a console warning if the serialzied size is above the\n *   limit.\n * @throws Error if `userDefinedMetadata` is not a plain JSON object.\n */\nexport function checkUserDefinedMetadata(userDefinedMetadata, modelName, checkSize = false) {\n    if (userDefinedMetadata == null ||\n        typeof userDefinedMetadata !== 'object' ||\n        Object.getPrototypeOf(userDefinedMetadata) !== Object.prototype ||\n        !plainObjectCheck(userDefinedMetadata)) {\n        throw new Error('User-defined metadata is expected to be a JSON object, but is not.');\n    }\n    if (checkSize) {\n        const out = JSON.stringify(userDefinedMetadata);\n        if (out.length > MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH) {\n            console.warn(`User-defined metadata of model \"${modelName}\" is too large in ` +\n                `size (length=${out.length} when serialized). It is not ` +\n                `recommended to store such large objects in user-defined metadata. ` +\n                `Please make sure its serialized length is <= ` +\n                `${MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH}.`);\n        }\n    }\n}\n/**\n * Check if an input is plain JSON object or any valid subfield of it.\n *\n * @param x The input to be checked.\n * @param assertObject Whether to assert `x` is a JSON object, i.e., reject\n *   cases of arrays and primitives.\n * @return Returns `true` if and only if `x` is a plain JSON object,\n *   a JSON-valid primitive including string, number, boolean and null,\n *   or an array of the said types.\n */\n// tslint:disable-next-line:no-any\nexport function plainObjectCheck(x) {\n    if (x === null) {\n        // Note: typeof `null` is 'object', and `null` is valid in JSON.\n        return true;\n    }\n    else if (typeof x === 'object') {\n        if (Object.getPrototypeOf(x) === Object.prototype) {\n            // `x` is a JavaScript object and its prototype is Object.\n            const keys = Object.keys(x);\n            for (const key of keys) {\n                if (typeof key !== 'string') {\n                    // JSON keys must be strings.\n                    return false;\n                }\n                if (!plainObjectCheck(x[key])) { // Recursive call.\n                    return false;\n                }\n            }\n            return true;\n        }\n        else {\n            // `x` is a JavaScript object but its prototype is not Object.\n            if (Array.isArray(x)) {\n                // `x` is a JavaScript array.\n                for (const item of x) {\n                    if (!plainObjectCheck(item)) { // Recursive call.\n                        return false;\n                    }\n                }\n                return true;\n            }\n            else {\n                // `x` is a JavaScript object and its prototype is not Object,\n                // and it's not an Array. I.e., it's a complex object such as\n                // `Error` and `Date`.\n                return false;\n            }\n        }\n    }\n    else {\n        // `x` is not a JavaScript object or `null`.\n        const xType = typeof x;\n        return xType === 'string' || xType === 'number' || xType === 'boolean';\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXNlcl9kZWZpbmVkX21ldGFkYXRhLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL3VzZXJfZGVmaW5lZF9tZXRhZGF0YS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVILDBEQUEwRDtBQUUxRCxpRUFBaUU7QUFDakUsZ0ZBQWdGO0FBQ2hGLFVBQVU7QUFDVixNQUFNLENBQUMsTUFBTSwyQ0FBMkMsR0FBRyxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQztBQUUzRTs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQU0sVUFBVSx3QkFBd0IsQ0FDcEMsbUJBQXVCLEVBQUUsU0FBaUIsRUFBRSxTQUFTLEdBQUcsS0FBSztJQUMvRCxJQUFJLG1CQUFtQixJQUFJLElBQUk7UUFDM0IsT0FBTyxtQkFBbUIsS0FBSyxRQUFRO1FBQ3ZDLE1BQU0sQ0FBQyxjQUFjLENBQUMsbUJBQW1CLENBQUMsS0FBSyxNQUFNLENBQUMsU0FBUztRQUMvRCxDQUFDLGdCQUFnQixDQUFDLG1CQUFtQixDQUFDLEVBQUU7UUFDMUMsTUFBTSxJQUFJLEtBQUssQ0FDWCxvRUFBb0UsQ0FBQyxDQUFDO0tBQzNFO0lBRUQsSUFBSSxTQUFTLEVBQUU7UUFDYixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDaEQsSUFBSSxHQUFHLENBQUMsTUFBTSxHQUFHLDJDQUEyQyxFQUFFO1lBQzVELE9BQU8sQ0FBQyxJQUFJLENBQ1IsbUNBQW1DLFNBQVMsb0JBQW9CO2dCQUNoRSxnQkFBZ0IsR0FBRyxDQUFDLE1BQU0sK0JBQStCO2dCQUN6RCxvRUFBb0U7Z0JBQ3BFLCtDQUErQztnQkFDL0MsR0FBRywyQ0FBMkMsR0FBRyxDQUFDLENBQUM7U0FDeEQ7S0FDRjtBQUNILENBQUM7QUFFRDs7Ozs7Ozs7O0dBU0c7QUFDSCxrQ0FBa0M7QUFDbEMsTUFBTSxVQUFVLGdCQUFnQixDQUFDLENBQU07SUFDckMsSUFBSSxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ2QsZ0VBQWdFO1FBQ2hFLE9BQU8sSUFBSSxDQUFDO0tBQ2I7U0FBTSxJQUFJLE9BQU8sQ0FBQyxLQUFLLFFBQVEsRUFBRTtRQUNoQyxJQUFJLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxDQUFDLFNBQVMsRUFBRTtZQUNqRCwwREFBMEQ7WUFDMUQsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QixLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTtnQkFDdEIsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7b0JBQzNCLDZCQUE2QjtvQkFDN0IsT0FBTyxLQUFLLENBQUM7aUJBQ2Q7Z0JBQ0QsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUcsa0JBQWtCO29CQUNsRCxPQUFPLEtBQUssQ0FBQztpQkFDZDthQUNGO1lBQ0QsT0FBTyxJQUFJLENBQUM7U0FDYjthQUFNO1lBQ0wsOERBQThEO1lBQzlELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDcEIsNkJBQTZCO2dCQUM3QixLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsRUFBRTtvQkFDcEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUcsa0JBQWtCO3dCQUNoRCxPQUFPLEtBQUssQ0FBQztxQkFDZDtpQkFDRjtnQkFDRCxPQUFPLElBQUksQ0FBQzthQUNiO2lCQUFNO2dCQUNMLDhEQUE4RDtnQkFDOUQsNkRBQTZEO2dCQUM3RCxzQkFBc0I7Z0JBQ3RCLE9BQU8sS0FBSyxDQUFDO2FBQ2Q7U0FDRjtLQUNGO1NBQU07UUFDTCw0Q0FBNEM7UUFDNUMsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLENBQUM7UUFDdkIsT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssS0FBSyxRQUFRLElBQUksS0FBSyxLQUFLLFNBQVMsQ0FBQztLQUN4RTtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKiogVXRpbGl0eSBmdW5jdGlvbnMgcmVsYXRlZCB0byB1c2VyLWRlZmluZWQgbWV0YWRhdGEuICovXG5cbi8vIE1heGltdW0gcmVjb21tZW5kZWQgc2VyaWFsaXplZCBzaXplIGZvciB1c2VyLWRlZmluZWQgbWV0YWRhdGEuXG4vLyBCZXlvbmQgdGhpcyBsaW1pdCwgYSB3YXJuaW5nIG1lc3NhZ2Ugd2lsbCBiZSBwcmludGVkIGR1cmluZyBtb2RlbCBsb2FkaW5nIGFuZFxuLy8gc2F2aW5nLlxuZXhwb3J0IGNvbnN0IE1BWF9VU0VSX0RFRklORURfTUVUQURBVEFfU0VSSUFMSVpFRF9MRU5HVEggPSAxICogMTAyNCAqIDEwMjQ7XG5cbi8qKlxuICogQ2hlY2sgdmFsaWRpdHkgb2YgdXNlci1kZWZpbmVkIG1ldGFkYXRhLlxuICpcbiAqIEBwYXJhbSB1c2VyRGVmaW5lZE1ldGFkYXRhXG4gKiBAcGFyYW0gbW9kZWxOYW1lIE5hbWUgb2YgdGhlIG1vZGVsIHRoYXQgdGhlIHVzZXItZGVmaW5lZCBtZXRhZGF0YSBiZWxvbmdzIHRvLlxuICogICBVc2VkIGR1cmluZyBjb25zdHJ1Y3Rpb24gb2YgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gY2hlY2tTaXplIFdoZXRoZXIgdG8gY2hlY2sgdGhlIHNpemUgb2YgdGhlIG1ldGFkYXRhIGlzIHVuZGVyXG4gKiAgIHJlY29tbWVuZGVkIGxpbWl0LiBEZWZhdWx0OiBgZmFsc2VgLiBJZiBgdHJ1ZWAsIHdpbGwgdHJ5IHN0cmluZ2lmeSB0aGVcbiAqICAgSlNPTiBvYmplY3QgYW5kIHByaW50IGEgY29uc29sZSB3YXJuaW5nIGlmIHRoZSBzZXJpYWx6aWVkIHNpemUgaXMgYWJvdmUgdGhlXG4gKiAgIGxpbWl0LlxuICogQHRocm93cyBFcnJvciBpZiBgdXNlckRlZmluZWRNZXRhZGF0YWAgaXMgbm90IGEgcGxhaW4gSlNPTiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1VzZXJEZWZpbmVkTWV0YWRhdGEoXG4gICAgdXNlckRlZmluZWRNZXRhZGF0YToge30sIG1vZGVsTmFtZTogc3RyaW5nLCBjaGVja1NpemUgPSBmYWxzZSk6IHZvaWQge1xuICBpZiAodXNlckRlZmluZWRNZXRhZGF0YSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdXNlckRlZmluZWRNZXRhZGF0YSAhPT0gJ29iamVjdCcgfHxcbiAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZih1c2VyRGVmaW5lZE1ldGFkYXRhKSAhPT0gT2JqZWN0LnByb3RvdHlwZSB8fFxuICAgICAgIXBsYWluT2JqZWN0Q2hlY2sodXNlckRlZmluZWRNZXRhZGF0YSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVc2VyLWRlZmluZWQgbWV0YWRhdGEgaXMgZXhwZWN0ZWQgdG8gYmUgYSBKU09OIG9iamVjdCwgYnV0IGlzIG5vdC4nKTtcbiAgfVxuXG4gIGlmIChjaGVja1NpemUpIHtcbiAgICBjb25zdCBvdXQgPSBKU09OLnN0cmluZ2lmeSh1c2VyRGVmaW5lZE1ldGFkYXRhKTtcbiAgICBpZiAob3V0Lmxlbmd0aCA+IE1BWF9VU0VSX0RFRklORURfTUVUQURBVEFfU0VSSUFMSVpFRF9MRU5HVEgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgVXNlci1kZWZpbmVkIG1ldGFkYXRhIG9mIG1vZGVsIFwiJHttb2RlbE5hbWV9XCIgaXMgdG9vIGxhcmdlIGluIGAgK1xuICAgICAgICAgIGBzaXplIChsZW5ndGg9JHtvdXQubGVuZ3RofSB3aGVuIHNlcmlhbGl6ZWQpLiBJdCBpcyBub3QgYCArXG4gICAgICAgICAgYHJlY29tbWVuZGVkIHRvIHN0b3JlIHN1Y2ggbGFyZ2Ugb2JqZWN0cyBpbiB1c2VyLWRlZmluZWQgbWV0YWRhdGEuIGAgK1xuICAgICAgICAgIGBQbGVhc2UgbWFrZSBzdXJlIGl0cyBzZXJpYWxpemVkIGxlbmd0aCBpcyA8PSBgICtcbiAgICAgICAgICBgJHtNQVhfVVNFUl9ERUZJTkVEX01FVEFEQVRBX1NFUklBTElaRURfTEVOR1RIfS5gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBpbnB1dCBpcyBwbGFpbiBKU09OIG9iamVjdCBvciBhbnkgdmFsaWQgc3ViZmllbGQgb2YgaXQuXG4gKlxuICogQHBhcmFtIHggVGhlIGlucHV0IHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0gYXNzZXJ0T2JqZWN0IFdoZXRoZXIgdG8gYXNzZXJ0IGB4YCBpcyBhIEpTT04gb2JqZWN0LCBpLmUuLCByZWplY3RcbiAqICAgY2FzZXMgb2YgYXJyYXlzIGFuZCBwcmltaXRpdmVzLlxuICogQHJldHVybiBSZXR1cm5zIGB0cnVlYCBpZiBhbmQgb25seSBpZiBgeGAgaXMgYSBwbGFpbiBKU09OIG9iamVjdCxcbiAqICAgYSBKU09OLXZhbGlkIHByaW1pdGl2ZSBpbmNsdWRpbmcgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4gYW5kIG51bGwsXG4gKiAgIG9yIGFuIGFycmF5IG9mIHRoZSBzYWlkIHR5cGVzLlxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG5leHBvcnQgZnVuY3Rpb24gcGxhaW5PYmplY3RDaGVjayh4OiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKHggPT09IG51bGwpIHtcbiAgICAvLyBOb3RlOiB0eXBlb2YgYG51bGxgIGlzICdvYmplY3QnLCBhbmQgYG51bGxgIGlzIHZhbGlkIGluIEpTT04uXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgLy8gYHhgIGlzIGEgSmF2YVNjcmlwdCBvYmplY3QgYW5kIGl0cyBwcm90b3R5cGUgaXMgT2JqZWN0LlxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHgpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBKU09OIGtleXMgbXVzdCBiZSBzdHJpbmdzLlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsYWluT2JqZWN0Q2hlY2soeFtrZXldKSkgeyAgLy8gUmVjdXJzaXZlIGNhbGwuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYHhgIGlzIGEgSmF2YVNjcmlwdCBvYmplY3QgYnV0IGl0cyBwcm90b3R5cGUgaXMgbm90IE9iamVjdC5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICAgIC8vIGB4YCBpcyBhIEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB4KSB7XG4gICAgICAgICAgaWYgKCFwbGFpbk9iamVjdENoZWNrKGl0ZW0pKSB7ICAvLyBSZWN1cnNpdmUgY2FsbC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBgeGAgaXMgYSBKYXZhU2NyaXB0IG9iamVjdCBhbmQgaXRzIHByb3RvdHlwZSBpcyBub3QgT2JqZWN0LFxuICAgICAgICAvLyBhbmQgaXQncyBub3QgYW4gQXJyYXkuIEkuZS4sIGl0J3MgYSBjb21wbGV4IG9iamVjdCBzdWNoIGFzXG4gICAgICAgIC8vIGBFcnJvcmAgYW5kIGBEYXRlYC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBgeGAgaXMgbm90IGEgSmF2YVNjcmlwdCBvYmplY3Qgb3IgYG51bGxgLlxuICAgIGNvbnN0IHhUeXBlID0gdHlwZW9mIHg7XG4gICAgcmV0dXJuIHhUeXBlID09PSAnc3RyaW5nJyB8fCB4VHlwZSA9PT0gJ251bWJlcicgfHwgeFR5cGUgPT09ICdib29sZWFuJztcbiAgfVxufVxuIl19"],"names":["printSummary","model","lineLength","positions","printFn","console","log","sequentialLike","nodesByDepth","nodes","depth","push","depthNodes","length","inboundLayers","layer","layers","flag","node","inboundNodes","indexOf","isModelSequentialLike","toDisplay","relevantNodes","map","p","Math","floor","repeat","printRow","i","printLayerSummary","printLayerSummaryWithConnections","checkTrainableWeightsConsistency","trainableCount","collectedTrainableWeights","trainableWeights","countTrainableParams","nonTrainableCount","nonTrainableWeights","fields","line","slice","outputShape","inputShape","x","JSON","stringify","inputShapes","join","err","name","getClassName","countParams","toString","connections","inboundLayer","inboundLayerIndex","nodeIndices","inboundTensorIndex","tensorIndices","className","firstConnection","LruCache","constructor","maxEntries","this","cache","Map","get","key","entry","has","delete","set","put","value","size","keyToDelete","keys","next","getMaxEntries","setMaxEntries","Error","getOptimizer","identifier","optimizerMap","train","adagrad","adadelta","adam","adamax","rmsprop","sgd","pyListRepeat","numValues","Array","isArray","newArray","concat","fill","assert","val","message","count","array","refernce","counter","item","singletonOrArray","xs","toList","toSnakeCase","insecure","replace","toLowerCase","toCamelCase","m","p1","toUpperCase","_GLOBAL_CUSTOM_OBJECTS","serializeKerasObject","instance","undefined","dict","getConfig","convertNDArrayScalarsInConfig","config","forEach","configItem","Object","field","deserializeKerasObject","moduleObjects","customObjects","printableModuleName","fastWeightInit","functionName","fn","cls","fromConfig","customObjectsCombined","backupCustomObjects","assign","returnObj","reverseNumberCompare","a","b","numberCompare","unique","out","isObjectEmpty","obj","hasOwnProperty","checkStringTypeUnionValue","values","label","checkArrayTypeAndLength","expectedType","minLength","maxLength","Infinity","every","e","assertPositiveInteger","util","v","Number","isInteger","formatAsFriendlyString","debounce","f","waitMs","nowFunc","lastResult","lastTime","args","now","mapActivationToFusedKernel","activationName","countParamsInWeights","weights","weight","shape","reduce","isArrayOfShapes","normalizeShapeList","getExactlyOneTensor","getExactlyOneShape","shapes","normalizeArray","n","singleValue","convOutputLength","inputLength","filterSize","padding","stride","dilation","outputLength","deconvLength","dimSize","strideSize","kernelSize","parseInt","arrayProd","begin","end","prod","min","NaN","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","range","assertObjectArgs","Regularizer","serialization","L1L2","super","l1","l2","hasL1","hasL2","apply","tidy","regularization","zeros","add","sum","abs","REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP","serializeRegularizer","constraint","deserializeRegularizer","getMap","classNameMap","getRegularizer","isArrayItemInputOrOutputName","index","convertPythonicToTs","pythonicConfig","tsArray","arrayLength","tsDict","pythonicKey","pythonicValue","tsKey","convertTsToPythonic","tsConfig","pyArray","pyDict","tsValue","pyKey","checkUserDefinedMetadata","userDefinedMetadata","modelName","checkSize","getPrototypeOf","prototype","plainObjectCheck","xType"],"sourceRoot":""}