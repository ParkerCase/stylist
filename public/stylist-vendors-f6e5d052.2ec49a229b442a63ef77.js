"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[8266],{7175:function(t,e,i){i.d(e,{r:function(){return r}});const r="4.22.0"},7766:function(t,e,i){i.d(e,{jG:function(){return o}});var r=i(9495),s=i(7391),n=i(52619),a=i(63284);class o{constructor(){this.size=null}batch(t,e=!0){const i=this;let s;return r.util.assert(t>0,(()=>`batchSize needs to be positive, but it is\n      ${t}`)),s=this.size===1/0||null==this.size?this.size:e?Math.ceil(this.size/t):Math.floor(this.size/t),u((async()=>(await i.iterator()).columnMajorBatch(t,e,c)),s)}concatenate(t){const e=this;let i;return i=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null,u((async()=>(await e.iterator()).concatenate(await t.iterator())),i)}filter(t){const e=this;let i;return i=this.size===1/0?1/0:null,u((async()=>(await e.iterator()).filter((e=>r.tidy((()=>t(e)))))),i)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){const e=this;return u((async()=>(await e.iterator()).map((e=>r.tidy((()=>t(e)))))),this.size)}mapAsync(t){const e=this;return u((async()=>(await e.iterator()).mapAsync(t)),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return u((async()=>(await e.iterator()).prefetch(t)),this.size)}repeat(t){const e=this;let i;return i=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null,u((async()=>{const i=(0,n.ht)((async()=>({value:await e.iterator(),done:!1})));return(0,n.kP)(i.take(t))}),i)}skip(t){const e=this;let i;return i=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null,u((async()=>(await e.iterator()).skip(t)),i)}shuffle(t,e,i=!0){if(null==t||t<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const n=this,a=s.alea(e||r.util.now().toString());return u((async()=>{let e=a.int32();return i&&(e+=a.int32()),(await n.iterator()).shuffle(t,e.toString())}),this.size)}take(t){const e=this;let i;return i=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null,u((async()=>(await e.iterator()).take(t)),i)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function u(t,e=null){return new class extends o{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function c(t){if(null===t)return null;const e=t[0];if((0,a.mf)(e)){return{value:function(t){if(0===t.length)throw new Error("Can't make a batch of zero elements.");return t[0]instanceof r.Tensor?r.stack(t):r.tensor(t)}(t),recurse:!1}}return{value:null,recurse:!0}}o.MAX_BUFFER_SIZE=1e4},71591:function(t,e,i){i.d(e,{g:function(){return s}});var r=i(7766);class s extends r.jG{constructor(t){super(),this.input=t}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((t=>(t.endsWith("\r")&&(t=t.slice(0,-1)),t)))}}},91773:function(t,e,i){i.d(e,{q:function(){return r}});class r{}},96109:function(t,e,i){i(9495);var r=i(7766);i(71591);Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");r.jG}}]);
//# sourceMappingURL=stylist-vendors-f6e5d052.2ec49a229b442a63ef77.js.map