"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[1287],{1404:function(n,t,e){e.d(t,{R:function(){return i}});var o=e(92394);class i{constructor(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;let e="";for(let o=0;o<4;o++){let n="thisRC = rc;";o%2===1&&(n+="thisRC.z += 1;"),o>1&&(n+="thisRC.y += 1;"),e+=`\n        ${n}\n        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${o}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${o>0?"}":""}\n      `}var i;this.userCode=`\n      ${i=t,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${o.UG(["r","c","d"],i)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${o.fM(n)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${n[1]};\n        int cols = ${n[2]};\n\n        ${e}\n\n        setOutput(result);\n      }\n    `}}},5144:function(n,t,e){e.d(t,{V:function(){return r}});var o=e(75694),i=e(27575);class r{constructor(n){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.rank=n.length;const t=(0,i.b)(this.rank),e=(0,o.Jp)("coords",this.rank),r=(0,o.Jp)("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,u=`getChannel(getSource(${r.join()}), ${a})`,c=`\n      result.x = ${u};\n      if (++${e[this.rank-1]} < ${n[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${u};\n        --${r[this.rank-1]};\n      }\n    `,s=1===this.rank?"":`\n      --${e[this.rank-1]};\n      if (++${e[this.rank-2]} < ${n[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${u};\n        if (++${e[this.rank-1]} < ${n[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${u};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${n.map(((n,t)=>`start[${t}]`)).join()});`:n.map(((n,t)=>`${r[t]} = ${e[t]} + start[${t}];`)).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${c}\n        ${s}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(n){if(n.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${n.length})`);return(t,e)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(e,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,n)}}}},6917:function(n,t,e){e.d(t,{$:function(){return o}});class o{constructor(n,t,e,o,i){this.variableNames=["A"],this.outputShape=[];const[r,a,u,c]=n;this.outputShape=[r,t,e,c];const s=[o&&t>1?a-1:a,o&&e>1?u-1:u],l=[o&&t>1?t-1:t,o&&e>1?e-1:e],d=o?"0.5":"0.0";let f;f=i?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${s[0]/l[0]},\n          ${s[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}},8939:function(n,t,e){e.d(t,{$:function(){return i}});var o=e(27575);class i{constructor(n,t,e,i,r,a,u=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const c=(0,o.b)(r.length),s=(0,o.b)(a.length);let l="";1===e?l="i":2===e&&(l="i, j");const d=`getIndices(${l})`;let f="";1===i?f="i":2===i&&(f="i, coords[1]");const h=`getUpdates(${f})`,x=t>1?"strides[j]":"strides";this.userCode=`\n        ${c} strides = ${c}(${r});\n\n        void main() {\n          ${s} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${n}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${d});\n              flattenedIndex += index * ${x};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}},10043:function(n,t,e){e.d(t,{J:function(){return i}});var o=e(27575);class i{constructor(n){this.variableNames=["source"],this.outputShape=n,this.rank=n.length;const t=(0,o.b)(this.rank),e=`uniform int start[${this.rank}];`,i=function(n){if(1===n)return"sourceLoc";if(n<=6)return r.slice(0,n).map((n=>"sourceLoc."+n)).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let a;a=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${n.map(((n,t)=>`sourceLoc.${r[t]} = start[${t}] + coords.${r[t]};`)).join("\n")}\n      `,this.userCode=`\n      ${e}\n      void main() {\n        ${a}\n        setOutput(getSource(${i}));\n      }\n    `}getCustomSetupFunc(n){if(n.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${n.length})`);return(t,e)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(e,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,n)}}}const r=["x","y","z","w","u","v"]},11039:function(n,t,e){e.d(t,{U:function(){return i}});var o=e(27575);class i{constructor(n,t,e){this.variableNames=["x"],this.outputShape=e;const i=e.length,r=(0,o.b)(e.length),a=(0,o.b)(e.length);let u="";if(1===i)u="coords * strides + begin";else{let n=0;u=e.map(((t,o)=>(n++,1===e.length?`coords * strides[${o}] + begin[${o}]`:`coords[${n-1}] * strides[${o}] + begin[${o}]`))).join(",")}this.userCode=`\n      ${r} begin = ${r}(${n});\n      ${r} strides = ${r}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${u}));\n      }\n    `}}},11601:function(n,t,e){e.d(t,{_:function(){return r}});var o=e(75694),i=e(27575);class r{constructor(n,t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,e)=>t[0]+n[e]+t[1]));const r=n.length,a=(0,i.b)(r),u=t.map((n=>n[0])).join(","),c=t.map(((t,e)=>t[0]+n[e])).join(","),s=(0,o.Jp)("rc",r),l=(0,o.Jp)("source",r),d=`${s[r-1]} < ${this.outputShape[r-1]}`,f=1===r?"source":`vec2(${l.slice(-2).join()})`,h=[`${a} rc = outputLoc;`,`${s[r-1]} += 1;\n       if(${d}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${s[r-2]} += 1;\n       if(${s[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${s[r-1]} += 1;\n         if(${d}) {`],x=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let o=0,i=1===r?2:4;o<i;o++)p+=`\n        ${h[o]}\n        if (${x}) {\n          result[${o}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${o}] = getChannel(getX(${l.join()}), ${f});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${u});\n      const ${a} end = ${a}(${c});\n      uniform float value;\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(n){return(t,e)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(e,"value")),t.gl.uniform1f(this.valueLoc,n)}}}},16853:function(n,t,e){e.d(t,{x:function(){return o}});class o{constructor(n,t,e,o,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[r,a,u,c]=n;this.outputShape=[r,t,e,c];const s=[o&&t>1?a-1:a,o&&e>1?u-1:u],l=[o&&t>1?t-1:t,o&&e>1?e-1:e];let d;d=i?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${s[0]/l[0]},\n          ${s[1]/l[1]},\n          ${s[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${e-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}},18541:function(n,t,e){e.d(t,{t:function(){return o}});class o{constructor(n,t){this.variableNames=["x"];const{windowSize:e,batchSize:o,inSize:i,outSize:r}=n;this.outputShape=[o,r];let a="0.0",u="";"prod"===t?a="1.0":"min"===t?(a="1.0 / 1e-20",u="min"):"max"===t&&(a="-1.0 / 1e-20",u="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");const s=4*Math.floor(e/4),l=e%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${u}(values, minMaxValue);\n      }\n    `,f="vec4";"all"===t?(a="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===t&&(a="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");let h="";i%e>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${e};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${1===l}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===l}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===l}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${c});\n      }\n    `}}},26180:function(n,t,e){e.d(t,{z:function(){return o}});class o{constructor(n,t,e,o,i){this.variableNames=["A"],this.outputShape=[];const[r,a,u,c]=n;this.outputShape=[r,t,e,c];const s=[o&&t>1?a-1:a,o&&e>1?u-1:u],l=[o&&t>1?t-1:t,o&&e>1?e-1:e];let d;d=i?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${s[0]/l[0]},\n          ${s[1]/l[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}},27436:function(n,t,e){e.d(t,{x:function(){return o}});class o{constructor(n,t,e){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,o,i]=t,[,r,a]=n,u=[e&&r>1?o-1:o,e&&a>1?i-1:i],c=[e&&r>1?r-1:r,e&&a>1?a-1:a],s=u[0]/c[0],l=u[1]/c[1],d=1/s,f=1/l,h=2*Math.ceil(d)+2,x=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${s});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${x});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${r}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${u[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${u[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${o}) - 1),\n                ${e} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${i}) - 1),\n                ${e} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}},27575:function(n,t,e){e.d(t,{b:function(){return v},y:function(){return u}});var o=e(9495),i=e(18765),r=e(92394);const{getBroadcastDims:a}=o.backend_util;function u(n,t,e,u){const p=[];n.forEach((n=>{const t=o.util.sizeFromShape(n.shapeInfo.logicalShape);n.shapeInfo.isUniform?p.push(`uniform float ${n.name}${t>1?`[${t}]`:""};`):(p.push(`uniform sampler2D ${n.name};`),p.push(`uniform int offset${n.name};`))}));const $=p.join("\n"),C=n.map((n=>function(n,t,e=!1){let i="";i+=e?s(n):c(n);const r=n.shapeInfo.logicalShape,u=t.logicalShape;r.length<=u.length&&(i+=e?function(n,t){const e=n.name,i=e.charAt(0).toUpperCase()+e.slice(1),r="get"+i+"AtOutCoords",u=n.shapeInfo.logicalShape.length,c=t.logicalShape.length,s=a(n.shapeInfo.logicalShape,t.logicalShape),l=v(c),d=c-u;let f;const h=["x","y","z","w","u","v"];f=0===u?"":c<2&&s.length>=1?"coords = 0;":s.map((n=>`coords.${h[n+d]} = 0;`)).join("\n");let x="";x=c<2&&u>0?"coords":n.shapeInfo.logicalShape.map(((n,t)=>`coords.${h[t+d]}`)).join(", ");let p="return outputValue;";const $=1===o.util.sizeFromShape(n.shapeInfo.logicalShape),C=o.util.sizeFromShape(t.logicalShape),g=1===C;if(1!==u||$||g){if($&&!g)p=1===c?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(s.length){const n=u-2,t=u-1;s.indexOf(n)>-1&&s.indexOf(t)>-1?p="return vec4(outputValue.x);":s.indexOf(n)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":s.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${r}() {\n      ${l} coords = getOutputCoords();\n      ${f}\n      vec4 outputValue = get${i}(${x});\n      ${p}\n    }\n  `}(n,t):function(n,t){const e=n.name,i=e.charAt(0).toUpperCase()+e.slice(1),r="get"+i+"AtOutCoords",u=t.texShape,c=n.shapeInfo.texShape,s=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&s===l&&null==n.shapeInfo.flatOffset&&o.util.arraysEqual(c,u))return`\n      float ${r}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const d=v(l),f=a(n.shapeInfo.logicalShape,t.logicalShape),h=l-s;let x;const p=["x","y","z","w","u","v"];x=0===s?"":l<2&&f.length>=1?"coords = 0;":f.map((n=>`coords.${p[n+h]} = 0;`)).join("\n");let $="";$=l<2&&s>0?"coords":n.shapeInfo.logicalShape.map(((n,t)=>`coords.${p[t+h]}`)).join(", ");return`\n    float ${r}() {\n      ${d} coords = getOutputCoords();\n      ${x}\n      return get${i}(${$});\n    }\n  `}(n,t));return i}(n,t,u))).join("\n"),g=t.texShape,m=(0,i.B)(),R=function(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(m);let w,y,V=function(n){const t=`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${l}\n    ${d}\n    ${f}\n  `;return t}(m);t.isPacked?(w=function(n,t){switch(n.length){case 0:return x();case 1:return function(n,t){const e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===e[0])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${e[1]}.0);\n      }\n    `;if(1===e[1])return`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${e[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      return 2 * (resTexRC.x * ${e[1]} + resTexRC.y);\n    }\n  `}(0,t);case 2:return function(n,t){const e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(o.util.arraysEqual(n,t))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));\n      }\n    `;const i=Math.ceil(n[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t);case 3:return function(n,t){const e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(n[2]/2),i=o*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t);default:return function(n,t){const e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(n[n.length-1]/2),i=o*Math.ceil(n[n.length-2]/2);let r=i,a="",u="b, r, c";for(let c=2;c<n.length-1;c++)r*=n[n.length-c-1],a=`\n      int b${c} = index / ${r};\n      index -= b${c} * ${r};\n    `+a,u=`b${c}, `+u;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${e[0]}, ${e[1]}));\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\n\n      ${a}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec${n.length}(${u});\n    }\n  `}(n,t)}}(t.logicalShape,g),y=function(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(m)):(w=function(n,t){switch(n.length){case 0:return x();case 1:return function(n,t){if(1===t[0])return`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t);case 2:return function(n,t){if(o.util.arraysEqual(n,t))return`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===n[1])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===n[0])return`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t);case 3:return function(n,t){const e=r.UG(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${e}\n      return ivec3(r, c, d);\n    }\n  `}(n,t);case 4:return function(n,t){const e=r.UG(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${e}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t);case 5:return function(n,t){const e=r.UG(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function(n,t){const e=r.UG(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,g),y=function(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(m)),u&&(V+=h);return[V,R,y,$,w,C,e].join("\n")}function c(n){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return function(n){const t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${e}() {return ${t};}`;const[o,i]=n.shapeInfo.texShape;if(1===o&&1===i)return`\n      float ${e}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const[r,a]=n.shapeInfo.texShape,u=p(t);return`\n    float ${e}() {\n      vec2 uv = uvFromFlat(${r}, ${a}, ${u});\n      return sampleTexture(${t}, uv);\n    }\n  `}(n);case 1:return function(n){const t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${e}(int index) {\n        ${$(n)}\n      }\n    `;const o=n.shapeInfo.texShape,i=o[0],r=o[1];if(1===r&&1===i)return`\n      float ${e}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const a=p(t);if(1===r)return`\n      float ${e}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `;if(1===i)return`\n      float ${e}(int index) {\n        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${r}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `;return`\n    float ${e}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${r}, index + ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `}(n);case 2:return function(n){const t=n.shapeInfo.logicalShape,e=n.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1),r=n.shapeInfo.texShape;if(null!=r&&o.util.arraysEqual(t,r)){const n=r[0];return`\n    float ${i}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${r[1]}.0, ${n}.0);\n      return sampleTexture(${e}, uv);\n    }\n  `}const{newShape:a,keptDims:u}=o.util.squeezeShape(t),s=a;if(s.length<t.length){const t=["row","col"];return`\n      ${c(C(n,s))}\n      float ${i}(int row, int col) {\n        return ${i}(${g(t,u)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${$(n)}\n      }\n    `;const l=r[0],d=r[1],f=p(e);if(1===d)return`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);\n      return sampleTexture(${e}, uv);\n    }\n  `;if(1===l)return`\n    float ${i}(int row, int col) {\n      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n      return sampleTexture(${e}, uv);\n    }\n  `;return`\n  float ${i}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${f};\n    vec2 uv = uvFromFlat(${l}, ${d}, index);\n    return sampleTexture(${e}, uv);\n  }\n`}(n);case 3:return function(n){const t=n.shapeInfo.logicalShape,e=n.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[1]*t[2],a=t[2],{newShape:u,keptDims:s}=o.util.squeezeShape(t),l=u;if(l.length<t.length){const t=["row","col","depth"];return`\n        ${c(C(n,l))}\n        float ${i}(int row, int col, int depth) {\n          return ${i}(${g(t,s)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${r}, ${a}, 1)));\n        ${$(n)}\n      }\n    `;const d=n.shapeInfo.texShape,f=d[0],h=d[1],x=n.shapeInfo.flatOffset;if(h===r&&null==x)return`\n        float ${i}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${f}.0);\n          return sampleTexture(${e}, uv);\n        }\n      `;if(h===a&&null==x)return`\n    float ${i}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${f}.0);\n      return sampleTexture(${e}, uv);\n    }\n  `;const v=p(e);return`\n      float ${i}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r} + col * ${a} + depth + ${v};\n        vec2 uv = uvFromFlat(${f}, ${h}, index);\n        return sampleTexture(${e}, uv);\n      }\n  `}(n);case 4:return function(n){const t=n.shapeInfo.logicalShape,e=n.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[3],a=t[2]*r,u=t[1]*a,{newShape:s,keptDims:l}=o.util.squeezeShape(t);if(s.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${c(C(n,s))}\n      float ${i}(int row, int col, int depth, int depth2) {\n        return ${i}(${g(t,l)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${u}, ${a}, ${r}, 1)));\n        ${$(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,h=f[0],x=f[1];if(x===u&&null==d)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${x}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(x===r&&null==d)return`\n      float ${i}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${x}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;const v=p(e);return`\n    float ${i}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${u} + col * ${a} +\n          depth * ${r} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${x}, index + ${v});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 5:return function(n){const t=n.shapeInfo.logicalShape,e=n.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[4],a=t[3]*r,u=t[2]*a,s=t[1]*u,{newShape:l,keptDims:d}=o.util.squeezeShape(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${c(C(n,l))}\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        return ${i}(${g(t,d)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${s}, ${u}, ${a}, ${r})) +\n          depth3;\n        ${$(n)}\n      }\n    `;const f=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,x=h[0],v=h[1];if(v===s&&null==f)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${u}, ${a}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${v}.0, ${x}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(v===r&&null==f)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${v}.0, ${x}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;const m=p(e);return`\n    float ${i}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${s} + col * ${u} + depth * ${a} +\n          depth2 * ${r} + depth3 + ${m};\n      vec2 uv = uvFromFlat(${x}, ${v}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function(n){const t=n.shapeInfo.logicalShape,e=n.name,i="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:r,keptDims:a}=o.util.squeezeShape(t);if(r.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${c(C(n,r))}\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${i}(${g(t,a)});\n      }\n    `}const u=t[5],s=t[4]*u,l=t[3]*s,d=t[2]*l,f=t[1]*d;if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${f}, ${d}, ${l}, ${s})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${u}, 1)));\n        ${$(n)}\n      }\n    `;const h=n.shapeInfo.flatOffset,x=n.shapeInfo.texShape,v=x[0],m=x[1];if(m===f&&null==h)return`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${d}, ${l}, ${s}, ${u})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${v}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(m===u&&null==h)return`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${v}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;const R=p(e);return`\n    float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${f} + col * ${d} + depth * ${l} +\n          depth2 * ${s} + depth3 * ${u} + depth4 + ${R};\n      vec2 uv = uvFromFlat(${v}, ${m}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function s(n){switch(n.shapeInfo.logicalShape.length){case 0:return function(n){const t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),o=(0,i.B)();return`\n    vec4 ${e}() {\n      return ${o.texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function(n){const t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),o=n.shapeInfo.texShape,r=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],a=(0,i.B)();return`\n    vec4 ${e}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${r[0]}, ${r[1]}, index);\n      return ${a.texture2D}(${t}, uv);\n    }\n  `}(n);case 2:return function(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),a=n.shapeInfo.texShape,u=a[0],c=a[1],s=(0,i.B)();if(null!=a&&o.util.arraysEqual(t,a))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${c}.0, ${u}.0);\n\n        return ${s.texture2D}(${e}, uv);\n      }\n    `;const l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],d=Math.ceil(t[1]/2);return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${d}, ${l[0]}, ${l[1]}, row, col);\n      return ${s.texture2D}(${e}, uv);\n    }\n  `}(n);case 3:return function(n){const t=n.shapeInfo.logicalShape,e=n.name,o="get"+e.charAt(0).toUpperCase()+e.slice(1),r=n.shapeInfo.texShape,a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(1===t[0]){const e=[1,2],i=["b","row","col"];return`\n        ${s(C(n,t.slice(1)))}\n        vec4 ${o}(int b, int row, int col) {\n          return ${o}(${g(i,e)});\n        }\n      `}const u=a[0],c=a[1],l=Math.ceil(t[2]/2),d=l*Math.ceil(t[1]/2),f=(0,i.B)();return`\n    vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${c}, ${d}, ${l}, b, row, col);\n      return ${f.texture2D}(${e}, uv);\n    }\n  `}(n);default:return function(n){const t=n.shapeInfo.logicalShape,e=t.length,o=n.name,r="get"+o.charAt(0).toUpperCase()+o.slice(1),a=n.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=u[0],s=u[1],l=Math.ceil(t[e-1]/2);let d=l*Math.ceil(t[e-2]/2),f="int b, int row, int col",h=`b * ${d} + (row / 2) * ${l} + (col / 2)`;for(let i=2;i<e-1;i++)f=`int b${i}, `+f,d*=t[e-i-1],h=`b${i} * ${d} + `+h;const x=(0,i.B)();return`\n    vec4 ${r}(${f}) {\n      int index = ${h};\n      int texR = index / ${s};\n      int texC = index - texR * ${s};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}, ${c});\n      return ${x.texture2D}(${o}, uv);\n    }\n  `}(n)}}const l="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",d="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",f="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",h="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function x(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function p(n){return`offset${n}`}function $(n){const t=n.name,e=o.util.sizeFromShape(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function v(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function C(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function g(n,t){return t.map((t=>n[t])).join(", ")}},30282:function(n,t,e){e.d(t,{m:function(){return r}});var o=e(75694),i=e(27575);class r{constructor(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n;const t=n.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=(0,o.Jp)("rc",t),r=(0,i.b)(t),a=function(n,t,e){if(1===n)return`rc > ${t[0]}`;let o="";for(let i=n-2;i<n;i++)o+=`${e[i]} >= ${t[i]}`,i<n-1&&(o+="||");return o}(t,n,e),u=function(n,t,e,o){if(1===n)return"";const i=o.slice(-2);return`\n    int r = ${i[0]};\n    int c = ${i[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${e};\n  `}(t,n[n.length-1],n[n.length-2],e),c=function(n,t){const e=n.length,o=function(n,t){const e=[];for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){let r=`${0===o?"r":"rp1"}, ${0===i?"c":"cp1"}`;for(let e=2;e<n;e++)r=`${t[t.length-1-e]},`+r;e.push(r)}return e}(e,t);if(1===e)return`getA(rc),\n            rc + 1 >= ${n[0]} ? 0. : getA(rc + 1),\n            0, 0`;return`getA(${o[0]}),\n          cEdge ? 0. : getA(${o[1]}),\n          rEdge ? 0. : getA(${o[2]}),\n          rEdge || cEdge ? 0. : getA(${o[3]})`}(n,e);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${a}) {\n            setOutput(vec4(0));\n          } else {\n            ${u}\n\n            setOutput(vec4(${c}));\n          }\n        }\n      `}}}},40784:function(n,t,e){e.d(t,{e:function(){return o}});class o{constructor(n,t){this.variableNames=["Image"],this.outputShape=[];const e=n[1],o=n[2];this.outputShape=n;let i="";i="number"===typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${i}\n          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${e}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(n,t,e,o){return(i,r)=>{null==this.paramsLoc&&(this.paramsLoc=i.getUniformLocationNoThrow(r,"params")),i.gl.uniform4f(this.paramsLoc,n,t,e,o)}}}},47791:function(n,t,e){e.d(t,{h:function(){return o}});class o{constructor(n,t,e){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,o,i]=t,[,r,a]=n,u=[e&&r>1?o-1:o,e&&a>1?i-1:i],c=[e&&r>1?r-1:r,e&&a>1?a-1:a],s=u[0]/c[0],l=u[1]/c[1],d=1/s,f=1/l,h=2*Math.ceil(d)+2,x=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${s});\n        const float widthScale = float(${l});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${x});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${r}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}},50476:function(n,t,e){e.d(t,{v:function(){return o}});class o{constructor(n,t){this.variableNames=["x","segmentIds"];const e=n.windowSize,o=n.batchSize,i=n.inSize,r=n.numSegments,a=r*Math.ceil(i/e);this.outputShape=[o,a];const u=4*Math.floor(e/4),c=e%4,s="\n        sumValue += dot(values, segFilter);\n    ";let l="";i%e>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `);let d="";i%e>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${r})) * float(${e}));\n        int currentSeg = int(mod(float(outIdx), float(${r})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${s}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${s}\n        } else if (${2===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${s}\n        } else if (${3===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${s}\n        }\n        setOutput(sumValue);\n      }\n    `}}},59250:function(n,t,e){e.d(t,{z:function(){return o}});class o{constructor(n,t,e,o,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[r,a,u,c]=n;this.outputShape=[r,t,e,c];const s=[o&&t>1?a-1:a,o&&e>1?u-1:u],l=[o&&t>1?t-1:t,o&&e>1?e-1:e],d=o?"0.5":"0.0";let f;f=i?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${s[0]/l[0]},\n          ${s[1]/l[1]},\n          ${s[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${e-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}},59344:function(n,t,e){e.d(t,{e:function(){return i}});var o=e(27575);class i{constructor(n,t,e){this.variableNames=["x"],this.outputShape=t.map(((t,e)=>t[0]+n[e]+t[1]));const i=n.length,r=(0,o.b)(i),a=t.map((n=>n[0])).join(","),u=t.map(((t,e)=>t[0]+n[e])).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);this.userCode=1!==i?`\n      ${r} start = ${r}(${a});\n      ${r} end = ${r}(${u});\n      uniform float value;\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${c}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${u};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(n){return(t,e)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(e,"value")),t.gl.uniform1f(this.valueLoc,n)}}}},68636:function(n,t,e){e.d(t,{X:function(){return r}});var o=e(75694),i=e(27575);class r{constructor(n,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const e=n.length;if(e>4)throw new Error(`WebGL backend: Reverse of rank-${e} tensor is not yet supported`);this.outputShape=n;const r=(0,o.Jp)("rc",e),a=`${r[e-1]} + 1 < ${this.outputShape[e-1]}`,u=`${r[e-2]} + 1 < ${this.outputShape[e-2]}`,c=(0,i.b)(e);function s(e){const o=n.map(((o,i)=>function(e,o){return-1!==t.indexOf(e)&&1!==n[e]?`${n[e]} - ${o[e]} - 1`:`${o[e]}`}(i,e)));return`getChannel(getX(${o.join(",")}), vec2(${o.slice(-2).join(",")}))`}this.userCode=1===e?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${n[0]} - rc - 1),\n            ${n[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),\n                ${n[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${c} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(n){return s(n)}(r.slice())};\n          if(${a}){\n            result.g = ${function(n){return n[e-1]="("+n[e-1]+" + 1)",s(n)}(r.slice())};\n          }\n          if(${u}) {\n            result.b = ${function(n){return n[e-2]="("+n[e-2]+" + 1)",s(n)}(r.slice())};\n            if(${a}) {\n              result.a = ${function(n){return n[e-1]="("+n[e-1]+" + 1)",n[e-2]="("+n[e-2]+" + 1)",s(n)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}},71967:function(n,t,e){e.d(t,{N:function(){return i}});var o=e(27575);class i{constructor(n,t){this.variableNames=["x"];const e=n.length;if(e>4)throw new Error(`WebGL backend: Reverse of rank-${e} tensor is not yet supported`);if(this.outputShape=n,1===e)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${n[0]} - coord - 1));\n        }\n      `);const i=n.map(((e,o)=>(e=>-1!==t.indexOf(e)&&1!==n[e]?`${n[e]} - coords[${e}] - 1`:`coords[${e}]`)(o))).join(","),r=(0,o.b)(e);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}},75694:function(n,t,e){function o(n,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${n}.${t}`))}function i(n,t){return 1===t?[n]:o(n,t)}function r(n,t){if(1===n)return"rc";let e="";for(let o=0;o<n;o++)e+=t[o],o<n-1&&(e+=",");return e}e.d(t,{Fd:function(){return o},Jp:function(){return i},kp:function(){return r}})},76202:function(n,t,e){var o=e(9495),i=e(47149),r=e(65253),a=e(32019),u=e(92619),c=e(8982),s=e(40154),l=e(63990),d=e(72335),f=e(45247),h=e(90085),x=e(1806),p=e(73844),$=e(25007),v=e(37913),C=e(97743),g=e(21119),m=e(78060),R=e(83312),w=e(84631),y=e(8537),V=e(82339),b=e(65514),I=e(72517),S=e(36446),O=e(35960),F=e(47357),D=e(8993),N=e(37053),z=e(93179),A=e(66045),M=e(91241),L=e(27260),k=e(14992),T=e(7664),U=e(94948),j=e(15354),W=e(86856),E=e(16998),H=e(5171),X=e(99590),q=e(46355),G=e(14947),B=e(86099),J=e(48689),_=e(7530),Y=e(31345),P=e(72718),K=e(46321),Z=e(93057),Q=e(73525),nn=e(83910),tn=e(29450),en=e(98134),on=e(70324),rn=e(89805),an=e(37664),un=e(99893),cn=e(54087),sn=e(15328),ln=e(16386),dn=e(39882),fn=e(65057),hn=e(66900),xn=e(23706),pn=e(95171),$n=e(379),vn=e(77723),Cn=e(66696),gn=e(39803),mn=e(83834),Rn=e(95442),wn=e(3872),yn=e(66921),Vn=e(26132),bn=e(4094),In=e(22970),Sn=e(71739),On=e(12462),Fn=e(57133),Dn=e(4873),Nn=e(10695),zn=e(6489),An=e(89193),Mn=e(99160),Ln=e(23007),kn=e(18801),Tn=e(92914),Un=e(65886),jn=e(17249),Wn=e(38717),En=e(52132),Hn=e(69941),Xn=e(25621),qn=e(94449),Gn=e(19013),Bn=e(89488),Jn=e(26041),_n=e(40279),Yn=e(73816),Pn=e(14669),Kn=e(70318),Zn=e(98890),Qn=e(62642),nt=e(64635),tt=e(54532),et=e(92616),ot=e(48223),it=e(14899),rt=e(74952),at=e(39264),ut=e(4313),ct=e(4490),st=e(49649),lt=e(37647),dt=e(14421),ft=e(94043),ht=e(2249),xt=e(68889),pt=e(43137),$t=e(96017),vt=e(86567),Ct=e(24929),gt=e(84745),mt=e(34733),Rt=e(57518),wt=e(51361),yt=e(64770),Vt=e(24129),bt=e(43168),It=e(60739),St=e(49627),Ot=e(29547),Ft=e(62667),Dt=e(68065),Nt=e(50894),zt=e(49442),At=e(25103),Mt=e(80809),Lt=e(63575),kt=e(5643),Tt=e(12030),Ut=e(55571),jt=e(97667),Wt=e(5466),Et=e(38483),Ht=e(22853),Xt=e(43178),qt=e(85048),Gt=e(74021),Bt=e(72641),Jt=e(31137),_t=e(58246),Yt=e(29154),Pt=e(41719),Kt=e(50307),Zt=e(30097);const Qt=[zn.x,An.j,i.l,r.l,a.t,u.D,c.U,s.y,l.k,d.l,f.n,h.l,x.S,p.M,v.r,$.L,C.l,m.O,g.R,R.K,w.$,y.X,V.V,b.e,I.l,S.M,O.u,F.F,N.t,D.v,z.V,M.r,L.f,A.x,T.i,U.Y,k.i,j.o,W.k,E.O,H.$,X.Y,q.R,B.n,J.V,G.v,_.O,Y.F,P._,K.J,Z.x,Q.R,nn._,tn.AC,en.a,on.Y,rn.N,an.u,un.D,cn.H,sn.U,ln.y,dn.q,fn.l,hn.K,xn.a,pn.x,$n.V,vn.F,Cn.c,gn.l,mn.K,Rn.I,wn.I,yn.zp,Vn.Y,bn.Q,In.o,On.W,Sn.F,Fn.V,Dn.f,Nn.r,Mn.l,Tn.A,kn.$,Un.y,jn.P,Wn.l,Ln.l,En.M,Hn.j,Xn.N,qn.V,Gn.X,Bn.a,Jn.t,_n.h,Yn.m,Pn.F,Kn.u,Zn.A,Qn._,nt.h,tt.q,et.e,ot.j,it.HK,rt.S,at.i,ut.r,ct.G,st.l,dt.X,lt.z,ft.V,ht.T,xt.j,pt.j,$t.n,vt.r,Ct.f,gt.$,mt.L,Rt.H,wt.z,yt.k,Vt.X,bt.C,It.b,St.$,Ot.l,Ft.$,Dt.Z,Nt.W,zt.K,At.F,Mt.x,Lt.t,kt.F,Tt.e,Ut.b,jt.t,Wt.c,Et.Z,Ht.q,Xt.W,qt.i,Gt.n,Bt.p,Jt.N,_t.W,Yt.a,Pt.B,Kt.b,Zt.Z];for(const ne of Qt)(0,o.registerKernel)(ne)},80297:function(n,t,e){e.d(t,{U:function(){return i},h:function(){return o}});class o{constructor(n,t,e,o=!1,i=!1){if(this.variableNames=["x"],"avg"===t&&e)throw new Error("Cannot compute positions for average pool.");const r=n.filterWidth,a=n.strideHeight,u=n.strideWidth,c=n.dilationHeight,s=n.dilationWidth,l=n.effectiveFilterHeight,d=n.effectiveFilterWidth,f=n.padInfo.top,h=n.padInfo.left;this.outputShape=n.outShape;const x="avg"===t,p=`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`,$=`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`;let v="0.0";if(x||(v="-1.0 / 1e-20"),e){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${u});\n        const ivec2 pads = ivec2(${f}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${l};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${s}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${o?i?p:$:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let C=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(C="avgValue / count");const g=4*Math.floor(r/4),m=r%4,R=`\n      if (${x}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${u});\n      const ivec2 pads = ivec2(${f}, ${h});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${l};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${g}; wC += 4) {\n            int xC = xCCorner + wC * ${s};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${s}, d),\n              getValue(batch, xR, xC + 2 * ${s}, d),\n              getValue(batch, xR, xC + 3 * ${s}, d)\n            );\n\n            ${R}\n          }\n\n          int xC = xCCorner + ${g};\n          if (${1===m}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${R}\n          } else if (${2===m}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${s}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${R}\n          } else if (${3===m}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${s}, d),\n              getValue(batch, xR, xC + 2 * ${s}, d),\n              initializationValue\n            );\n\n            ${R}\n          }\n        }\n        setOutput(${C});\n      }\n    `}}class i{constructor(n,t,e,o=!1,i=!1){if(this.variableNames=["x"],"avg"===t&&e)throw new Error("Cannot compute positions for average pool.");const r=n.filterWidth,a=n.strideDepth,u=n.strideHeight,c=n.strideWidth,s=n.dilationDepth,l=n.dilationHeight,d=n.dilationWidth,f=n.effectiveFilterDepth,h=n.effectiveFilterHeight,x=n.effectiveFilterWidth,p=n.padInfo.front,$=n.padInfo.top,v=n.padInfo.left;this.outputShape=n.outShape;const C="avg"===t;let g="0.0";if(C||(g="-1.0 / 1e-20"),e){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${u}, ${c});\n        const ivec3 pads = ivec3(${p}, ${$}, ${v});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${f};\n              wD += ${s}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${l}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${x};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${o?i?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${h} * ${x} +\n                      wR * ${x} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let m=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(m="avgValue / count");const R=4*Math.floor(r/4),w=r%4,y=`\n      if (${C}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${u}, ${c});\n      const ivec3 pads = ivec3(${p}, ${$}, ${v});\n      const float initializationValue = ${g};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${g});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${f};\n            wD += ${s}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${R}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${y}\n            }\n\n            int xC = xCCorner + ${R};\n            if (${1===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${y}\n            } else if (${2===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${y}\n            } else if (${3===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${y}\n            }\n          }\n          setOutput(${m});\n        }\n      }\n    `}}},81847:function(n,t,e){e.d(t,{T:function(){return i}});var o=e(27575);class i{constructor(n,t,e){let i,r;if(this.variableNames=["c","a","b"],this.outputShape=t,e>4)throw Error(`Where for rank ${e} is not yet supported`);if(1===e)r="resRC",i="resRC";else{const e=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],a=[];for(let i=0;i<t.length;i++)a.push(`${e[i]}`),i<n&&o.push(`${e[i]}`);i=o.join(),r=a.join()}const a=(0,o.b)(e);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${i});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}}},92394:function(n,t,e){e.d(t,{G2:function(){return a},UG:function(){return i},fM:function(){return r}});var o=e(9495);function i(n,t,e="index"){const i=o.util.computeStrides(t);return i.map(((t,o)=>`${`int ${n[o]} = ${e} / ${t}`}; ${o===i.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${t}`:`index -= ${n[o]} * ${t}`};`)).join("")}function r(n){const t=o.util.computeStrides(n).map((n=>n.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}const a="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n"}}]);
//# sourceMappingURL=stylist-vendors-746661ec.85c981ae2a3802b05e42.js.map