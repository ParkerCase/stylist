"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[7024],{11086:function(t,n,e){e.d(n,{E:function(){return o}});var r=e(9495),i=e(91773),s=e(39485),u=e(49801);class o extends i.q{constructor(t,n={}){super(),this.input=t,this.options=n}async iterator(){if((0,u.N)(this.input)&&(0,r.env)().get("IS_NODE")){const t=e(8108);this.input=t.readFileSync(this.input.slice(7))}return new s.c(this.input,this.options)}}},15377:function(t,n,e){var r=e(91773);e(89870),e(49801),e(11086);r.q},20578:function(t,n,e){e.d(n,{N:function(){return r}});class r{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,n){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=n}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const n of t)this.push(n)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const n=this.wrap(this.begin+t),e=this.get(n);return this.set(n,this.pop()),e}}},33906:function(t,n,e){e.d(n,{r:function(){return r}});const r="4.22.0"},35027:function(t,n,e){e.d(n,{G:function(){return s}});var r=e(9495),i=e(63284);function s(t){return(0,i.Bl)(t,u)}function u(t){return t instanceof r.Tensor?{value:t.clone(),recurse:!1}:(0,i.xZ)(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}},37624:function(t,n,e){e.d(n,{g:function(){return i}});var r=e(20578);class i extends r.N{constructor(){super(i.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){const t=2*this.capacity,n=new Array(t),e=this.length();for(let r=0;r<e;r++)n[r]=this.get(this.wrap(this.begin+r));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=e}}i.INITIAL_CAPACITY=32},49801:function(t,n,e){function r(t){return"string"===typeof t&&"file://"===t.slice(0,7)}e.d(n,{N:function(){return r}})},63284:function(t,n,e){e.d(n,{Bl:function(){return i},mf:function(){return h},rN:function(){return a},sy:function(){return u},te:function(){return c},xZ:function(){return f}});var r=e(9495);function i(t,n){return s(t,n)}function s(t,n,e=new Map,r=new Set){if(null==t)return null;if("function"===typeof Blob&&t instanceof Blob)return t.slice();if(r.has(t))throw new Error("Circular references are not supported.");if(e.has(t))return e.get(t);const i=n(t);if(i.recurse&&null!==i.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse){if(f(t)){const i=Array.isArray(t)?[]:{};r.add(t);for(const u in t){const o=s(t[u],n,e,r);i[u]=o}return r.delete(t),t.__proto__&&(i.__proto__=t.__proto__),i}throw new Error(`Can't recurse into non-iterable type: ${t}`)}return e.set(t,i.value),i.value}function u(t,n=a){return o(t,n)}function o(t,n,e=new Set){const r=t[0];if(e.has(r))throw new Error("Circular references are not supported.");const i=n(t);if(i.recurse&&null!==i.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse){if(f(r)){const i=Array.isArray(r)?[]:{};e.add(r);for(const s in r){const r=o(t.map((t=>t[s])),n,e);i[s]=r}return e.delete(r),i}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return i.value}function a(t){return null===t?null:f(t[0])?{value:null,recurse:!0}:{value:t,recurse:!1}}async function c(t,n){const e=new Map;s(t,n,e);for(const i of Array.from(e.keys())){const t=e.get(i);if(r.util.isPromise(t)){const n=await t;e.set(i,n)}}return s(t,n,e)}function f(t){let n=!1;if(r.env().get("IS_BROWSER"))n=t instanceof TextDecoder;else{const{StringDecoder:r}=e(80551);n=t instanceof r}return null!=t&&!ArrayBuffer.isView(t)&&(Array.isArray(t)||"object"===typeof t&&!(t instanceof r.Tensor)&&!(t instanceof Promise)&&!n)}function h(t){return null==t||(null===(n=t)||"object"!==typeof n&&"function"!==typeof n)||Array.isArray(t)||"object"===typeof t&&t instanceof r.Tensor||r.util.isTypedArray(t);var n}},84242:function(t,n,e){e(7766),e(96109),e(52619),e(88757),e(5458),e(15377)}}]);
//# sourceMappingURL=stylist-vendors-01581d6f.8665252835039fbc7297.js.map