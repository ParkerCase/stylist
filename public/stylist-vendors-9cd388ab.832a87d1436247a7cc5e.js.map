{"version":3,"file":"stylist-vendors-9cd388ab.832a87d1436247a7cc5e.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu_depthwise.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_packed_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu_depthwise.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_backprop_gpu.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-backend-webgl/dist/concat_packed_gpu.js"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { useShapeUniforms } from './gpgpu_math';\nexport class DepthwiseConv2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivation = false, hasLeakyReluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.customUniforms = [\n            { name: 'pads', type: 'ivec2' },\n            { name: 'strides', type: 'ivec2' },\n            { name: 'dilations', type: 'ivec2' },\n            { name: 'inDims', type: 'ivec2' },\n        ];\n        this.outputShape = convInfo.outShape;\n        this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivation) {\n                activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyReluAlpha) {\n                activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivation) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyReluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9ncHVfZGVwdGh3aXNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1iYWNrZW5kLXdlYmdsL3NyYy9jb252X2dwdV9kZXB0aHdpc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxFQUFlLGdCQUFnQixFQUFDLE1BQU0sY0FBYyxDQUFDO0FBRTVELE1BQU0sT0FBTyxzQkFBc0I7SUFZakMsWUFDSSxRQUFpQyxFQUFFLE9BQU8sR0FBRyxLQUFLLEVBQ2xELGFBQXFCLElBQUksRUFBRSxrQkFBa0IsR0FBRyxLQUFLLEVBQ3JELGlCQUFpQixHQUFHLEtBQUs7UUFkN0Isa0JBQWEsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUkzQixtQkFBYyxHQUFHO1lBQ2YsRUFBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFnQixFQUFFO1lBQ3ZDLEVBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsT0FBZ0IsRUFBRTtZQUMxQyxFQUFDLElBQUksRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLE9BQWdCLEVBQUU7WUFDNUMsRUFBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxPQUFnQixFQUFFO1NBQzFDLENBQUM7UUFNQSxJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUM7UUFDckMsSUFBSSxDQUFDLG1CQUFtQixHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFckUsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQztRQUMzQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBQ3pDLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQztRQUU5RCxJQUFJLGlCQUFpQixHQUFHLEVBQUUsRUFBRSxzQkFBc0IsR0FBRyxFQUFFLENBQUM7UUFDeEQsSUFBSSxVQUFVLEVBQUU7WUFDZCxJQUFJLGtCQUFrQixFQUFFO2dCQUN0QixpQkFBaUIsR0FBRzs7WUFFaEIsVUFBVTtVQUNaLENBQUM7YUFDSjtpQkFBTSxJQUFJLGlCQUFpQixFQUFFO2dCQUM1QixpQkFBaUIsR0FBRzs7WUFFaEIsVUFBVTtVQUNaLENBQUM7YUFDSjtpQkFBTTtnQkFDTCxpQkFBaUIsR0FBRzs7Y0FFZCxVQUFVOztTQUVmLENBQUM7YUFDSDtZQUVELHNCQUFzQixHQUFHLDhCQUE4QixDQUFDO1NBQ3pEO1FBRUQsTUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3hFLElBQUksT0FBTyxFQUFFO1lBQ1gsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDakM7UUFFRCxJQUFJLGtCQUFrQixFQUFFO1lBQ3RCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLENBQUM7U0FDbkQ7UUFDRCxJQUFJLGlCQUFpQixFQUFFO1lBQ3JCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7U0FDM0M7UUFFRCxJQUFJLENBQUMsUUFBUSxHQUFHO1FBQ1osaUJBQWlCOzs7Ozs7O3dCQU9ELFVBQVU7NEJBQ04sVUFBVTs7Ozs7Ozs7O2dDQVNOLFlBQVk7Ozs7Ozs7a0NBT1YsV0FBVzs7Ozs7Ozs7Ozs7Ozs7VUFjbkMsY0FBYztVQUNkLHNCQUFzQjs7O0tBRzNCLENBQUM7SUFDSixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtHUEdQVVByb2dyYW0sIHVzZVNoYXBlVW5pZm9ybXN9IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbmV4cG9ydCBjbGFzcyBEZXB0aHdpc2VDb252MkRQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcbiAgZW5hYmxlU2hhcGVVbmlmb3JtczogYm9vbGVhbjtcbiAgY3VzdG9tVW5pZm9ybXMgPSBbXG4gICAge25hbWU6ICdwYWRzJywgdHlwZTogJ2l2ZWMyJyBhcyBjb25zdCB9LFxuICAgIHtuYW1lOiAnc3RyaWRlcycsIHR5cGU6ICdpdmVjMicgYXMgY29uc3QgfSxcbiAgICB7bmFtZTogJ2RpbGF0aW9ucycsIHR5cGU6ICdpdmVjMicgYXMgY29uc3QgfSxcbiAgICB7bmFtZTogJ2luRGltcycsIHR5cGU6ICdpdmVjMicgYXMgY29uc3QgfSxcbiAgXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICAgIGNvbnZJbmZvOiBiYWNrZW5kX3V0aWwuQ29udjJESW5mbywgYWRkQmlhcyA9IGZhbHNlLFxuICAgICAgYWN0aXZhdGlvbjogc3RyaW5nID0gbnVsbCwgaGFzUHJlbHVBY3RpdmF0aW9uID0gZmFsc2UsXG4gICAgICBoYXNMZWFreVJlbHVBbHBoYSA9IGZhbHNlKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgIHRoaXMuZW5hYmxlU2hhcGVVbmlmb3JtcyA9IHVzZVNoYXBlVW5pZm9ybXModGhpcy5vdXRwdXRTaGFwZS5sZW5ndGgpO1xuXG4gICAgY29uc3QgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgIGNvbnN0IGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgY29uc3QgY2hhbm5lbE11bCA9IGNvbnZJbmZvLm91dENoYW5uZWxzIC8gY29udkluZm8uaW5DaGFubmVscztcblxuICAgIGxldCBhY3RpdmF0aW9uU25pcHBldCA9ICcnLCBhcHBseUFjdGl2YXRpb25TbmlwcGV0ID0gJyc7XG4gICAgaWYgKGFjdGl2YXRpb24pIHtcbiAgICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb24pIHtcbiAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBgZmxvYXQgYWN0aXZhdGlvbihmbG9hdCBhKSB7XG4gICAgICAgICAgZmxvYXQgYiA9IGdldFByZWx1QWN0aXZhdGlvbldlaWdodHNBdE91dENvb3JkcygpO1xuICAgICAgICAgICR7YWN0aXZhdGlvbn1cbiAgICAgICAgfWA7XG4gICAgICB9IGVsc2UgaWYgKGhhc0xlYWt5UmVsdUFscGhhKSB7XG4gICAgICAgIGFjdGl2YXRpb25TbmlwcGV0ID0gYGZsb2F0IGFjdGl2YXRpb24oZmxvYXQgYSkge1xuICAgICAgICAgIGZsb2F0IGIgPSBnZXRMZWFreXJlbHVBbHBoYUF0T3V0Q29vcmRzKCk7XG4gICAgICAgICAgJHthY3RpdmF0aW9ufVxuICAgICAgICB9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRpb25TbmlwcGV0ID0gYFxuICAgICAgICAgIGZsb2F0IGFjdGl2YXRpb24oZmxvYXQgeCkge1xuICAgICAgICAgICAgJHthY3RpdmF0aW9ufVxuICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgIH1cblxuICAgICAgYXBwbHlBY3RpdmF0aW9uU25pcHBldCA9IGByZXN1bHQgPSBhY3RpdmF0aW9uKHJlc3VsdCk7YDtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRCaWFzU25pcHBldCA9IGFkZEJpYXMgPyAncmVzdWx0ICs9IGdldEJpYXNBdE91dENvb3JkcygpOycgOiAnJztcbiAgICBpZiAoYWRkQmlhcykge1xuICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2JpYXMnKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUHJlbHVBY3RpdmF0aW9uKSB7XG4gICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgncHJlbHVBY3RpdmF0aW9uV2VpZ2h0cycpO1xuICAgIH1cbiAgICBpZiAoaGFzTGVha3lSZWx1QWxwaGEpIHtcbiAgICAgIHRoaXMudmFyaWFibGVOYW1lcy5wdXNoKCdsZWFreXJlbHVBbHBoYScpO1xuICAgIH1cblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICAke2FjdGl2YXRpb25TbmlwcGV0fVxuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xuICAgICAgICBpbnQgZDEgPSBkMiAvICR7Y2hhbm5lbE11bH07XG4gICAgICAgIGludCBxID0gZDIgLSBkMSAqICR7Y2hhbm5lbE11bH07XG5cbiAgICAgICAgaW50IHhSQ29ybmVyID0geFJDQ29ybmVyLng7XG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xuXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgZDEpIHdpdGggdyg6LCA6LCBkMSwgcSkgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgICAvLyBUTyBETyhkc21pbGtvdik6IEZsYXR0ZW4gdGhlIHR3byBmb3IgbG9vcHMgYW5kIHZlYzQgdGhlIG9wZXJhdGlvbnMuXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke2ZpbHRlckhlaWdodH07IHdSKyspIHtcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogZGlsYXRpb25zWzBdO1xuXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSBpbkRpbXNbMF0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke2ZpbHRlcldpZHRofTsgd0MrKykge1xuICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QyAqIGRpbGF0aW9uc1sxXTtcblxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBpbkRpbXNbMV0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsb2F0IHhWYWwgPSBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKHdSLCB3QywgZDEsIHEpO1xuICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbG9hdCByZXN1bHQgPSBkb3RQcm9kO1xuICAgICAgICAke2FkZEJpYXNTbmlwcGV0fVxuICAgICAgICAke2FwcGx5QWN0aXZhdGlvblNuaXBwZXR9XG4gICAgICAgIHNldE91dHB1dChyZXN1bHQpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nexport class ConcatProgram {\n    // Concats 2d tensors along axis=1. See comments in MathBackendWebGL.concat().\n    constructor(shapes) {\n        this.outputShape = [];\n        this.outputShape = backend_util.computeOutShape(shapes, 1 /* axis */);\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][1];\n        for (let i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][1];\n        }\n        const snippets = [`if (yC < ${offsets[0]}) setOutput(getT0(yR, yC));`];\n        for (let i = 1; i < offsets.length; i++) {\n            const shift = offsets[i - 1];\n            snippets.push(`else if (yC < ${offsets[i]}) ` +\n                `setOutput(getT${i}(yR, yC-${shift}));`);\n        }\n        const lastIndex = offsets.length;\n        const lastShift = offsets[offsets.length - 1];\n        snippets.push(`else setOutput(getT${lastIndex}(yR, yC-${lastShift}));`);\n        this.userCode = `\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${snippets.join('\\n        ')}\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uY2F0X2dwdS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtYmFja2VuZC13ZWJnbC9zcmMvY29uY2F0X2dwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFHbkQsTUFBTSxPQUFPLGFBQWE7SUFLeEIsOEVBQThFO0lBQzlFLFlBQVksTUFBK0I7UUFKM0MsZ0JBQVcsR0FBYSxFQUFFLENBQUM7UUFLekIsSUFBSSxDQUFDLFdBQVcsR0FBRyxZQUFZLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDdEUsSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRW5ELE1BQU0sT0FBTyxHQUFhLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDdkQsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMxQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN2QyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDNUM7UUFFRCxNQUFNLFFBQVEsR0FBRyxDQUFDLFlBQVksT0FBTyxDQUFDLENBQUMsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1FBQ3ZFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3ZDLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDN0IsUUFBUSxDQUFDLElBQUksQ0FDVCxpQkFBaUIsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJO2dCQUMvQixpQkFBaUIsQ0FBQyxXQUFXLEtBQUssS0FBSyxDQUFDLENBQUM7U0FDOUM7UUFDRCxNQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO1FBQ2pDLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzlDLFFBQVEsQ0FBQyxJQUFJLENBQUMsc0JBQXNCLFNBQVMsV0FBVyxTQUFTLEtBQUssQ0FBQyxDQUFDO1FBRXhFLElBQUksQ0FBQyxRQUFRLEdBQUc7Ozs7OztVQU1WLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDOztLQUVoQyxDQUFDO0lBQ0osQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7R1BHUFVQcm9ncmFtfSBmcm9tICcuL2dwZ3B1X21hdGgnO1xuXG5leHBvcnQgY2xhc3MgQ29uY2F0UHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXM6IHN0cmluZ1tdO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW10gPSBbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcblxuICAvLyBDb25jYXRzIDJkIHRlbnNvcnMgYWxvbmcgYXhpcz0xLiBTZWUgY29tbWVudHMgaW4gTWF0aEJhY2tlbmRXZWJHTC5jb25jYXQoKS5cbiAgY29uc3RydWN0b3Ioc2hhcGVzOiBBcnJheTxbbnVtYmVyLCBudW1iZXJdPikge1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBiYWNrZW5kX3V0aWwuY29tcHV0ZU91dFNoYXBlKHNoYXBlcywgMSAvKiBheGlzICovKTtcbiAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBzaGFwZXMubWFwKChfLCBpKSA9PiBgVCR7aX1gKTtcblxuICAgIGNvbnN0IG9mZnNldHM6IG51bWJlcltdID0gbmV3IEFycmF5KHNoYXBlcy5sZW5ndGggLSAxKTtcbiAgICBvZmZzZXRzWzBdID0gc2hhcGVzWzBdWzFdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2Zmc2V0c1tpXSA9IG9mZnNldHNbaSAtIDFdICsgc2hhcGVzW2ldWzFdO1xuICAgIH1cblxuICAgIGNvbnN0IHNuaXBwZXRzID0gW2BpZiAoeUMgPCAke29mZnNldHNbMF19KSBzZXRPdXRwdXQoZ2V0VDAoeVIsIHlDKSk7YF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBvZmZzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzaGlmdCA9IG9mZnNldHNbaSAtIDFdO1xuICAgICAgc25pcHBldHMucHVzaChcbiAgICAgICAgICBgZWxzZSBpZiAoeUMgPCAke29mZnNldHNbaV19KSBgICtcbiAgICAgICAgICBgc2V0T3V0cHV0KGdldFQke2l9KHlSLCB5Qy0ke3NoaWZ0fSkpO2ApO1xuICAgIH1cbiAgICBjb25zdCBsYXN0SW5kZXggPSBvZmZzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0U2hpZnQgPSBvZmZzZXRzW29mZnNldHMubGVuZ3RoIC0gMV07XG4gICAgc25pcHBldHMucHVzaChgZWxzZSBzZXRPdXRwdXQoZ2V0VCR7bGFzdEluZGV4fSh5UiwgeUMtJHtsYXN0U2hpZnR9KSk7YCk7XG5cbiAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IHlSID0gY29vcmRzLng7XG4gICAgICAgIGludCB5QyA9IGNvb3Jkcy55O1xuXG4gICAgICAgICR7c25pcHBldHMuam9pbignXFxuICAgICAgICAnKX1cbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Conv2DProgram {\n    constructor(convInfo, addBias = false, activation = null, hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        const inputDepthVec4Remainder = convInfo.inChannels % 4;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const rowDim = isChannelsLast ? 1 : 2;\n        const colDim = isChannelsLast ? 2 : 3;\n        const channelDim = isChannelsLast ? 3 : 1;\n        let activationSnippet = '', applyActivationSnippet = '';\n        if (activation) {\n            if (hasPreluActivationWeights) {\n                activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else if (hasLeakyreluAlpha) {\n                activationSnippet = `float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${activation}\n        }`;\n            }\n            else {\n                activationSnippet = `\n          float activation(float x) {\n            ${activation}\n          }\n        `;\n            }\n            applyActivationSnippet = `result = activation(result);`;\n        }\n        const addBiasSnippet = addBias ? 'result += getBiasAtOutCoords();' : '';\n        if (addBias) {\n            this.variableNames.push('bias');\n        }\n        if (hasPreluActivationWeights) {\n            this.variableNames.push('preluActivationWeights');\n        }\n        if (hasLeakyreluAlpha) {\n            this.variableNames.push('leakyreluAlpha');\n        }\n        this.userCode = `\n      ${activationSnippet}\n\n      const ivec2 strides = ivec2(${strideHeight}, ${strideWidth});\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${channelDim}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${rowDim}], coords[${colDim}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          int xR = xRCorner + wR * ${dilationHeight};\n\n          if (xR < 0 || xR >= ${convInfo.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int xC = xCCorner + wC * ${dilationWidth};\n\n            if (xC < 0 || xC >= ${convInfo.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${inputDepthVec4Remainder === 1}) {\n\n              if (${isChannelsLast}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${inputDepthNearestVec4}) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${inputDepthNearestVec4}, xR, xC) *\n                    getW(wR, wC, ${inputDepthNearestVec4}, d2);\n              }\n\n            } else if (${inputDepthVec4Remainder === 2}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${inputDepthVec4Remainder === 3}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${inputDepthNearestVec4}, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                getW(wR, wC, ${inputDepthNearestVec4} + 2, d2)\n              );\n\n              if (${isChannelsLast}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${inputDepthNearestVec4}, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 1, xR, xC),\n                  getX(batch, ${inputDepthNearestVec4} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(result);\n      }\n    `;\n    }\n}\nexport class Conv3DProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'W'];\n        this.outputShape = convInfo.outShape;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const dilationDepth = convInfo.dilationDepth;\n        const dilationHeight = convInfo.dilationHeight;\n        const dilationWidth = convInfo.dilationWidth;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;\n        const inputDepthVec4Remainder = convInfo.inChannels % 4;\n        this.userCode = `\n      const ivec3 strides = ivec3(${strideDepth}, ${strideHeight}, ${strideWidth});\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          int xF = xFCorner + wF * ${dilationDepth};\n\n          if (xF < 0 || xF >= ${convInfo.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            int xR = xRCorner + wR * ${dilationHeight};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              int xC = xCCorner + wC * ${dilationWidth};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${inputDepthNearestVec4}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${inputDepthVec4Remainder === 1}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}) *\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2);\n              } else if (${inputDepthVec4Remainder === 2}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${inputDepthVec4Remainder === 3}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4}),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 1),\n                  getX(batch, xF, xR, xC, ${inputDepthNearestVec4} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${inputDepthNearestVec4}, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 1, d2),\n                  getW(wF, wR, wC, ${inputDepthNearestVec4} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9ncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ2wvc3JjL2NvbnZfZ3B1LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUtILE1BQU0sT0FBTyxhQUFhO0lBS3hCLFlBQ0ksUUFBaUMsRUFBRSxPQUFPLEdBQUcsS0FBSyxFQUNsRCxhQUFxQixJQUFJLEVBQUUseUJBQXlCLEdBQUcsS0FBSyxFQUM1RCxpQkFBaUIsR0FBRyxLQUFLO1FBUDdCLGtCQUFhLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFRekIsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsUUFBUSxDQUFDO1FBQ3JDLE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1FBQ3BDLE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQ3RDLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUM7UUFDM0MsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUN6QyxNQUFNLGNBQWMsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDO1FBQy9DLE1BQU0sYUFBYSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUM7UUFDN0MsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQztRQUMzQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBRXpDLE1BQU0scUJBQXFCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN0RSxNQUFNLHVCQUF1QixHQUFHLFFBQVEsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO1FBQ3hELE1BQU0sY0FBYyxHQUFHLFFBQVEsQ0FBQyxVQUFVLEtB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dUJBQXVCLEtBQUssQ0FBQzs7NENBRVoscUJBQXFCOzRDQUNyQixxQkFBcUI7OztxQ0FHNUIscUJBQXFCO3FDQUNyQixxQkFBcUI7OzsyQkFHL0IsdUJBQXVCLEtBQUssQ0FBQzs7NENBRVoscUJBQXFCOzRDQUNyQixxQkFBcUI7NENBQ3JCLHFCQUFxQjs7O3FDQUc1QixxQkFBcUI7cUNBQ3JCLHFCQUFxQjtxQ0FDckIscUJBQXFCOzs7Ozs7Ozs7S0FTckQsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtiYWNrZW5kX3V0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge0dQR1BVUHJvZ3JhbX0gZnJvbSAnLi9ncGdwdV9tYXRoJztcblxuZXhwb3J0IGNsYXNzIENvbnYyRFByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWyd4JywgJ1cnXTtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgY29udkluZm86IGJhY2tlbmRfdXRpbC5Db252MkRJbmZvLCBhZGRCaWFzID0gZmFsc2UsXG4gICAgICBhY3RpdmF0aW9uOiBzdHJpbmcgPSBudWxsLCBoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzID0gZmFsc2UsXG4gICAgICBoYXNMZWFreXJlbHVBbHBoYSA9IGZhbHNlKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgIGNvbnN0IHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIGNvbnN0IHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgY29uc3Qgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgIGNvbnN0IHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgY29uc3QgZGlsYXRpb25IZWlnaHQgPSBjb252SW5mby5kaWxhdGlvbkhlaWdodDtcbiAgICBjb25zdCBkaWxhdGlvbldpZHRoID0gY29udkluZm8uZGlsYXRpb25XaWR0aDtcbiAgICBjb25zdCBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgY29uc3QgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcblxuICAgIGNvbnN0IGlucHV0RGVwdGhOZWFyZXN0VmVjNCA9IE1hdGguZmxvb3IoY29udkluZm8uaW5DaGFubmVscyAvIDQpICogNDtcbiAgICBjb25zdCBpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9IGNvbnZJbmZvLmluQ2hhbm5lbHMgJSA0O1xuICAgIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gY29udkluZm8uZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG5cbiAgICBjb25zdCByb3dEaW0gPSBpc0NoYW5uZWxzTGFzdCA/IDEgOiAyO1xuICAgIGNvbnN0IGNvbERpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMiA6IDM7XG4gICAgY29uc3QgY2hhbm5lbERpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMyA6IDE7XG5cbiAgICBsZXQgYWN0aXZhdGlvblNuaXBwZXQgPSAnJywgYXBwbHlBY3RpdmF0aW9uU25pcHBldCA9ICcnO1xuICAgIGlmIChhY3RpdmF0aW9uKSB7XG4gICAgICBpZiAoaGFzUHJlbHVBY3RpdmF0aW9uV2VpZ2h0cykge1xuICAgICAgICBhY3RpdmF0aW9uU25pcHBldCA9IGBmbG9hdCBhY3RpdmF0aW9uKGZsb2F0IGEpIHtcbiAgICAgICAgICBmbG9hdCBiID0gZ2V0UHJlbHVBY3RpdmF0aW9uV2VpZ2h0c0F0T3V0Q29vcmRzKCk7XG4gICAgICAgICAgJHthY3RpdmF0aW9ufVxuICAgICAgICB9YDtcbiAgICAgIH0gZWxzZSBpZiAoaGFzTGVha3lyZWx1QWxwaGEpIHtcbiAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBgZmxvYXQgYWN0aXZhdGlvbihmbG9hdCBhKSB7XG4gICAgICAgICAgZmxvYXQgYiA9IGdldExlYWt5cmVsdUFscGhhQXRPdXRDb29yZHMoKTtcbiAgICAgICAgICAke2FjdGl2YXRpb259XG4gICAgICAgIH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGlvblNuaXBwZXQgPSBgXG4gICAgICAgICAgZmxvYXQgYWN0aXZhdGlvbihmbG9hdCB4KSB7XG4gICAgICAgICAgICAke2FjdGl2YXRpb259XG4gICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgfVxuXG4gICAgICBhcHBseUFjdGl2YXRpb25TbmlwcGV0ID0gYHJlc3VsdCA9IGFjdGl2YXRpb24ocmVzdWx0KTtgO1xuICAgIH1cblxuICAgIGNvbnN0IGFkZEJpYXNTbmlwcGV0ID0gYWRkQmlhcyA/ICdyZXN1bHQgKz0gZ2V0Qmlhc0F0T3V0Q29vcmRzKCk7JyA6ICcnO1xuICAgIGlmIChhZGRCaWFzKSB7XG4gICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnYmlhcycpO1xuICAgIH1cblxuICAgIGlmIChoYXNQcmVsdUFjdGl2YXRpb25XZWlnaHRzKSB7XG4gICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgncHJlbHVBY3RpdmF0aW9uV2VpZ2h0cycpO1xuICAgIH1cblxuICAgIGlmIChoYXNMZWFreXJlbHVBbHBoYSkge1xuICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2xlYWt5cmVsdUFscGhhJyk7XG4gICAgfVxuXG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgICR7YWN0aXZhdGlvblNuaXBwZXR9XG5cbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMigke3N0cmlkZUhlaWdodH0sICR7c3RyaWRlV2lkdGh9KTtcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3BhZFRvcH0sICR7cGFkTGVmdH0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgIGludCBkMiA9IGNvb3Jkc1ske2NoYW5uZWxEaW19XTtcblxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPVxuICAgICAgICAgICAgaXZlYzIoY29vcmRzWyR7cm93RGltfV0sIGNvb3Jkc1ske2NvbERpbX1dKSAqIHN0cmlkZXMgLSBwYWRzO1xuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XG5cbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gZ2V0IHkoeVIsIHlDLCBkMikuXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtmaWx0ZXJIZWlnaHR9OyB3UisrKSB7XG4gICAgICAgICAgaW50IHhSID0geFJDb3JuZXIgKyB3UiAqICR7ZGlsYXRpb25IZWlnaHR9O1xuXG4gICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2NvbnZJbmZvLmluSGVpZ2h0fSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZmlsdGVyV2lkdGh9OyB3QysrKSB7XG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogJHtkaWxhdGlvbldpZHRofTtcblxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSAke2NvbnZJbmZvLmluV2lkdGh9KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGludCBkMSA9IDA7IGQxIDwgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9OyBkMSArPSA0KSB7XG4gICAgICAgICAgICAgIHZlYzQgd1ZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxLCBkMiksXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMSwgZDIpLFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDIsIGQyKSxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAzLCBkMilcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBpZiAoJHtpc0NoYW5uZWxzTGFzdH0pIHtcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMiksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlYzQgeFZhbHVlcyA9IHZlYzQoXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMSwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMywgeFIsIHhDKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCR7aW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDF9KSB7XG5cbiAgICAgICAgICAgICAgaWYgKCR7aXNDaGFubmVsc0xhc3R9KSB7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxuICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSkgKlxuICAgICAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9LCBkMik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxuICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0sIHhSLCB4QykgKlxuICAgICAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9LCBkMik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIGlmICgke2lucHV0RGVwdGhWZWM0UmVtYWluZGVyID09PSAyfSkge1xuICAgICAgICAgICAgICB2ZWMyIHdWYWx1ZXMgPSB2ZWMyKFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0sIGQyKSxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9ICsgMSwgZDIpXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgaWYgKCR7aXNDaGFubmVsc0xhc3R9KSB7XG4gICAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9KSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9ICsgMSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlYzIgeFZhbHVlcyA9IHZlYzIoXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0sIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0gKyAxLCB4UiwgeEMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCR7aW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDN9KSB7XG4gICAgICAgICAgICAgIHZlYzMgd1ZhbHVlcyA9IHZlYzMoXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSwgZDIpLFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0gKyAxLCBkMiksXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSArIDIsIGQyKVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGlmICgke2lzQ2hhbm5lbHNMYXN0fSkge1xuICAgICAgICAgICAgICAgIHZlYzMgeFZhbHVlcyA9IHZlYzMoXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSArIDEpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0gKyAyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSArIDEsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0gKyAyLCB4UiwgeEMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmxvYXQgcmVzdWx0ID0gZG90UHJvZDtcbiAgICAgICAgJHthZGRCaWFzU25pcHBldH1cbiAgICAgICAgJHthcHBseUFjdGl2YXRpb25TbmlwcGV0fVxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb252M0RQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCcsICdXJ107XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihjb252SW5mbzogYmFja2VuZF91dGlsLkNvbnYzREluZm8pIHtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG4gICAgY29uc3QgcGFkRnJvbnQgPSBjb252SW5mby5wYWRJbmZvLmZyb250O1xuICAgIGNvbnN0IHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIGNvbnN0IHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgY29uc3Qgc3RyaWRlRGVwdGggPSBjb252SW5mby5zdHJpZGVEZXB0aDtcbiAgICBjb25zdCBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgY29uc3Qgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICBjb25zdCBkaWxhdGlvbkRlcHRoID0gY29udkluZm8uZGlsYXRpb25EZXB0aDtcbiAgICBjb25zdCBkaWxhdGlvbkhlaWdodCA9IGNvbnZJbmZvLmRpbGF0aW9uSGVpZ2h0O1xuICAgIGNvbnN0IGRpbGF0aW9uV2lkdGggPSBjb252SW5mby5kaWxhdGlvbldpZHRoO1xuICAgIGNvbnN0IGZpbHRlckRlcHRoID0gY29udkluZm8uZmlsdGVyRGVwdGg7XG4gICAgY29uc3QgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgIGNvbnN0IGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG5cbiAgICBjb25zdCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKGNvbnZJbmZvLmluQ2hhbm5lbHMgLyA0KSAqIDQ7XG4gICAgY29uc3QgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSBjb252SW5mby5pbkNoYW5uZWxzICUgNDtcblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICBjb25zdCBpdmVjMyBzdHJpZGVzID0gaXZlYzMoJHtzdHJpZGVEZXB0aH0sICR7c3RyaWRlSGVpZ2h0fSwgJHtcbiAgICAgICAgc3RyaWRlV2lkdGh9KTtcbiAgICAgIGNvbnN0IGl2ZWMzIHBhZHMgPSBpdmVjMygke3BhZEZyb250fSwgJHtwYWRUb3B9LCAke3BhZExlZnR9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNSBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzLng7XG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy51O1xuXG4gICAgICAgIGl2ZWMzIHhGUkNDb3JuZXIgPSBpdmVjMyhjb29yZHMueSwgY29vcmRzLnosIGNvb3Jkcy53KSAqIHN0cmlkZXMgLSBwYWRzO1xuICAgICAgICBpbnQgeEZDb3JuZXIgPSB4RlJDQ29ybmVyLng7XG4gICAgICAgIGludCB4UkNvcm5lciA9IHhGUkNDb3JuZXIueTtcbiAgICAgICAgaW50IHhDQ29ybmVyID0geEZSQ0Nvcm5lci56O1xuXG4gICAgICAgIC8vIENvbnZvbHZlIHgoPywgPywgPywgZDEpIHdpdGggdyg6LCA6LCA6LCBkMSwgZDIpIHRvIGdldFxuICAgICAgICAvLyB5KHlGLCB5UiwgeUMsIGQyKS4gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsXG4gICAgICAgIC8vIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XG4gICAgICAgIGZvciAoaW50IHdGID0gMDsgd0YgPCAke2ZpbHRlckRlcHRofTsgd0YrKykge1xuICAgICAgICAgIGludCB4RiA9IHhGQ29ybmVyICsgd0YgKiAke2RpbGF0aW9uRGVwdGh9O1xuXG4gICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSAke2NvbnZJbmZvLmluRGVwdGh9KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtmaWx0ZXJIZWlnaHR9OyB3UisrKSB7XG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSICogJHtkaWxhdGlvbkhlaWdodH07XG5cbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gJHtjb252SW5mby5pbkhlaWdodH0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCAke2ZpbHRlcldpZHRofTsgd0MrKykge1xuICAgICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDICogJHtkaWxhdGlvbldpZHRofTtcblxuICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49ICR7Y29udkluZm8uaW5XaWR0aH0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGZvciAoaW50IGQxID0gMDsgZDEgPCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH07IGQxICs9IDQpIHtcbiAgICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMiksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZXMgPSB2ZWM0KFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSwgZDIpLFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCBkMSArIDEsIGQyKSxcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgZDEgKyAyLCBkMiksXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsIGQxICsgMywgZDIpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCR7aW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDF9KSB7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPVxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9KSAqXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSwgZDIpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCR7aW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT09IDJ9KSB7XG4gICAgICAgICAgICAgICAgdmVjMiB4VmFsdWVzID0gdmVjMihcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSksXG4gICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0gKyAxKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdmVjMiB3VmFsdWVzID0gdmVjMihcbiAgICAgICAgICAgICAgICAgIGdldFcod0YsIHdSLCB3QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9LCBkMiksXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSArIDEsIGQyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHtpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gM30pIHtcbiAgICAgICAgICAgICAgICB2ZWMzIHhWYWx1ZXMgPSB2ZWMzKFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9KSxcbiAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSArIDEpLFxuICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgJHtpbnB1dERlcHRoTmVhcmVzdFZlYzR9ICsgMilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHZlYzMgd1ZhbHVlcyA9IHZlYzMoXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSwgZDIpLFxuICAgICAgICAgICAgICAgICAgZ2V0Vyh3Riwgd1IsIHdDLCAke2lucHV0RGVwdGhOZWFyZXN0VmVjNH0gKyAxLCBkMiksXG4gICAgICAgICAgICAgICAgICBnZXRXKHdGLCB3Uiwgd0MsICR7aW5wdXREZXB0aE5lYXJlc3RWZWM0fSArIDIsIGQyKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2023 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { useShapeUniforms } from './gpgpu_math';\nexport class Conv2DDerInputPackedProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.customUniforms = [\n            { name: 'strides', type: 'vec2' },\n        ];\n        this.outputShape = convInfo.inShape;\n        this.enableShapeUniforms = useShapeUniforms(this.outputShape.length);\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${convInfo.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${convInfo.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9iYWNrcHJvcF9wYWNrZWRfZ3B1LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1iYWNrZW5kLXdlYmdsL3NyYy9jb252X2JhY2twcm9wX3BhY2tlZF9ncHUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxFQUFlLGdCQUFnQixFQUFDLE1BQU0sY0FBYyxDQUFDO0FBRTVELE1BQU0sT0FBTywyQkFBMkI7SUFXdEMsWUFBWSxRQUFpQztRQVY3QyxrQkFBYSxHQUFHLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzVCLGlCQUFZLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLGlCQUFZLEdBQUcsSUFBSSxDQUFDO1FBSXBCLG1CQUFjLEdBQUc7WUFDZixFQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLE1BQWUsRUFBRTtTQUMxQyxDQUFDO1FBR0EsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXJFLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUM7UUFDM0MsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUV6QyxNQUFNLE1BQU0sR0FBRyxZQUFZLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1FBQ3ZELE1BQU0sT0FBTyxHQUFHLFdBQVcsR0FBRyxDQUFDLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFFeEQsSUFBSSxDQUFDLFFBQVEsR0FBRztpQ0FDYSxNQUFNLEtBQUssT0FBTzs7Ozs7Ozs7Ozs7O2dDQVluQixZQUFZOztvQ0FFUixRQUFRLENBQUMsU0FBUzs7Ozt5QkFJN0IsWUFBWTs7a0NBRUgsV0FBVzsyQkFDbEIsV0FBVzs7O29EQUdjLFFBQVEsQ0FBQyxRQUFROzs7Ozt1REFLZCxRQUFRLENBQUMsUUFBUTs7Ozs7c0NBS2xDLFFBQVEsQ0FBQyxXQUFXOzs7Ozs7Ozs7Ozs7Ozs7OztzQ0FpQnBCLFFBQVEsQ0FBQyxXQUFXOzs7Ozs7Ozs7c0NBU3BCLFFBQVEsQ0FBQyxXQUFXOzs7Ozs7Ozs7Ozs7O0tBYXJELENBQUM7SUFDSixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMyBHb29nbGUgTExDLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtHUEdQVVByb2dyYW0sIHVzZVNoYXBlVW5pZm9ybXN9IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbmV4cG9ydCBjbGFzcyBDb252MkREZXJJbnB1dFBhY2tlZFByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWydkeScsICdXJ107XG4gIHBhY2tlZElucHV0cyA9IHRydWU7XG4gIHBhY2tlZE91dHB1dCA9IHRydWU7XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcbiAgZW5hYmxlU2hhcGVVbmlmb3JtczogYm9vbGVhbjtcbiAgY3VzdG9tVW5pZm9ybXMgPSBbXG4gICAge25hbWU6ICdzdHJpZGVzJywgdHlwZTogJ3ZlYzInIGFzIGNvbnN0IH0sXG4gIF07XG5cbiAgY29uc3RydWN0b3IoY29udkluZm86IGJhY2tlbmRfdXRpbC5Db252MkRJbmZvKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG4gICAgdGhpcy5lbmFibGVTaGFwZVVuaWZvcm1zID0gdXNlU2hhcGVVbmlmb3Jtcyh0aGlzLm91dHB1dFNoYXBlLmxlbmd0aCk7XG5cbiAgICBjb25zdCBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgY29uc3QgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcblxuICAgIGNvbnN0IHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICBjb25zdCBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuXG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3BhZFRvcH0sICR7cGFkTGVmdH0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1szXTtcblxuICAgICAgICBpdmVjMiBkeUNvcm5lciA9IGl2ZWMyKGNvb3Jkc1sxXSwgY29vcmRzWzJdKSAtIHBhZHM7XG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcblxuICAgICAgICB2ZWM0IHJlc3VsdCA9IHZlYzQoMC4pO1xuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtmaWx0ZXJIZWlnaHR9OyB3UisrKSB7XG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gc3RyaWRlc1swXTtcbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2NvbnZJbmZvLm91dEhlaWdodH0uMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcbiAgICAgICAgICBpbnQgd1JQZXJtID0gJHtmaWx0ZXJIZWlnaHR9IC0gMSAtIHdSO1xuXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZmlsdGVyV2lkdGh9OyB3QysrKSB7XG4gICAgICAgICAgICBpbnQgd0NQZXJtID0gJHtmaWx0ZXJXaWR0aH0gLSAxIC0gd0M7XG5cbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIHN0cmlkZXNbMV07XG4gICAgICAgICAgICBib29sIGlkeUNWYWwgPSAoZHlDID49IDAuMCkgJiYgKGR5QyA8ICR7Y29udkluZm8ub3V0V2lkdGh9LjApXG4gICAgICAgICAgICAgICYmIChmcmFjdChkeUMpID09IDAuMCk7XG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xuXG4gICAgICAgICAgICBmbG9hdCBkeUMyID0gZmxvYXQoZHlDQ29ybmVyICsgd0MgKyAxKSAvIHN0cmlkZXNbMV07XG4gICAgICAgICAgICBib29sIGlkeUNWYWwyID0gKGR5QzIgPj0gMC4wKSAmJiAoZHlDMiA8ICR7Y29udkluZm8ub3V0V2lkdGh9LjApXG4gICAgICAgICAgICAgICYmIChmcmFjdChkeUMyKSA9PSAwLjApO1xuICAgICAgICAgICAgaW50IGlkeUMyID0gaW50KGR5QzIpO1xuXG4gICAgICAgICAgICBpZiAoaWR5Q1ZhbCAmJiBpZHlDVmFsMikge1xuICAgICAgICAgICAgICBmb3IgKGludCBkMiA9IDA7IGQyIDwgJHtjb252SW5mby5vdXRDaGFubmVsc307IGQyICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2ZWM0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgdmVjNCBkeVNhbXBsZSA9IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDLCBkMik7XG4gICAgICAgICAgICAgICAgdmVjNCBkeVNhbXBsZTIgPSAoaWR5QyAvIDIgPT0gaWR5QzIgLyAyKSA/XG4gICAgICAgICAgICAgICAgICBkeVNhbXBsZSA6IGdldER5KGJhdGNoLCBpZHlSLCBpZHlDMiwgZDIpO1xuXG4gICAgICAgICAgICAgICAgdmVjMiBkeVZhbHVlID0gbW9kKGZsb2F0KGlkeUMpLCAyLikgPT0gMC4gP1xuICAgICAgICAgICAgICAgICAgZHlTYW1wbGUueHkgOiBkeVNhbXBsZS56dztcbiAgICAgICAgICAgICAgICByZXN1bHQueHkgKz0gdmVjMihkb3QoZHlWYWx1ZSwgd1ZhbHVlLnh5KSxcbiAgICAgICAgICAgICAgICAgIGRvdChkeVZhbHVlLCB3VmFsdWUuencpKTtcblxuICAgICAgICAgICAgICAgIGR5VmFsdWUgPSBtb2QoZmxvYXQoaWR5QzIpLCAyLikgPT0gMC4gP1xuICAgICAgICAgICAgICAgICAgZHlTYW1wbGUyLnh5IDogZHlTYW1wbGUyLnp3O1xuICAgICAgICAgICAgICAgIHJlc3VsdC56dyArPSB2ZWMyKGRvdChkeVZhbHVlLCB3VmFsdWUueHkpLFxuICAgICAgICAgICAgICAgICAgZG90KGR5VmFsdWUsIHdWYWx1ZS56dykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlkeUNWYWwpIHtcbiAgICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8ICR7Y29udkluZm8ub3V0Q2hhbm5lbHN9OyBkMiArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmVjNCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgIHZlYzQgZHlTYW1wbGUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QywgZDIpO1xuICAgICAgICAgICAgICAgIHZlYzIgZHlWYWx1ZSA9IG1vZChmbG9hdChpZHlDKSwgMi4pID09IDAuID9cbiAgICAgICAgICAgICAgICAgIGR5U2FtcGxlLnh5IDogZHlTYW1wbGUuenc7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lnh5ICs9IHZlYzIoZG90KGR5VmFsdWUsIHdWYWx1ZS54eSksXG4gICAgICAgICAgICAgICAgICBkb3QoZHlWYWx1ZSwgd1ZhbHVlLnp3KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaWR5Q1ZhbDIpIHtcbiAgICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8ICR7Y29udkluZm8ub3V0Q2hhbm5lbHN9OyBkMiArPSAyKSB7XG4gICAgICAgICAgICAgICAgdmVjNCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgIHZlYzQgZHlTYW1wbGUgPSBnZXREeShiYXRjaCwgaWR5UiwgaWR5QzIsIGQyKTtcbiAgICAgICAgICAgICAgICB2ZWMyIGR5VmFsdWUgPSBtb2QoZmxvYXQoaWR5QzIpLCAyLikgPT0gMC4gP1xuICAgICAgICAgICAgICAgICAgZHlTYW1wbGUueHkgOiBkeVNhbXBsZS56dztcbiAgICAgICAgICAgICAgICByZXN1bHQuencgKz0gdmVjMihkb3QoZHlWYWx1ZSwgd1ZhbHVlLnh5KSxcbiAgICAgICAgICAgICAgICAgIGRvdChkeVZhbHVlLCB3VmFsdWUuencpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQocmVzdWx0KTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class DepthwiseConv2DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${channelMul} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class DepthwiseConv2DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        const channelMul = convInfo.outChannels / convInfo.inChannels;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${channelMul}; dm++) {\n              int d2 = d1 * ${channelMul} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9iYWNrcHJvcF9ncHVfZGVwdGh3aXNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1iYWNrZW5kLXdlYmdsL3NyYy9jb252X2JhY2twcm9wX2dwdV9kZXB0aHdpc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBS0gsTUFBTSxPQUFPLCtCQUErQjtJQUsxQyxZQUFZLFFBQWlDO1FBSjdDLGtCQUFhLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFLMUIsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBRXhDLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUM7UUFDM0MsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUN6QyxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztRQUNwQyxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztRQUN0QyxNQUFNLFVBQVUsR0FBRyxRQUFRLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxVQUFVLENBQUM7UUFFOUQsSUFBSSxDQUFDLFFBQVEsR0FBRzs7Ozs7Ozt3QkFPSSxVQUFVOzs7Ozs4QkFLSixRQUFRLENBQUMsU0FBUztrQ0FDZCxRQUFRLENBQUMsU0FBUztpQ0FDbkIsWUFBWSxNQUFNLE1BQU07O2tDQUV2QixRQUFRLENBQUMsUUFBUTs7OztvQ0FJZixRQUFRLENBQUMsUUFBUTttQ0FDbEIsV0FBVyxNQUFNLE9BQU87O29DQUV2QixRQUFRLENBQUMsT0FBTzs7Ozs7Ozs7Ozs7O0tBWS9DLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFFRCxNQUFNLE9BQU8sOEJBQThCO0lBS3pDLFlBQVksUUFBaUM7UUFKN0Msa0JBQWEsR0FBRyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztRQUsxQixJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUM7UUFFcEMsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQztRQUMzQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBQ3pDLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUM7UUFDM0MsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUV6QyxNQUFNLE1BQU0sR0FBRyxZQUFZLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO1FBQ3ZELE1BQU0sT0FBTyxHQUFHLFdBQVcsR0FBRyxDQUFDLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDeEQsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsVUFBVSxDQUFDO1FBRTlELElBQUksQ0FBQyxRQUFRLEdBQUc7aUNBQ2EsTUFBTSxLQUFLLE9BQU87Ozs7Ozs7Ozs7OztnQ0FZbkIsWUFBWTtnREFDSSxZQUFZOztvQ0FFeEIsUUFBUSxDQUFDLFNBQVM7Ozs7O3lCQUs3QixZQUFZOztrQ0FFSCxXQUFXO2tEQUNLLFdBQVc7O3NDQUV2QixRQUFRLENBQUMsUUFBUTs7Ozs7OzJCQU01QixXQUFXOzs7b0NBR0YsVUFBVTs4QkFDaEIsVUFBVTs7Ozs7Ozs7O0tBU25DLENBQUM7SUFDSixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YmFja2VuZF91dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtHUEdQVVByb2dyYW19IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5cbmV4cG9ydCBjbGFzcyBEZXB0aHdpc2VDb252MkREZXJGaWx0ZXJQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCcsICdkeSddO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY29udkluZm86IGJhY2tlbmRfdXRpbC5Db252MkRJbmZvKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmZpbHRlclNoYXBlO1xuXG4gICAgY29uc3Qgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgIGNvbnN0IHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgY29uc3QgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgY29uc3QgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICBjb25zdCBjaGFubmVsTXVsID0gY29udkluZm8ub3V0Q2hhbm5lbHMgLyBjb252SW5mby5pbkNoYW5uZWxzO1xuXG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy54O1xuICAgICAgICBpbnQgd0MgPSBjb29yZHMueTtcbiAgICAgICAgaW50IGQxID0gY29vcmRzLno7XG4gICAgICAgIGludCBkbSA9IGNvb3Jkcy53O1xuICAgICAgICBpbnQgZDIgPSBkMSAqICR7Y2hhbm5lbE11bH0gKyBkbTtcblxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuXG4gICAgICAgIC8vIFRPIERPOiBWZWM0IG92ZXIgdGhlIGJhdGNoIHNpemVcbiAgICAgICAgZm9yIChpbnQgYiA9IDA7IGIgPCAke2NvbnZJbmZvLmJhdGNoU2l6ZX07IGIrKykge1xuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCAke2NvbnZJbmZvLm91dEhlaWdodH07IHlSKyspIHtcbiAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiAke3N0cmlkZUhlaWdodH0gLSAke3BhZFRvcH07XG5cbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gJHtjb252SW5mby5pbkhlaWdodH0pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaW50IHlDID0gMDsgeUMgPCAke2NvbnZJbmZvLm91dFdpZHRofTsgeUMrKykge1xuICAgICAgICAgICAgICBpbnQgeEMgPSB3QyArIHlDICogJHtzdHJpZGVXaWR0aH0gLSAke3BhZExlZnR9O1xuXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gJHtjb252SW5mby5pbldpZHRofSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIERlcHRod2lzZUNvbnYyRERlcklucHV0UHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ2R5JywgJ1cnXTtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGNvbnZJbmZvOiBiYWNrZW5kX3V0aWwuQ29udjJESW5mbykge1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5pblNoYXBlO1xuXG4gICAgY29uc3QgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgIGNvbnN0IGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgY29uc3Qgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgIGNvbnN0IHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG5cbiAgICBjb25zdCBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgY29uc3QgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICBjb25zdCBjaGFubmVsTXVsID0gY29udkluZm8ub3V0Q2hhbm5lbHMgLyBjb252SW5mby5pbkNoYW5uZWxzO1xuXG4gICAgdGhpcy51c2VyQ29kZSA9IGBcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMigke3BhZFRvcH0sICR7cGFkTGVmdH0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1szXTtcbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBjb29yZHMueXogLSBwYWRzO1xuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XG5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgJHtmaWx0ZXJIZWlnaHR9OyB3UisrKSB7XG4gICAgICAgICAgZmxvYXQgZHlSID0gZmxvYXQoZHlSQ29ybmVyICsgd1IpIC8gJHtzdHJpZGVIZWlnaHR9LjA7XG5cbiAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2NvbnZJbmZvLm91dEhlaWdodH0uMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcblxuICAgICAgICAgIGludCB3UlBlcm0gPSAke2ZpbHRlckhlaWdodH0gLSAxIC0gd1I7XG5cbiAgICAgICAgICBmb3IgKGludCB3QyA9IDA7IHdDIDwgJHtmaWx0ZXJXaWR0aH07IHdDKyspIHtcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvICR7c3RyaWRlV2lkdGh9LjA7XG5cbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7Y29udkluZm8ub3V0V2lkdGh9LjAgfHxcbiAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50IGlkeUMgPSBpbnQoZHlDKTtcblxuICAgICAgICAgICAgaW50IHdDUGVybSA9ICR7ZmlsdGVyV2lkdGh9IC0gMSAtIHdDO1xuXG4gICAgICAgICAgICAvLyBUTyBETzogVmVjNCBvdmVyIHRoZSBjaGFubmVsTXVsXG4gICAgICAgICAgICBmb3IgKGludCBkbSA9IDA7IGRtIDwgJHtjaGFubmVsTXVsfTsgZG0rKykge1xuICAgICAgICAgICAgICBpbnQgZDIgPSBkMSAqICR7Y2hhbm5lbE11bH0gKyBkbTtcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcbiAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGRtKTtcbiAgICAgICAgICAgICAgZG90UHJvZCArPSB4VmFsdWUgKiB3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport class Conv2DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        this.userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n            int xR = wR + yR * ${strideHeight} - ${padTop};\n\n            if (xR < 0 || xR >= ${convInfo.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n              int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n              if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                continue;\n              }\n\n              ${isChannelsLast ?\n            `float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);` :\n            `float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);`}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv2DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        const rowDim = isChannelsLast ? 1 : 2;\n        const colDim = isChannelsLast ? 2 : 3;\n        const channelDim = isChannelsLast ? 3 : 1;\n        this.userCode = `\n      const ivec2 pads = ivec2(${padTop}, ${padLeft});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${channelDim}];\n\n        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${filterHeight}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${filterHeight} - 1 - wR;\n\n          for (int wC = 0; wC < ${filterWidth}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${filterWidth} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n\n              if (${isChannelsLast}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv3DDerFilterProgram {\n    constructor(convInfo) {\n        this.variableNames = ['x', 'dy'];\n        this.outputShape = convInfo.filterShape;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padFront = convInfo.padInfo.front;\n        const padTop = convInfo.padInfo.top;\n        const padLeft = convInfo.padInfo.left;\n        this.userCode = `\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${convInfo.batchSize}; b++) {\n          for (int yF = 0; yF < ${convInfo.outDepth}; yF++) {\n            int xF = wF + yF * ${strideDepth} - ${padFront};\n\n            if (xF < 0 || xF >= ${convInfo.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${convInfo.outHeight}; yR++) {\n              int xR = wR + yR * ${strideHeight} - ${padTop};\n\n              if (xR < 0 || xR >= ${convInfo.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${convInfo.outWidth}; yC++) {\n                int xC = wC + yC * ${strideWidth} - ${padLeft};\n\n                if (xC < 0 || xC >= ${convInfo.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\nexport class Conv3DDerInputProgram {\n    constructor(convInfo) {\n        this.variableNames = ['dy', 'W'];\n        this.outputShape = convInfo.inShape;\n        const filterDepth = convInfo.filterDepth;\n        const filterHeight = convInfo.filterHeight;\n        const filterWidth = convInfo.filterWidth;\n        const strideDepth = convInfo.strideDepth;\n        const strideHeight = convInfo.strideHeight;\n        const strideWidth = convInfo.strideWidth;\n        const padFront = filterDepth - 1 - convInfo.padInfo.front;\n        const padTop = filterHeight - 1 - convInfo.padInfo.top;\n        const padLeft = filterWidth - 1 - convInfo.padInfo.left;\n        this.userCode = `\n      const ivec3 pads = ivec3(${padFront}, ${padTop}, ${padLeft});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${filterDepth}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${convInfo.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${filterDepth} - 1 - wF;\n\n          for (int wR = 0; wR < ${filterHeight}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${convInfo.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${filterHeight} - 1 - wR;\n\n            for (int wC = 0; wC < ${filterWidth}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${convInfo.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${filterWidth} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${convInfo.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl9iYWNrcHJvcF9ncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ2wvc3JjL2NvbnZfYmFja3Byb3BfZ3B1LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUtILE1BQU0sT0FBTyxzQkFBc0I7SUFLakMsWUFBWSxRQUFpQztRQUo3QyxrQkFBYSxHQUFHLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBSzFCLElBQUksQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQztRQUV4QyxNQUFNLFlBQVksR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDO1FBQzNDLE1BQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUM7UUFDekMsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7UUFDcEMsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7UUFDdEMsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLFVBQVUsS0FBSyxjQUFjLENBQUM7UUFFOUQsSUFBSSxDQUFDLFFBQVEsR0FBRzs7Ozs7Ozs7Ozs7OzhCQVlVLFFBQVEsQ0FBQyxTQUFTO2tDQUNkLFFBQVEsQ0FBQyxTQUFTO2lDQUNuQixZQUFZLE1BQU0sTUFBTTs7a0NBRXZCLFFBQVEsQ0FBQyxRQUFROzs7O29DQUlmLFFBQVEsQ0FBQyxRQUFRO21DQUNsQixXQUFXLE1BQU0sT0FBTzs7b0NBRXZCLFFBQVEsQ0FBQyxPQUFPOzs7O2dCQUlwQyxjQUFjLENBQUEsQ0FBQztZQUNsQjs7NkNBRWdDLENBQUMsQ0FBQztZQUNsQzs7NkNBRWdDOzs7Ozs7S0FNeEMsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQUVELE1BQU0sT0FBTyxxQkFBcUI7SUFLaEMsWUFBWSxRQUFpQztRQUo3QyxrQkFBYSxHQUFHLENBQUMsSUFBSSxF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LENBQUM7UUFDekMsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQztRQUMzQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBQ3pDLE1BQU0sV0FBVyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUM7UUFDekMsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQztRQUMzQyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDO1FBRXpDLE1BQU0sUUFBUSxHQUFHLFdBQVcsR0FBRyxDQUFDLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7UUFDMUQsTUFBTSxNQUFNLEdBQUcsWUFBWSxHQUFHLENBQUMsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztRQUN2RCxNQUFNLE9BQU8sR0FBRyxXQUFXLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBRXhELElBQUksQ0FBQyxRQUFRLEdBQUc7aUNBQ2EsUUFBUSxLQUFLLE1BQU0sS0FBSyxPQUFPOzs7Ozs7Ozs7Ozs7OztnQ0FjaEMsV0FBVztnREFDSyxXQUFXOztvQ0FFdkIsUUFBUSxDQUFDLFFBQVE7Ozs7O3lCQUs1QixXQUFXOztrQ0FFRixZQUFZO2tEQUNJLFlBQVk7O3NDQUV4QixRQUFRLENBQUMsU0FBUzs7Ozs7OzJCQU03QixZQUFZOztvQ0FFSCxXQUFXO29EQUNLLFdBQVc7O3dDQUV2QixRQUFRLENBQUMsUUFBUTs7Ozs7OzZCQU01QixXQUFXOztzQ0FFRixRQUFRLENBQUMsV0FBVzs7Ozs7Ozs7OztLQVVyRCxDQUFDO0lBQ0osQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7R1BHUFVQcm9ncmFtfSBmcm9tICcuL2dwZ3B1X21hdGgnO1xuXG5leHBvcnQgY2xhc3MgQ29udjJERGVyRmlsdGVyUHJvZ3JhbSBpbXBsZW1lbnRzIEdQR1BVUHJvZ3JhbSB7XG4gIHZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnZHknXTtcbiAgb3V0cHV0U2hhcGU6IG51bWJlcltdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGNvbnZJbmZvOiBiYWNrZW5kX3V0aWwuQ29udjJESW5mbykge1xuICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5maWx0ZXJTaGFwZTtcblxuICAgIGNvbnN0IHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICBjb25zdCBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgIGNvbnN0IHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIGNvbnN0IHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgY29uc3QgaXNDaGFubmVsc0xhc3QgPSBjb252SW5mby5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0JztcblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgd1IgPSBjb29yZHMueDtcbiAgICAgICAgaW50IHdDID0gY29vcmRzLnk7XG4gICAgICAgIGludCBkMSA9IGNvb3Jkcy56O1xuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcblxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIGR5KDosIDosIGQyKSB0byBnZXQgZHcod1IsIHdDLCBkMSwgZDIpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8ICR7Y29udkluZm8uYmF0Y2hTaXplfTsgYisrKSB7XG4gICAgICAgICAgZm9yIChpbnQgeVIgPSAwOyB5UiA8ICR7Y29udkluZm8ub3V0SGVpZ2h0fTsgeVIrKykge1xuICAgICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqICR7c3RyaWRlSGVpZ2h0fSAtICR7cGFkVG9wfTtcblxuICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2NvbnZJbmZvLmluSGVpZ2h0fSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8ICR7Y29udkluZm8ub3V0V2lkdGh9OyB5QysrKSB7XG4gICAgICAgICAgICAgIGludCB4QyA9IHdDICsgeUMgKiAke3N0cmlkZVdpZHRofSAtICR7cGFkTGVmdH07XG5cbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSAke2NvbnZJbmZvLmluV2lkdGh9KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAke2lzQ2hhbm5lbHNMYXN0P1xuICAgICAgICAgICAgIGBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO2AgOlxuICAgICAgICAgICAgIGBmbG9hdCBkeVZhbHVlID0gZ2V0RHkoYiwgZDIsIHlSLCB5Qyk7XG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgZDEsIHhSLCB4Qyk7XG4gICAgICAgICAgICAgIGRvdFByb2QgKz0gKHhWYWx1ZSAqIGR5VmFsdWUpO2B9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb252MkREZXJJbnB1dFByb2dyYW0gaW1wbGVtZW50cyBHUEdQVVByb2dyYW0ge1xuICB2YXJpYWJsZU5hbWVzID0gWydkeScsICdXJ107XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXTtcbiAgdXNlckNvZGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcihjb252SW5mbzogYmFja2VuZF91dGlsLkNvbnYyREluZm8pIHtcbiAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uaW5TaGFwZTtcblxuICAgIGNvbnN0IGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICBjb25zdCBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgIGNvbnN0IHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICBjb25zdCBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgIGNvbnN0IGlzQ2hhbm5lbHNMYXN0ID0gY29udkluZm8uZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCc7XG5cbiAgICBjb25zdCBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgY29uc3QgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcblxuICAgIGNvbnN0IHJvd0RpbSA9IGlzQ2hhbm5lbHNMYXN0ID8gMSA6IDI7XG4gICAgY29uc3QgY29sRGltID0gaXNDaGFubmVsc0xhc3QgPyAyIDogMztcbiAgICBjb25zdCBjaGFubmVsRGltID0gaXNDaGFubmVsc0xhc3QgPyAzIDogMTtcblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoJHtwYWRUb3B9LCAke3BhZExlZnR9KTtcblxuICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcbiAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xuICAgICAgICBpbnQgZDEgPSBjb29yZHNbJHtjaGFubmVsRGltfV07XG5cbiAgICAgICAgaXZlYzIgZHlDb3JuZXIgPSBpdmVjMihjb29yZHNbJHtyb3dEaW19XSwgY29vcmRzWyR7Y29sRGltfV0pIC0gcGFkcztcbiAgICAgICAgaW50IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgIGludCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcbiAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8ICR7ZmlsdGVySGVpZ2h0fTsgd1IrKykge1xuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvICR7c3RyaWRlSGVpZ2h0fS4wO1xuXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtjb252SW5mby5vdXRIZWlnaHR9LjAgfHwgZnJhY3QoZHlSKSA+IDAuMCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGludCBpZHlSID0gaW50KGR5Uik7XG5cbiAgICAgICAgICBpbnQgd1JQZXJtID0gJHtmaWx0ZXJIZWlnaHR9IC0gMSAtIHdSO1xuXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZmlsdGVyV2lkdGh9OyB3QysrKSB7XG4gICAgICAgICAgICBmbG9hdCBkeUMgPSBmbG9hdChkeUNDb3JuZXIgKyB3QykgLyAke3N0cmlkZVdpZHRofS4wO1xuXG4gICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke2NvbnZJbmZvLm91dFdpZHRofS4wIHx8XG4gICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XG5cbiAgICAgICAgICAgIGludCB3Q1Blcm0gPSAke2ZpbHRlcldpZHRofSAtIDEgLSB3QztcblxuICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8ICR7Y29udkluZm8ub3V0Q2hhbm5lbHN9OyBkMisrKSB7XG5cbiAgICAgICAgICAgICAgaWYgKCR7aXNDaGFubmVsc0xhc3R9KSB7XG4gICAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcbiAgICAgICAgICAgICAgICBmbG9hdCB3VmFsdWUgPSBnZXRXKHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBkMiwgaWR5UiwgaWR5Qyk7XG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3UlBlcm0sIHdDUGVybSwgZDEsIGQyKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb252M0REZXJGaWx0ZXJQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsneCcsICdkeSddO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY29udkluZm86IGJhY2tlbmRfdXRpbC5Db252M0RJbmZvKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmZpbHRlclNoYXBlO1xuXG4gICAgY29uc3Qgc3RyaWRlRGVwdGggPSBjb252SW5mby5zdHJpZGVEZXB0aDtcbiAgICBjb25zdCBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgY29uc3Qgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICBjb25zdCBwYWRGcm9udCA9IGNvbnZJbmZvLnBhZEluZm8uZnJvbnQ7XG4gICAgY29uc3QgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgY29uc3QgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcblxuICAgIHRoaXMudXNlckNvZGUgPSBgXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgd0YgPSBjb29yZHMueDtcbiAgICAgICAgaW50IHdSID0gY29vcmRzLnk7XG4gICAgICAgIGludCB3QyA9IGNvb3Jkcy56O1xuICAgICAgICBpbnQgZDEgPSBjb29yZHMudztcbiAgICAgICAgaW50IGQyID0gY29vcmRzLnU7XG5cbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcblxuICAgICAgICBmb3IgKGludCBiID0gMDsgYiA8ICR7Y29udkluZm8uYmF0Y2hTaXplfTsgYisrKSB7XG4gICAgICAgICAgZm9yIChpbnQgeUYgPSAwOyB5RiA8ICR7Y29udkluZm8ub3V0RGVwdGh9OyB5RisrKSB7XG4gICAgICAgICAgICBpbnQgeEYgPSB3RiArIHlGICogJHtzdHJpZGVEZXB0aH0gLSAke3BhZEZyb250fTtcblxuICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSAke2NvbnZJbmZvLmluRGVwdGh9KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGludCB5UiA9IDA7IHlSIDwgJHtjb252SW5mby5vdXRIZWlnaHR9OyB5UisrKSB7XG4gICAgICAgICAgICAgIGludCB4UiA9IHdSICsgeVIgKiAke3N0cmlkZUhlaWdodH0gLSAke3BhZFRvcH07XG5cbiAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSAke2NvbnZJbmZvLmluSGVpZ2h0fSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8ICR7Y29udkluZm8ub3V0V2lkdGh9OyB5QysrKSB7XG4gICAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqICR7c3RyaWRlV2lkdGh9IC0gJHtwYWRMZWZ0fTtcblxuICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gJHtjb252SW5mby5pbldpZHRofSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZmxvYXQgZHlWYWx1ZSA9IGdldER5KGIsIHlGLCB5UiwgeUMsIGQyKTtcbiAgICAgICAgICAgICAgICBmbG9hdCB4VmFsdWUgPSBnZXRYKGIsIHhGLCB4UiwgeEMsIGQxKTtcbiAgICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29udjNERGVySW5wdXRQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lcyA9IFsnZHknLCAnVyddO1xuICBvdXRwdXRTaGFwZTogbnVtYmVyW107XG4gIHVzZXJDb2RlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoY29udkluZm86IGJhY2tlbmRfdXRpbC5Db252M0RJbmZvKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG5cbiAgICBjb25zdCBmaWx0ZXJEZXB0aCA9IGNvbnZJbmZvLmZpbHRlckRlcHRoO1xuICAgIGNvbnN0IGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICBjb25zdCBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgIGNvbnN0IHN0cmlkZURlcHRoID0gY29udkluZm8uc3RyaWRlRGVwdGg7XG4gICAgY29uc3Qgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgIGNvbnN0IHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG5cbiAgICBjb25zdCBwYWRGcm9udCA9IGZpbHRlckRlcHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8uZnJvbnQ7XG4gICAgY29uc3QgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgIGNvbnN0IHBhZExlZnQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG5cbiAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgY29uc3QgaXZlYzMgcGFkcyA9IGl2ZWMzKCR7cGFkRnJvbnR9LCAke3BhZFRvcH0sICR7cGFkTGVmdH0pO1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGl2ZWM1IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHMueDtcbiAgICAgICAgaW50IGQxID0gY29vcmRzLnU7XG5cblxuICAgICAgICBpdmVjMyBkeUNvcm5lciA9IGl2ZWMzKGNvb3Jkcy55LCBjb29yZHMueiwgY29vcmRzLncpIC0gcGFkcztcbiAgICAgICAgaW50IGR5RkNvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICBpbnQgZHlDQ29ybmVyID0gZHlDb3JuZXIuejtcblxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xuICAgICAgICBmb3IgKGludCB3RiA9IDA7IHdGIDwgJHtmaWx0ZXJEZXB0aH07IHdGKyspIHtcbiAgICAgICAgICBmbG9hdCBkeUYgPSBmbG9hdChkeUZDb3JuZXIgKyB3RikgLyAke3N0cmlkZURlcHRofS4wO1xuXG4gICAgICAgICAgaWYgKGR5RiA8IDAuMCB8fCBkeUYgPj0gJHtjb252SW5mby5vdXREZXB0aH0uMCB8fCBmcmFjdChkeUYpID4gMC4wKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW50IGlkeUYgPSBpbnQoZHlGKTtcblxuICAgICAgICAgIGludCB3RlBlcm0gPSAke2ZpbHRlckRlcHRofSAtIDEgLSB3RjtcblxuICAgICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCAke2ZpbHRlckhlaWdodH07IHdSKyspIHtcbiAgICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvICR7c3RyaWRlSGVpZ2h0fS4wO1xuXG4gICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke2NvbnZJbmZvLm91dEhlaWdodH0uMCB8fFxuICAgICAgICAgICAgICBmcmFjdChkeVIpID4gMC4wKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcblxuICAgICAgICAgICAgaW50IHdSUGVybSA9ICR7ZmlsdGVySGVpZ2h0fSAtIDEgLSB3UjtcblxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8ICR7ZmlsdGVyV2lkdGh9OyB3QysrKSB7XG4gICAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvICR7c3RyaWRlV2lkdGh9LjA7XG5cbiAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtjb252SW5mby5vdXRXaWR0aH0uMCB8fFxuICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGludCBpZHlDID0gaW50KGR5Qyk7XG5cbiAgICAgICAgICAgICAgaW50IHdDUGVybSA9ICR7ZmlsdGVyV2lkdGh9IC0gMSAtIHdDO1xuXG4gICAgICAgICAgICAgIGZvciAoaW50IGQyID0gMDsgZDIgPCAke2NvbnZJbmZvLm91dENoYW5uZWxzfTsgZDIrKykge1xuICAgICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldER5KGJhdGNoLCBpZHlGLCBpZHlSLCBpZHlDLCBkMik7XG4gICAgICAgICAgICAgICAgZmxvYXQgd1ZhbHVlID0gZ2V0Vyh3RlBlcm0sIHdSUGVybSwgd0NQZXJtLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbHVlICogd1ZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util } from '@tensorflow/tfjs-core';\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ConcatPackedProgram {\n    constructor(shapes, axis) {\n        this.packedInputs = true;\n        this.packedOutput = true;\n        this.outputShape = [];\n        this.outputShape = backend_util.computeOutShape(shapes, axis);\n        const shape = this.outputShape;\n        const rank = shape.length;\n        const dtype = getCoordsDataType(rank);\n        const coords = getChannels('coords', rank);\n        const channels = ['x', 'y', 'z', 'w', 'u', 'v'].slice(0, rank);\n        this.variableNames = shapes.map((_, i) => `T${i}`);\n        const offsets = new Array(shapes.length - 1);\n        offsets[0] = shapes[0][axis];\n        for (let i = 1; i < offsets.length; i++) {\n            offsets[i] = offsets[i - 1] + shapes[i][axis];\n        }\n        const channel = channels[axis];\n        const lastChannels = channels.slice(-2);\n        const allChannels = channels.join();\n        let getValueSnippet = `if (${channel} < ${offsets[0]}) {\n        return getChannel(\n            getT0(${allChannels}), vec2(${lastChannels.join()}));\n        }`;\n        for (let i = 1; i < offsets.length; i++) {\n            const shift = offsets[i - 1];\n            // Note: the >= comparison below may seem unnecessary given the check\n            // above but is needed to workaround branch execution issues on some\n            // devices. It makes all the conditions exclusive without relying on\n            // execution order.\n            getValueSnippet += `\n        if (${channel} < ${offsets[i]}  && ${channel} >= ${offsets[i - 1]}) {\n          return getChannel(\n            getT${i}(${shiftedChannels(channels, channel, shift)}),\n            vec2(${shiftedChannels(lastChannels, channel, shift)}));\n        }`;\n        }\n        const lastIndex = offsets.length;\n        const shift = offsets[offsets.length - 1];\n        getValueSnippet += `\n        return getChannel(\n          getT${lastIndex}(${shiftedChannels(channels, channel, shift)}),\n          vec2(${shiftedChannels(lastChannels, channel, shift)}));`;\n        this.userCode = `\n      float getValue(${channels.map(x => 'int ' + x)}) {\n        ${getValueSnippet}\n      }\n\n      void main() {\n        ${dtype} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${coords}), 0., 0., 0.);\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} + 1;\n        if (${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.g = getValue(${coords});\n        }\n\n        ${coords[rank - 2]} = ${coords[rank - 2]} + 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]}) {\n          result.a = getValue(${coords});\n        }\n\n        ${coords[rank - 1]} = ${coords[rank - 1]} - 1;\n        if (${coords[rank - 2]} < ${shape[rank - 2]} &&\n            ${coords[rank - 1]} < ${shape[rank - 1]}) {\n          result.b = getValue(${coords});\n        }\n        setOutput(result);\n      }\n    `;\n    }\n}\n/**\n * Return an expression for coordinates into a vector where a given channel\n * will be offset by [shift].\n *\n * @param channels the channels to consider\n * @param channel the channel we want shifted\n * @param shift  the amount to subtract from the channel.\n *\n * @returns a string of the form 'x, y-[shift], z' where any one channel can\n * have the shift applied.\n */\nfunction shiftedChannels(channels, channel, shift) {\n    const channelIdx = channels.indexOf(channel);\n    const res = channels.map((c, idx) => {\n        if (idx === channelIdx) {\n            return `${c} - ${shift}`;\n        }\n        else {\n            return c;\n        }\n    });\n    return res.join();\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uY2F0X3BhY2tlZF9ncHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtd2ViZ2wvc3JjL2NvbmNhdF9wYWNrZWRfZ3B1LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUduRCxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFFcEQsTUFBTSxPQUFPLG1CQUFtQjtJQU85QixZQUFZLE1BQWtCLEVBQUUsSUFBWTtRQUw1QyxpQkFBWSxHQUFHLElBQUksQ0FBQztRQUNwQixpQkFBWSxHQUFHLElBQUksQ0FBQztRQUNwQixnQkFBVyxHQUFhLEVBQUUsQ0FBQztRQUl6QixJQUFJLENBQUMsV0FBVyxHQUFHLFlBQVksQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzlELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDL0IsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUMxQixNQUFNLEtBQUssR0FBRyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0QyxNQUFNLE1BQU0sR0FBRyxXQUFXLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzNDLE1BQU0sUUFBUSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQy9ELElBQUksQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxD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Q0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7Y0FDckMsTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztnQ0FDbkIsTUFBTTs7OztLQUlqQyxDQUFDO0lBQ0osQ0FBQztDQUNGO0FBRUQ7Ozs7Ozs7Ozs7R0FVRztBQUNILFNBQVMsZUFBZSxDQUFDLFFBQWtCLEVBQUUsT0FBZSxFQUFFLEtBQWE7SUFDekUsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM3QyxNQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFO1FBQ2xDLElBQUksR0FBRyxLQUFLLFVBQVUsRUFBRTtZQUN0QixPQUFPLEdBQUcsQ0FBQyxNQUFNLEtBQUssRUFBRSxDQUFDO1NBQzFCO2FBQU07WUFDTCxPQUFPLENBQUMsQ0FBQztTQUNWO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUNwQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2JhY2tlbmRfdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtHUEdQVVByb2dyYW19IGZyb20gJy4vZ3BncHVfbWF0aCc7XG5pbXBvcnQge2dldENoYW5uZWxzfSBmcm9tICcuL3BhY2tpbmdfdXRpbCc7XG5pbXBvcnQge2dldENvb3Jkc0RhdGFUeXBlfSBmcm9tICcuL3NoYWRlcl9jb21waWxlcic7XG5cbmV4cG9ydCBjbGFzcyBDb25jYXRQYWNrZWRQcm9ncmFtIGltcGxlbWVudHMgR1BHUFVQcm9ncmFtIHtcbiAgdmFyaWFibGVOYW1lczogc3RyaW5nW107XG4gIHBhY2tlZElucHV0cyA9IHRydWU7XG4gIHBhY2tlZE91dHB1dCA9IHRydWU7XG4gIG91dHB1dFNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICB1c2VyQ29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHNoYXBlczogbnVtYmVyW11bXSwgYXhpczogbnVtYmVyKSB7XG4gICAgdGhpcy5vdXRwdXRTaGFwZSA9IGJhY2tlbmRfdXRpbC5jb21wdXRlT3V0U2hhcGUoc2hhcGVzLCBheGlzKTtcbiAgICBjb25zdCBzaGFwZSA9IHRoaXMub3V0cHV0U2hhcGU7XG4gICAgY29uc3QgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBjb25zdCBkdHlwZSA9IGdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICAgIGNvbnN0IGNvb3JkcyA9IGdldENoYW5uZWxzKCdjb29yZHMnLCByYW5rKTtcbiAgICBjb25zdCBjaGFubmVscyA9IFsneCcsICd5JywgJ3onLCAndycsICd1JywgJ3YnXS5zbGljZSgwLCByYW5rKTtcbiAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBzaGFwZXMubWFwKChfLCBpKSA9PiBgVCR7aX1gKTtcblxuICAgIGNvbnN0IG9mZnNldHM6IG51bWJlcltdID0gbmV3IEFycmF5KHNoYXBlcy5sZW5ndGggLSAxKTtcbiAgICBvZmZzZXRzWzBdID0gc2hhcGVzWzBdW2F4aXNdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2Zmc2V0c1tpXSA9IG9mZnNldHNbaSAtIDFdICsgc2hhcGVzW2ldW2F4aXNdO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYW5uZWwgPSBjaGFubmVsc1theGlzXTtcbiAgICBjb25zdCBsYXN0Q2hhbm5lbHMgPSBjaGFubmVscy5zbGljZSgtMik7XG4gICAgY29uc3QgYWxsQ2hhbm5lbHMgPSBjaGFubmVscy5qb2luKCk7XG5cbiAgICBsZXQgZ2V0VmFsdWVTbmlwcGV0ID0gYGlmICgke2NoYW5uZWx9IDwgJHtvZmZzZXRzWzBdfSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcbiAgICAgICAgICAgIGdldFQwKCR7YWxsQ2hhbm5lbHN9KSwgdmVjMigke2xhc3RDaGFubmVscy5qb2luKCl9KSk7XG4gICAgICAgIH1gO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2hpZnQgPSBvZmZzZXRzW2kgLSAxXTtcbiAgICAgIC8vIE5vdGU6IHRoZSA+PSBjb21wYXJpc29uIGJlbG93IG1heSBzZWVtIHVubmVjZXNzYXJ5IGdpdmVuIHRoZSBjaGVja1xuICAgICAgLy8gYWJvdmUgYnV0IGlzIG5lZWRlZCB0byB3b3JrYXJvdW5kIGJyYW5jaCBleGVjdXRpb24gaXNzdWVzIG9uIHNvbWVcbiAgICAgIC8vIGRldmljZXMuIEl0IG1ha2VzIGFsbCB0aGUgY29uZGl0aW9ucyBleGNsdXNpdmUgd2l0aG91dCByZWx5aW5nIG9uXG4gICAgICAvLyBleGVjdXRpb24gb3JkZXIuXG4gICAgICBnZXRWYWx1ZVNuaXBwZXQgKz0gYFxuICAgICAgICBpZiAoJHtjaGFubmVsfSA8ICR7b2Zmc2V0c1tpXX0gICYmICR7Y2hhbm5lbH0gPj0gJHtvZmZzZXRzW2kgLSAxXX0pIHtcbiAgICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcbiAgICAgICAgICAgIGdldFQke2l9KCR7c2hpZnRlZENoYW5uZWxzKGNoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSxcbiAgICAgICAgICAgIHZlYzIoJHtzaGlmdGVkQ2hhbm5lbHMobGFzdENoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSk7XG4gICAgICAgIH1gO1xuICAgIH1cbiAgICBjb25zdCBsYXN0SW5kZXggPSBvZmZzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBzaGlmdCA9IG9mZnNldHNbb2Zmc2V0cy5sZW5ndGggLSAxXTtcbiAgICBnZXRWYWx1ZVNuaXBwZXQgKz0gYFxuICAgICAgICByZXR1cm4gZ2V0Q2hhbm5lbChcbiAgICAgICAgICBnZXRUJHtsYXN0SW5kZXh9KCR7c2hpZnRlZENoYW5uZWxzKGNoYW5uZWxzLCBjaGFubmVsLCBzaGlmdCl9KSxcbiAgICAgICAgICB2ZWMyKCR7c2hpZnRlZENoYW5uZWxzKGxhc3RDaGFubmVscywgY2hhbm5lbCwgc2hpZnQpfSkpO2A7XG5cbiAgICB0aGlzLnVzZXJDb2RlID0gYFxuICAgICAgZmxvYXQgZ2V0VmFsdWUoJHtjaGFubmVscy5tYXAoeCA9PiAnaW50ICcgKyB4KX0pIHtcbiAgICAgICAgJHtnZXRWYWx1ZVNuaXBwZXR9XG4gICAgICB9XG5cbiAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgJHtkdHlwZX0gY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XG4gICAgICAgIHZlYzQgcmVzdWx0ID0gdmVjNChnZXRWYWx1ZSgke2Nvb3Jkc30pLCAwLiwgMC4sIDAuKTtcblxuICAgICAgICAke2Nvb3Jkc1tyYW5rIC0gMV19ID0gJHtjb29yZHNbcmFuayAtIDFdfSArIDE7XG4gICAgICAgIGlmICgke2Nvb3Jkc1tyYW5rIC0gMV19IDwgJHtzaGFwZVtyYW5rIC0gMV19KSB7XG4gICAgICAgICAgcmVzdWx0LmcgPSBnZXRWYWx1ZSgke2Nvb3Jkc30pO1xuICAgICAgICB9XG5cbiAgICAgICAgJHtjb29yZHNbcmFuayAtIDJdfSA9ICR7Y29vcmRzW3JhbmsgLSAyXX0gKyAxO1xuICAgICAgICBpZiAoJHtjb29yZHNbcmFuayAtIDJdfSA8ICR7c2hhcGVbcmFuayAtIDJdfSkge1xuICAgICAgICAgIHJlc3VsdC5hID0gZ2V0VmFsdWUoJHtjb29yZHN9KTtcbiAgICAgICAgfVxuXG4gICAgICAgICR7Y29vcmRzW3JhbmsgLSAxXX0gPSAke2Nvb3Jkc1tyYW5rIC0gMV19IC0gMTtcbiAgICAgICAgaWYgKCR7Y29vcmRzW3JhbmsgLSAyXX0gPCAke3NoYXBlW3JhbmsgLSAyXX0gJiZcbiAgICAgICAgICAgICR7Y29vcmRzW3JhbmsgLSAxXX0gPCAke3NoYXBlW3JhbmsgLSAxXX0pIHtcbiAgICAgICAgICByZXN1bHQuYiA9IGdldFZhbHVlKCR7Y29vcmRzfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3V0cHV0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgYDtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiBhbiBleHByZXNzaW9uIGZvciBjb29yZGluYXRlcyBpbnRvIGEgdmVjdG9yIHdoZXJlIGEgZ2l2ZW4gY2hhbm5lbFxuICogd2lsbCBiZSBvZmZzZXQgYnkgW3NoaWZ0XS5cbiAqXG4gKiBAcGFyYW0gY2hhbm5lbHMgdGhlIGNoYW5uZWxzIHRvIGNvbnNpZGVyXG4gKiBAcGFyYW0gY2hhbm5lbCB0aGUgY2hhbm5lbCB3ZSB3YW50IHNoaWZ0ZWRcbiAqIEBwYXJhbSBzaGlmdCAgdGhlIGFtb3VudCB0byBzdWJ0cmFjdCBmcm9tIHRoZSBjaGFubmVsLlxuICpcbiAqIEByZXR1cm5zIGEgc3RyaW5nIG9mIHRoZSBmb3JtICd4LCB5LVtzaGlmdF0sIHonIHdoZXJlIGFueSBvbmUgY2hhbm5lbCBjYW5cbiAqIGhhdmUgdGhlIHNoaWZ0IGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIHNoaWZ0ZWRDaGFubmVscyhjaGFubmVsczogc3RyaW5nW10sIGNoYW5uZWw6IHN0cmluZywgc2hpZnQ6IG51bWJlcikge1xuICBjb25zdCBjaGFubmVsSWR4ID0gY2hhbm5lbHMuaW5kZXhPZihjaGFubmVsKTtcbiAgY29uc3QgcmVzID0gY2hhbm5lbHMubWFwKChjLCBpZHgpID0+IHtcbiAgICBpZiAoaWR4ID09PSBjaGFubmVsSWR4KSB7XG4gICAgICByZXR1cm4gYCR7Y30gLSAke3NoaWZ0fWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXMuam9pbigpO1xufVxuIl19"],"names":["DepthwiseConv2DProgram","constructor","convInfo","addBias","activation","hasPreluActivation","hasLeakyReluAlpha","this","variableNames","customUniforms","name","type","outputShape","outShape","enableShapeUniforms","length","filterHeight","filterWidth","channelMul","outChannels","inChannels","activationSnippet","applyActivationSnippet","addBiasSnippet","push","userCode","ConcatProgram","shapes","backend_util","map","_","i","offsets","Array","snippets","shift","lastIndex","lastShift","join","Conv2DProgram","hasPreluActivationWeights","hasLeakyreluAlpha","padTop","padInfo","top","padLeft","left","strideHeight","strideWidth","dilationHeight","dilationWidth","inputDepthNearestVec4","Math","floor","inputDepthVec4Remainder","isChannelsLast","dataFormat","rowDim","colDim","channelDim","inHeight","inWidth","Conv3DProgram","padFront","front","strideDepth","dilationDepth","filterDepth","inDepth","Conv2DDerInputPackedProgram","packedInputs","packedOutput","inShape","outHeight","outWidth","DepthwiseConv2DDerFilterProgram","filterShape","batchSize","DepthwiseConv2DDerInputProgram","Conv2DDerFilterProgram","Conv2DDerInputProgram","Conv3DDerFilterProgram","outDepth","Conv3DDerInputProgram","ConcatPackedProgram","axis","shape","rank","dtype","coords","channels","slice","channel","lastChannels","allChannels","getValueSnippet","shiftedChannels","x","channelIdx","indexOf","c","idx"],"sourceRoot":""}