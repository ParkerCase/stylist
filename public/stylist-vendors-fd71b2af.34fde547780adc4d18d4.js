"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[4954],{23325:function(e,t,r){r.d(t,{F:function(){return o}});var n=r(50259),s=r(28189),a=r(45119);const o=async function(e,t){const r=(0,s.YT)(e,"x","setdiff1d"),o=(0,s.YT)(t,"y","setdiff1d");a.vA(r.dtype===o.dtype,(()=>`x and y should have the same dtype, but got x (${r.dtype}) and y (${o.dtype}).`)),a.vA(1===r.rank,(()=>`x should be 1D tensor, but got x (${r.shape}).`)),a.vA(1===o.rank,(()=>`y should be 1D tensor, but got y (${o.shape}).`));const i=await r.data(),h=await o.data(),u=new Set(h);let p=0;for(let n=0;n<i.length;n++)u.has(i[n])||p++;const c=new n.yl([p],r.dtype),l=new n.yl([p],"int32");for(let n=0,s=0;n<i.length;n++)u.has(i[n])||(c.values[s]=i[n],l.values[s]=n,s++);return[c.toTensor(),l.toTensor()]}},26170:function(e,t,r){r.r(t),r.d(t,{calculateShapes:function(){return o},validateInput:function(){return a},validateUpdateShape:function(){return s}});var n=r(45119);function s(e,t,r){const n=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${r.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${n}, and batchDim: ${s}.`;if(r.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<n+(r.rank-s))throw new Error(a+` Output shape length < ${n+(r.rank-s)}`);if(r.rank!==s+e.length-n)throw new Error(a+" update.rank != "+(s+e.length-n));for(let o=0;o<s;++o)if(r.shape[o]!==t.shape[o])throw new Error(a+` updates.shape[${o}] (${r.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<r.rank-s;++o)if(r.shape[o+s]!==e[o+n])throw new Error(a+` updates.shape[${o+s}] (${r.shape[o+s]}) != shape[${o+s}] (${e[o+s]})`)}function a(e,t,r){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(r.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${r}`);if(0===r.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}s(r,t,e)}function o(e,t,r){const s=t.shape.length,a=s>1?t.shape[s-1]:1,o=r.length;let i=1;for(let n=a;n<o;++n)i*=r[n];const h=a<1?1:a;return{sliceRank:a,numUpdates:(0,n.Ze)(t.shape)/h,sliceSize:i,strides:[...(0,n.Ur)(r.slice(0,a)),1],outputSize:(0,n.Ze)(r)}}},26325:function(e,t,r){r.d(t,{W:function(){return o}});var n=r(67897),s=r(15441),a=r(28189);const o=(0,r(70929).op)({selu_:function(e){const t={x:(0,a.YT)(e,"x","selu")};return n.T2.runKernel(s.u$b,t)}})},28576:function(e,t,r){r.d(t,{X:function(){return s},j:function(){return n}});const n=1.7580993408473768,s=1.0507009873554805},45702:function(e,t,r){r.d(t,{d:function(){return a}});var n=r(89783),s=r(19171);function a(e,t){if(((0,n.isTypedArray)(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&(0,n.isTypedArray)(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,s.Q)(e,[],[],t)}},47516:function(e,t,r){r.r(t),r.d(t,{collectGatherOpShapeInfo:function(){return i},computeOutShape:function(){return o},segOpComputeOptimalWindowSize:function(){return a}});var n=r(45119),s=r(29827);function a(e,t){let r,a=!1;for(e<=s.m?(r=e,a=!0):r=(0,n.lK)(e,Math.floor(Math.sqrt(e)));!a;)r>t||r===e?a=!0:r=(0,n.lK)(e,r+1);return r}function o(e,t,r){const n=[],s=e.length;for(let a=0;a<s;a++)a!==t?n.push(e[a]):n.push(r);return n}function i(e,t,r,n){const s=t.shape.length,a=e.shape.length;if(0!==n&&(n<-s||n>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${n}`);if(n<0&&(n+=s),n>a)throw new Error(`batchDims (${n}) must be less than rank(x) (\n    ${a}).`);if(r<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${r}).`);for(let c=0;c<n;++c)if(e.shape[c]!==t.shape[c])throw new Error(`x.shape[${c}]: ${e.shape[c]} should be equal to indices.shape[${c}]: ${t.shape[c]}.`);const o=e.shape[r],i=[];let h=1,u=1,p=1;for(let c=0;c<n;++c)i.push(e.shape[c]),h*=e.shape[c];for(let c=n;c<r;c++)i.push(e.shape[c]),u*=e.shape[c];for(let c=n;c<s;c++)i.push(t.shape[c]);for(let c=r+1;c<a;c++)i.push(e.shape[c]),p*=e.shape[c];return{batchSize:h,sliceSize:p,outerSize:u,dimSize:o,outputShape:i}}},79120:function(e,t,r){r.d(t,{s:function(){return p}});var n=r(67897),s=r(15441),a=r(28189),o=r(45119),i=r(70929),h=r(62302);const u=2147483648;const p=(0,i.op)({searchSorted_:function(e,t,r="left"){const i=(0,a.YT)(e,"sortedSequence","searchSorted"),p=(0,a.YT)(t,"values","searchSorted"),c=i.shape[i.shape.length-1],l=p.shape[p.shape.length-1],d=(0,h.t)(i,[-1,c]),f=(0,h.t)(p,[-1,l]);if(d.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(d.shape[0]!==f.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,o.Ze)(f.shape)>=u)throw new Error("values tensor size must less than 2147483648");if(d.shape[1]>=u)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${d.shape[1]}`);const w={sortedSequence:d,values:f},b={side:r};return n.T2.runKernel(s.uWl,w,b)}})},89986:function(e,t,r){r.d(t,{w:function(){return u}});var n=r(28189),s=r(45119),a=r(28794),o=r(10676),i=r(70929),h=r(62302);const u=(0,i.op)({separableConv2d_:function(e,t,r,i,u,p=[1,1],c="NHWC"){const l=(0,n.YT)(e,"x","separableConv2d"),d=(0,n.YT)(t,"depthwiseFilter","separableConv2d"),f=(0,n.YT)(r,"pointwiseFilter","separableConv2d");let w=l,b=!1;if(3===l.rank&&(b=!0,w=(0,h.t)(l,[1,l.shape[0],l.shape[1],l.shape[2]])),"NCHW"===c)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");s.vA(4===w.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${w.rank}.`)),s.vA(4===d.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${d.rank}.`)),s.vA(4===f.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${d.rank}.`)),s.vA(1===f.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${f.shape[0]}.`)),s.vA(1===f.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${f.shape[1]}.`));const m=d.shape[2],$=d.shape[3];s.vA(f.shape[2]===m*$,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*$}, but got ${f.shape[2]}.`));const g=(0,o.G)(w,d,i,u,c,p),k=(0,a.X)(g,f,1,"valid",c);return b?(0,h.t)(k,[k.shape[1],k.shape[2],k.shape[3]]):k}})},94791:function(e,t,r){r.d(t,{N:function(){return u}});var n=r(67897),s=r(15441),a=r(28189),o=r(45119),i=r(70929),h=r(26170);const u=(0,i.op)({scatterND_:function(e,t,r){(0,o.SA)(r);const i=(0,a.YT)(e,"indices","scatterND","int32"),u=(0,a.YT)(t,"updates","scatterND");h.validateInput(u,i,r);const p={indices:i,updates:u},c={shape:r};return n.T2.runKernel(s.pJc,p,c)}})}}]);
//# sourceMappingURL=stylist-vendors-fd71b2af.34fde547780adc4d18d4.js.map