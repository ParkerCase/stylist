"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[5151],{12629:function(t,e,s){var n=s(9495),i=s(47661),r=s(87504),a=s(79730),l=s(15841),u=s(59351),o=s(84379),h=s(44813),p=s(63057);class c extends a.Wd{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==t.batchInputShape&&null==t.inputShape){let e=null;null!=t.batchSize&&(e=t.batchSize),null==t.inputLength?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(h.st(t.inputLength))}this.inputDim=t.inputDim,h.oo(this.inputDim,"inputDim"),this.outputDim=t.outputDim,h.oo(this.outputDim,"outputDim"),this.embeddingsInitializer=(0,u.Fe)(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=(0,o.Bm)(t.embeddingsRegularizer),this.activityRegularizer=(0,o.Bm)(t.activityRegularizer),this.embeddingsConstraint=(0,r.YZ)(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return(0,n.tidy)((()=>this.maskZero?(t=(0,p.un)(t),(0,n.notEqual)(t,(0,n.zerosLike)(t))):null))}computeOutputShape(t){if(t=(0,p.U$)(t),null==this.inputLength)return[...t,this.outputDim];const e=h.st(this.inputLength);if(e.length!==t.length-1)throw new l.Qp(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let s=0;for(let n=0;n<e.length;++n){const i=e[n],r=t[n+1];if(null!=i&&null!=r&&i!==r)throw new l.Qp(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);null==i&&(e[s]=r),s++}}return[t[0],...e,this.outputDim]}call(t,e){return(0,n.tidy)((()=>{this.invokeCallHook(t,e);let s=(0,p.un)(t);"int32"!==s.dtype&&(s=i.wg(s,"int32"));const r=i.kg(this.embeddings.read(),(0,n.reshape)(s,[s.size]));return(0,n.reshape)(r,(0,p.U$)(this.computeOutputShape(s.shape)))}))}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:(0,u.zo)(this.embeddingsInitializer),embeddingsRegularizer:(0,o.R9)(this.embeddingsRegularizer),activityRegularizer:(0,o.R9)(this.activityRegularizer),embeddingsConstraint:(0,r.uH)(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}c.className="Embedding",n.serialization.registerClass(c)},36165:function(t,e,s){var n=s(9495),i=s(47661),r=s(79730),a=s(63057);class l extends r.Wd{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return(0,n.tidy)((()=>{this.invokeCallHook(t,e);const s=(0,a.un)(t);return i.Ls((()=>(0,n.add)(i.FE(s.shape,0,this.stddev),s)),(()=>s),e.training||!1)}))}}l.className="GaussianNoise",n.serialization.registerClass(l);class u extends r.Wd{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return(0,n.tidy)((()=>{this.invokeCallHook(t,e);const s=(0,a.un)(t);if(this.rate>0&&this.rate<1){const t=()=>{const t=Math.sqrt(this.rate/(1-this.rate));return(0,n.mul)(s,i.FE(s.shape,1,t))};return i.Ls(t,(()=>s),e.training||!1)}return s}))}}u.className="GaussianDropout",n.serialization.registerClass(u);class o extends r.Wd{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||(0,a.un)(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return(0,n.tidy)((()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(t),r=()=>{const e=(0,a.un)(t),r=-1.7580993408473766;let l=(0,n.greaterEqual)((0,n.randomUniform)(s),this.rate);l=i.wg(l,"float32");const u=((1-this.rate)*(1+this.rate*r**2))**-.5,o=-u*r*this.rate,h=(0,n.add)((0,n.mul)(e,l),(0,n.mul)((0,n.add)(l,-1),r));return(0,n.add)((0,n.mul)(h,u),o)};return i.Ls(r,(()=>(0,a.un)(t)),e.training||!1)}return t}))}}o.className="AlphaDropout",n.serialization.registerClass(o)},47483:function(t,e,s){var n=s(9495),i=s(47661),r=s(79730),a=s(15841),l=s(48981),u=s(44813),o=s(73072),h=s(63057);class p extends r.Wd{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new a.EH}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const s=t.slice(0,t.length-e.length);for(let n=0;n<e.length;++n){const i=t[t.length-e.length+n],r=e[n];if(null==i||null==r||i<0||r<0)s.push(null);else if(1===i)s.push(r);else if(1===r)s.push(i);else{if(i!==r)throw new a.Qp("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(i)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[(0,h.U$)(t)]),t.length<2)throw new a.Qp(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const i of t)null!=i&&null!==i[0]&&e.push(i[0]);if(e=u.Am(e),e.length>1)throw new a.Qp(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=null==t[0]?null:t[0].slice(1);for(let i=1;i<t.length;++i){const e=null==t[i]?null:t[i].slice(1);s=this.computeElementwiseOpOutputShape(s,e)}const n=t.map((t=>t.length));-1===t.indexOf(null)&&1===u.Am(n).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return(0,n.tidy)((()=>{if(this.reshapeRequired){const e=[],s=t.map((t=>t.rank));if(-1===s.indexOf(null)){const n=o.T9(s);for(let s of t){const t=s.rank;for(let e=0;e<n-t;++e)s=i.UG(s,1);e.push(s)}return this.mergeFunction(e)}{let s=!1;for(const a of t){const t=a.rank;if(null==t){const t=a.shape,i=t[0],r=t.slice(1).concat([i]);let l=n.reshape(a,[i].concat(o.no(t.slice(1))));l=n.transpose(l,[1,0]),l=n.reshape(l,r),e.push(l),s=!0}else if(t>1){const i=o.y1(1,t).concat([0]);e.push(n.transpose(a,i)),s=!0}else e.push(a)}let i=this.mergeFunction(e);const r=i.rank;if(s)if(null==r){const t=i.shape,e=t[t.length-1],s=[e].concat(t.slice(0,t.length-1));i=n.reshape(n.transpose(n.reshape(i,[-1,e]),[1,0]),s)}else if(r>1){const t=[r-1].concat(o.y1(0,r-1));i=n.transpose(i,t)}return i}}return this.mergeFunction(t)}))}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let n=1;n<t.length;++n){const s=null==t[n]?null:t[n].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let s=[];for(const n of t)null!=n&&null!==n[0]&&s.push(n[0]);return s=u.Am(s),e=1===s.length?s.concat(e):[null].concat(e),e}computeMask(t,e){return n.tidy((()=>{if(null==e)return null;if(!Array.isArray(e))throw new a.Qp("`mask` should be an Array");if(!Array.isArray(t))throw new a.Qp("`inputs` should be an Array");if(e.length!==t.length)throw new a.Qp(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every((t=>null==t)))return null;let s=(e=e.map((t=>null==t?t:n.expandDims(t,0))))[0];for(let t=1;t<e.length-1;++t)s=n.logicalAnd(s,e[t]);return s}))}}class c extends p{constructor(t){super(t)}mergeFunction(t){return(0,n.tidy)((()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=n.add(e,t[s]);return e}))}}c.className="Add",n.serialization.registerClass(c);class g extends p{constructor(t){super(t)}mergeFunction(t){return(0,n.tidy)((()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=n.mul(e,t[s]);return e}))}}g.className="Multiply",n.serialization.registerClass(g);class d extends p{constructor(t){super(t)}mergeFunction(t){return(0,n.tidy)((()=>{let e=t[0].clone();for(let s=1;s<t.length;++s)e=n.add(e,t[s]);return n.mul(1/t.length,e)}))}}d.className="Average",n.serialization.registerClass(d);class m extends p{constructor(t){super(t)}mergeFunction(t){return(0,n.tidy)((()=>{let e=t[0];for(let s=1;s<t.length;++s)e=n.maximum(e,t[s]);return e}))}}m.className="Maximum",n.serialization.registerClass(m);class f extends p{constructor(t){super(t)}mergeFunction(t){return(0,n.tidy)((()=>{let e=t[0];for(let s=1;s<t.length;++s)e=n.minimum(e,t[s]);return e}))}}f.className="Minimum",n.serialization.registerClass(f);class y extends p{constructor(t){super(t),this.DEFAULT_AXIS=-1,null==t&&(t={}),this.axis=null==t.axis?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new a.Qp("A `Concatenate` layer should be called on a list of at least 2 inputs");let e=!0;for(const n of t)if(null!=n){e=!1;break}if(e)return;const s=[];for(let i=0;i<t.length;++i){const e=t[i].slice();e.splice(this.axis,1);let r=!1;for(const t of s)if(n.util.arraysEqual(t,e)){r=!0;break}r||s.push(e)}if(s.length>1)throw new a.Qp("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return(0,n.tidy)((()=>i.u1(t,this.axis)))}computeOutputShape(t){if(!Array.isArray(t)||!Array.isArray(t[0]))throw new a.Qp("A `Concatenate` layer should be called on a list of inputs.");const e=t,s=e[0].slice(),n=this.axis<0?s.length+this.axis:this.axis;for(const i of e.slice(1)){if(null==s[n]||null==i[n]){s[n]=null;break}s[n]+=i[n]}return s}computeMask(t,e){if(null==e)return null;if(!Array.isArray(e))throw new a.Qp("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new a.Qp("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new a.Qp(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return n.tidy((()=>{let s=!0;if(e.forEach((t=>{null==t||(s=!1)})),s)return null;const i=[];for(let a=0;a<t.length;++a)null==e[a]?i.push(n.cast(n.onesLike(t[a]),"bool")):e[a].rank<t[a].rank?i.push(n.expandDims(e[a],-1)):i.push(e[a]);const r=n.concat(i,this.axis);return n.all(r,-1,!1)}))}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}function b(t,e){for(;t<0;)t+=e;return t}y.className="Concatenate",n.serialization.registerClass(y);class A extends p{constructor(t){super(t),this.axes=t.axes,this.normalize=null!=t.normalize&&t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){n.util.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0],s=t[1];if(e.length>3||s.length>3)throw new a.EH("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,s);if(e[i[0]]!==s[i[1]])throw new a.Qp(`Dimension incompatibility: ${e[i[0]]} !== ${s[i[1]]}`)}mergeFunction(t){if(2!==t.length)throw new a.Qp(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e,s=t[0],i=t[1];return e=Array.isArray(this.axes)?this.axes.map(((e,s)=>b(e,t[s].shape.length))):[b(this.axes,s.shape.length),b(this.axes,i.shape.length)],this.normalize&&(s=(0,l.Yq)(s,e[0]),i=(0,l.Yq)(i,e[1])),function(t,e,s){if(t.shape.length>3||e.shape.length>3)throw new a.EH("batchDot is not implemented for tensors of 4D or higher rank yet");if(n.util.assert(t.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`)),n.util.assert(t.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`)),"number"===typeof s&&(s=[s,s]),"complex64"===t.dtype||"complex64"===e.dtype)throw new a.EH("batchDot is not implemented for complex64-type Tensors yet.");const i=t.shape.length,r=e.shape.length;null==s&&(s=[i-1,r-2]);const l=s;return n.tidy((()=>{let s,a;if(i>r){s=i-r;const t=[];for(let e=0;e<s;++e)t.push(1);e=n.reshape(e,e.shape.concat(t))}else if(r>i){s=r-i;const e=[];for(let t=0;t<s;++t)e.push(1);t=n.reshape(t,t.shape.concat(e))}else s=0;if(2===t.shape.length&&2===e.shape.length)a=l[0]===l[1]?n.sum(n.mul(t,e),l[0]):n.sum(n.mul(n.transpose(t,[1,0]),e),l[1]);else{const s=l[0]!==t.shape.length-1,i=l[1]===e.shape.length-1;a=n.matMul(t,e,s,i)}if(s>0){let t;t=i>r?i+r-3:i-1;const e=[];for(let n=t;n<t+s;++n)e.push(n);a=n.squeeze(a,e)}return 1===a.shape.length&&(a=n.expandDims(a,1)),a}))}(s,i,e)}interpretAxes(t,e){let s;return s=Array.isArray(this.axes)?this.axes:[b(this.axes,t.length),b(this.axes,e.length)],s}computeOutputShape(t){n.util.assert(Array.isArray(t)&&2===t.length&&Array.isArray(t[0])&&Array.isArray(t[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const e=t[0].slice(),s=t[1].slice();if(e.length>3||s.length>3)throw new a.EH("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(e,s);e.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const r=e.concat(s);return 1===r.length&&r.push(1),r}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}A.className="Dot",n.serialization.registerClass(A)}}]);
//# sourceMappingURL=stylist-vendors-6e5319ad.73170098612f82731a0c.js.map