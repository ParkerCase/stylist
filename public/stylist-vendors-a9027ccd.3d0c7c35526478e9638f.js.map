{"version":3,"file":"stylist-vendors-a9027ccd.3d0c7c35526478e9638f.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-converter/dist/executor/tensor_list.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-converter/dist/executor/tensor_array.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-converter/dist/executor/tensor_utils.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-converter/dist/executor/resource_manager.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-converter/dist/executor/model_analysis.js"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { concat, keep, reshape, scalar, slice, stack, tensor, tidy, unstack } from '@tensorflow/tfjs-core';\nimport { assertShapesMatchAllowUndefinedSize, inferElementShape, mergeElementShape } from './tensor_utils';\n/**\n * TensorList stores a container of `tf.Tensor` objects, which are accessible\n * via tensors field.\n *\n * In order to get a copy of the underlying list, use the copy method:\n * ```\n *    TensorList b = a.copy();\n *    b.tensors().pushBack(t);  // This does not modify a.tensors().\n * ```\n *\n * Note that this is not a deep copy: the memory locations of the underlying\n * tensors will still point to the same locations of the corresponding tensors\n * in the original.\n */\nexport class TensorList {\n    get id() {\n        return this.idTensor.id;\n    }\n    /**\n     *\n     * @param tensors list of tensors\n     * @param elementShape shape of each tensor, this can be a single number (any\n     * shape is allowed) or partial shape (dim = -1).\n     * @param elementDtype data type of each tensor\n     * @param maxNumElements The maximum allowed size of `tensors`. Defaults to -1\n     *   meaning that the size of `tensors` is unbounded.\n     */\n    constructor(tensors, elementShape, elementDtype, maxNumElements = -1) {\n        this.tensors = tensors;\n        this.elementShape = elementShape;\n        this.elementDtype = elementDtype;\n        if (tensors != null) {\n            tensors.forEach(tensor => {\n                if (elementDtype !== tensor.dtype) {\n                    throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${tensor.dtype}`);\n                }\n                assertShapesMatchAllowUndefinedSize(elementShape, tensor.shape, 'TensorList shape mismatch: ');\n                keep(tensor);\n            });\n        }\n        this.idTensor = scalar(0);\n        this.maxNumElements = maxNumElements;\n        keep(this.idTensor);\n    }\n    /**\n     * Get a new TensorList containing a copy of the underlying tensor container.\n     */\n    copy() {\n        return new TensorList([...this.tensors], this.elementShape, this.elementDtype);\n    }\n    /**\n     * Dispose the tensors and idTensor and clear the tensor list.\n     */\n    clearAndClose(keepIds) {\n        this.tensors.forEach(tensor => {\n            if (keepIds == null || !keepIds.has(tensor.id)) {\n                tensor.dispose();\n            }\n        });\n        this.tensors.length = 0;\n        this.idTensor.dispose();\n    }\n    /**\n     * The size of the tensors in the tensor list.\n     */\n    size() {\n        return this.tensors.length;\n    }\n    /**\n     * Return a tensor that stacks a list of rank-R tf.Tensors into one rank-(R+1)\n     * tf.Tensor.\n     * @param elementShape shape of each tensor\n     * @param elementDtype data type of each tensor\n     * @param numElements the number of elements to stack\n     */\n    stack(elementShape, elementDtype, numElements = -1) {\n        if (elementDtype !== this.elementDtype) {\n            throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);\n        }\n        if (numElements !== -1 && this.tensors.length !== numElements) {\n            throw new Error(`Operation expected a list with ${numElements} elements but got a list with ${this.tensors.length} elements.`);\n        }\n        assertShapesMatchAllowUndefinedSize(elementShape, this.elementShape, 'TensorList shape mismatch: ');\n        const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);\n        return tidy(() => {\n            const reshapedTensors = this.tensors.map(tensor => reshape(tensor, outputElementShape));\n            return stack(reshapedTensors, 0);\n        });\n    }\n    /**\n     * Pop a tensor from the end of the list.\n     * @param elementShape shape of the tensor\n     * @param elementDtype data type of the tensor\n     */\n    popBack(elementShape, elementDtype) {\n        if (elementDtype !== this.elementDtype) {\n            throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);\n        }\n        if (this.size() === 0) {\n            throw new Error('Trying to pop from an empty list.');\n        }\n        const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);\n        const tensor = this.tensors.pop();\n        tensor.kept = false;\n        assertShapesMatchAllowUndefinedSize(tensor.shape, elementShape, 'TensorList shape mismatch: ');\n        return reshape(tensor, outputElementShape);\n    }\n    /**\n     * Push a tensor to the end of the list.\n     * @param tensor Tensor to be pushed.\n     */\n    pushBack(tensor) {\n        if (tensor.dtype !== this.elementDtype) {\n            throw new Error(`Invalid data types; op elements ${tensor.dtype}, but list elements ${this.elementDtype}`);\n        }\n        assertShapesMatchAllowUndefinedSize(tensor.shape, this.elementShape, 'TensorList shape mismatch: ');\n        if (this.maxNumElements === this.size()) {\n            throw new Error(`Trying to push element into a full list.`);\n        }\n        keep(tensor);\n        this.tensors.push(tensor);\n    }\n    /**\n     * Update the size of the list.\n     * @param size the new size of the list.\n     */\n    resize(size) {\n        if (size < 0) {\n            throw new Error(`TensorListResize expects size to be non-negative. Got: ${size}`);\n        }\n        if (this.maxNumElements !== -1 && size > this.maxNumElements) {\n            throw new Error(`TensorListResize input size ${size} is greater maxNumElement ${this.maxNumElements}.`);\n        }\n        const destTensorList = new TensorList([], this.elementShape, this.elementDtype, this.maxNumElements);\n        destTensorList.tensors.length = size;\n        for (let i = 0; i < Math.min(this.tensors.length, size); ++i) {\n            destTensorList.tensors[i] = this.tensors[i];\n        }\n        return destTensorList;\n    }\n    /**\n     * Retrieve the element at the provided index\n     * @param elementShape shape of the tensor\n     * @param elementDtype dtype of the tensor\n     * @param elementIndex index of the tensor\n     */\n    getItem(elementIndex, elementShape, elementDtype) {\n        if (elementDtype !== this.elementDtype) {\n            throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);\n        }\n        if (elementIndex < 0 || elementIndex > this.tensors.length) {\n            throw new Error(`Trying to access element ${elementIndex} in a list with ${this.tensors.length} elements.`);\n        }\n        if (this.tensors[elementIndex] == null) {\n            throw new Error(`element at index ${elementIndex} is null.`);\n        }\n        assertShapesMatchAllowUndefinedSize(this.tensors[elementIndex].shape, elementShape, 'TensorList shape mismatch: ');\n        const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);\n        return reshape(this.tensors[elementIndex], outputElementShape);\n    }\n    /**\n     * Set the tensor at the index\n     * @param elementIndex index of the tensor\n     * @param tensor the tensor to be inserted into the list\n     */\n    setItem(elementIndex, tensor) {\n        if (tensor.dtype !== this.elementDtype) {\n            throw new Error(`Invalid data types; op elements ${tensor.dtype}, but list elements ${this.elementDtype}`);\n        }\n        if (elementIndex < 0 ||\n            this.maxNumElements !== -1 && elementIndex >= this.maxNumElements) {\n            throw new Error(`Trying to set element ${elementIndex} in a list with max ${this.maxNumElements} elements.`);\n        }\n        assertShapesMatchAllowUndefinedSize(this.elementShape, tensor.shape, 'TensorList shape mismatch: ');\n        keep(tensor);\n        // dispose the previous value if it is replacing.\n        if (this.tensors[elementIndex] != null) {\n            this.tensors[elementIndex].kept = false;\n        }\n        this.tensors[elementIndex] = tensor;\n    }\n    /**\n     * Return selected values in the TensorList as a stacked Tensor. All of\n     * selected values must have been written and their shapes must all match.\n     * @param indices indices of tensors to gather\n     * @param elementDtype output tensor dtype\n     * @param elementShape output tensor element shape\n     */\n    gather(indices, elementDtype, elementShape) {\n        if (elementDtype !== this.elementDtype) {\n            throw new Error(`Invalid data types; op elements ${elementDtype}, but list elements ${this.elementDtype}`);\n        }\n        assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, 'TensorList shape mismatch: ');\n        // When indices is greater than the size of the list, indices beyond the\n        // size of the list are ignored.\n        indices = indices.slice(0, this.size());\n        const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);\n        if (indices.length === 0) {\n            return tensor([], [0].concat(outputElementShape));\n        }\n        return tidy(() => {\n            const tensors = indices.map(i => reshape(this.tensors[i], outputElementShape));\n            return stack(tensors, 0);\n        });\n    }\n    /**\n     * Return the values in the TensorList as a concatenated Tensor.\n     * @param elementDtype output tensor dtype\n     * @param elementShape output tensor element shape\n     */\n    concat(elementDtype, elementShape) {\n        if (!!elementDtype && elementDtype !== this.elementDtype) {\n            throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${elementDtype}`);\n        }\n        assertShapesMatchAllowUndefinedSize(this.elementShape, elementShape, 'TensorList shape mismatch: ');\n        const outputElementShape = inferElementShape(this.elementShape, this.tensors, elementShape);\n        if (this.size() === 0) {\n            return tensor([], [0].concat(outputElementShape));\n        }\n        return tidy(() => {\n            const tensors = this.tensors.map(t => reshape(t, outputElementShape));\n            return concat(tensors, 0);\n        });\n    }\n}\n/**\n * Creates a TensorList which, when stacked, has the value of tensor.\n * @param tensor from tensor\n * @param elementShape output tensor element shape\n */\nexport function fromTensor(tensor, elementShape, elementDtype) {\n    const dtype = tensor.dtype;\n    if (tensor.shape.length < 1) {\n        throw new Error(`Tensor must be at least a vector, but saw shape: ${tensor.shape}`);\n    }\n    if (tensor.dtype !== elementDtype) {\n        throw new Error(`Invalid data types; op elements ${tensor.dtype}, but list elements ${elementDtype}`);\n    }\n    const tensorElementShape = tensor.shape.slice(1);\n    assertShapesMatchAllowUndefinedSize(tensorElementShape, elementShape, 'TensorList shape mismatch: ');\n    const tensorList = unstack(tensor);\n    return new TensorList(tensorList, elementShape, dtype);\n}\n/**\n * Return a TensorList of the given size with empty elements.\n * @param elementShape the shape of the future elements of the list\n * @param elementDtype the desired type of elements in the list\n * @param numElements the number of elements to reserve\n * @param maxNumElements the maximum number of elements in th list\n */\nexport function reserve(elementShape, elementDtype, numElements, maxNumElements) {\n    return new TensorList([], elementShape, elementDtype, maxNumElements);\n}\n/**\n * Put tensors at specific indices of a stacked tensor into a TensorList.\n * @param indices list of indices on how to scatter the tensor.\n * @param tensor input tensor.\n * @param elementShape the shape of the future elements of the list\n * @param numElements the number of elements to scatter\n */\nexport function scatter(tensor, indices, elementShape, numElements) {\n    if (indices.length !== tensor.shape[0]) {\n        throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor.shape[0]}`);\n    }\n    const maxIndex = Math.max(...indices);\n    if (numElements != null && numElements !== -1 && maxIndex >= numElements) {\n        throw new Error(`Max index must be < array size (${maxIndex}  vs. ${numElements})`);\n    }\n    const list = new TensorList([], elementShape, tensor.dtype, numElements);\n    const tensors = unstack(tensor, 0);\n    indices.forEach((value, index) => {\n        list.setItem(value, tensors[index]);\n    });\n    return list;\n}\n/**\n * Split the values of a Tensor into a TensorList.\n * @param length the lengths to use when splitting value along\n *    its first dimension.\n * @param tensor the tensor to split.\n * @param elementShape the shape of the future elements of the list\n */\nexport function split(tensor, length, elementShape) {\n    let totalLength = 0;\n    const cumulativeLengths = length.map(len => {\n        totalLength += len;\n        return totalLength;\n    });\n    if (totalLength !== tensor.shape[0]) {\n        throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${totalLength}, and tensor's shape is: ${tensor.shape}`);\n    }\n    const shapeWithoutFirstDim = tensor.shape.slice(1);\n    const outputElementShape = mergeElementShape(shapeWithoutFirstDim, elementShape);\n    const elementPerRow = totalLength === 0 ? 0 : tensor.size / totalLength;\n    const tensors = tidy(() => {\n        const tensors = [];\n        tensor = reshape(tensor, [1, totalLength, elementPerRow]);\n        for (let i = 0; i < length.length; ++i) {\n            const previousLength = (i === 0) ? 0 : cumulativeLengths[i - 1];\n            const indices = [0, previousLength, 0];\n            const sizes = [1, length[i], elementPerRow];\n            tensors[i] = reshape(slice(tensor, indices, sizes), outputElementShape);\n        }\n        tensor.dispose();\n        return tensors;\n    });\n    const list = new TensorList([], elementShape, tensor.dtype, length.length);\n    for (let i = 0; i < tensors.length; i++) {\n        list.setItem(i, tensors[i]);\n    }\n    return list;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVuc29yX2xpc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvbnZlcnRlci9zcmMvZXhlY3V0b3IvdGVuc29yX2xpc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBWSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFVLE1BQU0sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFM0gsT0FBTyxFQUFDLG1DQUFtQyxFQUFFLGlCQUFpQixFQUFFLGlCQUFpQixFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFFekc7Ozs7Ozs7Ozs7Ozs7R0FhRztBQUVILE1BQU0sT0FBTyxVQUFVO0lBSXJCLElBQUksRUFBRTtRQUNKLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7SUFDMUIsQ0FBQztJQUNEOzs7Ozs7OztPQVFHO0lBQ0gsWUFDYSxPQUFpQixFQUFXLFlBQTZCLEVBQ3pELFlBQXNCLEVBQUUsY0FBYyxHQUFHLENBQUMsQ0FBQztRQUQzQyxZQUFPLEdBQVAsT0FBTyxDQUFVO1FBQVcsaUJBQVksR0FBWixZQUFZLENBQWlCO1FBQ3pELGlCQUFZLEdBQVosWUFBWSxDQUFVO1FBQ2pDLElBQUksT0FBTyxJQUFJLElBQUksRUFBRTtZQUNuQixPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUN2QixJQUFJLFlBQVksS0FBSyxNQUFNLENBQUMsS0FBSyxFQUFFO29CQUNqQyxNQUFNLElBQUksS0FBSyxDQUFDLG1DQUNaLFlBQVksdUJBQXVCLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO2lCQUN4RDtnQkFDRCxtQ0FBbUMsQ0FDL0IsWUFBWSxFQUFFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsNkJBQTZCLENBQUMsQ0FBQztn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QUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzdCO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2NvbmNhdCwgRGF0YVR5cGUsIGtlZXAsIHJlc2hhcGUsIHNjYWxhciwgc2xpY2UsIHN0YWNrLCBUZW5zb3IsIHRlbnNvciwgdGlkeSwgdW5zdGFja30gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHthc3NlcnRTaGFwZXNNYXRjaEFsbG93VW5kZWZpbmVkU2l6ZSwgaW5mZXJFbGVtZW50U2hhcGUsIG1lcmdlRWxlbWVudFNoYXBlfSBmcm9tICcuL3RlbnNvcl91dGlscyc7XG5cbi8qKlxuICogVGVuc29yTGlzdCBzdG9yZXMgYSBjb250YWluZXIgb2YgYHRmLlRlbnNvcmAgb2JqZWN0cywgd2hpY2ggYXJlIGFjY2Vzc2libGVcbiAqIHZpYSB0ZW5zb3JzIGZpZWxkLlxuICpcbiAqIEluIG9yZGVyIHRvIGdldCBhIGNvcHkgb2YgdGhlIHVuZGVybHlpbmcgbGlzdCwgdXNlIHRoZSBjb3B5IG1ldGhvZDpcbiAqIGBgYFxuICogICAgVGVuc29yTGlzdCBiID0gYS5jb3B5KCk7XG4gKiAgICBiLnRlbnNvcnMoKS5wdXNoQmFjayh0KTsgIC8vIFRoaXMgZG9lcyBub3QgbW9kaWZ5IGEudGVuc29ycygpLlxuICogYGBgXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgaXMgbm90IGEgZGVlcCBjb3B5OiB0aGUgbWVtb3J5IGxvY2F0aW9ucyBvZiB0aGUgdW5kZXJseWluZ1xuICogdGVuc29ycyB3aWxsIHN0aWxsIHBvaW50IHRvIHRoZSBzYW1lIGxvY2F0aW9ucyBvZiB0aGUgY29ycmVzcG9uZGluZyB0ZW5zb3JzXG4gKiBpbiB0aGUgb3JpZ2luYWwuXG4gKi9cblxuZXhwb3J0IGNsYXNzIFRlbnNvckxpc3Qge1xuICByZWFkb25seSBpZFRlbnNvcjogVGVuc29yO1xuICBtYXhOdW1FbGVtZW50czogbnVtYmVyO1xuXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pZFRlbnNvci5pZDtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHRlbnNvcnMgbGlzdCBvZiB0ZW5zb3JzXG4gICAqIEBwYXJhbSBlbGVtZW50U2hhcGUgc2hhcGUgb2YgZWFjaCB0ZW5zb3IsIHRoaXMgY2FuIGJlIGEgc2luZ2xlIG51bWJlciAoYW55XG4gICAqIHNoYXBlIGlzIGFsbG93ZWQpIG9yIHBhcnRpYWwgc2hhcGUgKGRpbSA9IC0xKS5cbiAgICogQHBhcmFtIGVsZW1lbnREdHlwZSBkYXRhIHR5cGUgb2YgZWFjaCB0ZW5zb3JcbiAgICogQHBhcmFtIG1heE51bUVsZW1lbnRzIFRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBvZiBgdGVuc29yc2AuIERlZmF1bHRzIHRvIC0xXG4gICAqICAgbWVhbmluZyB0aGF0IHRoZSBzaXplIG9mIGB0ZW5zb3JzYCBpcyB1bmJvdW5kZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHJlYWRvbmx5IHRlbnNvcnM6IFRlbnNvcltdLCByZWFkb25seSBlbGVtZW50U2hhcGU6IG51bWJlcnxudW1iZXJbXSxcbiAgICAgIHJlYWRvbmx5IGVsZW1lbnREdHlwZTogRGF0YVR5cGUsIG1heE51bUVsZW1lbnRzID0gLTEpIHtcbiAgICBpZiAodGVuc29ycyAhPSBudWxsKSB7XG4gICAgICB0ZW5zb3JzLmZvckVhY2godGVuc29yID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnREdHlwZSAhPT0gdGVuc29yLmR0eXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgdHlwZXM7IG9wIGVsZW1lbnRzICR7XG4gICAgICAgICAgICAgIGVsZW1lbnREdHlwZX0sIGJ1dCBsaXN0IGVsZW1lbnRzICR7dGVuc29yLmR0eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKFxuICAgICAgICAgICAgZWxlbWVudFNoYXBlLCB0ZW5zb3Iuc2hhcGUsICdUZW5zb3JMaXN0IHNoYXBlIG1pc21hdGNoOiAnKTtcblxuICAgICAgICBrZWVwKHRlbnNvcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5pZFRlbnNvciA9IHNjYWxhcigwKTtcbiAgICB0aGlzLm1heE51bUVsZW1lbnRzID0gbWF4TnVtRWxlbWVudHM7XG4gICAga2VlcCh0aGlzLmlkVGVuc29yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBuZXcgVGVuc29yTGlzdCBjb250YWluaW5nIGEgY29weSBvZiB0aGUgdW5kZXJseWluZyB0ZW5zb3IgY29udGFpbmVyLlxuICAgKi9cbiAgY29weSgpOiBUZW5zb3JMaXN0IHtcbiAgICByZXR1cm4gbmV3IFRlbnNvckxpc3QoXG4gICAgICAgIFsuLi50aGlzLnRlbnNvcnNdLCB0aGlzLmVsZW1lbnRTaGFwZSwgdGhpcy5lbGVtZW50RHR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2UgdGhlIHRlbnNvcnMgYW5kIGlkVGVuc29yIGFuZCBjbGVhciB0aGUgdGVuc29yIGxpc3QuXG4gICAqL1xuICBjbGVhckFuZENsb3NlKGtlZXBJZHM/OiBTZXQ8bnVtYmVyPikge1xuICAgIHRoaXMudGVuc29ycy5mb3JFYWNoKHRlbnNvciA9PiB7XG4gICAgICBpZiAoa2VlcElkcyA9PSBudWxsIHx8ICFrZWVwSWRzLmhhcyh0ZW5zb3IuaWQpKSB7XG4gICAgICAgIHRlbnNvci5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy50ZW5zb3JzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5pZFRlbnNvci5kaXNwb3NlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSB0ZW5zb3JzIGluIHRoZSB0ZW5zb3IgbGlzdC5cbiAgICovXG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVuc29ycy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgdGVuc29yIHRoYXQgc3RhY2tzIGEgbGlzdCBvZiByYW5rLVIgdGYuVGVuc29ycyBpbnRvIG9uZSByYW5rLShSKzEpXG4gICAqIHRmLlRlbnNvci5cbiAgICogQHBhcmFtIGVsZW1lbnRTaGFwZSBzaGFwZSBvZiBlYWNoIHRlbnNvclxuICAgKiBAcGFyYW0gZWxlbWVudER0eXBlIGRhdGEgdHlwZSBvZiBlYWNoIHRlbnNvclxuICAgKiBAcGFyYW0gbnVtRWxlbWVudHMgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzdGFja1xuICAgKi9cbiAgc3RhY2soZWxlbWVudFNoYXBlOiBudW1iZXJbXSwgZWxlbWVudER0eXBlOiBEYXRhVHlwZSwgbnVtRWxlbWVudHMgPSAtMSk6XG4gICAgICBUZW5zb3Ige1xuICAgIGlmIChlbGVtZW50RHR5cGUgIT09IHRoaXMuZWxlbWVudER0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSB0eXBlczsgb3AgZWxlbWVudHMgJHtcbiAgICAgICAgICBlbGVtZW50RHR5cGV9LCBidXQgbGlzdCBlbGVtZW50cyAke3RoaXMuZWxlbWVudER0eXBlfWApO1xuICAgIH1cbiAgICBpZiAobnVtRWxlbWVudHMgIT09IC0xICYmIHRoaXMudGVuc29ycy5sZW5ndGggIT09IG51bUVsZW1lbnRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9wZXJhdGlvbiBleHBlY3RlZCBhIGxpc3Qgd2l0aCAke1xuICAgICAgICAgIG51bUVsZW1lbnRzfSBlbGVtZW50cyBidXQgZ290IGEgbGlzdCB3aXRoICR7XG4gICAgICAgICAgdGhpcy50ZW5zb3JzLmxlbmd0aH0gZWxlbWVudHMuYCk7XG4gICAgfVxuICAgIGFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKFxuICAgICAgICBlbGVtZW50U2hhcGUsIHRoaXMuZWxlbWVudFNoYXBlLCAnVGVuc29yTGlzdCBzaGFwZSBtaXNtYXRjaDogJyk7XG4gICAgY29uc3Qgb3V0cHV0RWxlbWVudFNoYXBlID1cbiAgICAgICAgaW5mZXJFbGVtZW50U2hhcGUodGhpcy5lbGVtZW50U2hhcGUsIHRoaXMudGVuc29ycywgZWxlbWVudFNoYXBlKTtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCByZXNoYXBlZFRlbnNvcnMgPVxuICAgICAgICAgIHRoaXMudGVuc29ycy5tYXAodGVuc29yID0+IHJlc2hhcGUodGVuc29yLCBvdXRwdXRFbGVtZW50U2hhcGUpKTtcbiAgICAgIHJldHVybiBzdGFjayhyZXNoYXBlZFRlbnNvcnMsIDApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvcCBhIHRlbnNvciBmcm9tIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAqIEBwYXJhbSBlbGVtZW50U2hhcGUgc2hhcGUgb2YgdGhlIHRlbnNvclxuICAgKiBAcGFyYW0gZWxlbWVudER0eXBlIGRhdGEgdHlwZSBvZiB0aGUgdGVuc29yXG4gICAqL1xuICBwb3BCYWNrKGVsZW1lbnRTaGFwZTogbnVtYmVyW10sIGVsZW1lbnREdHlwZTogRGF0YVR5cGUpOiBUZW5zb3Ige1xuICAgIGlmIChlbGVtZW50RHR5cGUgIT09IHRoaXMuZWxlbWVudER0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSB0eXBlczsgb3AgZWxlbWVudHMgJHtcbiAgICAgICAgICBlbGVtZW50RHR5cGV9LCBidXQgbGlzdCBlbGVtZW50cyAke3RoaXMuZWxlbWVudER0eXBlfWApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNpemUoKSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gcG9wIGZyb20gYW4gZW1wdHkgbGlzdC4nKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0RWxlbWVudFNoYXBlID1cbiAgICAgICAgaW5mZXJFbGVtZW50U2hhcGUodGhpcy5lbGVtZW50U2hhcGUsIHRoaXMudGVuc29ycywgZWxlbWVudFNoYXBlKTtcbiAgICBjb25zdCB0ZW5zb3IgPSB0aGlzLnRlbnNvcnMucG9wKCk7XG4gICAgdGVuc29yLmtlcHQgPSBmYWxzZTtcblxuICAgIGFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKFxuICAgICAgICB0ZW5zb3Iuc2hhcGUsIGVsZW1lbnRTaGFwZSwgJ1RlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6ICcpO1xuXG4gICAgcmV0dXJuIHJlc2hhcGUodGVuc29yLCBvdXRwdXRFbGVtZW50U2hhcGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggYSB0ZW5zb3IgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHRlbnNvciBUZW5zb3IgdG8gYmUgcHVzaGVkLlxuICAgKi9cbiAgcHVzaEJhY2sodGVuc29yOiBUZW5zb3IpIHtcbiAgICBpZiAodGVuc29yLmR0eXBlICE9PSB0aGlzLmVsZW1lbnREdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgdHlwZXM7IG9wIGVsZW1lbnRzICR7XG4gICAgICAgICAgdGVuc29yLmR0eXBlfSwgYnV0IGxpc3QgZWxlbWVudHMgJHt0aGlzLmVsZW1lbnREdHlwZX1gKTtcbiAgICB9XG5cbiAgICBhc3NlcnRTaGFwZXNNYXRjaEFsbG93VW5kZWZpbmVkU2l6ZShcbiAgICAgICAgdGVuc29yLnNoYXBlLCB0aGlzLmVsZW1lbnRTaGFwZSwgJ1RlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6ICcpO1xuXG4gICAgaWYgKHRoaXMubWF4TnVtRWxlbWVudHMgPT09IHRoaXMuc2l6ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyeWluZyB0byBwdXNoIGVsZW1lbnQgaW50byBhIGZ1bGwgbGlzdC5gKTtcbiAgICB9XG4gICAga2VlcCh0ZW5zb3IpO1xuICAgIHRoaXMudGVuc29ycy5wdXNoKHRlbnNvcik7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBzaXplIG9mIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0gc2l6ZSB0aGUgbmV3IHNpemUgb2YgdGhlIGxpc3QuXG4gICAqL1xuICByZXNpemUoc2l6ZTogbnVtYmVyKSB7XG4gICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFRlbnNvckxpc3RSZXNpemUgZXhwZWN0cyBzaXplIHRvIGJlIG5vbi1uZWdhdGl2ZS4gR290OiAke3NpemV9YCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWF4TnVtRWxlbWVudHMgIT09IC0xICYmIHNpemUgPiB0aGlzLm1heE51bUVsZW1lbnRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckxpc3RSZXNpemUgaW5wdXQgc2l6ZSAke1xuICAgICAgICAgIHNpemV9IGlzIGdyZWF0ZXIgbWF4TnVtRWxlbWVudCAke3RoaXMubWF4TnVtRWxlbWVudHN9LmApO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc3RUZW5zb3JMaXN0OiBUZW5zb3JMaXN0ID0gbmV3IFRlbnNvckxpc3QoXG4gICAgICAgIFtdLCB0aGlzLmVsZW1lbnRTaGFwZSwgdGhpcy5lbGVtZW50RHR5cGUsIHRoaXMubWF4TnVtRWxlbWVudHMpO1xuICAgIGRlc3RUZW5zb3JMaXN0LnRlbnNvcnMubGVuZ3RoID0gc2l6ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKHRoaXMudGVuc29ycy5sZW5ndGgsIHNpemUpOyArK2kpIHtcbiAgICAgIGRlc3RUZW5zb3JMaXN0LnRlbnNvcnNbaV0gPSB0aGlzLnRlbnNvcnNbaV07XG4gICAgfVxuICAgIHJldHVybiBkZXN0VGVuc29yTGlzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgZWxlbWVudCBhdCB0aGUgcHJvdmlkZWQgaW5kZXhcbiAgICogQHBhcmFtIGVsZW1lbnRTaGFwZSBzaGFwZSBvZiB0aGUgdGVuc29yXG4gICAqIEBwYXJhbSBlbGVtZW50RHR5cGUgZHR5cGUgb2YgdGhlIHRlbnNvclxuICAgKiBAcGFyYW0gZWxlbWVudEluZGV4IGluZGV4IG9mIHRoZSB0ZW5zb3JcbiAgICovXG4gIGdldEl0ZW0oZWxlbWVudEluZGV4OiBudW1iZXIsIGVsZW1lbnRTaGFwZTogbnVtYmVyW10sIGVsZW1lbnREdHlwZTogRGF0YVR5cGUpOlxuICAgICAgVGVuc29yIHtcbiAgICBpZiAoZWxlbWVudER0eXBlICE9PSB0aGlzLmVsZW1lbnREdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgdHlwZXM7IG9wIGVsZW1lbnRzICR7XG4gICAgICAgICAgZWxlbWVudER0eXBlfSwgYnV0IGxpc3QgZWxlbWVudHMgJHt0aGlzLmVsZW1lbnREdHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnRJbmRleCA8IDAgfHwgZWxlbWVudEluZGV4ID4gdGhpcy50ZW5zb3JzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcnlpbmcgdG8gYWNjZXNzIGVsZW1lbnQgJHtcbiAgICAgICAgICBlbGVtZW50SW5kZXh9IGluIGEgbGlzdCB3aXRoICR7dGhpcy50ZW5zb3JzLmxlbmd0aH0gZWxlbWVudHMuYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGVuc29yc1tlbGVtZW50SW5kZXhdID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZWxlbWVudCBhdCBpbmRleCAke2VsZW1lbnRJbmRleH0gaXMgbnVsbC5gKTtcbiAgICB9XG5cbiAgICBhc3NlcnRTaGFwZXNNYXRjaEFsbG93VW5kZWZpbmVkU2l6ZShcbiAgICAgICAgdGhpcy50ZW5zb3JzW2VsZW1lbnRJbmRleF0uc2hhcGUsIGVsZW1lbnRTaGFwZSxcbiAgICAgICAgJ1RlbnNvckxpc3Qgc2hhcGUgbWlzbWF0Y2g6ICcpO1xuICAgIGNvbnN0IG91dHB1dEVsZW1lbnRTaGFwZSA9XG4gICAgICAgIGluZmVyRWxlbWVudFNoYXBlKHRoaXMuZWxlbWVudFNoYXBlLCB0aGlzLnRlbnNvcnMsIGVsZW1lbnRTaGFwZSk7XG4gICAgcmV0dXJuIHJlc2hhcGUodGhpcy50ZW5zb3JzW2VsZW1lbnRJbmRleF0sIG91dHB1dEVsZW1lbnRTaGFwZSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0ZW5zb3IgYXQgdGhlIGluZGV4XG4gICAqIEBwYXJhbSBlbGVtZW50SW5kZXggaW5kZXggb2YgdGhlIHRlbnNvclxuICAgKiBAcGFyYW0gdGVuc29yIHRoZSB0ZW5zb3IgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgbGlzdFxuICAgKi9cbiAgc2V0SXRlbShlbGVtZW50SW5kZXg6IG51bWJlciwgdGVuc29yOiBUZW5zb3IpIHtcbiAgICBpZiAodGVuc29yLmR0eXBlICE9PSB0aGlzLmVsZW1lbnREdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgdHlwZXM7IG9wIGVsZW1lbnRzICR7XG4gICAgICAgICAgdGVuc29yLmR0eXBlfSwgYnV0IGxpc3QgZWxlbWVudHMgJHt0aGlzLmVsZW1lbnREdHlwZX1gKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudEluZGV4IDwgMCB8fFxuICAgICAgICB0aGlzLm1heE51bUVsZW1lbnRzICE9PSAtMSAmJiBlbGVtZW50SW5kZXggPj0gdGhpcy5tYXhOdW1FbGVtZW50cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcnlpbmcgdG8gc2V0IGVsZW1lbnQgJHtcbiAgICAgICAgICBlbGVtZW50SW5kZXh9IGluIGEgbGlzdCB3aXRoIG1heCAke3RoaXMubWF4TnVtRWxlbWVudHN9IGVsZW1lbnRzLmApO1xuICAgIH1cblxuICAgIGFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKFxuICAgICAgICB0aGlzLmVsZW1lbnRTaGFwZSwgdGVuc29yLnNoYXBlLCAnVGVuc29yTGlzdCBzaGFwZSBtaXNtYXRjaDogJyk7XG4gICAga2VlcCh0ZW5zb3IpO1xuXG4gICAgLy8gZGlzcG9zZSB0aGUgcHJldmlvdXMgdmFsdWUgaWYgaXQgaXMgcmVwbGFjaW5nLlxuICAgIGlmICh0aGlzLnRlbnNvcnNbZWxlbWVudEluZGV4XSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnRlbnNvcnNbZWxlbWVudEluZGV4XS5rZXB0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy50ZW5zb3JzW2VsZW1lbnRJbmRleF0gPSB0ZW5zb3I7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHNlbGVjdGVkIHZhbHVlcyBpbiB0aGUgVGVuc29yTGlzdCBhcyBhIHN0YWNrZWQgVGVuc29yLiBBbGwgb2ZcbiAgICogc2VsZWN0ZWQgdmFsdWVzIG11c3QgaGF2ZSBiZWVuIHdyaXR0ZW4gYW5kIHRoZWlyIHNoYXBlcyBtdXN0IGFsbCBtYXRjaC5cbiAgICogQHBhcmFtIGluZGljZXMgaW5kaWNlcyBvZiB0ZW5zb3JzIHRvIGdhdGhlclxuICAgKiBAcGFyYW0gZWxlbWVudER0eXBlIG91dHB1dCB0ZW5zb3IgZHR5cGVcbiAgICogQHBhcmFtIGVsZW1lbnRTaGFwZSBvdXRwdXQgdGVuc29yIGVsZW1lbnQgc2hhcGVcbiAgICovXG4gIGdhdGhlcihpbmRpY2VzOiBudW1iZXJbXSwgZWxlbWVudER0eXBlOiBEYXRhVHlwZSwgZWxlbWVudFNoYXBlOiBudW1iZXJbXSk6XG4gICAgICBUZW5zb3Ige1xuICAgIGlmIChlbGVtZW50RHR5cGUgIT09IHRoaXMuZWxlbWVudER0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0YSB0eXBlczsgb3AgZWxlbWVudHMgJHtcbiAgICAgICAgICBlbGVtZW50RHR5cGV9LCBidXQgbGlzdCBlbGVtZW50cyAke3RoaXMuZWxlbWVudER0eXBlfWApO1xuICAgIH1cblxuICAgIGFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKFxuICAgICAgICB0aGlzLmVsZW1lbnRTaGFwZSwgZWxlbWVudFNoYXBlLCAnVGVuc29yTGlzdCBzaGFwZSBtaXNtYXRjaDogJyk7XG5cbiAgICAvLyBXaGVuIGluZGljZXMgaXMgZ3JlYXRlciB0aGFuIHRoZSBzaXplIG9mIHRoZSBsaXN0LCBpbmRpY2VzIGJleW9uZCB0aGVcbiAgICAvLyBzaXplIG9mIHRoZSBsaXN0IGFyZSBpZ25vcmVkLlxuICAgIGluZGljZXMgPSBpbmRpY2VzLnNsaWNlKDAsIHRoaXMuc2l6ZSgpKTtcbiAgICBjb25zdCBvdXRwdXRFbGVtZW50U2hhcGUgPVxuICAgICAgICBpbmZlckVsZW1lbnRTaGFwZSh0aGlzLmVsZW1lbnRTaGFwZSwgdGhpcy50ZW5zb3JzLCBlbGVtZW50U2hhcGUpO1xuICAgIGlmIChpbmRpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRlbnNvcihbXSwgWzBdLmNvbmNhdChvdXRwdXRFbGVtZW50U2hhcGUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCB0ZW5zb3JzID1cbiAgICAgICAgICBpbmRpY2VzLm1hcChpID0+IHJlc2hhcGUodGhpcy50ZW5zb3JzW2ldLCBvdXRwdXRFbGVtZW50U2hhcGUpKTtcbiAgICAgIHJldHVybiBzdGFjayh0ZW5zb3JzLCAwKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHZhbHVlcyBpbiB0aGUgVGVuc29yTGlzdCBhcyBhIGNvbmNhdGVuYXRlZCBUZW5zb3IuXG4gICAqIEBwYXJhbSBlbGVtZW50RHR5cGUgb3V0cHV0IHRlbnNvciBkdHlwZVxuICAgKiBAcGFyYW0gZWxlbWVudFNoYXBlIG91dHB1dCB0ZW5zb3IgZWxlbWVudCBzaGFwZVxuICAgKi9cbiAgY29uY2F0KGVsZW1lbnREdHlwZTogRGF0YVR5cGUsIGVsZW1lbnRTaGFwZTogbnVtYmVyW10pOiBUZW5zb3Ige1xuICAgIGlmICghIWVsZW1lbnREdHlwZSAmJiBlbGVtZW50RHR5cGUgIT09IHRoaXMuZWxlbWVudER0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckxpc3QgZHR5cGUgaXMgJHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnREdHlwZX0gYnV0IGNvbmNhdCByZXF1ZXN0ZWQgZHR5cGUgJHtlbGVtZW50RHR5cGV9YCk7XG4gICAgfVxuXG4gICAgYXNzZXJ0U2hhcGVzTWF0Y2hBbGxvd1VuZGVmaW5lZFNpemUoXG4gICAgICAgIHRoaXMuZWxlbWVudFNoYXBlLCBlbGVtZW50U2hhcGUsICdUZW5zb3JMaXN0IHNoYXBlIG1pc21hdGNoOiAnKTtcbiAgICBjb25zdCBvdXRwdXRFbGVtZW50U2hhcGUgPVxuICAgICAgICBpbmZlckVsZW1lbnRTaGFwZSh0aGlzLmVsZW1lbnRTaGFwZSwgdGhpcy50ZW5zb3JzLCBlbGVtZW50U2hhcGUpO1xuXG4gICAgaWYgKHRoaXMuc2l6ZSgpID09PSAwKSB7XG4gICAgICByZXR1cm4gdGVuc29yKFtdLCBbMF0uY29uY2F0KG91dHB1dEVsZW1lbnRTaGFwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCB0ZW5zb3JzID0gdGhpcy50ZW5zb3JzLm1hcCh0ID0+IHJlc2hhcGUodCwgb3V0cHV0RWxlbWVudFNoYXBlKSk7XG4gICAgICByZXR1cm4gY29uY2F0KHRlbnNvcnMsIDApO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFRlbnNvckxpc3Qgd2hpY2gsIHdoZW4gc3RhY2tlZCwgaGFzIHRoZSB2YWx1ZSBvZiB0ZW5zb3IuXG4gKiBAcGFyYW0gdGVuc29yIGZyb20gdGVuc29yXG4gKiBAcGFyYW0gZWxlbWVudFNoYXBlIG91dHB1dCB0ZW5zb3IgZWxlbWVudCBzaGFwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRlbnNvcihcbiAgICB0ZW5zb3I6IFRlbnNvciwgZWxlbWVudFNoYXBlOiBudW1iZXJbXSwgZWxlbWVudER0eXBlOiBEYXRhVHlwZSkge1xuICBjb25zdCBkdHlwZSA9IHRlbnNvci5kdHlwZTtcbiAgaWYgKHRlbnNvci5zaGFwZS5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGVuc29yIG11c3QgYmUgYXQgbGVhc3QgYSB2ZWN0b3IsIGJ1dCBzYXcgc2hhcGU6ICR7dGVuc29yLnNoYXBlfWApO1xuICB9XG4gIGlmICh0ZW5zb3IuZHR5cGUgIT09IGVsZW1lbnREdHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIHR5cGVzOyBvcCBlbGVtZW50cyAke1xuICAgICAgICB0ZW5zb3IuZHR5cGV9LCBidXQgbGlzdCBlbGVtZW50cyAke2VsZW1lbnREdHlwZX1gKTtcbiAgfVxuICBjb25zdCB0ZW5zb3JFbGVtZW50U2hhcGUgPSB0ZW5zb3Iuc2hhcGUuc2xpY2UoMSk7XG4gIGFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKFxuICAgICAgdGVuc29yRWxlbWVudFNoYXBlLCBlbGVtZW50U2hhcGUsICdUZW5zb3JMaXN0IHNoYXBlIG1pc21hdGNoOiAnKTtcbiAgY29uc3QgdGVuc29yTGlzdDogVGVuc29yW10gPSB1bnN0YWNrKHRlbnNvcik7XG4gIHJldHVybiBuZXcgVGVuc29yTGlzdCh0ZW5zb3JMaXN0LCBlbGVtZW50U2hhcGUsIGR0eXBlKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBUZW5zb3JMaXN0IG9mIHRoZSBnaXZlbiBzaXplIHdpdGggZW1wdHkgZWxlbWVudHMuXG4gKiBAcGFyYW0gZWxlbWVudFNoYXBlIHRoZSBzaGFwZSBvZiB0aGUgZnV0dXJlIGVsZW1lbnRzIG9mIHRoZSBsaXN0XG4gKiBAcGFyYW0gZWxlbWVudER0eXBlIHRoZSBkZXNpcmVkIHR5cGUgb2YgZWxlbWVudHMgaW4gdGhlIGxpc3RcbiAqIEBwYXJhbSBudW1FbGVtZW50cyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlc2VydmVcbiAqIEBwYXJhbSBtYXhOdW1FbGVtZW50cyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGggbGlzdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXJ2ZShcbiAgICBlbGVtZW50U2hhcGU6IG51bWJlcltdLCBlbGVtZW50RHR5cGU6IERhdGFUeXBlLCBudW1FbGVtZW50czogbnVtYmVyLFxuICAgIG1heE51bUVsZW1lbnRzOiBudW1iZXIpIHtcbiAgcmV0dXJuIG5ldyBUZW5zb3JMaXN0KFtdLCBlbGVtZW50U2hhcGUsIGVsZW1lbnREdHlwZSwgbWF4TnVtRWxlbWVudHMpO1xufVxuXG4vKipcbiAqIFB1dCB0ZW5zb3JzIGF0IHNwZWNpZmljIGluZGljZXMgb2YgYSBzdGFja2VkIHRlbnNvciBpbnRvIGEgVGVuc29yTGlzdC5cbiAqIEBwYXJhbSBpbmRpY2VzIGxpc3Qgb2YgaW5kaWNlcyBvbiBob3cgdG8gc2NhdHRlciB0aGUgdGVuc29yLlxuICogQHBhcmFtIHRlbnNvciBpbnB1dCB0ZW5zb3IuXG4gKiBAcGFyYW0gZWxlbWVudFNoYXBlIHRoZSBzaGFwZSBvZiB0aGUgZnV0dXJlIGVsZW1lbnRzIG9mIHRoZSBsaXN0XG4gKiBAcGFyYW0gbnVtRWxlbWVudHMgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzY2F0dGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2F0dGVyKFxuICAgIHRlbnNvcjogVGVuc29yLCBpbmRpY2VzOiBudW1iZXJbXSwgZWxlbWVudFNoYXBlOiBudW1iZXJbXSxcbiAgICBudW1FbGVtZW50cz86IG51bWJlcik6IFRlbnNvckxpc3Qge1xuICBpZiAoaW5kaWNlcy5sZW5ndGggIT09IHRlbnNvci5zaGFwZVswXSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgbGVuKGluZGljZXMpID09IHRlbnNvci5zaGFwZVswXSwgYnV0IHNhdzogJHtcbiAgICAgICAgaW5kaWNlcy5sZW5ndGh9IHZzLiAke3RlbnNvci5zaGFwZVswXX1gKTtcbiAgfVxuXG4gIGNvbnN0IG1heEluZGV4ID0gTWF0aC5tYXgoLi4uaW5kaWNlcyk7XG5cbiAgaWYgKG51bUVsZW1lbnRzICE9IG51bGwgJiYgbnVtRWxlbWVudHMgIT09IC0xICYmIG1heEluZGV4ID49IG51bUVsZW1lbnRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTWF4IGluZGV4IG11c3QgYmUgPCBhcnJheSBzaXplICgke21heEluZGV4fSAgdnMuICR7bnVtRWxlbWVudHN9KWApO1xuICB9XG5cbiAgY29uc3QgbGlzdCA9IG5ldyBUZW5zb3JMaXN0KFtdLCBlbGVtZW50U2hhcGUsIHRlbnNvci5kdHlwZSwgbnVtRWxlbWVudHMpO1xuICBjb25zdCB0ZW5zb3JzID0gdW5zdGFjayh0ZW5zb3IsIDApO1xuICBpbmRpY2VzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgIGxpc3Quc2V0SXRlbSh2YWx1ZSwgdGVuc29yc1tpbmRleF0pO1xuICB9KTtcbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8qKlxuICogU3BsaXQgdGhlIHZhbHVlcyBvZiBhIFRlbnNvciBpbnRvIGEgVGVuc29yTGlzdC5cbiAqIEBwYXJhbSBsZW5ndGggdGhlIGxlbmd0aHMgdG8gdXNlIHdoZW4gc3BsaXR0aW5nIHZhbHVlIGFsb25nXG4gKiAgICBpdHMgZmlyc3QgZGltZW5zaW9uLlxuICogQHBhcmFtIHRlbnNvciB0aGUgdGVuc29yIHRvIHNwbGl0LlxuICogQHBhcmFtIGVsZW1lbnRTaGFwZSB0aGUgc2hhcGUgb2YgdGhlIGZ1dHVyZSBlbGVtZW50cyBvZiB0aGUgbGlzdFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXQoXG4gICAgdGVuc29yOiBUZW5zb3IsIGxlbmd0aDogbnVtYmVyW10sIGVsZW1lbnRTaGFwZTogbnVtYmVyW10pIHtcbiAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgY29uc3QgY3VtdWxhdGl2ZUxlbmd0aHMgPSBsZW5ndGgubWFwKGxlbiA9PiB7XG4gICAgdG90YWxMZW5ndGggKz0gbGVuO1xuICAgIHJldHVybiB0b3RhbExlbmd0aDtcbiAgfSk7XG5cbiAgaWYgKHRvdGFsTGVuZ3RoICE9PSB0ZW5zb3Iuc2hhcGVbMF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHN1bSBvZiBsZW5ndGhzIHRvIGJlIGVxdWFsIHRvXG4gICAgICAgICAgdGVuc29yLnNoYXBlWzBdLCBidXQgc3VtIG9mIGxlbmd0aHMgaXNcbiAgICAgICAgJHt0b3RhbExlbmd0aH0sIGFuZCB0ZW5zb3IncyBzaGFwZSBpczogJHt0ZW5zb3Iuc2hhcGV9YCk7XG4gIH1cblxuICBjb25zdCBzaGFwZVdpdGhvdXRGaXJzdERpbSA9IHRlbnNvci5zaGFwZS5zbGljZSgxKTtcbiAgY29uc3Qgb3V0cHV0RWxlbWVudFNoYXBlID1cbiAgICAgIG1lcmdlRWxlbWVudFNoYXBlKHNoYXBlV2l0aG91dEZpcnN0RGltLCBlbGVtZW50U2hhcGUpO1xuICBjb25zdCBlbGVtZW50UGVyUm93ID0gdG90YWxMZW5ndGggPT09IDAgPyAwIDogdGVuc29yLnNpemUgLyB0b3RhbExlbmd0aDtcbiAgY29uc3QgdGVuc29yczogVGVuc29yW10gPSB0aWR5KCgpID0+IHtcbiAgICBjb25zdCB0ZW5zb3JzID0gW107XG4gICAgdGVuc29yID0gcmVzaGFwZSh0ZW5zb3IsIFsxLCB0b3RhbExlbmd0aCwgZWxlbWVudFBlclJvd10pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0xlbmd0aCA9IChpID09PSAwKSA/IDAgOiBjdW11bGF0aXZlTGVuZ3Roc1tpIC0gMV07XG4gICAgICBjb25zdCBpbmRpY2VzID0gWzAsIHByZXZpb3VzTGVuZ3RoLCAwXTtcbiAgICAgIGNvbnN0IHNpemVzID0gWzEsIGxlbmd0aFtpXSwgZWxlbWVudFBlclJvd107XG4gICAgICB0ZW5zb3JzW2ldID0gcmVzaGFwZShcbiAgICAgICAgICBzbGljZSh0ZW5zb3IsIGluZGljZXMsIHNpemVzKSwgb3V0cHV0RWxlbWVudFNoYXBlIGFzIG51bWJlcltdKTtcbiAgICB9XG4gICAgdGVuc29yLmRpc3Bvc2UoKTtcbiAgICByZXR1cm4gdGVuc29ycztcbiAgfSk7XG5cbiAgY29uc3QgbGlzdCA9IG5ldyBUZW5zb3JMaXN0KFtdLCBlbGVtZW50U2hhcGUsIHRlbnNvci5kdHlwZSwgbGVuZ3RoLmxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW5zb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdC5zZXRJdGVtKGksIHRlbnNvcnNbaV0pO1xuICB9XG4gIHJldHVybiBsaXN0O1xufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { concat, keep, reshape, scalar, slice, stack, tensor, tidy, unstack } from '@tensorflow/tfjs-core';\nimport { assertShapesMatchAllowUndefinedSize } from './tensor_utils';\n/**\n * The TensorArray object keeps an array of Tensors.  It\n * allows reading from the array and writing to the array.\n */\nexport class TensorArray {\n    constructor(name, dtype, maxSize, elementShape, identicalElementShapes, dynamicSize, clearAfterRead) {\n        this.name = name;\n        this.dtype = dtype;\n        this.maxSize = maxSize;\n        this.elementShape = elementShape;\n        this.identicalElementShapes = identicalElementShapes;\n        this.dynamicSize = dynamicSize;\n        this.clearAfterRead = clearAfterRead;\n        this.tensors = [];\n        this.closed_ = false;\n        this.idTensor = scalar(0);\n        keep(this.idTensor);\n    }\n    get id() {\n        return this.idTensor.id;\n    }\n    get closed() {\n        return this.closed_;\n    }\n    /**\n     * Dispose the tensors and idTensor and mark the TensoryArray as closed.\n     */\n    clearAndClose(keepIds) {\n        this.tensors.forEach(tensor => {\n            if (keepIds == null || !keepIds.has(tensor.tensor.id)) {\n                tensor.tensor.dispose();\n            }\n        });\n        this.tensors = [];\n        this.closed_ = true;\n        this.idTensor.dispose();\n    }\n    size() {\n        return this.tensors.length;\n    }\n    /**\n     * Read the value at location index in the TensorArray.\n     * @param index Number the index to read from.\n     */\n    read(index) {\n        if (this.closed_) {\n            throw new Error(`TensorArray ${this.name} has already been closed.`);\n        }\n        if (index < 0 || index >= this.size()) {\n            throw new Error(`Tried to read from index ${index}, but array size is: ${this.size()}`);\n        }\n        const tensorWithState = this.tensors[index];\n        if (tensorWithState.cleared) {\n            throw new Error(`TensorArray ${this.name}: Could not read index ${index} twice because it was cleared after a previous read ` +\n                `(perhaps try setting clear_after_read = false?).`);\n        }\n        if (this.clearAfterRead) {\n            tensorWithState.cleared = true;\n        }\n        tensorWithState.read = true;\n        return tensorWithState.tensor;\n    }\n    /**\n     * Helper method to read multiple tensors from the specified indices.\n     */\n    readMany(indices) {\n        return indices.map(index => this.read(index));\n    }\n    /**\n     * Write value into the index of the TensorArray.\n     * @param index number the index to write to.\n     * @param tensor\n     */\n    write(index, tensor) {\n        if (this.closed_) {\n            throw new Error(`TensorArray ${this.name} has already been closed.`);\n        }\n        if (index < 0 || !this.dynamicSize && index >= this.maxSize) {\n            throw new Error(`Tried to write to index ${index}, but array is not resizeable and size is: ${this.maxSize}`);\n        }\n        const t = this.tensors[index] || {};\n        if (tensor.dtype !== this.dtype) {\n            throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index},\n          because the value dtype is ${tensor.dtype}, but TensorArray dtype is ${this.dtype}.`);\n        }\n        // Set the shape for the first time write to unknow shape tensor array\n        if (this.size() === 0 &&\n            (this.elementShape == null || this.elementShape.length === 0)) {\n            this.elementShape = tensor.shape;\n        }\n        assertShapesMatchAllowUndefinedSize(this.elementShape, tensor.shape, `TensorArray ${this.name}: Could not write to TensorArray index ${index}.`);\n        if (t.read) {\n            throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index}, because it has already been read.`);\n        }\n        if (t.written) {\n            throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${index}, because it has already been written.`);\n        }\n        t.tensor = tensor;\n        keep(tensor);\n        t.written = true;\n        this.tensors[index] = t;\n    }\n    /**\n     * Helper method to write multiple tensors to the specified indices.\n     */\n    writeMany(indices, tensors) {\n        if (indices.length !== tensors.length) {\n            throw new Error(`TensorArray ${this.name}: could not write multiple tensors,` +\n                `because the index size: ${indices.length} is not the same as tensors size: ${tensors.length}.`);\n        }\n        indices.forEach((i, index) => this.write(i, tensors[index]));\n    }\n    /**\n     * Return selected values in the TensorArray as a packed Tensor. All of\n     * selected values must have been written and their shapes must all match.\n     * @param [indices] number[] Optional. Taking values in [0, max_value). If the\n     *    TensorArray is not dynamic, max_value=size(). If not specified returns\n     *    all tensors in the original order.\n     * @param [dtype]\n     */\n    gather(indices, dtype) {\n        if (!!dtype && dtype !== this.dtype) {\n            throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${dtype}`);\n        }\n        if (!indices) {\n            indices = [];\n            for (let i = 0; i < this.size(); i++) {\n                indices.push(i);\n            }\n        }\n        else {\n            indices = indices.slice(0, this.size());\n        }\n        if (indices.length === 0) {\n            return tensor([], [0].concat(this.elementShape));\n        }\n        // Read all the PersistentTensors into a vector to keep track of\n        // their memory.\n        const tensors = this.readMany(indices);\n        assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, 'TensorArray shape mismatch: ');\n        return stack(tensors, 0);\n    }\n    /**\n     * Return the values in the TensorArray as a concatenated Tensor.\n     */\n    concat(dtype) {\n        if (!!dtype && dtype !== this.dtype) {\n            throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${dtype}`);\n        }\n        if (this.size() === 0) {\n            return tensor([], [0].concat(this.elementShape));\n        }\n        const indices = [];\n        for (let i = 0; i < this.size(); i++) {\n            indices.push(i);\n        }\n        // Collect all the tensors from the tensors array.\n        const tensors = this.readMany(indices);\n        assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, `TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${tensors[0].shape})`);\n        return concat(tensors, 0);\n    }\n    /**\n     * Scatter the values of a Tensor in specific indices of a TensorArray.\n     * @param indices number[] values in [0, max_value). If the\n     *    TensorArray is not dynamic, max_value=size().\n     * @param tensor Tensor input tensor.\n     */\n    scatter(indices, tensor) {\n        if (tensor.dtype !== this.dtype) {\n            throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor.dtype}`);\n        }\n        if (indices.length !== tensor.shape[0]) {\n            throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${indices.length} vs. ${tensor.shape[0]}`);\n        }\n        const maxIndex = Math.max(...indices);\n        if (!this.dynamicSize && maxIndex >= this.maxSize) {\n            throw new Error(`Max index must be < array size (${maxIndex}  vs. ${this.maxSize})`);\n        }\n        this.writeMany(indices, unstack(tensor, 0));\n    }\n    /**\n     * Split the values of a Tensor into the TensorArray.\n     * @param length number[] with the lengths to use when splitting value along\n     *    its first dimension.\n     * @param tensor Tensor, the tensor to split.\n     */\n    split(length, tensor) {\n        if (tensor.dtype !== this.dtype) {\n            throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${tensor.dtype}`);\n        }\n        let totalLength = 0;\n        const cumulativeLengths = length.map(len => {\n            totalLength += len;\n            return totalLength;\n        });\n        if (totalLength !== tensor.shape[0]) {\n            throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${totalLength}, and tensor's shape is: ${tensor.shape}`);\n        }\n        if (!this.dynamicSize && length.length !== this.maxSize) {\n            throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${length.length}), ` +\n                'and the TensorArray is not marked as dynamically resizeable');\n        }\n        const elementPerRow = totalLength === 0 ? 0 : tensor.size / totalLength;\n        const tensors = [];\n        tidy(() => {\n            tensor = reshape(tensor, [1, totalLength, elementPerRow]);\n            for (let i = 0; i < length.length; ++i) {\n                const previousLength = (i === 0) ? 0 : cumulativeLengths[i - 1];\n                const indices = [0, previousLength, 0];\n                const sizes = [1, length[i], elementPerRow];\n                tensors[i] = reshape(slice(tensor, indices, sizes), this.elementShape);\n            }\n            return tensors;\n        });\n        const indices = [];\n        for (let i = 0; i < length.length; i++) {\n            indices[i] = i;\n        }\n        this.writeMany(indices, tensors);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVuc29yX2FycmF5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb252ZXJ0ZXIvc3JjL2V4ZWN1dG9yL3RlbnNvcl9hcnJheS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsTUFBTSxFQUFZLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQVUsTUFBTSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUUzSCxPQUFPLEVBQUMsbUNBQW1DLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQVFuRTs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sV0FBVztJQUl0QixZQUNhLElBQVksRUFBVyxLQUFlLEVBQVUsT0FBZSxFQUNoRSxZQUFzQixFQUFXLHNCQUErQixFQUMvRCxXQUFvQixFQUFXLGNBQXVCO1FBRnRELFNBQUksR0FBSixJQUFJLENBQVE7UUFBVyxVQUFLLEdBQUwsS0FBSyxDQUFVO1FBQVUsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUNoRSxpQkFBWSxHQUFaLFlBQVksQ0FBVTtRQUFXLDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBUztRQUMvRCxnQkFBVyxHQUFYLFdBQVcsQ0FBUztRQUFXLG1CQUFjLEdBQWQsY0FBYyxDQUFTO1FBTjNELFlBQU8sR0FBc0IsRUFBRSxDQUFDO1FBQ2hDLFlBQU8sR0FBRyxLQUFLLENBQUM7UUFNdEIsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN0QixDQUFDO0lBRUQsSUFBSSxFQUFFO1FBQ0osT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztJQUMxQixDQUFDO0lBRUQsSUFBSSxNQUFNO1FBQ1IsT0FBTyxJQUFJLENB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RUFBRSxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDeEU7WUFDRCxPQUFPLE9BQU8sQ0FBQztRQUNqQixDQUFDLENBQUMsQ0FBQztRQUNILE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQztRQUNuQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUN0QyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2hCO1FBQ0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDbkMsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2NvbmNhdCwgRGF0YVR5cGUsIGtlZXAsIHJlc2hhcGUsIHNjYWxhciwgc2xpY2UsIHN0YWNrLCBUZW5zb3IsIHRlbnNvciwgdGlkeSwgdW5zdGFja30gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHthc3NlcnRTaGFwZXNNYXRjaEFsbG93VW5kZWZpbmVkU2l6ZX0gZnJvbSAnLi90ZW5zb3JfdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRlbnNvcldpdGhTdGF0ZSB7XG4gIHRlbnNvcj86IFRlbnNvcjtcbiAgd3JpdHRlbj86IGJvb2xlYW47XG4gIHJlYWQ/OiBib29sZWFuO1xuICBjbGVhcmVkPzogYm9vbGVhbjtcbn1cbi8qKlxuICogVGhlIFRlbnNvckFycmF5IG9iamVjdCBrZWVwcyBhbiBhcnJheSBvZiBUZW5zb3JzLiAgSXRcbiAqIGFsbG93cyByZWFkaW5nIGZyb20gdGhlIGFycmF5IGFuZCB3cml0aW5nIHRvIHRoZSBhcnJheS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbnNvckFycmF5IHtcbiAgcHJpdmF0ZSB0ZW5zb3JzOiBUZW5zb3JXaXRoU3RhdGVbXSA9IFtdO1xuICBwcml2YXRlIGNsb3NlZF8gPSBmYWxzZTtcbiAgcmVhZG9ubHkgaWRUZW5zb3I6IFRlbnNvcjtcbiAgY29uc3RydWN0b3IoXG4gICAgICByZWFkb25seSBuYW1lOiBzdHJpbmcsIHJlYWRvbmx5IGR0eXBlOiBEYXRhVHlwZSwgcHJpdmF0ZSBtYXhTaXplOiBudW1iZXIsXG4gICAgICBwcml2YXRlIGVsZW1lbnRTaGFwZTogbnVtYmVyW10sIHJlYWRvbmx5IGlkZW50aWNhbEVsZW1lbnRTaGFwZXM6IGJvb2xlYW4sXG4gICAgICByZWFkb25seSBkeW5hbWljU2l6ZTogYm9vbGVhbiwgcmVhZG9ubHkgY2xlYXJBZnRlclJlYWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmlkVGVuc29yID0gc2NhbGFyKDApO1xuICAgIGtlZXAodGhpcy5pZFRlbnNvcik7XG4gIH1cblxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWRUZW5zb3IuaWQ7XG4gIH1cblxuICBnZXQgY2xvc2VkKCkge1xuICAgIHJldHVybiB0aGlzLmNsb3NlZF87XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZSB0aGUgdGVuc29ycyBhbmQgaWRUZW5zb3IgYW5kIG1hcmsgdGhlIFRlbnNvcnlBcnJheSBhcyBjbG9zZWQuXG4gICAqL1xuICBjbGVhckFuZENsb3NlKGtlZXBJZHM/OiBTZXQ8bnVtYmVyPikge1xuICAgIHRoaXMudGVuc29ycy5mb3JFYWNoKHRlbnNvciA9PiB7XG4gICAgICBpZiAoa2VlcElkcyA9PSBudWxsIHx8ICFrZWVwSWRzLmhhcyh0ZW5zb3IudGVuc29yLmlkKSkge1xuICAgICAgICB0ZW5zb3IudGVuc29yLmRpc3Bvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnRlbnNvcnMgPSBbXTtcbiAgICB0aGlzLmNsb3NlZF8gPSB0cnVlO1xuICAgIHRoaXMuaWRUZW5zb3IuZGlzcG9zZSgpO1xuICB9XG5cbiAgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnRlbnNvcnMubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIHZhbHVlIGF0IGxvY2F0aW9uIGluZGV4IGluIHRoZSBUZW5zb3JBcnJheS5cbiAgICogQHBhcmFtIGluZGV4IE51bWJlciB0aGUgaW5kZXggdG8gcmVhZCBmcm9tLlxuICAgKi9cbiAgcmVhZChpbmRleDogbnVtYmVyKTogVGVuc29yIHtcbiAgICBpZiAodGhpcy5jbG9zZWRfKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckFycmF5ICR7dGhpcy5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5gKTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuc2l6ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyaWVkIHRvIHJlYWQgZnJvbSBpbmRleCAke2luZGV4fSwgYnV0IGFycmF5IHNpemUgaXM6ICR7XG4gICAgICAgICAgdGhpcy5zaXplKCl9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGVuc29yV2l0aFN0YXRlID0gdGhpcy50ZW5zb3JzW2luZGV4XTtcbiAgICBpZiAodGVuc29yV2l0aFN0YXRlLmNsZWFyZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVGVuc29yQXJyYXkgJHt0aGlzLm5hbWV9OiBDb3VsZCBub3QgcmVhZCBpbmRleCAke1xuICAgICAgICAgICAgICBpbmRleH0gdHdpY2UgYmVjYXVzZSBpdCB3YXMgY2xlYXJlZCBhZnRlciBhIHByZXZpb3VzIHJlYWQgYCArXG4gICAgICAgICAgYChwZXJoYXBzIHRyeSBzZXR0aW5nIGNsZWFyX2FmdGVyX3JlYWQgPSBmYWxzZT8pLmApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNsZWFyQWZ0ZXJSZWFkKSB7XG4gICAgICB0ZW5zb3JXaXRoU3RhdGUuY2xlYXJlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGVuc29yV2l0aFN0YXRlLnJlYWQgPSB0cnVlO1xuICAgIHJldHVybiB0ZW5zb3JXaXRoU3RhdGUudGVuc29yO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gcmVhZCBtdWx0aXBsZSB0ZW5zb3JzIGZyb20gdGhlIHNwZWNpZmllZCBpbmRpY2VzLlxuICAgKi9cbiAgcmVhZE1hbnkoaW5kaWNlczogbnVtYmVyW10pOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIGluZGljZXMubWFwKGluZGV4ID0+IHRoaXMucmVhZChpbmRleCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIHZhbHVlIGludG8gdGhlIGluZGV4IG9mIHRoZSBUZW5zb3JBcnJheS5cbiAgICogQHBhcmFtIGluZGV4IG51bWJlciB0aGUgaW5kZXggdG8gd3JpdGUgdG8uXG4gICAqIEBwYXJhbSB0ZW5zb3JcbiAgICovXG4gIHdyaXRlKGluZGV4OiBudW1iZXIsIHRlbnNvcjogVGVuc29yKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkXykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JBcnJheSAke3RoaXMubmFtZX0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuYCk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCB8fCAhdGhpcy5keW5hbWljU2l6ZSAmJiBpbmRleCA+PSB0aGlzLm1heFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJpZWQgdG8gd3JpdGUgdG8gaW5kZXggJHtcbiAgICAgICAgICBpbmRleH0sIGJ1dCBhcnJheSBpcyBub3QgcmVzaXplYWJsZSBhbmQgc2l6ZSBpczogJHt0aGlzLm1heFNpemV9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgdCA9IHRoaXMudGVuc29yc1tpbmRleF0gfHwge307XG5cbiAgICBpZiAodGVuc29yLmR0eXBlICE9PSB0aGlzLmR0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckFycmF5ICR7XG4gICAgICAgICAgdGhpcy5uYW1lfTogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4ICR7aW5kZXh9LFxuICAgICAgICAgIGJlY2F1c2UgdGhlIHZhbHVlIGR0eXBlIGlzICR7XG4gICAgICAgICAgdGVuc29yLmR0eXBlfSwgYnV0IFRlbnNvckFycmF5IGR0eXBlIGlzICR7dGhpcy5kdHlwZX0uYCk7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBzaGFwZSBmb3IgdGhlIGZpcnN0IHRpbWUgd3JpdGUgdG8gdW5rbm93IHNoYXBlIHRlbnNvciBhcnJheVxuICAgIGlmICh0aGlzLnNpemUoKSA9PT0gMCAmJlxuICAgICAgICAodGhpcy5lbGVtZW50U2hhcGUgPT0gbnVsbCB8fCB0aGlzLmVsZW1lbnRTaGFwZS5sZW5ndGggPT09IDApKSB7XG4gICAgICB0aGlzLmVsZW1lbnRTaGFwZSA9IHRlbnNvci5zaGFwZTtcbiAgICB9XG5cbiAgICBhc3NlcnRTaGFwZXNNYXRjaEFsbG93VW5kZWZpbmVkU2l6ZShcbiAgICAgICAgdGhpcy5lbGVtZW50U2hhcGUsIHRlbnNvci5zaGFwZSxcbiAgICAgICAgYFRlbnNvckFycmF5ICR7dGhpcy5uYW1lfTogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4ICR7XG4gICAgICAgICAgICBpbmRleH0uYCk7XG5cbiAgICBpZiAodC5yZWFkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFRlbnNvckFycmF5ICR7dGhpcy5uYW1lfTogQ291bGQgbm90IHdyaXRlIHRvIFRlbnNvckFycmF5IGluZGV4ICR7XG4gICAgICAgICAgICAgIGluZGV4fSwgYmVjYXVzZSBpdCBoYXMgYWxyZWFkeSBiZWVuIHJlYWQuYCk7XG4gICAgfVxuXG4gICAgaWYgKHQud3JpdHRlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBUZW5zb3JBcnJheSAke3RoaXMubmFtZX06IENvdWxkIG5vdCB3cml0ZSB0byBUZW5zb3JBcnJheSBpbmRleCAke1xuICAgICAgICAgICAgICBpbmRleH0sIGJlY2F1c2UgaXQgaGFzIGFscmVhZHkgYmVlbiB3cml0dGVuLmApO1xuICAgIH1cblxuICAgIHQudGVuc29yID0gdGVuc29yO1xuICAgIGtlZXAodGVuc29yKTtcbiAgICB0LndyaXR0ZW4gPSB0cnVlO1xuXG4gICAgdGhpcy50ZW5zb3JzW2luZGV4XSA9IHQ7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byB3cml0ZSBtdWx0aXBsZSB0ZW5zb3JzIHRvIHRoZSBzcGVjaWZpZWQgaW5kaWNlcy5cbiAgICovXG4gIHdyaXRlTWFueShpbmRpY2VzOiBudW1iZXJbXSwgdGVuc29yczogVGVuc29yW10pIHtcbiAgICBpZiAoaW5kaWNlcy5sZW5ndGggIT09IHRlbnNvcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFRlbnNvckFycmF5ICR7dGhpcy5uYW1lfTogY291bGQgbm90IHdyaXRlIG11bHRpcGxlIHRlbnNvcnMsYCArXG4gICAgICAgICAgYGJlY2F1c2UgdGhlIGluZGV4IHNpemU6ICR7XG4gICAgICAgICAgICAgIGluZGljZXMubGVuZ3RofSBpcyBub3QgdGhlIHNhbWUgYXMgdGVuc29ycyBzaXplOiAke1xuICAgICAgICAgICAgICB0ZW5zb3JzLmxlbmd0aH0uYCk7XG4gICAgfVxuXG4gICAgaW5kaWNlcy5mb3JFYWNoKChpLCBpbmRleCkgPT4gdGhpcy53cml0ZShpLCB0ZW5zb3JzW2luZGV4XSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBzZWxlY3RlZCB2YWx1ZXMgaW4gdGhlIFRlbnNvckFycmF5IGFzIGEgcGFja2VkIFRlbnNvci4gQWxsIG9mXG4gICAqIHNlbGVjdGVkIHZhbHVlcyBtdXN0IGhhdmUgYmVlbiB3cml0dGVuIGFuZCB0aGVpciBzaGFwZXMgbXVzdCBhbGwgbWF0Y2guXG4gICAqIEBwYXJhbSBbaW5kaWNlc10gbnVtYmVyW10gT3B0aW9uYWwuIFRha2luZyB2YWx1ZXMgaW4gWzAsIG1heF92YWx1ZSkuIElmIHRoZVxuICAgKiAgICBUZW5zb3JBcnJheSBpcyBub3QgZHluYW1pYywgbWF4X3ZhbHVlPXNpemUoKS4gSWYgbm90IHNwZWNpZmllZCByZXR1cm5zXG4gICAqICAgIGFsbCB0ZW5zb3JzIGluIHRoZSBvcmlnaW5hbCBvcmRlci5cbiAgICogQHBhcmFtIFtkdHlwZV1cbiAgICovXG4gIGdhdGhlcihpbmRpY2VzPzogbnVtYmVyW10sIGR0eXBlPzogRGF0YVR5cGUpOiBUZW5zb3Ige1xuICAgIGlmICghIWR0eXBlICYmIGR0eXBlICE9PSB0aGlzLmR0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbnNvckFycmF5IGR0eXBlIGlzICR7XG4gICAgICAgICAgdGhpcy5kdHlwZX0gYnV0IGdhdGhlciByZXF1ZXN0ZWQgZHR5cGUgJHtkdHlwZX1gKTtcbiAgICB9XG5cbiAgICBpZiAoIWluZGljZXMpIHtcbiAgICAgIGluZGljZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplKCk7IGkrKykge1xuICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGljZXMgPSBpbmRpY2VzLnNsaWNlKDAsIHRoaXMuc2l6ZSgpKTtcbiAgICB9XG5cbiAgICBpZiAoaW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0ZW5zb3IoW10sIFswXS5jb25jYXQodGhpcy5lbGVtZW50U2hhcGUpKTtcbiAgICB9XG5cbiAgICAvLyBSZWFkIGFsbCB0aGUgUGVyc2lzdGVudFRlbnNvcnMgaW50byBhIHZlY3RvciB0byBrZWVwIHRyYWNrIG9mXG4gICAgLy8gdGhlaXIgbWVtb3J5LlxuICAgIGNvbnN0IHRlbnNvcnMgPSB0aGlzLnJlYWRNYW55KGluZGljZXMpO1xuXG4gICAgYXNzZXJ0U2hhcGVzTWF0Y2hBbGxvd1VuZGVmaW5lZFNpemUoXG4gICAgICAgIHRoaXMuZWxlbWVudFNoYXBlLCB0ZW5zb3JzWzBdLnNoYXBlLCAnVGVuc29yQXJyYXkgc2hhcGUgbWlzbWF0Y2g6ICcpO1xuXG4gICAgcmV0dXJuIHN0YWNrKHRlbnNvcnMsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdmFsdWVzIGluIHRoZSBUZW5zb3JBcnJheSBhcyBhIGNvbmNhdGVuYXRlZCBUZW5zb3IuXG4gICAqL1xuICBjb25jYXQoZHR5cGU/OiBEYXRhVHlwZSk6IFRlbnNvciB7XG4gICAgaWYgKCEhZHR5cGUgJiYgZHR5cGUgIT09IHRoaXMuZHR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yQXJyYXkgZHR5cGUgaXMgJHtcbiAgICAgICAgICB0aGlzLmR0eXBlfSBidXQgY29uY2F0IHJlcXVlc3RlZCBkdHlwZSAke2R0eXBlfWApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNpemUoKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRlbnNvcihbXSwgWzBdLmNvbmNhdCh0aGlzLmVsZW1lbnRTaGFwZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGljZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICB9XG4gICAgLy8gQ29sbGVjdCBhbGwgdGhlIHRlbnNvcnMgZnJvbSB0aGUgdGVuc29ycyBhcnJheS5cbiAgICBjb25zdCB0ZW5zb3JzID0gdGhpcy5yZWFkTWFueShpbmRpY2VzKTtcblxuICAgIGFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKFxuICAgICAgICB0aGlzLmVsZW1lbnRTaGFwZSwgdGVuc29yc1swXS5zaGFwZSxcbiAgICAgICAgYFRlbnNvckFycmF5IHNoYXBlIG1pc21hdGNoOiB0ZW5zb3IgYXJyYXkgc2hhcGUgKCR7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRTaGFwZX0pIHZzIGZpcnN0IHRlbnNvciBzaGFwZSAoJHt0ZW5zb3JzWzBdLnNoYXBlfSlgKTtcblxuICAgIHJldHVybiBjb25jYXQodGVuc29ycywgMCk7XG4gIH1cblxuICAvKipcbiAgICogU2NhdHRlciB0aGUgdmFsdWVzIG9mIGEgVGVuc29yIGluIHNwZWNpZmljIGluZGljZXMgb2YgYSBUZW5zb3JBcnJheS5cbiAgICogQHBhcmFtIGluZGljZXMgbnVtYmVyW10gdmFsdWVzIGluIFswLCBtYXhfdmFsdWUpLiBJZiB0aGVcbiAgICogICAgVGVuc29yQXJyYXkgaXMgbm90IGR5bmFtaWMsIG1heF92YWx1ZT1zaXplKCkuXG4gICAqIEBwYXJhbSB0ZW5zb3IgVGVuc29yIGlucHV0IHRlbnNvci5cbiAgICovXG4gIHNjYXR0ZXIoaW5kaWNlczogbnVtYmVyW10sIHRlbnNvcjogVGVuc29yKSB7XG4gICAgaWYgKHRlbnNvci5kdHlwZSAhPT0gdGhpcy5kdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JBcnJheSBkdHlwZSBpcyAke1xuICAgICAgICAgIHRoaXMuZHR5cGV9IGJ1dCB0ZW5zb3IgaGFzIGR0eXBlICR7dGVuc29yLmR0eXBlfWApO1xuICAgIH1cblxuICAgIGlmIChpbmRpY2VzLmxlbmd0aCAhPT0gdGVuc29yLnNoYXBlWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGxlbihpbmRpY2VzKSA9PSB0ZW5zb3Iuc2hhcGVbMF0sIGJ1dCBzYXc6ICR7XG4gICAgICAgICAgaW5kaWNlcy5sZW5ndGh9IHZzLiAke3RlbnNvci5zaGFwZVswXX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXhJbmRleCA9IE1hdGgubWF4KC4uLmluZGljZXMpO1xuXG4gICAgaWYgKCF0aGlzLmR5bmFtaWNTaXplICYmIG1heEluZGV4ID49IHRoaXMubWF4U2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBNYXggaW5kZXggbXVzdCBiZSA8IGFycmF5IHNpemUgKCR7bWF4SW5kZXh9ICB2cy4gJHt0aGlzLm1heFNpemV9KWApO1xuICAgIH1cblxuICAgIHRoaXMud3JpdGVNYW55KGluZGljZXMsIHVuc3RhY2sodGVuc29yLCAwKSk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhlIHZhbHVlcyBvZiBhIFRlbnNvciBpbnRvIHRoZSBUZW5zb3JBcnJheS5cbiAgICogQHBhcmFtIGxlbmd0aCBudW1iZXJbXSB3aXRoIHRoZSBsZW5ndGhzIHRvIHVzZSB3aGVuIHNwbGl0dGluZyB2YWx1ZSBhbG9uZ1xuICAgKiAgICBpdHMgZmlyc3QgZGltZW5zaW9uLlxuICAgKiBAcGFyYW0gdGVuc29yIFRlbnNvciwgdGhlIHRlbnNvciB0byBzcGxpdC5cbiAgICovXG4gIHNwbGl0KGxlbmd0aDogbnVtYmVyW10sIHRlbnNvcjogVGVuc29yKSB7XG4gICAgaWYgKHRlbnNvci5kdHlwZSAhPT0gdGhpcy5kdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW5zb3JBcnJheSBkdHlwZSBpcyAke1xuICAgICAgICAgIHRoaXMuZHR5cGV9IGJ1dCB0ZW5zb3IgaGFzIGR0eXBlICR7dGVuc29yLmR0eXBlfWApO1xuICAgIH1cbiAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IGN1bXVsYXRpdmVMZW5ndGhzID0gbGVuZ3RoLm1hcChsZW4gPT4ge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGVuO1xuICAgICAgcmV0dXJuIHRvdGFsTGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgaWYgKHRvdGFsTGVuZ3RoICE9PSB0ZW5zb3Iuc2hhcGVbMF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgc3VtIG9mIGxlbmd0aHMgdG8gYmUgZXF1YWwgdG9cbiAgICAgICAgICB0ZW5zb3Iuc2hhcGVbMF0sIGJ1dCBzdW0gb2YgbGVuZ3RocyBpc1xuICAgICAgICAke3RvdGFsTGVuZ3RofSwgYW5kIHRlbnNvcidzIHNoYXBlIGlzOiAke3RlbnNvci5zaGFwZX1gKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZHluYW1pY1NpemUgJiYgbGVuZ3RoLmxlbmd0aCAhPT0gdGhpcy5tYXhTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFRlbnNvckFycmF5J3Mgc2l6ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHNpemUgb2YgbGVuZ3RocyAoJHtcbiAgICAgICAgICAgICAgdGhpcy5tYXhTaXplfSB2cy4gJHtsZW5ndGgubGVuZ3RofSksIGAgK1xuICAgICAgICAgICdhbmQgdGhlIFRlbnNvckFycmF5IGlzIG5vdCBtYXJrZWQgYXMgZHluYW1pY2FsbHkgcmVzaXplYWJsZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnRQZXJSb3cgPSB0b3RhbExlbmd0aCA9PT0gMCA/IDAgOiB0ZW5zb3Iuc2l6ZSAvIHRvdGFsTGVuZ3RoO1xuICAgIGNvbnN0IHRlbnNvcnM6IFRlbnNvcltdID0gW107XG4gICAgdGlkeSgoKSA9PiB7XG4gICAgICB0ZW5zb3IgPSByZXNoYXBlKHRlbnNvciwgWzEsIHRvdGFsTGVuZ3RoLCBlbGVtZW50UGVyUm93XSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBwcmV2aW91c0xlbmd0aCA9IChpID09PSAwKSA/IDAgOiBjdW11bGF0aXZlTGVuZ3Roc1tpIC0gMV07XG4gICAgICAgIGNvbnN0IGluZGljZXMgPSBbMCwgcHJldmlvdXNMZW5ndGgsIDBdO1xuICAgICAgICBjb25zdCBzaXplcyA9IFsxLCBsZW5ndGhbaV0sIGVsZW1lbnRQZXJSb3ddO1xuICAgICAgICB0ZW5zb3JzW2ldID0gcmVzaGFwZShzbGljZSh0ZW5zb3IsIGluZGljZXMsIHNpemVzKSwgdGhpcy5lbGVtZW50U2hhcGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRlbnNvcnM7XG4gICAgfSk7XG4gICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbmRpY2VzW2ldID0gaTtcbiAgICB9XG4gICAgdGhpcy53cml0ZU1hbnkoaW5kaWNlcywgdGVuc29ycyk7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * This differs from util.assertShapesMatch in that it allows values of\n * negative one, an undefined size of a dimensinon, in a shape to match\n * anything.\n */\nimport { util } from '@tensorflow/tfjs-core';\n/**\n * Used by TensorList and TensorArray to verify if elementShape matches, support\n * negative value as the dim shape.\n * @param shapeA\n * @param shapeB\n * @param errorMessagePrefix\n */\nexport function assertShapesMatchAllowUndefinedSize(shapeA, shapeB, errorMessagePrefix = '') {\n    // constant shape means unknown rank\n    if (typeof shapeA === 'number' || typeof shapeB === 'number') {\n        return;\n    }\n    util.assert(shapeA.length === shapeB.length, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);\n    for (let i = 0; i < shapeA.length; i++) {\n        const dim0 = shapeA[i];\n        const dim1 = shapeB[i];\n        util.assert(dim0 < 0 || dim1 < 0 || dim0 === dim1, () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);\n    }\n}\nexport function fullDefinedShape(elementShape) {\n    if (typeof elementShape === 'number' || elementShape.some(dim => dim < 0)) {\n        return false;\n    }\n    return true;\n}\n/**\n * Generate the output element shape from the list elementShape, list tensors\n * and input param.\n * @param listElementShape\n * @param tensors\n * @param elementShape\n */\nexport function inferElementShape(listElementShape, tensors, elementShape) {\n    let partialShape = mergeElementShape(listElementShape, elementShape);\n    const notfullDefinedShape = !fullDefinedShape(partialShape);\n    if (notfullDefinedShape && tensors.length === 0) {\n        throw new Error(`Tried to calculate elements of an empty list` +\n            ` with non-fully-defined elementShape: ${partialShape}`);\n    }\n    if (notfullDefinedShape) {\n        tensors.forEach(tensor => {\n            partialShape = mergeElementShape(tensor.shape, partialShape);\n        });\n    }\n    if (!fullDefinedShape(partialShape)) {\n        throw new Error(`Non-fully-defined elementShape: ${partialShape}`);\n    }\n    return partialShape;\n}\nexport function mergeElementShape(elementShapeA, elementShapeB) {\n    if (typeof elementShapeA === 'number') {\n        return elementShapeB;\n    }\n    if (typeof elementShapeB === 'number') {\n        return elementShapeA;\n    }\n    if (elementShapeA.length !== elementShapeB.length) {\n        throw new Error(`Incompatible ranks during merge: ${elementShapeA} vs. ${elementShapeB}`);\n    }\n    const result = [];\n    for (let i = 0; i < elementShapeA.length; ++i) {\n        const dim0 = elementShapeA[i];\n        const dim1 = elementShapeB[i];\n        if (dim0 >= 0 && dim1 >= 0 && dim0 !== dim1) {\n            throw new Error(`Incompatible shape during merge: ${elementShapeA} vs. ${elementShapeB}`);\n        }\n        result[i] = dim0 >= 0 ? dim0 : dim1;\n    }\n    return result;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVuc29yX3V0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb252ZXJ0ZXIvc3JjL2V4ZWN1dG9yL3RlbnNvcl91dGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFDSDs7OztHQUlHO0FBRUgsT0FBTyxFQUFTLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRW5EOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxtQ0FBbUMsQ0FDL0MsTUFBdUIsRUFBRSxNQUF1QixFQUNoRCxrQkFBa0IsR0FBRyxFQUFFO0lBQ3pCLG9DQUFvQztJQUNwQyxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsSUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLEVBQUU7UUFDNUQsT0FBTztLQUNSO0lBQ0QsSUFBSSxDQUFDLE1BQU0sQ0FDUCxNQUFNLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxNQUFNLEVBQy9CLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixHQUFHLFdBQVcsTUFBTSxRQUFRLE1BQU0sYUFBYSxDQUFDLENBQUM7SUFDN0UsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDdEMsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsTUFBTSxDQUNQLElBQUksR0FBRyxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsSUFBSSxJQUFJLEtBQUssSUFBSSxFQUNyQyxHQUFHLEVBQUUsQ0FDRCxrQkFBa0IsR0FBRyxXQUFXLE1BQU0sUUFBUSxNQUFNLGFBQWEsQ0FBQyxDQUFDO0tBQzVFO0FBQ0gsQ0FBQztBQUVELE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxZQUE2QjtJQUM1RCxJQUFJLE9BQU8sWUFBWSxLQUFLLFFBQVEsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ3pFLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUFDRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsaUJBQWlCLENBQzdCLGdCQUFpQyxFQUFFLE9BQWlCLEVBQ3BELFlBQTZCO0lBQy9CLElBQUksWUFBWSxHQUFHLGlCQUFpQixDQUFDLGdCQUFnQixFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ3JFLE1BQU0sbUJBQW1CLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUM1RCxJQUFJLG1CQUFtQixJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQy9DLE1BQU0sSUFBSSxLQUFLLENBQ1gsOENBQThDO1lBQzlDLHlDQUF5QyxZQUFZLEVBQUUsQ0FBQyxDQUFDO0tBQzlEO0lBQ0QsSUFBSSxtQkFBbUIsRUFBRTtRQUN2QixPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ3ZCLFlBQVksR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQy9ELENBQUMsQ0FBQyxDQUFDO0tBQ0o7SUFDRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLEVBQUU7UUFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQ0FBbUMsWUFBWSxFQUFFLENBQUMsQ0FBQztLQUNwRTtJQUNELE9BQU8sWUFBd0IsQ0FBQztBQUNsQyxDQUFDO0FBRUQsTUFBTSxVQUFVLGlCQUFpQixDQUM3QixhQUE4QixFQUFFLGFBQThCO0lBRWhFLElBQUksT0FBTyxhQUFhLEtBQUssUUFBUSxFQUFFO1FBQ3JDLE9BQU8sYUFBYSxDQUFDO0tBQ3RCO0lBQ0QsSUFBSSxPQUFPLGFBQWEsS0FBSyxRQUFRLEVBQUU7UUFDckMsT0FBTyxhQUFhLENBQUM7S0FDdEI7SUFFRCxJQUFJLGFBQWEsQ0FBQyxNQUFNLEtBQUssYUFBYSxDQUFDLE1BQU0sRUFBRTtRQUNqRCxNQUFNLElBQUksS0FBSyxDQUFDLG9DQUFvQyxhQUFhLFFBQzdELGFBQWEsRUFBRSxDQUFDLENBQUM7S0FDdEI7SUFFRCxNQUFNLE1BQU0sR0FBYSxFQUFFLENBQUM7SUFDNUIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUU7UUFDN0MsTUFBTSxJQUFJLEdBQUcsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlCLE1BQU0sSUFBSSxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM5QixJQUFJLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLEtBQUssSUFBSSxFQUFFO1lBQzNDLE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQW9DLGFBQWEsUUFDN0QsYUFBYSxFQUFFLENBQUMsQ0FBQztTQUN0QjtRQUNELE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztLQUNyQztJQUNELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogVGhpcyBkaWZmZXJzIGZyb20gdXRpbC5hc3NlcnRTaGFwZXNNYXRjaCBpbiB0aGF0IGl0IGFsbG93cyB2YWx1ZXMgb2ZcbiAqIG5lZ2F0aXZlIG9uZSwgYW4gdW5kZWZpbmVkIHNpemUgb2YgYSBkaW1lbnNpbm9uLCBpbiBhIHNoYXBlIHRvIG1hdGNoXG4gKiBhbnl0aGluZy5cbiAqL1xuXG5pbXBvcnQge1RlbnNvciwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuLyoqXG4gKiBVc2VkIGJ5IFRlbnNvckxpc3QgYW5kIFRlbnNvckFycmF5IHRvIHZlcmlmeSBpZiBlbGVtZW50U2hhcGUgbWF0Y2hlcywgc3VwcG9ydFxuICogbmVnYXRpdmUgdmFsdWUgYXMgdGhlIGRpbSBzaGFwZS5cbiAqIEBwYXJhbSBzaGFwZUFcbiAqIEBwYXJhbSBzaGFwZUJcbiAqIEBwYXJhbSBlcnJvck1lc3NhZ2VQcmVmaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFNoYXBlc01hdGNoQWxsb3dVbmRlZmluZWRTaXplKFxuICAgIHNoYXBlQTogbnVtYmVyfG51bWJlcltdLCBzaGFwZUI6IG51bWJlcnxudW1iZXJbXSxcbiAgICBlcnJvck1lc3NhZ2VQcmVmaXggPSAnJyk6IHZvaWQge1xuICAvLyBjb25zdGFudCBzaGFwZSBtZWFucyB1bmtub3duIHJhbmtcbiAgaWYgKHR5cGVvZiBzaGFwZUEgPT09ICdudW1iZXInIHx8IHR5cGVvZiBzaGFwZUIgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHV0aWwuYXNzZXJ0KFxuICAgICAgc2hhcGVBLmxlbmd0aCA9PT0gc2hhcGVCLmxlbmd0aCxcbiAgICAgICgpID0+IGVycm9yTWVzc2FnZVByZWZpeCArIGAgU2hhcGVzICR7c2hhcGVBfSBhbmQgJHtzaGFwZUJ9IG11c3QgbWF0Y2hgKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZUEubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaW0wID0gc2hhcGVBW2ldO1xuICAgIGNvbnN0IGRpbTEgPSBzaGFwZUJbaV07XG4gICAgdXRpbC5hc3NlcnQoXG4gICAgICAgIGRpbTAgPCAwIHx8IGRpbTEgPCAwIHx8IGRpbTAgPT09IGRpbTEsXG4gICAgICAgICgpID0+XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VQcmVmaXggKyBgIFNoYXBlcyAke3NoYXBlQX0gYW5kICR7c2hhcGVCfSBtdXN0IG1hdGNoYCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZ1bGxEZWZpbmVkU2hhcGUoZWxlbWVudFNoYXBlOiBudW1iZXJ8bnVtYmVyW10pOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50U2hhcGUgPT09ICdudW1iZXInIHx8IGVsZW1lbnRTaGFwZS5zb21lKGRpbSA9PiBkaW0gPCAwKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogR2VuZXJhdGUgdGhlIG91dHB1dCBlbGVtZW50IHNoYXBlIGZyb20gdGhlIGxpc3QgZWxlbWVudFNoYXBlLCBsaXN0IHRlbnNvcnNcbiAqIGFuZCBpbnB1dCBwYXJhbS5cbiAqIEBwYXJhbSBsaXN0RWxlbWVudFNoYXBlXG4gKiBAcGFyYW0gdGVuc29yc1xuICogQHBhcmFtIGVsZW1lbnRTaGFwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mZXJFbGVtZW50U2hhcGUoXG4gICAgbGlzdEVsZW1lbnRTaGFwZTogbnVtYmVyfG51bWJlcltdLCB0ZW5zb3JzOiBUZW5zb3JbXSxcbiAgICBlbGVtZW50U2hhcGU6IG51bWJlcnxudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgbGV0IHBhcnRpYWxTaGFwZSA9IG1lcmdlRWxlbWVudFNoYXBlKGxpc3RFbGVtZW50U2hhcGUsIGVsZW1lbnRTaGFwZSk7XG4gIGNvbnN0IG5vdGZ1bGxEZWZpbmVkU2hhcGUgPSAhZnVsbERlZmluZWRTaGFwZShwYXJ0aWFsU2hhcGUpO1xuICBpZiAobm90ZnVsbERlZmluZWRTaGFwZSAmJiB0ZW5zb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRyaWVkIHRvIGNhbGN1bGF0ZSBlbGVtZW50cyBvZiBhbiBlbXB0eSBsaXN0YCArXG4gICAgICAgIGAgd2l0aCBub24tZnVsbHktZGVmaW5lZCBlbGVtZW50U2hhcGU6ICR7cGFydGlhbFNoYXBlfWApO1xuICB9XG4gIGlmIChub3RmdWxsRGVmaW5lZFNoYXBlKSB7XG4gICAgdGVuc29ycy5mb3JFYWNoKHRlbnNvciA9PiB7XG4gICAgICBwYXJ0aWFsU2hhcGUgPSBtZXJnZUVsZW1lbnRTaGFwZSh0ZW5zb3Iuc2hhcGUsIHBhcnRpYWxTaGFwZSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKCFmdWxsRGVmaW5lZFNoYXBlKHBhcnRpYWxTaGFwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi1mdWxseS1kZWZpbmVkIGVsZW1lbnRTaGFwZTogJHtwYXJ0aWFsU2hhcGV9YCk7XG4gIH1cbiAgcmV0dXJuIHBhcnRpYWxTaGFwZSBhcyBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRWxlbWVudFNoYXBlKFxuICAgIGVsZW1lbnRTaGFwZUE6IG51bWJlcnxudW1iZXJbXSwgZWxlbWVudFNoYXBlQjogbnVtYmVyfG51bWJlcltdKTogbnVtYmVyfFxuICAgIG51bWJlcltdIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50U2hhcGVBID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBlbGVtZW50U2hhcGVCO1xuICB9XG4gIGlmICh0eXBlb2YgZWxlbWVudFNoYXBlQiA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZWxlbWVudFNoYXBlQTtcbiAgfVxuXG4gIGlmIChlbGVtZW50U2hhcGVBLmxlbmd0aCAhPT0gZWxlbWVudFNoYXBlQi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29tcGF0aWJsZSByYW5rcyBkdXJpbmcgbWVyZ2U6ICR7ZWxlbWVudFNoYXBlQX0gdnMuICR7XG4gICAgICAgIGVsZW1lbnRTaGFwZUJ9YCk7XG4gIH1cblxuICBjb25zdCByZXN1bHQ6IG51bWJlcltdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudFNoYXBlQS5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGRpbTAgPSBlbGVtZW50U2hhcGVBW2ldO1xuICAgIGNvbnN0IGRpbTEgPSBlbGVtZW50U2hhcGVCW2ldO1xuICAgIGlmIChkaW0wID49IDAgJiYgZGltMSA+PSAwICYmIGRpbTAgIT09IGRpbTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wYXRpYmxlIHNoYXBlIGR1cmluZyBtZXJnZTogJHtlbGVtZW50U2hhcGVBfSB2cy4gJHtcbiAgICAgICAgICBlbGVtZW50U2hhcGVCfWApO1xuICAgIH1cbiAgICByZXN1bHRbaV0gPSBkaW0wID49IDAgPyBkaW0wIDogZGltMTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuIl19","/**\n * Contains global resources of a model.\n */\nexport class ResourceManager {\n    constructor(hashTableNameToHandle = {}, hashTableMap = {}) {\n        this.hashTableNameToHandle = hashTableNameToHandle;\n        this.hashTableMap = hashTableMap;\n    }\n    /**\n     * Register a `HashTable` in the resource manager.\n     *\n     * The `HashTable` can be retrieved by `resourceManager.getHashTableById`,\n     * where id is the table handle tensor's id.\n     *\n     * @param name Op node name that creates the `HashTable`.\n     * @param hashTable The `HashTable` to be added to resource manager.\n     */\n    addHashTable(name, hashTable) {\n        this.hashTableNameToHandle[name] = hashTable.handle;\n        this.hashTableMap[hashTable.id] = hashTable;\n    }\n    /**\n     * Get the table handle by node name.\n     * @param name Op node name that creates the `HashTable`. This name is also\n     *     used in the inputs list of lookup and import `HashTable` ops.\n     */\n    getHashTableHandleByName(name) {\n        return this.hashTableNameToHandle[name];\n    }\n    /**\n     * Get the actual `HashTable` by its handle tensor's id.\n     * @param id The id of the handle tensor.\n     */\n    getHashTableById(id) {\n        return this.hashTableMap[id];\n    }\n    /**\n     * Dispose `ResourceManager`, including its hashTables and tensors in them.\n     */\n    dispose() {\n        for (const key in this.hashTableMap) {\n            this.hashTableMap[key].clearAndClose();\n            delete this.hashTableMap[key];\n        }\n        for (const name in this.hashTableNameToHandle) {\n            this.hashTableNameToHandle[name].dispose();\n            delete this.hashTableNameToHandle[name];\n        }\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzb3VyY2VfbWFuYWdlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29udmVydGVyL3NyYy9leGVjdXRvci9yZXNvdXJjZV9tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW1CQTs7R0FFRztBQUNILE1BQU0sT0FBTyxlQUFlO0lBQzFCLFlBQ2Esd0JBQXdDLEVBQUUsRUFDMUMsZUFBNkIsRUFBRTtRQUQvQiwwQkFBcUIsR0FBckIscUJBQXFCLENBQXFCO1FBQzFDLGlCQUFZLEdBQVosWUFBWSxDQUFtQjtJQUFHLENBQUM7SUFFaEQ7Ozs7Ozs7O09BUUc7SUFDSCxZQUFZLENBQUMsSUFBWSxFQUFFLFNBQW9CO1FBQzdDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDO1FBQ3BELElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILHdCQUF3QixDQUFDLElBQVk7UUFDbkMsT0FBTyxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7T0FHRztJQUNILGdCQUFnQixDQUFDLEVBQVU7UUFDekIsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRDs7T0FFRztJQUNILE9BQU87UUFDTCxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDbkMsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUN2QyxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDL0I7UUFFRCxLQUFLLE1BQU0sSUFBSSxJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRTtZQUM3QyxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDM0MsT0FBTyxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDekM7SUFDSCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5pbXBvcnQge0hhc2hUYWJsZU1hcCwgTmFtZWRUZW5zb3JNYXB9IGZyb20gJy4uL2RhdGEvdHlwZXMnO1xuaW1wb3J0IHtIYXNoVGFibGV9IGZyb20gJy4vaGFzaF90YWJsZSc7XG5cbi8qKlxuICogQ29udGFpbnMgZ2xvYmFsIHJlc291cmNlcyBvZiBhIG1vZGVsLlxuICovXG5leHBvcnQgY2xhc3MgUmVzb3VyY2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoXG4gICAgICByZWFkb25seSBoYXNoVGFibGVOYW1lVG9IYW5kbGU6IE5hbWVkVGVuc29yTWFwID0ge30sXG4gICAgICByZWFkb25seSBoYXNoVGFibGVNYXA6IEhhc2hUYWJsZU1hcCA9IHt9KSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGBIYXNoVGFibGVgIGluIHRoZSByZXNvdXJjZSBtYW5hZ2VyLlxuICAgKlxuICAgKiBUaGUgYEhhc2hUYWJsZWAgY2FuIGJlIHJldHJpZXZlZCBieSBgcmVzb3VyY2VNYW5hZ2VyLmdldEhhc2hUYWJsZUJ5SWRgLFxuICAgKiB3aGVyZSBpZCBpcyB0aGUgdGFibGUgaGFuZGxlIHRlbnNvcidzIGlkLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBPcCBub2RlIG5hbWUgdGhhdCBjcmVhdGVzIHRoZSBgSGFzaFRhYmxlYC5cbiAgICogQHBhcmFtIGhhc2hUYWJsZSBUaGUgYEhhc2hUYWJsZWAgdG8gYmUgYWRkZWQgdG8gcmVzb3VyY2UgbWFuYWdlci5cbiAgICovXG4gIGFkZEhhc2hUYWJsZShuYW1lOiBzdHJpbmcsIGhhc2hUYWJsZTogSGFzaFRhYmxlKSB7XG4gICAgdGhpcy5oYXNoVGFibGVOYW1lVG9IYW5kbGVbbmFtZV0gPSBoYXNoVGFibGUuaGFuZGxlO1xuICAgIHRoaXMuaGFzaFRhYmxlTWFwW2hhc2hUYWJsZS5pZF0gPSBoYXNoVGFibGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0YWJsZSBoYW5kbGUgYnkgbm9kZSBuYW1lLlxuICAgKiBAcGFyYW0gbmFtZSBPcCBub2RlIG5hbWUgdGhhdCBjcmVhdGVzIHRoZSBgSGFzaFRhYmxlYC4gVGhpcyBuYW1lIGlzIGFsc29cbiAgICogICAgIHVzZWQgaW4gdGhlIGlucHV0cyBsaXN0IG9mIGxvb2t1cCBhbmQgaW1wb3J0IGBIYXNoVGFibGVgIG9wcy5cbiAgICovXG4gIGdldEhhc2hUYWJsZUhhbmRsZUJ5TmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNoVGFibGVOYW1lVG9IYW5kbGVbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhY3R1YWwgYEhhc2hUYWJsZWAgYnkgaXRzIGhhbmRsZSB0ZW5zb3IncyBpZC5cbiAgICogQHBhcmFtIGlkIFRoZSBpZCBvZiB0aGUgaGFuZGxlIHRlbnNvci5cbiAgICovXG4gIGdldEhhc2hUYWJsZUJ5SWQoaWQ6IG51bWJlcik6IEhhc2hUYWJsZSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzaFRhYmxlTWFwW2lkXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwb3NlIGBSZXNvdXJjZU1hbmFnZXJgLCBpbmNsdWRpbmcgaXRzIGhhc2hUYWJsZXMgYW5kIHRlbnNvcnMgaW4gdGhlbS5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5oYXNoVGFibGVNYXApIHtcbiAgICAgIHRoaXMuaGFzaFRhYmxlTWFwW2tleV0uY2xlYXJBbmRDbG9zZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuaGFzaFRhYmxlTWFwW2tleV07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMuaGFzaFRhYmxlTmFtZVRvSGFuZGxlKSB7XG4gICAgICB0aGlzLmhhc2hUYWJsZU5hbWVUb0hhbmRsZVtuYW1lXS5kaXNwb3NlKCk7XG4gICAgICBkZWxldGUgdGhpcy5oYXNoVGFibGVOYW1lVG9IYW5kbGVbbmFtZV07XG4gICAgfVxuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n    const usedNodes = new Set();\n    const missingInputs = [];\n    let dynamicNode = null;\n    let syncInputs = null;\n    // Start with the outputs, going backwards and find all the nodes that are\n    // needed to compute those outputs.\n    const seen = new Set();\n    const inputNodeNames = new Set(Object.keys(inputs).map((name) => parseNodeName(name)[0]));\n    initNodes = initNodes || [];\n    const initNodeNames = new Set(initNodes.map((node) => parseNodeName(node.name)[0]));\n    const frontier = [...outputs];\n    while (frontier.length > 0) {\n        const node = frontier.pop();\n        if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n            if (dynamicNode == null) {\n                dynamicNode = node;\n                syncInputs = dynamicNode.children.map(child => child.name)\n                    .filter(name => usedNodes.has(name));\n            }\n        }\n        usedNodes.add(node.name);\n        // Weights are dead end since we already have their values.\n        if (weightMap[node.name] != null) {\n            continue;\n        }\n        // This node is a dead end since it's one of the user-provided inputs.\n        if (inputNodeNames.has(node.name)) {\n            continue;\n        }\n        // This node is a dead end since it doesn't have any inputs.\n        if (initNodeNames.has(node.name)) {\n            continue;\n        }\n        if (node.inputs.length === 0) {\n            missingInputs.push(node.name);\n            continue;\n        }\n        node.inputs.forEach(input => {\n            // Don't add to the frontier if it is already there.\n            if (seen.has(input.name)) {\n                return;\n            }\n            seen.add(input.name);\n            frontier.push(input);\n        });\n    }\n    return { inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(graph, executionInfo) {\n    const { usedNodes, inputs } = executionInfo;\n    const inputNodes = Object.keys(inputs)\n        .map(name => parseNodeName(name)[0])\n        .map(name => graph.nodes[name]);\n    const initNodes = graph.initNodes || [];\n    const isUsed = (node) => usedNodes.has(typeof node === 'string' ? node : node.name);\n    function unique(nodes) {\n        return [...new Map(nodes.map((node) => [node.name, node])).values()];\n    }\n    const predefinedNodes = unique([\n        ...inputNodes,\n        ...graph.weights,\n        ...initNodes,\n    ]).filter(isUsed);\n    const allNodes = unique([\n        ...predefinedNodes,\n        ...Object.values(graph.nodes),\n    ]).filter(isUsed);\n    const nameToNode = new Map(allNodes.map((node) => [node.name, node]));\n    const inCounts = {};\n    for (const node of allNodes) {\n        inCounts[node.name] = inCounts[node.name] || 0;\n        for (const child of node.children) {\n            // When the child is unused, set in counts to infinity so that it will\n            // never be decreased to 0 and added to the execution list.\n            if (!isUsed(child)) {\n                inCounts[child.name] = Number.POSITIVE_INFINITY;\n            }\n            inCounts[child.name] = (inCounts[child.name] || 0) + 1;\n        }\n    }\n    // Build execution order for all used nodes regardless whether they are\n    // predefined or not.\n    const frontier = Object.entries(inCounts)\n        .filter(([, inCount]) => inCount === 0)\n        .map(([name]) => name);\n    const orderedNodeNames = [...frontier];\n    while (frontier.length > 0) {\n        const nodeName = frontier.pop();\n        const node = nameToNode.get(nodeName);\n        for (const child of node.children.filter(isUsed)) {\n            if (--inCounts[child.name] === 0) {\n                orderedNodeNames.push(child.name);\n                frontier.push(child.name);\n            }\n        }\n    }\n    const orderedNodes = orderedNodeNames.map((name) => nameToNode.get(name));\n    const filteredOrderedNodes = filterPredefinedReachableNodes(orderedNodes, predefinedNodes);\n    // TODO: Turn validation on/off with tf env flag.\n    validateNodesExecutionOrder(filteredOrderedNodes, predefinedNodes);\n    return filteredOrderedNodes;\n}\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Returns ordered nodes reachable by at least one predefined node.\n * This can help us filter out redundant nodes from the returned node list.\n * For example:\n * If we have four nodes with dependencies like this:\n *   a --> b --> c --> d\n * when node `c` is predefined (e.g. given as an input tensor), we can\n * skip node `a` and `b` since their outputs will never be used.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction filterPredefinedReachableNodes(orderedNodes, predefinedNodes) {\n    const nameToNode = new Map(orderedNodes.map((node) => [node.name, node]));\n    // TODO: Filter out more nodes when >=2 nodes are predefined in a path.\n    const stack = predefinedNodes.map((node) => node.name);\n    const predefinedReachableNodeNames = new Set(stack);\n    // Perform a DFS starting from the set of all predefined nodes\n    // to find the set of all nodes reachable from the predefined nodes.\n    while (stack.length > 0) {\n        const nodeName = stack.pop();\n        const node = nameToNode.get(nodeName);\n        for (const child of node.children) {\n            if (!nameToNode.has(child.name) ||\n                predefinedReachableNodeNames.has(child.name)) {\n                continue;\n            }\n            predefinedReachableNodeNames.add(child.name);\n            stack.push(child.name);\n        }\n    }\n    // Filter out unreachable nodes and build the ordered node list.\n    const filteredOrderedNodes = orderedNodes.filter((node) => predefinedReachableNodeNames.has(node.name));\n    return filteredOrderedNodes;\n}\nclass NodesExecutionOrderError extends Error {\n    constructor(message) {\n        super(`NodesExecutionOrderError: ${message}`);\n    }\n}\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Validates property: given nodes `a` and `b`, Order(a) > Order(b) if `a`\n * is a child of `b`. This function throws an error if validation fails.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction validateNodesExecutionOrder(orderedNodes, predefinedNodes) {\n    const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));\n    const predefinedNodeNames = new Set(predefinedNodes.map((node) => node.name));\n    const isPredefined = (node) => predefinedNodeNames.has(typeof node === 'string' ? node : node.name);\n    const willBeExecutedNodeNames = new Set(orderedNodes.map((node) => node.name));\n    const willBeExecuted = (node) => willBeExecutedNodeNames.has(typeof node === 'string' ? node : node.name);\n    for (const node of orderedNodes) {\n        for (const child of node.children.filter(willBeExecuted)) {\n            if (!nodeNameToOrder.has(child.name)) {\n                throw new NodesExecutionOrderError(`Child ${child.name} of node ${node.name} is unreachable.`);\n            }\n            if (nodeNameToOrder.get(node.name) > nodeNameToOrder.get(child.name)) {\n                throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run after its child ${child.name}.`);\n            }\n        }\n        if (!isPredefined(node)) {\n            for (const input of node.inputs) {\n                if (!nodeNameToOrder.has(input.name)) {\n                    throw new NodesExecutionOrderError(`Input ${input.name} of node ${node.name} is unreachable.`);\n                }\n                if (nodeNameToOrder.get(input.name) > nodeNameToOrder.get(node.name)) {\n                    throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run before its input ${input.name}.`);\n                }\n            }\n        }\n    }\n}\n/**\n * Given the execution info, return a map from node name to the disposable\n * node name list after its execution.\n *\n * @returns A map from node name to disposable nodes after its\n *     execution. That is, for a node `x`, `nodeLiveUntilMap[x]` indicates\n *     all nodes which their intermediate tensors should be disposed after `x`\n *     being executed.\n */\nexport function getNodeLiveUntilMap(orderedNodes) {\n    const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));\n    const INF_LIFE = Number.MAX_SAFE_INTEGER;\n    // Make control flow nodes (and consequently their direct parents)\n    // live forever since they're tricky to track correctly.\n    const selfLifespans = orderedNodes.map((node, nodeOrder) => isControlFlow(node) ? INF_LIFE : nodeOrder);\n    const getSelfLifeSpan = (node) => {\n        const selfLife = selfLifespans[nodeNameToOrder.get(node.name)];\n        if (selfLife == null) {\n            // If nodeToOrder does not contain the node, it is unused or\n            // unreachable in graph.\n            return -1;\n        }\n        return selfLife;\n    };\n    // `liveUntil[i]` points to the last node in the `orderedNodes` array that\n    // may depend on tensors from node `i`. It indicates that all the\n    // intermediate tensors from `orderedNodes[i]` should be disposed after\n    // `orderedNodes[liveUntil[i]]` is executed.\n    // A node lives long enough to pass on its tensors to its children.\n    // It lives until at least `max(node's position, children's positions)`.\n    const liveUntilOrders = orderedNodes.map((node, nodeOrder) => {\n        return node.children.map(getSelfLifeSpan)\n            .reduce((a, b) => Math.max(a, b), selfLifespans[nodeOrder]);\n    });\n    // liveUntilMap:\n    // - Key: Name of a node `x`\n    // - Values: All nodes whose intermediate tensors should be disposed\n    //           after `x` is executed.\n    const liveUntilMap = new Map();\n    for (let nodeOrder = 0; nodeOrder < orderedNodes.length; ++nodeOrder) {\n        const liveUntilOrder = liveUntilOrders[nodeOrder];\n        if (liveUntilOrder === INF_LIFE) {\n            continue;\n        }\n        const node = orderedNodes[nodeOrder];\n        const liveUntilNode = orderedNodes[liveUntilOrder];\n        if (!liveUntilMap.has(liveUntilNode.name)) {\n            liveUntilMap.set(liveUntilNode.name, []);\n        }\n        liveUntilMap.get(liveUntilNode.name).push(node);\n    }\n    return liveUntilMap;\n}\nconst CONTROL_FLOW_OPS = new Set([\n    'Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf',\n    'StatelessWhile', 'if', 'While'\n]);\nconst DYNAMIC_SHAPE_OPS = new Set([\n    'NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'\n]);\nconst HASH_TABLE_OPS = new Set([\n    'HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2',\n    'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2'\n]);\nexport function isControlFlow(node) {\n    return CONTROL_FLOW_OPS.has(node.op);\n}\nexport function isDynamicShape(node) {\n    return DYNAMIC_SHAPE_OPS.has(node.op);\n}\nexport function isHashTable(node) {\n    return HASH_TABLE_OPS.has(node.op);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWxfYW5hbHlzaXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvbnZlcnRlci9zcmMvZXhlY3V0b3IvbW9kZWxfYW5hbHlzaXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBS0gsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLCtCQUErQixDQUFDO0FBWTVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsb0JBQW9CLENBQ2hDLE1BQXNCLEVBQUUsT0FBZSxFQUFFLFNBQTBCLEVBQ25FLFNBQWtCO0lBQ3BCLE1BQU0sU0FBUyxHQUFHLElBQUksR0FBRyxFQUFVLENBQUM7SUFDcEMsTUFBTSxhQUFhLEdBQWEsRUFBRSxDQUFDO0lBQ25DLElBQUksV0FBVyxHQUFTLElBQUksQ0FBQztJQUM3QixJQUFJLFVBQVUsR0FBYSxJQUFJLENBQUM7SUFFaEMsMEVBQTBFO0lBQzFFLG1DQUFtQztJQUNuQyxNQUFNLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBVSxDQUFDO0lBQy9CLE1BQU0sY0FBYyxHQUNoQixJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUV2RSxTQUFTLEdBQUcsU0FBUyxJQUFJLEVBQUUsQ0FBQztJQUM1QixNQUFNLGFBQWEsR0FDZixJQUFJLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVsRSxNQUFNLFFBQVEsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUM7SUFDOUIsT0FBTyxR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TSxpQkFBaUIsR0FBRyxJQUFJLEdBQUcsQ0FBQztJQUNoQyxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxPQUFPO0NBQzdFLENBQUMsQ0FBQztBQUNILE1BQU0sY0FBYyxHQUFHLElBQUksR0FBRyxDQUFDO0lBQzdCLFdBQVcsRUFBRSxhQUFhLEVBQUUsbUJBQW1CLEVBQUUscUJBQXFCO0lBQ3RFLGlCQUFpQixFQUFFLG1CQUFtQixFQUFFLGlCQUFpQixFQUFFLG1CQUFtQjtDQUMvRSxDQUFDLENBQUM7QUFFSCxNQUFNLFVBQVUsYUFBYSxDQUFDLElBQVU7SUFDdEMsT0FBTyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3ZDLENBQUM7QUFFRCxNQUFNLFVBQVUsY0FBYyxDQUFDLElBQVU7SUFDdkMsT0FBTyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3hDLENBQUM7QUFFRCxNQUFNLFVBQVUsV0FBVyxDQUFDLElBQVU7SUFDcEMsT0FBTyxjQUFjLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNyQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge05hbWVkVGVuc29yTWFwfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge05hbWVkVGVuc29yc01hcH0gZnJvbSAnLi4vZGF0YS90eXBlcyc7XG5pbXBvcnQge3BhcnNlTm9kZU5hbWV9IGZyb20gJy4uL29wZXJhdGlvbnMvZXhlY3V0b3JzL3V0aWxzJztcbmltcG9ydCB7R3JhcGgsIE5vZGV9IGZyb20gJy4uL29wZXJhdGlvbnMvdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEV4ZWN1dGlvbkluZm8ge1xuICBpbnB1dHM6IE5hbWVkVGVuc29yTWFwO1xuICBvdXRwdXRzOiBOb2RlW107XG4gIHVzZWROb2RlczogU2V0PHN0cmluZz47XG4gIG1pc3NpbmdJbnB1dHM6IHN0cmluZ1tdO1xuICBkeW5hbWljTm9kZTogTm9kZTtcbiAgc3luY0lucHV0czogc3RyaW5nW107XG59XG5cbi8qKlxuICogR2l2ZW4gZ3JhcGggaW5wdXRzIGFuZCBkZXNpcmVkIG91dHB1dHMsIGZpbmQgdGhlIG1pbmltYWwgc2V0IG9mIG5vZGVzXG4gKiB0byBleGVjdXRlIGluIG9yZGVyIHRvIGNvbXB1dGUgdGhlIG91dHB1dHMuIEluIGFkZGl0aW9uIHJldHVybiBvdGhlciB1c2VmdWxcbiAqIGluZm8gc3VjaDpcbiAqIC0gTWlzc2luZyBpbnB1dHMgbmVlZGVkIHRvIGNvbXB1dGUgdGhlIG91dHB1dC5cbiAqIC0gV2hldGhlciB0aGUgc3ViZ3JhcGggY29udGFpbnMgZHluYW1pYyBvcHMgKGNvbnRyb2wgZmxvdywgZHluYW1pYyBzaGFwZSkuXG4gKiAtIEFsdGVybmF0aXZlIGlucHV0cyBpbiBvcmRlciB0byBhdm9pZCBhc3luYyAoZHluYW1pYyBvcCkgZXhlY3V0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXhlY3V0aW9uU3ViZ3JhcGgoXG4gICAgaW5wdXRzOiBOYW1lZFRlbnNvck1hcCwgb3V0cHV0czogTm9kZVtdLCB3ZWlnaHRNYXA6IE5hbWVkVGVuc29yc01hcCxcbiAgICBpbml0Tm9kZXM/OiBOb2RlW10pOiBFeGVjdXRpb25JbmZvIHtcbiAgY29uc3QgdXNlZE5vZGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGNvbnN0IG1pc3NpbmdJbnB1dHM6IHN0cmluZ1tdID0gW107XG4gIGxldCBkeW5hbWljTm9kZTogTm9kZSA9IG51bGw7XG4gIGxldCBzeW5jSW5wdXRzOiBzdHJpbmdbXSA9IG51bGw7XG5cbiAgLy8gU3RhcnQgd2l0aCB0aGUgb3V0cHV0cywgZ29pbmcgYmFja3dhcmRzIGFuZCBmaW5kIGFsbCB0aGUgbm9kZXMgdGhhdCBhcmVcbiAgLy8gbmVlZGVkIHRvIGNvbXB1dGUgdGhvc2Ugb3V0cHV0cy5cbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBjb25zdCBpbnB1dE5vZGVOYW1lcyA9XG4gICAgICBuZXcgU2V0KE9iamVjdC5rZXlzKGlucHV0cykubWFwKChuYW1lKSA9PiBwYXJzZU5vZGVOYW1lKG5hbWUpWzBdKSk7XG5cbiAgaW5pdE5vZGVzID0gaW5pdE5vZGVzIHx8IFtdO1xuICBjb25zdCBpbml0Tm9kZU5hbWVzID1cbiAgICAgIG5ldyBTZXQoaW5pdE5vZGVzLm1hcCgobm9kZSkgPT4gcGFyc2VOb2RlTmFtZShub2RlLm5hbWUpWzBdKSk7XG5cbiAgY29uc3QgZnJvbnRpZXIgPSBbLi4ub3V0cHV0c107XG4gIHdoaWxlIChmcm9udGllci5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgbm9kZSA9IGZyb250aWVyLnBvcCgpO1xuICAgIGlmIChpc0NvbnRyb2xGbG93KG5vZGUpIHx8IGlzRHluYW1pY1NoYXBlKG5vZGUpIHx8IGlzSGFzaFRhYmxlKG5vZGUpKSB7XG4gICAgICBpZiAoZHluYW1pY05vZGUgPT0gbnVsbCkge1xuICAgICAgICBkeW5hbWljTm9kZSA9IG5vZGU7XG4gICAgICAgIHN5bmNJbnB1dHMgPSBkeW5hbWljTm9kZS5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKG5hbWUgPT4gdXNlZE5vZGVzLmhhcyhuYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHVzZWROb2Rlcy5hZGQobm9kZS5uYW1lKTtcblxuICAgIC8vIFdlaWdodHMgYXJlIGRlYWQgZW5kIHNpbmNlIHdlIGFscmVhZHkgaGF2ZSB0aGVpciB2YWx1ZXMuXG4gICAgaWYgKHdlaWdodE1hcFtub2RlLm5hbWVdICE9IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBUaGlzIG5vZGUgaXMgYSBkZWFkIGVuZCBzaW5jZSBpdCdzIG9uZSBvZiB0aGUgdXNlci1wcm92aWRlZCBpbnB1dHMuXG4gICAgaWYgKGlucHV0Tm9kZU5hbWVzLmhhcyhub2RlLm5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gVGhpcyBub2RlIGlzIGEgZGVhZCBlbmQgc2luY2UgaXQgZG9lc24ndCBoYXZlIGFueSBpbnB1dHMuXG4gICAgaWYgKGluaXROb2RlTmFtZXMuaGFzKG5vZGUubmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZS5pbnB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBtaXNzaW5nSW5wdXRzLnB1c2gobm9kZS5uYW1lKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBub2RlLmlucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgIC8vIERvbid0IGFkZCB0byB0aGUgZnJvbnRpZXIgaWYgaXQgaXMgYWxyZWFkeSB0aGVyZS5cbiAgICAgIGlmIChzZWVuLmhhcyhpbnB1dC5uYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWVuLmFkZChpbnB1dC5uYW1lKTtcbiAgICAgIGZyb250aWVyLnB1c2goaW5wdXQpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7aW5wdXRzLCBvdXRwdXRzLCB1c2VkTm9kZXMsIG1pc3NpbmdJbnB1dHMsIGR5bmFtaWNOb2RlLCBzeW5jSW5wdXRzfTtcbn1cblxuLyoqXG4gKiBHaXZlbiB0aGUgZXhlY3V0aW9uIGluZm8sIHJldHVybiBhIGxpc3Qgb2Ygbm9kZXMgaW4gdG9wb2xvZ2ljYWwgb3JkZXIgdGhhdFxuICogbmVlZCB0byBiZSBleGVjdXRlZCB0byBjb21wdXRlIHRoZSBvdXRwdXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2Rlc0luVG9wb2xvZ2ljYWxPcmRlcihcbiAgICBncmFwaDogR3JhcGgsIGV4ZWN1dGlvbkluZm86IEV4ZWN1dGlvbkluZm8pOiBOb2RlW10ge1xuICBjb25zdCB7dXNlZE5vZGVzLCBpbnB1dHN9ID0gZXhlY3V0aW9uSW5mbztcbiAgY29uc3QgaW5wdXROb2RlcyA9IE9iamVjdC5rZXlzKGlucHV0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKG5hbWUgPT4gcGFyc2VOb2RlTmFtZShuYW1lKVswXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKG5hbWUgPT4gZ3JhcGgubm9kZXNbbmFtZV0pO1xuICBjb25zdCBpbml0Tm9kZXMgPSBncmFwaC5pbml0Tm9kZXMgfHwgW107XG5cbiAgY29uc3QgaXNVc2VkID0gKG5vZGU6IE5vZGV8c3RyaW5nKSA9PlxuICAgICAgdXNlZE5vZGVzLmhhcyh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycgPyBub2RlIDogbm9kZS5uYW1lKTtcblxuICBmdW5jdGlvbiB1bmlxdWUobm9kZXM6IE5vZGVbXSk6IE5vZGVbXSB7XG4gICAgcmV0dXJuIFsuLi5uZXcgTWFwKG5vZGVzLm1hcCgobm9kZSkgPT4gW25vZGUubmFtZSwgbm9kZV0pKS52YWx1ZXMoKV07XG4gIH1cbiAgY29uc3QgcHJlZGVmaW5lZE5vZGVzID0gdW5pcXVlKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5pbnB1dE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmdyYXBoLndlaWdodHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uaW5pdE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBdKS5maWx0ZXIoaXNVc2VkKTtcbiAgY29uc3QgYWxsTm9kZXMgPSB1bmlxdWUoW1xuICAgICAgICAgICAgICAgICAgICAgLi4ucHJlZGVmaW5lZE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAgLi4uT2JqZWN0LnZhbHVlcyhncmFwaC5ub2RlcyksXG4gICAgICAgICAgICAgICAgICAgXSkuZmlsdGVyKGlzVXNlZCk7XG4gIGNvbnN0IG5hbWVUb05vZGUgPVxuICAgICAgbmV3IE1hcDxzdHJpbmcsIE5vZGU+KGFsbE5vZGVzLm1hcCgobm9kZSkgPT4gW25vZGUubmFtZSwgbm9kZV0pKTtcblxuICBjb25zdCBpbkNvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgYWxsTm9kZXMpIHtcbiAgICBpbkNvdW50c1tub2RlLm5hbWVdID0gaW5Db3VudHNbbm9kZS5uYW1lXSB8fCAwO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgLy8gV2hlbiB0aGUgY2hpbGQgaXMgdW51c2VkLCBzZXQgaW4gY291bnRzIHRvIGluZmluaXR5IHNvIHRoYXQgaXQgd2lsbFxuICAgICAgLy8gbmV2ZXIgYmUgZGVjcmVhc2VkIHRvIDAgYW5kIGFkZGVkIHRvIHRoZSBleGVjdXRpb24gbGlzdC5cbiAgICAgIGlmICghaXNVc2VkKGNoaWxkKSkge1xuICAgICAgICBpbkNvdW50c1tjaGlsZC5uYW1lXSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIH1cbiAgICAgIGluQ291bnRzW2NoaWxkLm5hbWVdID0gKGluQ291bnRzW2NoaWxkLm5hbWVdIHx8IDApICsgMTtcbiAgICB9XG4gIH1cblxuICAvLyBCdWlsZCBleGVjdXRpb24gb3JkZXIgZm9yIGFsbCB1c2VkIG5vZGVzIHJlZ2FyZGxlc3Mgd2hldGhlciB0aGV5IGFyZVxuICAvLyBwcmVkZWZpbmVkIG9yIG5vdC5cbiAgY29uc3QgZnJvbnRpZXIgPSBPYmplY3QuZW50cmllcyhpbkNvdW50cylcbiAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoWywgaW5Db3VudF0pID0+IGluQ291bnQgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKFtuYW1lXSkgPT4gbmFtZSk7XG4gIGNvbnN0IG9yZGVyZWROb2RlTmFtZXMgPSBbLi4uZnJvbnRpZXJdO1xuICB3aGlsZSAoZnJvbnRpZXIubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG5vZGVOYW1lID0gZnJvbnRpZXIucG9wKCk7XG4gICAgY29uc3Qgbm9kZSA9IG5hbWVUb05vZGUuZ2V0KG5vZGVOYW1lKSE7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuLmZpbHRlcihpc1VzZWQpKSB7XG4gICAgICBpZiAoLS1pbkNvdW50c1tjaGlsZC5uYW1lXSA9PT0gMCkge1xuICAgICAgICBvcmRlcmVkTm9kZU5hbWVzLnB1c2goY2hpbGQubmFtZSk7XG4gICAgICAgIGZyb250aWVyLnB1c2goY2hpbGQubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgb3JkZXJlZE5vZGVzID0gb3JkZXJlZE5vZGVOYW1lcy5tYXAoKG5hbWUpID0+IG5hbWVUb05vZGUuZ2V0KG5hbWUpKTtcbiAgY29uc3QgZmlsdGVyZWRPcmRlcmVkTm9kZXMgPVxuICAgICAgZmlsdGVyUHJlZGVmaW5lZFJlYWNoYWJsZU5vZGVzKG9yZGVyZWROb2RlcywgcHJlZGVmaW5lZE5vZGVzKTtcblxuICAvLyBUT0RPOiBUdXJuIHZhbGlkYXRpb24gb24vb2ZmIHdpdGggdGYgZW52IGZsYWcuXG4gIHZhbGlkYXRlTm9kZXNFeGVjdXRpb25PcmRlcihmaWx0ZXJlZE9yZGVyZWROb2RlcywgcHJlZGVmaW5lZE5vZGVzKTtcblxuICByZXR1cm4gZmlsdGVyZWRPcmRlcmVkTm9kZXM7XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBvZiBgZ2V0Tm9kZXNJblRvcG9sb2dpY2FsT3JkZXJgLlxuICogUmV0dXJucyBvcmRlcmVkIG5vZGVzIHJlYWNoYWJsZSBieSBhdCBsZWFzdCBvbmUgcHJlZGVmaW5lZCBub2RlLlxuICogVGhpcyBjYW4gaGVscCB1cyBmaWx0ZXIgb3V0IHJlZHVuZGFudCBub2RlcyBmcm9tIHRoZSByZXR1cm5lZCBub2RlIGxpc3QuXG4gKiBGb3IgZXhhbXBsZTpcbiAqIElmIHdlIGhhdmUgZm91ciBub2RlcyB3aXRoIGRlcGVuZGVuY2llcyBsaWtlIHRoaXM6XG4gKiAgIGEgLS0+IGIgLS0+IGMgLS0+IGRcbiAqIHdoZW4gbm9kZSBgY2AgaXMgcHJlZGVmaW5lZCAoZS5nLiBnaXZlbiBhcyBhbiBpbnB1dCB0ZW5zb3IpLCB3ZSBjYW5cbiAqIHNraXAgbm9kZSBgYWAgYW5kIGBiYCBzaW5jZSB0aGVpciBvdXRwdXRzIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0gb3JkZXJlZE5vZGVzIEdyYXBoIG5vZGVzIGluIGV4ZWN1dGlvbiBvcmRlci5cbiAqIEBwYXJhbSBwcmVkZWZpbmVkTm9kZXMgR3JhcGggaW5wdXRzLCB3ZWlnaHRzLCBhbmQgaW5pdCBub2Rlcy4gTm9kZXMgaW4gdGhpc1xuICogICAgIGxpc3QgbXVzdCBoYXZlIGRpc3RpbmN0IG5hbWVzLlxuICovXG5mdW5jdGlvbiBmaWx0ZXJQcmVkZWZpbmVkUmVhY2hhYmxlTm9kZXMoXG4gICAgb3JkZXJlZE5vZGVzOiBOb2RlW10sIHByZWRlZmluZWROb2RlczogTm9kZVtdKSB7XG4gIGNvbnN0IG5hbWVUb05vZGUgPVxuICAgICAgbmV3IE1hcDxzdHJpbmcsIE5vZGU+KG9yZGVyZWROb2Rlcy5tYXAoKG5vZGUpID0+IFtub2RlLm5hbWUsIG5vZGVdKSk7XG5cbiAgLy8gVE9ETzogRmlsdGVyIG91dCBtb3JlIG5vZGVzIHdoZW4gPj0yIG5vZGVzIGFyZSBwcmVkZWZpbmVkIGluIGEgcGF0aC5cbiAgY29uc3Qgc3RhY2sgPSBwcmVkZWZpbmVkTm9kZXMubWFwKChub2RlKSA9PiBub2RlLm5hbWUpO1xuICBjb25zdCBwcmVkZWZpbmVkUmVhY2hhYmxlTm9kZU5hbWVzID0gbmV3IFNldChzdGFjayk7XG4gIC8vIFBlcmZvcm0gYSBERlMgc3RhcnRpbmcgZnJvbSB0aGUgc2V0IG9mIGFsbCBwcmVkZWZpbmVkIG5vZGVzXG4gIC8vIHRvIGZpbmQgdGhlIHNldCBvZiBhbGwgbm9kZXMgcmVhY2hhYmxlIGZyb20gdGhlIHByZWRlZmluZWQgbm9kZXMuXG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBub2RlID0gbmFtZVRvTm9kZS5nZXQobm9kZU5hbWUpITtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGlmICghbmFtZVRvTm9kZS5oYXMoY2hpbGQubmFtZSkgfHxcbiAgICAgICAgICBwcmVkZWZpbmVkUmVhY2hhYmxlTm9kZU5hbWVzLmhhcyhjaGlsZC5uYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHByZWRlZmluZWRSZWFjaGFibGVOb2RlTmFtZXMuYWRkKGNoaWxkLm5hbWUpO1xuICAgICAgc3RhY2sucHVzaChjaGlsZC5uYW1lKTtcbiAgICB9XG4gIH1cblxuICAvLyBGaWx0ZXIgb3V0IHVucmVhY2hhYmxlIG5vZGVzIGFuZCBidWlsZCB0aGUgb3JkZXJlZCBub2RlIGxpc3QuXG4gIGNvbnN0IGZpbHRlcmVkT3JkZXJlZE5vZGVzID0gb3JkZXJlZE5vZGVzLmZpbHRlcihcbiAgICAgIChub2RlKSA9PiBwcmVkZWZpbmVkUmVhY2hhYmxlTm9kZU5hbWVzLmhhcyhub2RlLm5hbWUpKTtcblxuICByZXR1cm4gZmlsdGVyZWRPcmRlcmVkTm9kZXM7XG59XG5cbmNsYXNzIE5vZGVzRXhlY3V0aW9uT3JkZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgc3VwZXIoYE5vZGVzRXhlY3V0aW9uT3JkZXJFcnJvcjogJHttZXNzYWdlfWApO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBvZiBgZ2V0Tm9kZXNJblRvcG9sb2dpY2FsT3JkZXJgLlxuICogVmFsaWRhdGVzIHByb3BlcnR5OiBnaXZlbiBub2RlcyBgYWAgYW5kIGBiYCwgT3JkZXIoYSkgPiBPcmRlcihiKSBpZiBgYWBcbiAqIGlzIGEgY2hpbGQgb2YgYGJgLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBhbiBlcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICpcbiAqIEBwYXJhbSBvcmRlcmVkTm9kZXMgR3JhcGggbm9kZXMgaW4gZXhlY3V0aW9uIG9yZGVyLlxuICogQHBhcmFtIHByZWRlZmluZWROb2RlcyBHcmFwaCBpbnB1dHMsIHdlaWdodHMsIGFuZCBpbml0IG5vZGVzLiBOb2RlcyBpbiB0aGlzXG4gKiAgICAgbGlzdCBtdXN0IGhhdmUgZGlzdGluY3QgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTm9kZXNFeGVjdXRpb25PcmRlcihcbiAgICBvcmRlcmVkTm9kZXM6IE5vZGVbXSwgcHJlZGVmaW5lZE5vZGVzOiBOb2RlW10pIHtcbiAgY29uc3Qgbm9kZU5hbWVUb09yZGVyID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oXG4gICAgICBvcmRlcmVkTm9kZXMubWFwKChub2RlLCBvcmRlcikgPT4gW25vZGUubmFtZSwgb3JkZXJdKSk7XG4gIGNvbnN0IHByZWRlZmluZWROb2RlTmFtZXMgPSBuZXcgU2V0KHByZWRlZmluZWROb2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUubmFtZSkpO1xuICBjb25zdCBpc1ByZWRlZmluZWQgPSAobm9kZTogTm9kZXxzdHJpbmcpID0+XG4gICAgICBwcmVkZWZpbmVkTm9kZU5hbWVzLmhhcyh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycgPyBub2RlIDogbm9kZS5uYW1lKTtcbiAgY29uc3Qgd2lsbEJlRXhlY3V0ZWROb2RlTmFtZXMgPVxuICAgICAgbmV3IFNldChvcmRlcmVkTm9kZXMubWFwKChub2RlKSA9PiBub2RlLm5hbWUpKTtcbiAgY29uc3Qgd2lsbEJlRXhlY3V0ZWQgPSAobm9kZTogTm9kZXxzdHJpbmcpID0+XG4gICAgICB3aWxsQmVFeGVjdXRlZE5vZGVOYW1lcy5oYXModHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnID8gbm9kZSA6IG5vZGUubmFtZSk7XG5cbiAgZm9yIChjb25zdCBub2RlIG9mIG9yZGVyZWROb2Rlcykge1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbi5maWx0ZXIod2lsbEJlRXhlY3V0ZWQpKSB7XG4gICAgICBpZiAoIW5vZGVOYW1lVG9PcmRlci5oYXMoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vZGVzRXhlY3V0aW9uT3JkZXJFcnJvcihcbiAgICAgICAgICAgIGBDaGlsZCAke2NoaWxkLm5hbWV9IG9mIG5vZGUgJHtub2RlLm5hbWV9IGlzIHVucmVhY2hhYmxlLmApO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGVOYW1lVG9PcmRlci5nZXQobm9kZS5uYW1lKSA+IG5vZGVOYW1lVG9PcmRlci5nZXQoY2hpbGQubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vZGVzRXhlY3V0aW9uT3JkZXJFcnJvcihgTm9kZSAke1xuICAgICAgICAgICAgbm9kZS5uYW1lfSBpcyBzY2hlZHVsZWQgdG8gcnVuIGFmdGVyIGl0cyBjaGlsZCAke2NoaWxkLm5hbWV9LmApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzUHJlZGVmaW5lZChub2RlKSkge1xuICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiBub2RlLmlucHV0cykge1xuICAgICAgICBpZiAoIW5vZGVOYW1lVG9PcmRlci5oYXMoaW5wdXQubmFtZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTm9kZXNFeGVjdXRpb25PcmRlckVycm9yKFxuICAgICAgICAgICAgICBgSW5wdXQgJHtpbnB1dC5uYW1lfSBvZiBub2RlICR7bm9kZS5uYW1lfSBpcyB1bnJlYWNoYWJsZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZU5hbWVUb09yZGVyLmdldChpbnB1dC5uYW1lKSA+IG5vZGVOYW1lVG9PcmRlci5nZXQobm9kZS5uYW1lKSkge1xuICAgICAgICAgIHRocm93IG5ldyBOb2Rlc0V4ZWN1dGlvbk9yZGVyRXJyb3IoYE5vZGUgJHtcbiAgICAgICAgICAgICAgbm9kZS5uYW1lfSBpcyBzY2hlZHVsZWQgdG8gcnVuIGJlZm9yZSBpdHMgaW5wdXQgJHtpbnB1dC5uYW1lfS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBleGVjdXRpb24gaW5mbywgcmV0dXJuIGEgbWFwIGZyb20gbm9kZSBuYW1lIHRvIHRoZSBkaXNwb3NhYmxlXG4gKiBub2RlIG5hbWUgbGlzdCBhZnRlciBpdHMgZXhlY3V0aW9uLlxuICpcbiAqIEByZXR1cm5zIEEgbWFwIGZyb20gbm9kZSBuYW1lIHRvIGRpc3Bvc2FibGUgbm9kZXMgYWZ0ZXIgaXRzXG4gKiAgICAgZXhlY3V0aW9uLiBUaGF0IGlzLCBmb3IgYSBub2RlIGB4YCwgYG5vZGVMaXZlVW50aWxNYXBbeF1gIGluZGljYXRlc1xuICogICAgIGFsbCBub2RlcyB3aGljaCB0aGVpciBpbnRlcm1lZGlhdGUgdGVuc29ycyBzaG91bGQgYmUgZGlzcG9zZWQgYWZ0ZXIgYHhgXG4gKiAgICAgYmVpbmcgZXhlY3V0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlTGl2ZVVudGlsTWFwKG9yZGVyZWROb2RlczogTm9kZVtdKTogTWFwPHN0cmluZywgTm9kZVtdPiB7XG4gIGNvbnN0IG5vZGVOYW1lVG9PcmRlciA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KFxuICAgICAgb3JkZXJlZE5vZGVzLm1hcCgobm9kZSwgb3JkZXIpID0+IFtub2RlLm5hbWUsIG9yZGVyXSkpO1xuXG4gIGNvbnN0IElORl9MSUZFID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gIC8vIE1ha2UgY29udHJvbCBmbG93IG5vZGVzIChhbmQgY29uc2VxdWVudGx5IHRoZWlyIGRpcmVjdCBwYXJlbnRzKVxuICAvLyBsaXZlIGZvcmV2ZXIgc2luY2UgdGhleSdyZSB0cmlja3kgdG8gdHJhY2sgY29ycmVjdGx5LlxuICBjb25zdCBzZWxmTGlmZXNwYW5zID0gb3JkZXJlZE5vZGVzLm1hcChcbiAgICAgIChub2RlLCBub2RlT3JkZXIpID0+IGlzQ29udHJvbEZsb3cobm9kZSkgPyBJTkZfTElGRSA6IG5vZGVPcmRlcik7XG4gIGNvbnN0IGdldFNlbGZMaWZlU3BhbiA9IChub2RlOiBOb2RlKSA9PiB7XG4gICAgY29uc3Qgc2VsZkxpZmUgPSBzZWxmTGlmZXNwYW5zW25vZGVOYW1lVG9PcmRlci5nZXQobm9kZS5uYW1lKSFdO1xuICAgIGlmIChzZWxmTGlmZSA9PSBudWxsKSB7XG4gICAgICAvLyBJZiBub2RlVG9PcmRlciBkb2VzIG5vdCBjb250YWluIHRoZSBub2RlLCBpdCBpcyB1bnVzZWQgb3JcbiAgICAgIC8vIHVucmVhY2hhYmxlIGluIGdyYXBoLlxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZkxpZmU7XG4gIH07XG5cbiAgLy8gYGxpdmVVbnRpbFtpXWAgcG9pbnRzIHRvIHRoZSBsYXN0IG5vZGUgaW4gdGhlIGBvcmRlcmVkTm9kZXNgIGFycmF5IHRoYXRcbiAgLy8gbWF5IGRlcGVuZCBvbiB0ZW5zb3JzIGZyb20gbm9kZSBgaWAuIEl0IGluZGljYXRlcyB0aGF0IGFsbCB0aGVcbiAgLy8gaW50ZXJtZWRpYXRlIHRlbnNvcnMgZnJvbSBgb3JkZXJlZE5vZGVzW2ldYCBzaG91bGQgYmUgZGlzcG9zZWQgYWZ0ZXJcbiAgLy8gYG9yZGVyZWROb2Rlc1tsaXZlVW50aWxbaV1dYCBpcyBleGVjdXRlZC5cbiAgLy8gQSBub2RlIGxpdmVzIGxvbmcgZW5vdWdoIHRvIHBhc3Mgb24gaXRzIHRlbnNvcnMgdG8gaXRzIGNoaWxkcmVuLlxuICAvLyBJdCBsaXZlcyB1bnRpbCBhdCBsZWFzdCBgbWF4KG5vZGUncyBwb3NpdGlvbiwgY2hpbGRyZW4ncyBwb3NpdGlvbnMpYC5cbiAgY29uc3QgbGl2ZVVudGlsT3JkZXJzID0gb3JkZXJlZE5vZGVzLm1hcCgobm9kZSwgbm9kZU9yZGVyKSA9PiB7XG4gICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKGdldFNlbGZMaWZlU3BhbilcbiAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gTWF0aC5tYXgoYSwgYiksIHNlbGZMaWZlc3BhbnNbbm9kZU9yZGVyXSk7XG4gIH0pO1xuXG4gIC8vIGxpdmVVbnRpbE1hcDpcbiAgLy8gLSBLZXk6IE5hbWUgb2YgYSBub2RlIGB4YFxuICAvLyAtIFZhbHVlczogQWxsIG5vZGVzIHdob3NlIGludGVybWVkaWF0ZSB0ZW5zb3JzIHNob3VsZCBiZSBkaXNwb3NlZFxuICAvLyAgICAgICAgICAgYWZ0ZXIgYHhgIGlzIGV4ZWN1dGVkLlxuICBjb25zdCBsaXZlVW50aWxNYXAgPSBuZXcgTWFwPHN0cmluZywgTm9kZVtdPigpO1xuICBmb3IgKGxldCBub2RlT3JkZXIgPSAwOyBub2RlT3JkZXIgPCBvcmRlcmVkTm9kZXMubGVuZ3RoOyArK25vZGVPcmRlcikge1xuICAgIGNvbnN0IGxpdmVVbnRpbE9yZGVyID0gbGl2ZVVudGlsT3JkZXJzW25vZGVPcmRlcl07XG4gICAgaWYgKGxpdmVVbnRpbE9yZGVyID09PSBJTkZfTElGRSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBvcmRlcmVkTm9kZXNbbm9kZU9yZGVyXTtcbiAgICBjb25zdCBsaXZlVW50aWxOb2RlID0gb3JkZXJlZE5vZGVzW2xpdmVVbnRpbE9yZGVyXTtcbiAgICBpZiAoIWxpdmVVbnRpbE1hcC5oYXMobGl2ZVVudGlsTm9kZS5uYW1lKSkge1xuICAgICAgbGl2ZVVudGlsTWFwLnNldChsaXZlVW50aWxOb2RlLm5hbWUsIFtdKTtcbiAgICB9XG4gICAgbGl2ZVVudGlsTWFwLmdldChsaXZlVW50aWxOb2RlLm5hbWUpIS5wdXNoKG5vZGUpO1xuICB9XG4gIHJldHVybiBsaXZlVW50aWxNYXA7XG59XG5cbmNvbnN0IENPTlRST0xfRkxPV19PUFMgPSBuZXcgU2V0KFtcbiAgJ1N3aXRjaCcsICdNZXJnZScsICdFbnRlcicsICdFeGl0JywgJ05leHRJdGVyYXRpb24nLCAnU3RhdGVsZXNzSWYnLFxuICAnU3RhdGVsZXNzV2hpbGUnLCAnaWYnLCAnV2hpbGUnXG5dKTtcbmNvbnN0IERZTkFNSUNfU0hBUEVfT1BTID0gbmV3IFNldChbXG4gICdOb25NYXhTdXBwcmVzc2lvblYyJywgJ05vbk1heFN1cHByZXNzaW9uVjMnLCAnTm9uTWF4U3VwcHJlc3Npb25WNScsICdXaGVyZSdcbl0pO1xuY29uc3QgSEFTSF9UQUJMRV9PUFMgPSBuZXcgU2V0KFtcbiAgJ0hhc2hUYWJsZScsICdIYXNoVGFibGVWMicsICdMb29rdXBUYWJsZUltcG9ydCcsICdMb29rdXBUYWJsZUltcG9ydFYyJyxcbiAgJ0xvb2t1cFRhYmxlRmluZCcsICdMb29rdXBUYWJsZUZpbmRWMicsICdMb29rdXBUYWJsZVNpemUnLCAnTG9va3VwVGFibGVTaXplVjInXG5dKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29udHJvbEZsb3cobm9kZTogTm9kZSkge1xuICByZXR1cm4gQ09OVFJPTF9GTE9XX09QUy5oYXMobm9kZS5vcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0R5bmFtaWNTaGFwZShub2RlOiBOb2RlKSB7XG4gIHJldHVybiBEWU5BTUlDX1NIQVBFX09QUy5oYXMobm9kZS5vcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hhc2hUYWJsZShub2RlOiBOb2RlKSB7XG4gIHJldHVybiBIQVNIX1RBQkxFX09QUy5oYXMobm9kZS5vcCk7XG59XG4iXX0="],"names":["TensorList","id","this","idTensor","constructor","tensors","elementShape","elementDtype","maxNumElements","forEach","tensor","dtype","Error","shape","keep","scalar","copy","clearAndClose","keepIds","has","dispose","length","size","stack","numElements","outputElementShape","tidy","reshapedTensors","map","reshape","popBack","pop","kept","pushBack","push","resize","destTensorList","i","Math","min","getItem","elementIndex","setItem","gather","indices","slice","concat","t","fromTensor","tensorElementShape","tensorList","unstack","reserve","scatter","maxIndex","max","list","value","index","split","totalLength","cumulativeLengths","len","shapeWithoutFirstDim","elementPerRow","sizes","TensorArray","name","maxSize","identicalElementShapes","dynamicSize","clearAfterRead","closed_","closed","read","tensorWithState","cleared","readMany","write","written","writeMany","assertShapesMatchAllowUndefinedSize","shapeA","shapeB","errorMessagePrefix","util","dim0","dim1","fullDefinedShape","some","dim","inferElementShape","listElementShape","partialShape","mergeElementShape","notfullDefinedShape","elementShapeA","elementShapeB","result","ResourceManager","hashTableNameToHandle","hashTableMap","addHashTable","hashTable","handle","getHashTableHandleByName","getHashTableById","key","getExecutionSubgraph","inputs","outputs","weightMap","initNodes","usedNodes","Set","missingInputs","dynamicNode","syncInputs","seen","inputNodeNames","Object","keys","initNodeNames","node","frontier","isControlFlow","isDynamicShape","isHashTable","children","child","filter","add","input","getNodesInTopologicalOrder","graph","executionInfo","inputNodes","nodes","isUsed","unique","Map","values","predefinedNodes","weights","allNodes","nameToNode","inCounts","Number","POSITIVE_INFINITY","entries","inCount","orderedNodeNames","nodeName","get","filteredOrderedNodes","orderedNodes","predefinedReachableNodeNames","filterPredefinedReachableNodes","nodeNameToOrder","order","predefinedNodeNames","isPredefined","willBeExecutedNodeNames","willBeExecuted","NodesExecutionOrderError","validateNodesExecutionOrder","message","super","getNodeLiveUntilMap","INF_LIFE","MAX_SAFE_INTEGER","selfLifespans","nodeOrder","getSelfLifeSpan","selfLife","liveUntilOrders","reduce","a","b","liveUntilMap","liveUntilOrder","liveUntilNode","set","CONTROL_FLOW_OPS","DYNAMIC_SHAPE_OPS","HASH_TABLE_OPS","op"],"sourceRoot":""}