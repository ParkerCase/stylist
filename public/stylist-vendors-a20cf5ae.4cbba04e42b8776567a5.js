"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[6926],{24853:function(t,e,s){s.d(e,{J:function(){return r}});var n=s(9495),i=s(45702);class r{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=(0,n.scalar)(0),this.tensorMap=new Map,(0,n.keep)(this.handle)}clearAndClose(){this.tensorMap.forEach((t=>t.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return i.d(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);const s=await t.data();return this.tensorMap.forEach((t=>t.dispose())),this.tensorMap.clear(),(0,n.tidy)((()=>{const t=(0,n.unstack)(e),i=s.length,r=t.length;n.util.assert(i===r,(()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${r} elements.`));for(let e=0;e<i;e++){const i=s[e],r=t[e];(0,n.keep)(r),this.tensorMap.set(i,r)}return this.handle}))}async find(t,e){this.checkKeyAndValueTensor(t,e);const s=await t.data();return(0,n.tidy)((()=>{const t=[];for(let n=0;n<s.length;n++){const i=s[n],r=this.findWithDefault(i,e);t.push(r)}return(0,n.stack)(t)}))}findWithDefault(t,e){const s=this.tensorMap.get(t);return null!=s?s:e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}},85577:function(t,e,s){s.d(e,{ox:function(){return g}});var n=s(9495),i=s(18520),r=s(6439),o=s(79856);class a{constructor(t={},e={},s={},n={},i){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=s,this.functionMap=n,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const s=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(s))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map((t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`)).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}var h=s(96454);class u{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map((e=>t[e].map((t=>t.id))));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((t=>t.signatureKey||t.name))}get outputNodes(){return this._outputs.map((t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e}))}get functions(){return Object.keys(this._functions).reduce(((t,e)=>(t[e]=this._functions[e].signature,t)),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach((e=>{this._functionExecutorMap[e]=new u(t.functions[e],this)}))}getCompilationKey(t,e){const s=t.map((t=>t.name)).sort(),n=e.map((t=>t.name)).sort();return s.join(this.SEPARATOR)+"--"+n.join(this.SEPARATOR)}compile(t,e){const s=(0,h.r7)(t,e,this.weightMap,this._initNodes),{missingInputs:n,dynamicNode:i,syncInputs:r}=s;if(null!=i)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${r}]`);if(n.length>0){const s=e.map((t=>t.name)),i=Object.keys(t);throw new Error(`Cannot compute the outputs [${s}] from the provided inputs [${i}]. Missing the following inputs: [${n}]`)}const o=(0,h.I)(this.graph,s);return{orderedNodes:o,nodeLiveUntilMap:(0,h.n8)(o)}}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return(0,n.keep)(e),e}cloneTensorList(t){if(!t)return null;return t.map((t=>this.cloneAndKeepTensor(t)))}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map((([t,e])=>[t,this.cloneTensorList(e)])))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const s=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const i=s.map((t=>this.graph.nodes[(0,r.Xi)(t)[0]])),h=e.map((t=>(0,r.Xi)(t)[0])),u=new Set(h);let c=h.map((t=>this.graph.nodes[t]));0===c.length&&(c=this._outputs);const d=this.getCompilationKey(i,c);let p=this.compiledMap.get(d);null==p&&(p=this.compile(t,c),this.compiledMap.set(d,p));try{this.keepIntermediateTensors=(0,n.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(g){this.keepIntermediateTensors=!1}const l={},m={};return(0,n.tidy)((()=>{const s=new a(this.weightMap,l,m,this.functionExecutorMap,this.parseNodeNameCache),i=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach((e=>{const[n,o]=(0,r.Xi)(e,s),a=[];a[o]=t[e],i[n]=a,this.keepIntermediateTensors&&(this.clonedTensorsMap[n]=this.cloneTensorList(a))}));const h=this.getFrozenTensorIds(i),{orderedNodes:c,nodeLiveUntilMap:d}=p;for(const t of c){if(i[t.name])continue;const e=(0,o.j)(t,i,s,this._resourceManager);if(n.util.isPromise(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);i[t.name]=e,this.keepIntermediateTensors&&(this.clonedTensorsMap[t.name]=this.cloneTensorList(e)),this.checkTensorForDisposalWithNodeLiveUntilInfo(t,i,s,h,u,d.get(t.name))}return null==this.parent&&s.dispose(h),e.map((t=>(0,r.cS)(t,i,s)))}))}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map((e=>t[e])).map((t=>t.map((t=>t.id)))));return new Set(e)}checkTensorForDisposal(t,e,s,n,i,o,a){if(!(0,h.Uy)(e)&&!o.has(t)){for(const n of s[t])null!=n&&(a[n.id]=(a[n.id]||0)+e.children.length);for(const t of e.inputs){if((0,h.Uy)(t))continue;const e=(0,r.cI)(t.name,s,n);if(null!=e)for(const t of e){if(!t||t.kept||i.has(t.id))continue;const e=a[t.id];1===e?(t.dispose(),delete a[t.id]):null!=e&&a[t.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,s,n,i,o){function a(t){return(0,h.Uy)(t)||i.has(t.name)}if(!(0,h.Uy)(t)&&null!=o)for(const h of o){if(a(h))continue;const t=(0,r.cI)(h.name,e,s);for(const e of t)!e||e.kept||n.has(e.id)||e.dispose()}}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,e,s=!1,i={},o={}){this.disposeIntermediateTensors(),s||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepIntermediateTensors=(0,n.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1}const h=new a(this.weightMap,i,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const u=await this.executeWithControlFlow(t,h,e,s),c=e.map((t=>(0,r.cS)(t,u,h))),d=c.map((t=>t.id)),p=Object.keys(t).map((e=>t[e].id)),l=new Set([...d,...p,...this.weightIds]);return Object.values(u).forEach((t=>{t.forEach((t=>{!t||t.isDisposed||l.has(t.id)||t.dispose()}))})),null==this.parent&&h.dispose(l),c}async executeFunctionAsync(t,e,s){const n=t.reduce(((t,e,s)=>(t[this.inputs[s].name]=e,t)),{});return this._executeAsync(n,this.outputNodes,!0,e,s)}async executeWithControlFlow(t,e,s,n){const i=Object.keys(t),o=i.map((t=>this.graph.nodes[(0,r.Xi)(t)[0]])),a=s.map((t=>(0,r.Xi)(t)[0])),u=new Set(a);let c=a.map((t=>this.graph.nodes[t]));0===c.length&&(c=this._outputs);const{usedNodes:d,missingInputs:p,dynamicNode:l,syncInputs:m}=(0,h.r7)(t,c,this.weightMap,this._initNodes),g=[...o,...this.graph.weights,...this._initNodes||[]].map((t=>({node:t,contexts:e.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(t).forEach((e=>{const[s,n]=(0,r.Xi)(e),i=[];i[n]=t[e],f[s]=i}));const y={},I=this.getFrozenTensorIds(f),x={};for(;g.length>0;){const t=this.processStack(o,g,e,f,x,I,u,y,d);await Promise.all(t)}const w=c.filter((t=>!(0,h.Uy)(t)&&!(0,r.cS)(t.name,f,e))).map((t=>t.name));if(w.length>0){let t="";throw null!=l&&(t=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${i}]. Consider providing the following inputs: [${p}]. ${t}`)}return f}processStack(t,e,s,i,a,h,u,c,d){const p=[];for(;e.length>0;){const t=e.pop();s.currentContext=t.contexts;let l="";if("Enter"===t.node.op&&(0,r.Zg)("isConstant",t.node,i,s)&&([l]=(0,r.lz)(t.node.name,s)),null==i[t.node.name]){const m=(0,o.j)(t.node,i,s,this._resourceManager);l||([l]=(0,r.lz)(t.node.name,s));const g=s.currentContext;n.util.isPromise(m)?p.push(m.then((n=>(i[l]=n,this.keepIntermediateTensors&&(this.clonedTensorsMap[l]=this.cloneTensorList(n)),s.currentContext=g,this.checkTensorForDisposal(l,t.node,i,s,h,u,c),this.processChildNodes(t.node,e,s,i,a,d),n)))):(i[l]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[l]=this.cloneTensorList(m)),this.checkTensorForDisposal(l,t.node,i,s,h,u,c),this.processChildNodes(t.node,e,s,i,a,d))}else this.processChildNodes(t.node,e,s,i,a,d)}return p}processChildNodes(t,e,s,n,i,o){t.children.forEach((t=>{const[a]=(0,r.lz)(t.name,s);!i[a]&&o.has(t.name)&&("Merge"===t.op?t.inputNames.some((t=>!!(0,r.cS)(t,n,s)))&&(i[a]=!0,e.push({contexts:s.currentContext,node:t})):t.inputNames.every((t=>!!(0,r.cS)(t,n,s)))&&(i[a]=!0,e.push({contexts:s.currentContext,node:t})))}))}dispose(){Object.keys(this.weightMap).forEach((t=>this.weightMap[t].forEach((t=>t.dispose()))))}checkInputShapeAndType(t){Object.keys(t).forEach((e=>{const s=t[e],[i]=(0,r.Xi)(e),o=this.graph.nodes[i];if(o.attrParams.shape&&o.attrParams.shape.value){const t=o.attrParams.shape.value,e=t.length===s.shape.length&&s.shape.every(((e,s)=>-1===t[s]||t[s]===e));n.util.assert(e,(()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${t}], but was [${s.shape}]`))}o.attrParams.dtype&&o.attrParams.dtype.value&&n.util.assert(s.dtype===o.attrParams.dtype.value,(()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${s.dtype}`))}))}mapInputs(t){var e,s;const n={};for(const i in t){const r=null===(s=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===s?void 0:s[i];null!=r?n[r.name]=t[i]:n[i]=t[i]}return n}checkInputs(t){const e=Object.keys(t).filter((t=>{const[e]=(0,r.Xi)(t);return null==this.graph.nodes[e]}));if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map((t=>{var e,s;const n=null===(s=null===(e=this._signature)||void 0===e?void 0:e.outputs)||void 0===s?void 0:s[t];return null!=n?n.name:t}),{})}checkOutputs(t){t.forEach((t=>{const[e]=(0,r.Xi)(t);if(!this.graph.nodes[e])throw new Error(`The output '${t}' is not found in the graph`)}))}}var c=s(88154),d=s(77084);const p="?tfjs-format=file",l="model.json";class m{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},s=n.io){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=s,null==e&&(this.loadOptions={}),this.resourceManager=new c.Q}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return n.util.isPromise(t)?t.then((t=>null==t.getWeightStream?this.loadSync(t):this.loadStreaming(t))):this.loadSync(t)}loadSync(t){const e=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,e)}async loadStreaming(t){if(null==t.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const e=await(0,d.s5)(t.getWeightStream(),t.weightSpecs);return this.loadWithWeightMap(t,e)}loadWithWeightMap(t,e){this.artifacts=t;const s=this.artifacts.modelTopology;let n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const t=this.artifacts.userDefinedMetadata;null!=t.signature&&(n=t.signature),null!=t.structuredOutputKeys&&(this.structuredOutputKeys=t.structuredOutputKeys)}if(this.signature=n,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new u(i.bo.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(e),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const e=i.bo.Instance.transformGraph(t.modelInitializer);this.initializer=new u(e),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,e){if("string"===typeof t){const e=this.io.getSaveHandlers(t);if(0===e.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new Error(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const e=t instanceof n.Tensor?[t]:t,s={};return e.forEach(((t,e)=>s[this.structuredOutputKeys[e]]=t)),s}return t}predict(t,e){const s=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(t,e){const s=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(t){var e;if(!(t instanceof n.Tensor)&&!Array.isArray(t)){const s=null===(e=this.signature)||void 0===e?void 0:e.inputs;if(null!=s)for(const e in s){const n=s[e];null!=n.resourceId&&(t[e]=this.resourceIdToCapturedInput[n.resourceId])}return t}t=Array.isArray(t)?t:[t];const s=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${t.length} input tensors provided.`);let i=0;return this.inputNodes.reduce(((e,s)=>{var n,r,o;const a=null===(o=null===(r=null===(n=this.signature)||void 0===n?void 0:n.inputs)||void 0===r?void 0:r[s])||void 0===o?void 0:o.resourceId;return e[s]=null!=a?this.resourceIdToCapturedInput[a]:t[i++],e}),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,s=Object.keys(e);for(let n=0;n<s.length;n++){const i=e[s[n]];this.resourceIdToCapturedInput[i.resourceId]=t[n]}}}execute(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const s=this.executor.execute(t,e);return s.length>1?s:s[0]}async executeAsync(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const s=await this.executor.executeAsync(t,e);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce(((e,s)=>(e[s]=[t[s]],e)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,n.dispose)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function g(t,e={},s=n.io){if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==e&&(e={}),e.fromTFHub&&"string"===typeof t&&(t=function(t){t.endsWith("/")||(t+="/");return`${t}${l}${p}`}(t));const i=new m(t,e,s);return await i.load(),i}}}]);
//# sourceMappingURL=stylist-vendors-a20cf5ae.4cbba04e42b8776567a5.js.map