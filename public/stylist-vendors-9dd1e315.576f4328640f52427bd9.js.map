{"version":3,"file":"stylist-vendors-9dd1e315.576f4328640f52427bd9.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/tensor_util_env.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/tensor_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/test_util.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/tensor_format.js","webpack://StylistWidget/./node_modules/@tensorflow/tfjs-core/dist/tensor.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from './engine';\nimport { env } from './environment';\nimport { Tensor } from './tensor';\nimport { assert, flatten, inferDtype, isTypedArray, toTypedArray } from './util';\nexport function inferShape(val, dtype) {\n    let firstElem = val;\n    if (isTypedArray(val)) {\n        return dtype === 'string' ? [] : [val.length];\n    }\n    if (!Array.isArray(val)) {\n        return []; // Scalar.\n    }\n    const shape = [];\n    while (Array.isArray(firstElem) ||\n        isTypedArray(firstElem) && dtype !== 'string') {\n        shape.push(firstElem.length);\n        firstElem = firstElem[0];\n    }\n    if (Array.isArray(val) &&\n        env().getBool('TENSORLIKE_CHECK_SHAPE_CONSISTENCY')) {\n        deepAssertShapeConsistency(val, shape, []);\n    }\n    return shape;\n}\nfunction deepAssertShapeConsistency(val, shape, indices) {\n    indices = indices || [];\n    if (!(Array.isArray(val)) && !isTypedArray(val)) {\n        assert(shape.length === 0, () => `Element arr[${indices.join('][')}] is a primitive, ` +\n            `but should be an array/TypedArray of ${shape[0]} elements`);\n        return;\n    }\n    assert(shape.length > 0, () => `Element arr[${indices.join('][')}] should be a primitive, ` +\n        `but is an array of ${val.length} elements`);\n    assert(val.length === shape[0], () => `Element arr[${indices.join('][')}] should have ${shape[0]} ` +\n        `elements, but has ${val.length} elements`);\n    const subShape = shape.slice(1);\n    for (let i = 0; i < val.length; ++i) {\n        deepAssertShapeConsistency(val[i], subShape, indices.concat(i));\n    }\n}\nfunction assertDtype(expectedDtype, actualDType, argName, functionName) {\n    if (expectedDtype === 'string_or_numeric') {\n        return;\n    }\n    if (expectedDtype == null) {\n        throw new Error(`Expected dtype cannot be null.`);\n    }\n    if (expectedDtype !== 'numeric' && expectedDtype !== actualDType ||\n        expectedDtype === 'numeric' && actualDType === 'string') {\n        throw new Error(`Argument '${argName}' passed to '${functionName}' must ` +\n            `be ${expectedDtype} tensor, but got ${actualDType} tensor`);\n    }\n}\nexport function convertToTensor(x, argName, functionName, parseAsDtype = 'numeric') {\n    if (x instanceof Tensor) {\n        assertDtype(parseAsDtype, x.dtype, argName, functionName);\n        return x;\n    }\n    let inferredDtype = inferDtype(x);\n    // If the user expects a bool/int/float, use that info to update the\n    // inferredDtype when it is not a string.\n    if (inferredDtype !== 'string' &&\n        ['bool', 'int32', 'float32'].indexOf(parseAsDtype) >= 0) {\n        inferredDtype = parseAsDtype;\n    }\n    assertDtype(parseAsDtype, inferredDtype, argName, functionName);\n    if ((x == null) ||\n        (!isTypedArray(x) && !Array.isArray(x) && typeof x !== 'number' &&\n            typeof x !== 'boolean' && typeof x !== 'string')) {\n        const type = x == null ? 'null' : x.constructor.name;\n        throw new Error(`Argument '${argName}' passed to '${functionName}' must be a ` +\n            `Tensor or TensorLike, but got '${type}'`);\n    }\n    const inferredShape = inferShape(x, inferredDtype);\n    if (!isTypedArray(x) && !Array.isArray(x)) {\n        x = [x];\n    }\n    const skipTypedArray = true;\n    const values = inferredDtype !== 'string' ?\n        toTypedArray(x, inferredDtype) :\n        flatten(x, [], skipTypedArray);\n    return ENGINE.makeTensor(values, inferredShape, inferredDtype);\n}\nexport function convertToTensorArray(arg, argName, functionName, parseAsDtype = 'numeric') {\n    if (!Array.isArray(arg)) {\n        throw new Error(`Argument ${argName} passed to ${functionName} must be a ` +\n            '`Tensor[]` or `TensorLike[]`');\n    }\n    const tensors = arg;\n    return tensors.map((t, i) => convertToTensor(t, `${argName}[${i}]`, functionName, parseAsDtype));\n}\n//# sourceMappingURL=tensor_util_env.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Tensor } from './tensor';\nimport { upcastType } from './types';\nimport { assert } from './util';\nexport function makeTypesMatch(a, b) {\n    if (a.dtype === b.dtype) {\n        return [a, b];\n    }\n    const dtype = upcastType(a.dtype, b.dtype);\n    return [a.cast(dtype), b.cast(dtype)];\n}\nexport function assertTypesMatch(a, b) {\n    assert(a.dtype === b.dtype, () => `The dtypes of the first(${a.dtype}) and` +\n        ` second(${b.dtype}) input must match`);\n}\nexport function isTensorInList(tensor, tensorList) {\n    return tensorList.some(x => x.id === tensor.id);\n}\n/**\n * Extracts any `Tensor`s found within the provided object.\n *\n * @param container an object that may be a `Tensor` or may directly contain\n *   `Tensor`s, such as a `Tensor[]` or `{key: Tensor, ...}`. In general it\n *   is safe to pass any object here, except that `Promise`s are not\n *   supported.\n * @returns An array of `Tensors` found within the passed object. If the\n *   argument is simply a `Tensor', a list containing that `Tensor` is\n *   returned. If the object is not a `Tensor` or does not\n *   contain `Tensors`, an empty list is returned.\n */\nexport function getTensorsInContainer(result) {\n    const list = [];\n    const seen = new Set();\n    walkTensorContainer(result, list, seen);\n    return list;\n}\nfunction walkTensorContainer(container, list, seen) {\n    if (container == null) {\n        return;\n    }\n    if (container instanceof Tensor) {\n        list.push(container);\n        return;\n    }\n    if (!isIterable(container)) {\n        return;\n    }\n    // Iteration over keys works also for arrays.\n    const iterable = container;\n    for (const k in iterable) {\n        const val = iterable[k];\n        if (!seen.has(val)) {\n            seen.add(val);\n            walkTensorContainer(val, list, seen);\n        }\n    }\n}\n// tslint:disable-next-line:no-any\nfunction isIterable(obj) {\n    return Array.isArray(obj) || typeof obj === 'object';\n}\n//# sourceMappingURL=tensor_util.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from './engine';\nimport { inferShape } from './tensor_util_env';\nimport { arraysEqual, encodeString, flatten, isString, isTypedArray } from './util';\nconst TEST_EPSILON_FLOAT32 = 1e-3;\nexport const TEST_EPSILON_FLOAT16 = 1e-1;\nexport function expectArraysClose(actual, expected, epsilon) {\n    if (epsilon == null) {\n        epsilon = testEpsilon();\n    }\n    return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, epsilon));\n}\nexport function testEpsilon() {\n    return ENGINE.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 :\n        TEST_EPSILON_FLOAT16;\n}\nfunction expectArraysPredicate(actual, expected, predicate) {\n    let checkClassType = true;\n    if (isTypedArray(actual) || isTypedArray(expected)) {\n        checkClassType = false;\n    }\n    if (isTypedArray(actual) && isTypedArray(expected)) {\n        checkClassType = true;\n    }\n    if (checkClassType) {\n        const aType = actual.constructor.name;\n        const bType = expected.constructor.name;\n        if (aType !== bType) {\n            throw new Error(`Arrays are of different type. Actual: ${aType}. ` +\n                `Expected: ${bType}`);\n        }\n    }\n    if (Array.isArray(actual) && Array.isArray(expected)) {\n        const actualShape = inferShape(actual);\n        const expectedShape = inferShape(expected);\n        if (!arraysEqual(actualShape, expectedShape)) {\n            throw new Error(`Arrays have different shapes. ` +\n                `Actual: [${actualShape}]. Expected: [${expectedShape}]`);\n        }\n    }\n    const actualFlat = isTypedArray(actual) ? actual : flatten(actual);\n    const expectedFlat = isTypedArray(expected) ?\n        expected :\n        flatten(expected);\n    if (actualFlat.length !== expectedFlat.length) {\n        throw new Error(`Arrays have different lengths actual: ${actualFlat.length} vs ` +\n            `expected: ${expectedFlat.length}.\\n` +\n            `Actual:   ${actualFlat}.\\n` +\n            `Expected: ${expectedFlat}.`);\n    }\n    for (let i = 0; i < expectedFlat.length; ++i) {\n        const a = actualFlat[i];\n        const e = expectedFlat[i];\n        if (!predicate(a, e)) {\n            throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${e}.\\n` +\n                `Actual:   ${actualFlat}.\\n` +\n                `Expected: ${expectedFlat}.`);\n        }\n    }\n}\nexport function expectPromiseToFail(fn, done) {\n    fn().then(() => done.fail(), () => done());\n}\nexport function expectArraysEqual(actual, expected) {\n    const exp = typeof expected === 'string' || typeof expected === 'number' ||\n        typeof expected === 'boolean' ?\n        [expected] :\n        expected;\n    if (isString(actual) || isString(actual[0]) ||\n        isString(expected) || isString(expected[0])) {\n        // tslint:disable-next-line: triple-equals\n        return expectArraysPredicate(actual, exp, (a, b) => a == b);\n    }\n    return expectArraysPredicate(actual, expected, (a, b) => areClose(a, b, 0));\n}\nexport function expectNumbersClose(a, e, epsilon) {\n    if (epsilon == null) {\n        epsilon = testEpsilon();\n    }\n    if (!areClose(a, e, epsilon)) {\n        throw new Error(`Numbers differ: actual === ${a}, expected === ${e}`);\n    }\n}\nfunction areClose(a, e, epsilon) {\n    if (!isFinite(a) && !isFinite(e)) {\n        return true;\n    }\n    if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {\n        return false;\n    }\n    return true;\n}\nexport function expectValuesInRange(actual, low, high) {\n    for (let i = 0; i < actual.length; i++) {\n        if (actual[i] < low || actual[i] > high) {\n            throw new Error(`Value out of range:${actual[i]} low: ${low}, high: ${high}`);\n        }\n    }\n}\nexport function expectArrayBuffersEqual(actual, expected) {\n    // Safari & Jasmine don't like comparing ArrayBuffers directly. Wrapping in\n    // a Float32Array solves this issue.\n    expect(new Float32Array(actual)).toEqual(new Float32Array(expected));\n}\n/** Encodes strings into utf-8 bytes. */\nexport function encodeStrings(a) {\n    for (let i = 0; i < a.length; i++) {\n        const val = a[i];\n        if (Array.isArray(val)) {\n            encodeStrings(val);\n        }\n        else {\n            a[i] = encodeString(val);\n        }\n    }\n    return a;\n}\n//# sourceMappingURL=test_util.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util';\n// Maximum number of values before we decide to show ellipsis.\nconst FORMAT_LIMIT_NUM_VALS = 20;\n// Number of first and last values to show when displaying a, b,...,y, z.\nconst FORMAT_NUM_FIRST_LAST_VALS = 3;\n// Number of significant digits to show.\nconst FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n    const strides = computeStrides(shape);\n    const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n    const rank = shape.length;\n    const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n    const lines = ['Tensor'];\n    if (verbose) {\n        lines.push(`  dtype: ${dtype}`);\n        lines.push(`  rank: ${rank}`);\n        lines.push(`  shape: [${shape}]`);\n        lines.push(`  values:`);\n    }\n    lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n    return lines.join('\\n');\n}\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n    const n = sizeFromShape(shape);\n    const numCols = strides[strides.length - 1];\n    const padPerCol = new Array(numCols).fill(0);\n    const rank = shape.length;\n    const valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n    if (rank > 1) {\n        for (let row = 0; row < n / numCols; row++) {\n            const offset = row * numCols;\n            for (let j = 0; j < numCols; j++) {\n                padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n            }\n        }\n    }\n    return padPerCol;\n}\nfunction valToString(val, pad, dtype) {\n    let valStr;\n    if (Array.isArray(val)) {\n        valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` +\n            `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n    }\n    else if (isString(val)) {\n        valStr = `'${val}'`;\n    }\n    else if (dtype === 'bool') {\n        valStr = boolNumToString(val);\n    }\n    else {\n        valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n    }\n    return rightPad(valStr, pad);\n}\nfunction boolNumToString(v) {\n    return v === 0 ? 'false' : 'true';\n}\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {\n    const storagePerElement = dtype === 'complex64' ? 2 : 1;\n    const size = shape[0];\n    const rank = shape.length;\n    if (rank === 0) {\n        if (dtype === 'complex64') {\n            const complexTuple = createComplexTuples(vals);\n            return [valToString(complexTuple[0], 0, dtype)];\n        }\n        if (dtype === 'bool') {\n            return [boolNumToString(vals[0])];\n        }\n        return [vals[0].toString()];\n    }\n    if (rank === 1) {\n        if (size > FORMAT_LIMIT_NUM_VALS) {\n            const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n            let firstVals = Array.from(vals.slice(0, firstValsSize));\n            let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n            if (dtype === 'complex64') {\n                firstVals = createComplexTuples(firstVals);\n                lastVals = createComplexTuples(lastVals);\n            }\n            return [\n                '[' +\n                    firstVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                        .join(', ') +\n                    ', ..., ' +\n                    lastVals\n                        .map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype))\n                        .join(', ') +\n                    ']'\n            ];\n        }\n        const displayVals = dtype === 'complex64' ? createComplexTuples(vals) :\n            Array.from(vals);\n        return [\n            '[' +\n                displayVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n                    .join(', ') +\n                ']'\n        ];\n    }\n    // The array is rank 2 or more.\n    const subshape = shape.slice(1);\n    const substrides = strides.slice(1);\n    const stride = strides[0] * storagePerElement;\n    const lines = [];\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n        for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false /* isLast */));\n        }\n        lines.push('...');\n        for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    else {\n        for (let i = 0; i < size; i++) {\n            const start = i * stride;\n            const end = start + stride;\n            lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n        }\n    }\n    const sep = rank === 2 ? ',' : '';\n    lines[0] = '[' + lines[0] + sep;\n    for (let i = 1; i < lines.length - 1; i++) {\n        lines[i] = ' ' + lines[i] + sep;\n    }\n    let newLineSep = ',\\n';\n    for (let i = 2; i < rank; i++) {\n        newLineSep += '\\n';\n    }\n    lines[lines.length - 1] =\n        ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n    return lines;\n}\nfunction createComplexTuples(vals) {\n    const complexTuples = [];\n    for (let i = 0; i < vals.length; i += 2) {\n        complexTuples.push([vals[i], vals[i + 1]]);\n    }\n    return complexTuples;\n}\n//# sourceMappingURL=tensor_format.js.map","/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getGlobal } from './global_util';\nimport { tensorToString } from './tensor_format';\nimport * as util from './util';\nimport { computeStrides, toNestedArray } from './util';\n/**\n * A mutable object, similar to `tf.Tensor`, that allows users to set values\n * at locations before converting to an immutable `tf.Tensor`.\n *\n * See `tf.buffer` for creating a tensor buffer.\n *\n * @doc {heading: 'Tensors', subheading: 'Classes'}\n */\nexport class TensorBuffer {\n    constructor(shape, dtype, values) {\n        this.dtype = dtype;\n        this.shape = shape.slice();\n        this.size = util.sizeFromShape(shape);\n        if (values != null) {\n            const n = values.length;\n            util.assert(n === this.size, () => `Length of values '${n}' does not match the size ` +\n                `inferred by the shape '${this.size}'.`);\n        }\n        if (dtype === 'complex64') {\n            throw new Error(`complex64 dtype TensorBuffers are not supported. Please create ` +\n                `a TensorBuffer for the real and imaginary parts separately and ` +\n                `call tf.complex(real, imag).`);\n        }\n        this.values = values || util.getArrayFromDType(dtype, this.size);\n        this.strides = computeStrides(shape);\n    }\n    /**\n     * Sets a value in the buffer at a given location.\n     *\n     * @param value The value to set.\n     * @param locs  The location indices.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Creation'}\n     */\n    set(value, ...locs) {\n        if (locs.length === 0) {\n            locs = [0];\n        }\n        util.assert(locs.length === this.rank, () => `The number of provided coordinates (${locs.length}) must ` +\n            `match the rank (${this.rank})`);\n        const index = this.locToIndex(locs);\n        this.values[index] = value;\n    }\n    /**\n     * Returns the value in the buffer at the provided location.\n     *\n     * @param locs The location indices.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Creation'}\n     */\n    get(...locs) {\n        if (locs.length === 0) {\n            locs = [0];\n        }\n        let i = 0;\n        for (const loc of locs) {\n            if (loc < 0 || loc >= this.shape[i]) {\n                const msg = `Requested out of range element at ${locs}. ` +\n                    `  Buffer shape=${this.shape}`;\n                throw new Error(msg);\n            }\n            i++;\n        }\n        let index = locs[locs.length - 1];\n        for (let i = 0; i < locs.length - 1; ++i) {\n            index += this.strides[i] * locs[i];\n        }\n        return this.values[index];\n    }\n    locToIndex(locs) {\n        if (this.rank === 0) {\n            return 0;\n        }\n        else if (this.rank === 1) {\n            return locs[0];\n        }\n        let index = locs[locs.length - 1];\n        for (let i = 0; i < locs.length - 1; ++i) {\n            index += this.strides[i] * locs[i];\n        }\n        return index;\n    }\n    indexToLoc(index) {\n        if (this.rank === 0) {\n            return [];\n        }\n        else if (this.rank === 1) {\n            return [index];\n        }\n        const locs = new Array(this.shape.length);\n        for (let i = 0; i < locs.length - 1; ++i) {\n            locs[i] = Math.floor(index / this.strides[i]);\n            index -= locs[i] * this.strides[i];\n        }\n        locs[locs.length - 1] = index;\n        return locs;\n    }\n    get rank() {\n        return this.shape.length;\n    }\n    /**\n     * Creates an immutable `tf.Tensor` object from the buffer.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Creation'}\n     */\n    toTensor() {\n        return trackerFn().makeTensor(this.values, this.shape, this.dtype);\n    }\n}\n// For tracking tensor creation and disposal.\nlet trackerFn = null;\n// Used by chaining methods to call into ops.\nlet opHandler = null;\n// Used to warn about deprecated methods.\nlet deprecationWarningFn = null;\n// This here so that we can use this method on dev branches and keep the\n// functionality at master.\n// tslint:disable-next-line:no-unused-expression\n[deprecationWarningFn];\n/**\n * An external consumer can register itself as the tensor tracker. This way\n * the Tensor class can notify the tracker for every tensor created and\n * disposed.\n */\nexport function setTensorTracker(fn) {\n    trackerFn = fn;\n}\n/**\n * An external consumer can register itself as the op handler. This way the\n * Tensor class can have chaining methods that call into ops via the op\n * handler.\n */\nexport function setOpHandler(handler) {\n    opHandler = handler;\n}\n/**\n * Sets the deprecation warning function to be used by this file. This way the\n * Tensor class can be a leaf but still use the environment.\n */\nexport function setDeprecationWarningFn(fn) {\n    deprecationWarningFn = fn;\n}\n/**\n * A `tf.Tensor` object represents an immutable, multidimensional array of\n * numbers that has a shape and a data type.\n *\n * For performance reasons, functions that create tensors do not necessarily\n * perform a copy of the data passed to them (e.g. if the data is passed as a\n * `Float32Array`), and changes to the data will change the tensor. This is not\n * a feature and is not supported. To avoid this behavior, use the tensor before\n * changing the input data or create a copy with `copy = tf.add(yourTensor, 0)`.\n *\n * See `tf.tensor` for details on how to create a `tf.Tensor`.\n *\n * @doc {heading: 'Tensors', subheading: 'Classes'}\n */\nexport class Tensor {\n    constructor(shape, dtype, dataId, id) {\n        /** Whether this tensor has been globally kept. */\n        this.kept = false;\n        this.isDisposedInternal = false;\n        this.shape = shape.slice();\n        this.dtype = dtype || 'float32';\n        this.size = util.sizeFromShape(shape);\n        this.strides = computeStrides(shape);\n        this.dataId = dataId;\n        this.id = id;\n        this.rankType = (this.rank < 5 ? this.rank.toString() : 'higher');\n    }\n    get rank() {\n        return this.shape.length;\n    }\n    /**\n     * Returns a promise of `tf.TensorBuffer` that holds the underlying data.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    async buffer() {\n        const vals = await this.data();\n        return opHandler.buffer(this.shape, this.dtype, vals);\n    }\n    /**\n     * Returns a `tf.TensorBuffer` that holds the underlying data.\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    bufferSync() {\n        return opHandler.buffer(this.shape, this.dtype, this.dataSync());\n    }\n    /**\n     * Returns the tensor data as a nested array. The transfer of data is done\n     * asynchronously.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    async array() {\n        const vals = await this.data();\n        return toNestedArray(this.shape, vals, this.dtype === 'complex64');\n    }\n    /**\n     * Returns the tensor data as a nested array. The transfer of data is done\n     * synchronously.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    arraySync() {\n        return toNestedArray(this.shape, this.dataSync(), this.dtype === 'complex64');\n    }\n    /**\n     * Asynchronously downloads the values from the `tf.Tensor`. Returns a\n     * promise of `TypedArray` that resolves when the computation has finished.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    async data() {\n        this.throwIfDisposed();\n        const data = trackerFn().read(this.dataId);\n        if (this.dtype === 'string') {\n            const bytes = await data;\n            try {\n                return bytes.map(b => util.decodeString(b));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode the string bytes into utf-8. ' +\n                    'To get the original bytes, call tensor.bytes().');\n            }\n        }\n        return data;\n    }\n    /**\n     * Synchronously downloads the values from the `tf.Tensor`. This blocks the\n     * UI thread until the values are ready, which can cause performance issues.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    dataSync() {\n        this.throwIfDisposed();\n        const data = trackerFn().readSync(this.dataId);\n        if (this.dtype === 'string') {\n            try {\n                return data.map(b => util.decodeString(b));\n            }\n            catch (_a) {\n                throw new Error('Failed to decode the string bytes into utf-8. ' +\n                    'To get the original bytes, call tensor.bytes().');\n            }\n        }\n        return data;\n    }\n    /** Returns the underlying bytes of the tensor's data. */\n    async bytes() {\n        this.throwIfDisposed();\n        const data = await trackerFn().read(this.dataId);\n        if (this.dtype === 'string') {\n            return data;\n        }\n        else {\n            return new Uint8Array(data.buffer);\n        }\n    }\n    /**\n     * Disposes `tf.Tensor` from memory.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        trackerFn().disposeTensor(this);\n        this.isDisposedInternal = true;\n    }\n    get isDisposed() {\n        return this.isDisposedInternal;\n    }\n    throwIfDisposed() {\n        if (this.isDisposed) {\n            throw new Error(`Tensor is disposed.`);\n        }\n    }\n    /**\n     * Prints the `tf.Tensor`. See `tf.print` for details.\n     *\n     * @param verbose Whether to print verbose information about the tensor,\n     *    including dtype and size.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    print(verbose = false) {\n        return opHandler.print(this, verbose);\n    }\n    /**\n     * Returns a copy of the tensor. See `tf.clone` for details.\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    clone() {\n        this.throwIfDisposed();\n        return opHandler.clone(this);\n    }\n    /**\n     * Returns a human-readable description of the tensor. Useful for logging.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    toString(verbose = false) {\n        const vals = this.dataSync();\n        return tensorToString(vals, this.shape, this.dtype, verbose);\n    }\n    cast(dtype) {\n        this.throwIfDisposed();\n        return opHandler.cast(this, dtype);\n    }\n    variable(trainable = true, name, dtype) {\n        this.throwIfDisposed();\n        return trackerFn().makeVariable(this, trainable, name, dtype);\n    }\n}\nObject.defineProperty(Tensor, Symbol.hasInstance, {\n    value: (instance) => {\n        // Implementation note: we should use properties of the object that will be\n        // defined before the constructor body has finished executing (methods).\n        // This is because when this code is transpiled by babel, babel will call\n        // classCallCheck before the constructor body is run.\n        // See https://github.com/tensorflow/tfjs/issues/3384 for backstory.\n        return !!instance && instance.data != null && instance.dataSync != null &&\n            instance.throwIfDisposed != null;\n    }\n});\nexport function getGlobalTensorClass() {\n    // Use getGlobal so that we can augment the Tensor class across package\n    // boundaries becase the node resolution alg may result in different modules\n    // being returned for this file depending on the path they are loaded from.\n    return getGlobal('Tensor', () => {\n        return Tensor;\n    });\n}\n// Global side effect. Cache global reference to Tensor class\ngetGlobalTensorClass();\n/**\n * A mutable `tf.Tensor`, useful for persisting state, e.g. for training.\n *\n * @doc {heading: 'Tensors', subheading: 'Classes'}\n */\nexport class Variable extends Tensor {\n    constructor(initialValue, trainable, name, tensorId) {\n        super(initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);\n        this.trainable = trainable;\n        this.name = name;\n    }\n    /**\n     * Assign a new `tf.Tensor` to this variable. The new `tf.Tensor` must have\n     * the same shape and dtype as the old `tf.Tensor`.\n     *\n     * @param newValue New tensor to be assigned to this variable.\n     *\n     * @doc {heading: 'Tensors', subheading: 'Classes'}\n     */\n    assign(newValue) {\n        if (newValue.dtype !== this.dtype) {\n            throw new Error(`dtype of the new value (${newValue.dtype}) and ` +\n                `previous value (${this.dtype}) must match`);\n        }\n        if (!util.arraysEqual(newValue.shape, this.shape)) {\n            throw new Error(`shape of the new value (${newValue.shape}) and ` +\n                `previous value (${this.shape}) must match`);\n        }\n        trackerFn().disposeTensor(this);\n        this.dataId = newValue.dataId;\n        trackerFn().incRef(this, null /* backend */);\n    }\n    dispose() {\n        trackerFn().disposeVariable(this);\n        this.isDisposedInternal = true;\n    }\n}\nObject.defineProperty(Variable, Symbol.hasInstance, {\n    value: (instance) => {\n        return instance instanceof Tensor && instance.assign != null &&\n            instance.assign instanceof Function;\n    }\n});\n//# sourceMappingURL=tensor.js.map"],"names":["inferShape","val","dtype","firstElem","length","Array","isArray","shape","push","getBool","deepAssertShapeConsistency","indices","join","subShape","slice","i","concat","assertDtype","expectedDtype","actualDType","argName","functionName","Error","convertToTensor","x","parseAsDtype","inferredDtype","indexOf","type","constructor","name","inferredShape","values","toTypedArray","makeTensor","convertToTensorArray","arg","map","t","makeTypesMatch","a","b","cast","assertTypesMatch","isTensorInList","tensor","tensorList","some","id","getTensorsInContainer","result","list","walkTensorContainer","Set","container","seen","obj","iterable","k","has","add","TEST_EPSILON_FLOAT32","TEST_EPSILON_FLOAT16","expectArraysClose","actual","expected","epsilon","testEpsilon","expectArraysPredicate","areClose","backend","floatPrecision","predicate","checkClassType","aType","bType","actualShape","expectedShape","actualFlat","expectedFlat","e","expectPromiseToFail","fn","done","then","fail","expectArraysEqual","exp","expectNumbersClose","isFinite","isNaN","Math","abs","expectValuesInRange","low","high","expectArrayBuffersEqual","expect","Float32Array","toEqual","encodeStrings","encodeString","tensorToString","vals","verbose","strides","padPerCol","n","numCols","fill","rank","valuesOrTuples","createComplexTuples","row","offset","j","max","valToString","computeMaxSizePerColumn","valsLines","subTensorToString","lines","l","pad","valStr","parseFloat","toFixed","boolNumToString","toString","v","isLast","storagePerElement","size","firstValsSize","firstVals","from","lastVals","subshape","substrides","stride","start","end","sep","newLineSep","complexTuples","TensorBuffer","this","set","value","locs","index","locToIndex","get","loc","msg","indexToLoc","floor","toTensor","trackerFn","opHandler","deprecationWarningFn","setTensorTracker","setOpHandler","handler","setDeprecationWarningFn","Tensor","dataId","kept","isDisposedInternal","rankType","buffer","data","bufferSync","dataSync","array","arraySync","throwIfDisposed","read","bytes","util","decodeString","_a","readSync","Uint8Array","dispose","isDisposed","disposeTensor","print","clone","variable","trainable","makeVariable","getGlobalTensorClass","Object","defineProperty","Symbol","hasInstance","instance","Variable","initialValue","tensorId","super","assign","newValue","incRef","disposeVariable","Function"],"sourceRoot":""}