"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[4424],{45978:function(e,n,t){t.d(n,{RW:function(){return l},g7:function(){return f},oR:function(){return h}});var s=t(9495),i=t(15841),o=t(26235),a=t(44813),u=t(78825),r=t(79730);class l{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof l)for(const n in e.id2Value)this.id2Value[n]=e.id2Value[n],n in e.id2Mask&&(this.id2Mask[n]=e.id2Mask[n]);else{if(null==e)return;for(const n of e)this.add(n.key,n.value)}}add(e,n,t){if(null!=this.id2Value[e.id])throw new i.Qp(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,n){if(null==e.dtype||e.dtype===n.dtype)return n;try{return(0,s.cast)(n,e.dtype)}catch(t){throw new i.Qp(`The dtype of the feed (${n.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,n),this.name2Id[e.name]=e.id,null!=t&&(this.id2Mask[e.id]=t),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof r.Ar){if(null==this.id2Value[e.id])throw new i.Qp(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const n=this.name2Id[e];if(null==n)throw new i.Qp(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[n]}}getMask(e){if(e instanceof r.Ar){if(null==this.id2Value[e.id])throw new i.Qp(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const n=this.name2Id[e];if(null==n)throw new i.Qp(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[n]}}disposeMasks(){null!=this.id2Mask&&(0,s.dispose)(this.id2Mask)}}const d=new o.Q,c=new o.Q;function h(e){null!=d&&d.setMaxEntries(e),null!=c&&c.setMaxEntries(e)}function f(e,n,t,i){const o=null!=t&&t.training,r=Array.isArray(e),h=r?e:[e],f=h.map((e=>e.name)),k=[],g=n.names();for(const s of f)-1!==g.indexOf(s)?k.push(n.getValue(s)):k.push(null);null!=i&&(i.maxNumTensors=-1/0,i.minNumTensors=1/0);const w=f.join(",")+"|"+n.names().sort().join(",");let M,V=d.get(w);if(null==V){const e=function(e,n){s.util.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let t=[],i={};if(1===e.length){const s=m(e[0],n);t=s.sorted,i=s.recipientMap}else{const s=new Set;for(const o of e){const{sorted:e,recipientMap:a}=m(o,n);for(const n of e)s.has(n.name)||(t.push(n),s.add(n.name));for(const n in a)null==i[n]&&(i[n]=new Set),a[n].forEach((e=>i[n].add(e)))}}return{sorted:t,recipientCounts:p(i)}}(h,n);V=e.sorted,M=e.recipientCounts,d.put(w,V),c.put(w,M)}M={},o||Object.assign(M,c.get(w));const b=new l(n);for(let l=0;l<V.length;++l){if(null!=i){const e=(0,s.memory)().numTensors;e>i.maxNumTensors&&(i.maxNumTensors=e),e<i.minNumTensors&&(i.minNumTensors=e)}const e=V[l],r=e.sourceLayer;if(r instanceof u.m)continue;const d=[],c=[],h=[];let p=!1;for(const t of e.inputs){const e=b.getValue(t),s=b.getMask(t);d.push(e),c.push(s),null!=s&&(p=!0),o||(M[t.name]--,0!==M[t.name]||n.hasKey(t)||-1!==f.indexOf(t.name)||e.isDisposed||!0===t.sourceLayer.stateful||h.push(e))}p&&((t=t||{}).mask=c[0]);const m=(0,a.st)(r.apply(d,t));let g=null;r.supportsMasking&&(g=r.computeMask(d,c));const w=y(e),x=Array.isArray(w)?w:[w];for(let n=0;n<x.length;++n){b.hasKey(x[n])||b.add(x[n],m[n],Array.isArray(g)?g[0]:g);const e=f.indexOf(x[n].name);-1!==e&&(k[e]=m[n])}o||(0,s.dispose)(h)}return b.disposeMasks(),r?k:k[0]}function p(e){const n={};for(const t in e)n[t]=e[t].size;return n}function m(e,n){const t=new Set,s=[],i={};for(const u of n.names())t.add(u);const o=[],a=[];for(o.push(e);o.length>0;){const e=o[o.length-1];if(t.has(e.name)){o.pop();continue}const n=a[a.length-1]===o.length-1;if(0===e.inputs.length||n)o.pop(),s.push(e),t.add(e.name),n&&a.pop();else{a.push(o.length-1);for(const n of e.inputs)null==i[n.name]&&(i[n.name]=new Set),i[n.name].add(e.name),t.has(n.name)||o.push(n)}}return{sorted:s,recipientMap:i}}function y(e){let n;if(1===e.sourceLayer.inboundNodes.length)n=e.sourceLayer.output;else{let t=null;for(let n=0;n<e.sourceLayer.inboundNodes.length;++n)for(const s of e.sourceLayer.inboundNodes[n].outputTensors)if(s.id===e.id){t=n;break}n=e.sourceLayer.getOutputAt(t)}return n}}}]);
//# sourceMappingURL=stylist-vendors-e1d614cc.0a87a5c0c10450912228.js.map