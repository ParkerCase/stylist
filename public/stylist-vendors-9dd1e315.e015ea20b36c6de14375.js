"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[3513],{28189:function(t,e,r){r.d(e,{MZ:function(){return h},YT:function(){return f},j1:function(){return d}});var n=r(67897),s=r(46574),i=r(50259),o=r(52046),a=r(89783),u=r(45119);function h(t,e){let r=t;if((0,a.isTypedArray)(t))return"string"===e?[]:[t.length];if((0,o.Oj)(t)){const e=t.channels||"RGBA";return[t.height,t.width*e.length]}if((0,o.Nw)(t))return[t.buffer.size/(null==e?4:(0,u.jv)(e))];if(!Array.isArray(t))return[];const n=[];for(;Array.isArray(r)||(0,a.isTypedArray)(r)&&"string"!==e;)n.push(r.length),r=r[0];return Array.isArray(t)&&(0,s._K)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&l(t,n,[]),n}function l(t,e,r){if(r=r||[],!Array.isArray(t)&&!(0,a.isTypedArray)(t))return void(0,u.vA)(0===e.length,(()=>`Element arr[${r.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`));(0,u.vA)(e.length>0,(()=>`Element arr[${r.join("][")}] should be a primitive, but is an array of ${t.length} elements`)),(0,u.vA)(t.length===e[0],(()=>`Element arr[${r.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`));const n=e.slice(1);for(let s=0;s<t.length;++s)l(t[s],n,r.concat(s))}function c(t,e,r,n){if("string_or_numeric"!==t){if(null==t)throw new Error("Expected dtype cannot be null.");if("numeric"!==t&&t!==e||"numeric"===t&&"string"===e)throw new Error(`Argument '${r}' passed to '${n}' must be ${t} tensor, but got ${e} tensor`)}}function f(t,e,r,s="numeric"){if(t instanceof(0,i.tp)())return c(s,t.dtype,e,r),t;let o=(0,u.X$)(t);if("string"!==o&&["bool","int32","float32"].indexOf(s)>=0&&(o=s),c(s,o,e,r),null==t||!(0,a.isTypedArray)(t)&&!Array.isArray(t)&&"number"!==typeof t&&"boolean"!==typeof t&&"string"!==typeof t){const n=null==t?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${r}' must be a Tensor or TensorLike, but got '${n}'`)}const l=h(t,o);(0,a.isTypedArray)(t)||Array.isArray(t)||(t=[t]);const f="string"!==o?(0,a.toTypedArray)(t,o):(0,a.flatten)(t,[],!0);return n.T2.makeTensor(f,l,o)}function d(t,e,r,n="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${r} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map(((t,s)=>f(t,`${e}[${s}]`,r,n)))}},30565:function(t,e,r){r.r(e),r.d(e,{assertTypesMatch:function(){return a},getTensorsInContainer:function(){return h},isTensorInList:function(){return u},makeTypesMatch:function(){return o}});var n=r(50259),s=r(52046),i=r(45119);function o(t,e){if(t.dtype===e.dtype)return[t,e];const r=(0,s.Tu)(t.dtype,e.dtype);return[t.cast(r),e.cast(r)]}function a(t,e){(0,i.vA)(t.dtype===e.dtype,(()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`))}function u(t,e){return e.some((e=>e.id===t.id))}function h(t){const e=[];return l(t,e,new Set),e}function l(t,e,r){if(null==t)return;if(t instanceof n.qY)return void e.push(t);if(s=t,!Array.isArray(s)&&"object"!==typeof s)return;var s;const i=t;for(const n in i){const t=i[n];r.has(t)||(r.add(t),l(t,e,r))}}},49490:function(t,e,r){r.r(e),r.d(e,{TEST_EPSILON_FLOAT16:function(){return u},createVideoElement:function(){return A},encodeStrings:function(){return w},expectArrayBuffersEqual:function(){return m},expectArraysClose:function(){return h},expectArraysEqual:function(){return d},expectNumbersClose:function(){return p},expectPromiseToFail:function(){return f},expectValuesInRange:function(){return g},play:function(){return $},testEpsilon:function(){return l}});var n=r(67897),s=r(28189),i=r(89783),o=r(45119);const a=.001,u=.1;function h(t,e,r){return null==r&&(r=l()),c(t,e,((t,e)=>y(t,e,r)))}function l(){return 32===n.T2.backend.floatPrecision()?a:u}function c(t,e,r){let n=!0;if(((0,i.isTypedArray)(t)||(0,i.isTypedArray)(e))&&(n=!1),(0,i.isTypedArray)(t)&&(0,i.isTypedArray)(e)&&(n=!0),n){const r=t.constructor.name,n=e.constructor.name;if(r!==n)throw new Error(`Arrays are of different type. Actual: ${r}. Expected: ${n}`)}if(Array.isArray(t)&&Array.isArray(e)){const r=(0,s.MZ)(t),n=(0,s.MZ)(e);if(!(0,o.r1)(r,n))throw new Error(`Arrays have different shapes. Actual: [${r}]. Expected: [${n}]`)}const a=(0,i.isTypedArray)(t)?t:(0,i.flatten)(t),u=(0,i.isTypedArray)(e)?e:(0,i.flatten)(e);if(a.length!==u.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${u.length}.\nActual:   ${a}.\nExpected: ${u}.`);for(let s=0;s<u.length;++s){const t=a[s],e=u[s];if(!r(t,e))throw new Error(`Arrays differ: actual[${s}] = ${t}, expected[${s}] = ${e}.\nActual:   ${a}.\nExpected: ${u}.`)}"undefined"!==typeof expect&&expect().nothing()}function f(t,e){t().then((()=>e.fail()),(()=>e())),"undefined"!==typeof expect&&expect().nothing()}function d(t,e){const r="string"===typeof e||"number"===typeof e||"boolean"===typeof e?[e]:e;return(0,o.Kg)(t)||(0,o.Kg)(t[0])||(0,o.Kg)(e)||(0,o.Kg)(e[0])?c(t,r,((t,e)=>t==e)):c(t,e,((t,e)=>y(t,e,0)))}function p(t,e,r){if(null==r&&(r=l()),!y(t,e,r))throw new Error(`Numbers differ: actual === ${t}, expected === ${e}`);"undefined"!==typeof expect&&expect().nothing()}function y(t,e,r){return!isFinite(t)&&!isFinite(e)||!(isNaN(t)||isNaN(e)||Math.abs(t-e)>r)}function g(t,e,r){for(let n=0;n<t.length;n++)if(t[n]<e||t[n]>r)throw new Error(`Value out of range:${t[n]} low: ${e}, high: ${r}`)}function m(t,e){const r=new Float32Array(t),n=new Float32Array(e);if(r.length!==n.length)throw new Error(`Expected ArrayBuffer to be of length ${n.length}, but it was ${r.length}`);for(let s=0;s<n.length;s++)if(r[s]!==n[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${n[s]} but got ${r[s]} instead`)}function w(t){for(let e=0;e<t.length;e++){const r=t[e];Array.isArray(r)?w(r):t[e]=(0,i.encodeString)(r)}return t}function A(t){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(t),new Promise((t=>{e.addEventListener("loadeddata",(r=>t(e))),e.load()}))}async function $(t){await t.play(),"requestVideoFrameCallback"in t&&await new Promise((e=>{t.requestVideoFrameCallback(e)}))}},50259:function(t,e,r){r.d(e,{qY:function(){return w},yl:function(){return c},rT:function(){return $},tp:function(){return A},B4:function(){return m},Q5:function(){return g},qP:function(){return y}});var n=r(41743),s=r(45119);function i(t,e,r,n){const i=(0,s.Ur)(e),a=function(t,e,r,n){const i=(0,s.Ze)(e),a=n[n.length-1],u=new Array(a).fill(0),l=e.length,c="complex64"===r?h(t):t;if(l>1)for(let s=0;s<i/a;s++){const t=s*a;for(let e=0;e<a;e++)u[e]=Math.max(u[e],o(c[t+e],0,r).length)}return u}(t,e,r,i),l=e.length,c=u(t,e,r,i,a),f=["Tensor"];return n&&(f.push(`  dtype: ${r}`),f.push(`  rank: ${l}`),f.push(`  shape: [${e}]`),f.push("  values:")),f.push(c.map((t=>"    "+t)).join("\n")),f.join("\n")}function o(t,e,r){let n;return n=Array.isArray(t)?`${parseFloat(t[0].toFixed(7))} + ${parseFloat(t[1].toFixed(7))}j`:(0,s.Kg)(t)?`'${t}'`:"bool"===r?a(t):parseFloat(t.toFixed(7)).toString(),(0,s.av)(n,e)}function a(t){return 0===t?"false":"true"}function u(t,e,r,n,s,i=!0){const l="complex64"===r?2:1,c=e[0],f=e.length;if(0===f){if("complex64"===r){return[o(h(t)[0],0,r)]}return"bool"===r?[a(t[0])]:[t[0].toString()]}if(1===f){if(c>20){const e=3*l;let n=Array.from(t.slice(0,e)),i=Array.from(t.slice((c-3)*l,c*l));return"complex64"===r&&(n=h(n),i=h(i)),["["+n.map(((t,e)=>o(t,s[e],r))).join(", ")+", ..., "+i.map(((t,e)=>o(t,s[c-3+e],r))).join(", ")+"]"]}return["["+("complex64"===r?h(t):Array.from(t)).map(((t,e)=>o(t,s[e],r))).join(", ")+"]"]}const d=e.slice(1),p=n.slice(1),y=n[0]*l,g=[];if(c>20){for(let e=0;e<3;e++){const n=e*y,i=n+y;g.push(...u(t.slice(n,i),d,r,p,s,!1))}g.push("...");for(let e=c-3;e<c;e++){const n=e*y,i=n+y;g.push(...u(t.slice(n,i),d,r,p,s,e===c-1))}}else for(let o=0;o<c;o++){const e=o*y,n=e+y;g.push(...u(t.slice(e,n),d,r,p,s,o===c-1))}const m=2===f?",":"";g[0]="["+(c>0?g[0]+m:"");for(let o=1;o<g.length-1;o++)g[o]=" "+g[o]+m;let w=",\n";for(let o=2;o<f;o++)w+="\n";return g[g.length-1]=" "+g[g.length-1]+"]"+(i?"":w),g}function h(t){const e=[];for(let r=0;r<t.length;r+=2)e.push([t[r],t[r+1]]);return e}var l=r(89783);class c{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=s.Ze(t),null!=r){const t=r.length;s.vA(t===this.size,(()=>`Length of values '${t}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||s.Ab(e,this.size),this.strides=(0,s.Ur)(t)}set(t,...e){0===e.length&&(e=[0]),s.vA(e.length===this.rank,(()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`));const r=this.locToIndex(e);this.values[r]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const n of t){if(n<0||n>=this.shape[e]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}e++}let r=t[t.length-1];for(let n=0;n<t.length-1;++n)r+=this.strides[n]*t[n];return this.values[r]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return f().makeTensor(this.values,this.shape,this.dtype)}}let f=null,d=null,p=null;function y(t){f=t}function g(t){d=t}function m(t){p=t}class w{constructor(t,e,r,n){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=s.Ze(t),this.strides=(0,s.Ur)(t),this.dataId=r,this.id=n,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return d.buffer(this.shape,this.dtype,t)}bufferSync(){return d.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return(0,s.yw)(this.shape,t,"complex64"===this.dtype)}arraySync(){return(0,s.yw)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=f().read(this.dataId);if("string"===this.dtype){const r=await t;try{return r.map((t=>l.decodeString(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),f().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=f().readSync(this.dataId);if("string"===this.dtype)try{return t.map((t=>l.decodeString(t)))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await f().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),f().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return d.print(this,t)}clone(){return this.throwIfDisposed(),d.clone(this)}toString(t=!1){return i(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),d.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),f().makeVariable(this,t,e,r)}}function A(){return(0,n.m)("Tensor",(()=>w))}Object.defineProperty(w,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),A();class $ extends w{constructor(t,e,r,n){super(t.shape,t.dtype,t.dataId,n),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!s.r1(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);f().disposeTensor(this),this.dataId=t.dataId,f().incRef(this,null)}dispose(){f().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty($,Symbol.hasInstance,{value:t=>t instanceof w&&null!=t.assign&&t.assign instanceof Function})}}]);
//# sourceMappingURL=stylist-vendors-9dd1e315.e015ea20b36c6de14375.js.map