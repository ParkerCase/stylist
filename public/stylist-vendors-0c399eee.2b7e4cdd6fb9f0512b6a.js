"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[5162],{31830:function(e,n,a){a.d(n,{Dv:function(){return i},_X:function(){return c},jY:function(){return o},mu:function(){return l},ok:function(){return d},y7:function(){return f}});var r=a(67897),t=a(50259),s=a(28189),u=a(45119);function i(e){return u.vA(u.Tn(e),(()=>"The f passed in grad(f) must be a function")),(n,a)=>{const t=(0,s.YT)(n,"x","tf.grad","string_or_numeric"),i=null!=a?(0,s.YT)(a,"dy","tf.grad"):null;return r.T2.tidy((()=>{const{value:n,grads:a}=r.T2.gradients((()=>e(t)),[t],i);return null!=i&&u.O3(n.shape,i.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),h(a),a[0]}))}}function d(e){return u.vA(u.Tn(e),(()=>"The f passed in grads(f) must be a function")),(n,a)=>{u.vA(Array.isArray(n),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const t=(0,s.j1)(n,"args","tf.grads","string_or_numeric"),i=null!=a?(0,s.YT)(a,"dy","tf.grads"):null;return r.T2.tidy((()=>{const{value:n,grads:a}=r.T2.gradients((()=>e(...t)),t,i);return null!=i&&u.O3(n.shape,i.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),h(a),a}))}}function o(e){return u.vA(u.Tn(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(n,a)=>{u.vA(n instanceof t.qY,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),u.vA(null==a||a instanceof t.qY,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:s,value:i}=r.T2.gradients((()=>e(n)),[n],a);return h(s),{grad:s[0],value:i}}}function l(e){return u.vA(u.Tn(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(n,a)=>{u.vA(Array.isArray(n)&&n.every((e=>e instanceof t.qY)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),u.vA(null==a||a instanceof t.qY,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const s=r.T2.gradients((()=>e(...n)),n,a);return null!=a&&u.O3(s.value.shape,a.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),h(s.grads),s}}function f(e,n){u.vA(u.Tn(e),(()=>"The f passed in variableGrads(f) must be a function")),u.vA(null==n||Array.isArray(n)&&n.every((e=>e instanceof t.rT)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const a=null!=n;if(!a){n=[];for(const e in r.T2.registeredVariables)n.push(r.T2.registeredVariables[e])}const s=a?n.filter((e=>!e.trainable)):null,i=n.length;n=n.filter((e=>e.trainable)),u.vA(n.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`));const{value:d,grads:o}=r.T2.gradients(e,n,null,!0);u.vA(o.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),u.vA(0===d.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${d.rank} tensor`));const l={};return n.forEach(((e,n)=>{null!=o[n]&&(l[e.name]=o[n])})),null!=s&&s.forEach((e=>l[e.name]=null)),{value:d,grads:l}}function c(e){return r.T2.customGrad(e)}function h(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},43546:function(e,n,a){a.d(n,{v:function(){return d}});var r=a(21078),t=a(29809),s=a(13020),u=a(9258),i=a(62302);function d(e,n,a,d){return n.rank<a.rank&&(n=(0,i.t)(n,r.SM(n.shape,d))),e.rank<a.rank&&(e=(0,i.t)(e,r.SM(e.shape,d))),{x:()=>(0,u.l)(e,(0,t.w)((0,s.L)(a,n),e.dtype))}}}}]);
//# sourceMappingURL=stylist-vendors-0c399eee.2b7e4cdd6fb9f0512b6a.js.map