{"version":3,"file":"stylist-main-afbe97b7.ccdc225e6d8ff6e583c7.js","mappings":"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","sources":["webpack://StylistWidget/./src/index.tsx","webpack://StylistWidget/./src/hooks/useNetworkStatus.ts","webpack://StylistWidget/./src/diagnostics.ts","webpack://StylistWidget/./src/hooks/useOfflineMode.ts","webpack://StylistWidget/./src/hooks/useSyncedStore.ts","webpack://StylistWidget/./src/hooks/useBackgroundRemoval.ts","webpack://StylistWidget/./src/hooks/useImageProcessing.ts","webpack://StylistWidget/./src/hooks/useTryOn.ts","webpack://StylistWidget/./src/diagnosticHooks.tsx"],"sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\n// Main entry point for the widget\nimport React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport StylistWidget from './StylistWidget';\nimport { useChatStore, useRecommendationStore, useUserStore } from './store/index';\nimport { logGlobalFlag, logComponentRender, logStore, logPerformance } from './diagnostics';\nimport { monitorExistingStore } from './storeMonitor';\n// Feature flag for lazy loading - set to true to enable lazy loading\nexport const USE_LAZY_LOADING = true;\n// Feature flag for controlling parallel vs sequential initialization\n// Set to false for optimized background initialization (better performance)\nexport const USE_PARALLEL_INIT = false;\n// Create safe store selectors that won't crash if the store isn't initialized\nconst getSafeStoreValue = (store, selector, defaultValue) => {\n    var _a;\n    try {\n        // First check if store exists and has getState method\n        if (store && typeof store.getState === 'function') {\n            const state = store.getState();\n            // Then check if selector can be safely applied\n            return (_a = selector(state)) !== null && _a !== void 0 ? _a : defaultValue;\n        }\n        return defaultValue;\n    }\n    catch (error) {\n        console.warn('Error accessing store:', error);\n        return defaultValue;\n    }\n};\n// Initialize stores early to prevent race conditions\n// This ensures stores are ready before any UI renders\nconst initializeStores = () => {\n    try {\n        // Prevent duplicate initialization\n        if (window.__STYLIST_STORES_INITIALIZING) {\n            console.log('Store initialization already in progress, skipping');\n            logStore('global', 'init', 'Store initialization already in progress, skipping');\n            return false;\n        }\n        // Performance tracking for store initialization\n        const initStartTime = performance.now();\n        logPerformance('storeInitialization:start', 0, { phase: 'start' });\n        // Set initializing flag to prevent concurrent initialization\n        window.__STYLIST_STORES_INITIALIZING = true;\n        logGlobalFlag('__STYLIST_STORES_INITIALIZING', true, 'Setting store initialization flag');\n        // Touch each store to initialize it - with proper error handling for each\n        try {\n            const chatInitialState = useChatStore.getState();\n            console.log('Chat store initialized');\n            // Monitor the chat store\n            monitorExistingStore('chatStore', useChatStore);\n            logStore('chatStore', 'init', 'Chat store successfully initialized', {\n                isOpen: chatInitialState.isOpen,\n                hasMessages: chatInitialState.messages.length > 0,\n                currentView: chatInitialState.currentView\n            });\n        }\n        catch (e) {\n            console.error('Failed to initialize chat store:', e);\n            logStore('chatStore', 'init', 'Failed to initialize chat store', {\n                error: e instanceof Error ? e.message : String(e)\n            });\n        }\n        try {\n            const userInitialState = useUserStore.getState();\n            console.log('User store initialized');\n            // Monitor the user store\n            monitorExistingStore('userStore', useUserStore);\n            logStore('userStore', 'init', 'User store successfully initialized', {\n                hasUser: !!userInitialState.user\n            });\n        }\n        catch (e) {\n            console.error('Failed to initialize user store:', e);\n            logStore('userStore', 'init', 'Failed to initialize user store', {\n                error: e instanceof Error ? e.message : String(e)\n            });\n        }\n        try {\n            const recInitialState = useRecommendationStore.getState();\n            console.log('Recommendation store initialized');\n            // Monitor the recommendation store\n            monitorExistingStore('recommendationStore', useRecommendationStore);\n            logStore('recommendationStore', 'init', 'Recommendation store successfully initialized', {\n                itemCount: recInitialState.recommendedItems.length,\n                outfitCount: recInitialState.recommendedOutfits.length\n            });\n        }\n        catch (e) {\n            console.error('Failed to initialize recommendation store:', e);\n            logStore('recommendationStore', 'init', 'Failed to initialize recommendation store', {\n                error: e instanceof Error ? e.message : String(e)\n            });\n        }\n        // Performance tracking for completion\n        const initDuration = performance.now() - initStartTime;\n        logPerformance('storeInitialization:complete', initDuration, {\n            phase: 'complete',\n            duration: `${initDuration.toFixed(2)}ms`\n        });\n        // Log successful initialization\n        console.log('Store initialization completed');\n        logStore('global', 'init', 'All stores initialized successfully', {\n            initDuration: `${initDuration.toFixed(2)}ms`\n        });\n        // Add a global flag to indicate stores are ready\n        window.__STYLIST_STORES_INITIALIZED = true;\n        window.__STYLIST_STORES_INITIALIZING = false;\n        logGlobalFlag('__STYLIST_STORES_INITIALIZED', true, 'Stores successfully initialized');\n        logGlobalFlag('__STYLIST_STORES_INITIALIZING', false, 'Cleared store initialization flag');\n        return true;\n    }\n    catch (error) {\n        console.error('Critical error during store initialization:', error);\n        logStore('global', 'init', 'Critical error during store initialization', {\n            error: error instanceof Error ? error.message : String(error),\n            stack: error instanceof Error ? error.stack : undefined\n        });\n        window.__STYLIST_STORES_INITIALIZING = false;\n        logGlobalFlag('__STYLIST_STORES_INITIALIZING', false, 'Cleared store initialization flag after error');\n        return false;\n    }\n};\n// Initialize stores immediately, but with safety timeout\nconst initTimeout = setTimeout(() => {\n    if (!window.__STYLIST_STORES_INITIALIZED) {\n        console.warn('Store initialization taking too long, forcing completion');\n        logStore('global', 'init', 'Store initialization timeout - forcing completion', {\n            timeoutDuration: '5000ms'\n        });\n        window.__STYLIST_STORES_INITIALIZED = true;\n        window.__STYLIST_STORES_INITIALIZING = false;\n        logGlobalFlag('__STYLIST_STORES_INITIALIZED', true, 'Forced store initialization to complete due to timeout');\n        logGlobalFlag('__STYLIST_STORES_INITIALIZING', false, 'Cleared store initialization flag after timeout');\n    }\n}, 5000); // 5 second safety timeout\n// Start initialization\nlogComponentRender('index', 'mount', 'Main entry point initialized');\ninitializeStores();\n// Use a self-invoking function to encapsulate the widget creation and prevent duplication\n(function mountWidgetOnce() {\n    // Track performance for widget mounting\n    const mountStartTime = performance.now();\n    logPerformance('widgetMount:start', 0, { phase: 'start' });\n    // Check if widget is already mounted\n    if (window.__STYLIST_WIDGET_DOM_MOUNTED === true) {\n        console.log('Widget DOM already mounted, skipping render');\n        logComponentRender('index', 'render', 'Widget DOM already mounted, skipping render');\n        return;\n    }\n    // Get or create a container for the widget\n    let stylistContainer = document.getElementById('stylist-widget-container');\n    // Only create a new container if one doesn't exist\n    if (!stylistContainer) {\n        console.log('Creating widget container as it does not exist');\n        logComponentRender('index', 'render', 'Creating widget container');\n        stylistContainer = createWidgetContainer();\n    }\n    else {\n        console.log('Using existing widget container');\n        logComponentRender('index', 'render', 'Using existing widget container');\n    }\n    // Set mounting flag BEFORE creating root to prevent any race conditions\n    window.__STYLIST_WIDGET_DOM_MOUNTED = true;\n    logGlobalFlag('__STYLIST_WIDGET_DOM_MOUNTED', true, 'Setting widget DOM mounted flag');\n    // Set a safety timeout to clear the widget mounted flag if rendering fails\n    // This allows a future retry if the initial attempt fails\n    const safetyTimeout = setTimeout(() => {\n        if (!window.__STYLIST_WIDGET_RENDER_COMPLETE) {\n            console.warn('Stylist Widget render did not complete within the timeout period, resetting initialization flags');\n            logGlobalFlag('__STYLIST_WIDGET_DOM_MOUNTED', false, 'Resetting DOM mounted flag after render timeout', {\n                timeoutDuration: '10000ms',\n                elapsedTime: `${((performance.now() - mountStartTime) / 1000).toFixed(1)}s`\n            });\n            // Reset the mount flag to allow another initialization attempt\n            window.__STYLIST_WIDGET_DOM_MOUNTED = false;\n        }\n    }, 10000); // 10 second safety timeout\n    try {\n        // Create root for React rendering\n        const root = createRoot(stylistContainer);\n        logComponentRender('index', 'render', 'Created React root for rendering');\n        // Get configuration from the global object with fallback\n        const config = window.__StylistWidgetConfig || {\n            apiKey: 'demo_key',\n            retailerId: 'demo_retailer'\n        };\n        logComponentRender('index', 'render', 'Using widget configuration', {\n            hasConfig: !!window.__StylistWidgetConfig,\n            apiKey: config.apiKey === 'demo_key' ? 'demo_key' : 'custom_key',\n            retailerId: config.retailerId === 'demo_retailer' ? 'demo_retailer' : 'custom_retailer'\n        });\n        // Import the SyncProvider\n        const { SyncProvider } = require('./services/SyncProvider');\n        // Render the widget with SyncProvider\n        root.render(_jsx(React.StrictMode, { children: _jsx(SyncProvider, { children: _jsx(StylistWidget, Object.assign({}, config)) }) }));\n        // Mark render as complete\n        window.__STYLIST_WIDGET_RENDER_COMPLETE = true;\n        clearTimeout(safetyTimeout);\n        console.log('Widget root rendered successfully');\n        const mountDuration = performance.now() - mountStartTime;\n        logGlobalFlag('__STYLIST_WIDGET_RENDER_COMPLETE', true, 'Widget render completed successfully');\n        logPerformance('widgetMount:complete', mountDuration, {\n            phase: 'complete',\n            duration: `${mountDuration.toFixed(2)}ms`\n        });\n    }\n    catch (error) {\n        console.error('Error mounting Stylist Widget:', error);\n        logComponentRender('index', 'error', 'Error mounting Stylist Widget', {\n            error: error instanceof Error ? error.message : String(error),\n            stack: error instanceof Error ? error.stack : undefined\n        });\n        // Only keep the DOM mounted flag if render actually succeeded\n        window.__STYLIST_WIDGET_RENDER_COMPLETE = false;\n        clearTimeout(safetyTimeout);\n        logGlobalFlag('__STYLIST_WIDGET_RENDER_COMPLETE', false, 'Widget render failed', {\n            error: error instanceof Error ? error.message : String(error)\n        });\n    }\n})();\n// Helper function to create the widget container\nfunction createWidgetContainer() {\n    const container = document.createElement('div');\n    container.id = 'stylist-widget-container';\n    document.body.appendChild(container);\n    return container;\n}\n// Export the StylistWidget component for direct use\nexport default StylistWidget;\n// Create a widget API with safe store access\nconst widgetAPI = {\n    init: (config) => {\n        logComponentRender('API', 'init', 'StylistWidget API initialization', {\n            hasApiKey: !!(config === null || config === void 0 ? void 0 : config.apiKey),\n            hasRetailerId: !!(config === null || config === void 0 ? void 0 : config.retailerId)\n        });\n        window.__StylistWidgetConfig = Object.assign(Object.assign({}, window.__StylistWidgetConfig), config);\n        logGlobalFlag('__StylistWidgetConfig', true, 'Widget configuration set via API', {\n            hasApiKey: !!(config === null || config === void 0 ? void 0 : config.apiKey),\n            hasRetailerId: !!(config === null || config === void 0 ? void 0 : config.retailerId)\n        });\n        // Ensure root is present\n        if (!document.getElementById('stylist-widget-container')) {\n            logComponentRender('API', 'init', 'Creating widget container via API');\n            createWidgetContainer();\n        }\n        // Ensure stores are initialized\n        logComponentRender('API', 'init', 'Initializing stores via API');\n        const initResult = initializeStores();\n        logComponentRender('API', 'init', 'Store initialization result', { success: initResult });\n        return {\n            success: true,\n            message: 'Stylist Widget initialized successfully'\n        };\n    },\n    open: () => {\n        logComponentRender('API', 'action', 'Open widget requested via API');\n        // Safely get isOpen and use toggleOpen only if needed\n        const isOpen = getSafeStoreValue(useChatStore, state => state.isOpen, false);\n        if (!isOpen) {\n            const chatStore = useChatStore.getState();\n            if (chatStore && typeof chatStore.toggleOpen === 'function') {\n                logComponentRender('API', 'action', 'Opening widget via store action');\n                chatStore.toggleOpen();\n                return true;\n            }\n            else {\n                logComponentRender('API', 'error', 'Failed to open widget - store not available', {\n                    error: 'Chat store not available or toggleOpen not a function'\n                });\n                return false;\n            }\n        }\n        else {\n            logComponentRender('API', 'action', 'Widget already open, no action needed');\n            return true;\n        }\n    },\n    close: () => {\n        logComponentRender('API', 'action', 'Close widget requested via API');\n        // Safely get isOpen and use toggleOpen only if needed\n        const isOpen = getSafeStoreValue(useChatStore, state => state.isOpen, false);\n        if (isOpen) {\n            const chatStore = useChatStore.getState();\n            if (chatStore && typeof chatStore.toggleOpen === 'function') {\n                logComponentRender('API', 'action', 'Closing widget via store action');\n                chatStore.toggleOpen();\n                return true;\n            }\n            else {\n                logComponentRender('API', 'error', 'Failed to close widget - store not available', {\n                    error: 'Chat store not available or toggleOpen not a function'\n                });\n                return false;\n            }\n        }\n        else {\n            logComponentRender('API', 'action', 'Widget already closed, no action needed');\n            return true;\n        }\n    },\n    minimize: () => {\n        logComponentRender('API', 'action', 'Minimize widget requested via API');\n        const chatStore = useChatStore.getState();\n        if (chatStore && typeof chatStore.toggleMinimize === 'function') {\n            logComponentRender('API', 'action', 'Minimizing widget via store action');\n            chatStore.toggleMinimize();\n            return true;\n        }\n        else {\n            logComponentRender('API', 'error', 'Failed to minimize widget - store not available', {\n                error: 'Chat store not available or toggleMinimize not a function'\n            });\n            return false;\n        }\n    },\n    switchView: (view) => {\n        logComponentRender('API', 'action', 'Switch view requested via API', { view });\n        const chatStore = useChatStore.getState();\n        if (chatStore && typeof chatStore.setCurrentView === 'function') {\n            logComponentRender('API', 'action', `Switching to ${view} view via store action`);\n            chatStore.setCurrentView(view);\n            return true;\n        }\n        else {\n            logComponentRender('API', 'error', 'Failed to switch view - store not available', {\n                error: 'Chat store not available or setCurrentView not a function',\n                requestedView: view\n            });\n            return false;\n        }\n    },\n    openStyleQuiz: () => {\n        logComponentRender('API', 'action', 'Open style quiz requested via API');\n        // Set the global flag to show style quiz\n        window.__StylistShowStyleQuiz = true;\n        logGlobalFlag('__StylistShowStyleQuiz', true, 'Style quiz flag set via API');\n        // Make sure the widget is open - with safety checks\n        const chatStore = useChatStore.getState();\n        if (chatStore && typeof chatStore.setIsOpen === 'function') {\n            logComponentRender('API', 'action', 'Opening widget for style quiz');\n            chatStore.setIsOpen(true);\n            return true;\n        }\n        else {\n            logComponentRender('API', 'warning', 'Style quiz flag set but widget could not be opened', {\n                error: 'Chat store not available or setIsOpen not a function'\n            });\n            return false;\n        }\n    },\n    openVirtualTryOn: () => {\n        logComponentRender('API', 'action', 'Open virtual try-on requested via API');\n        // Set the global flag to show virtual try-on\n        window.__StylistShowVirtualTryOn = true;\n        logGlobalFlag('__StylistShowVirtualTryOn', true, 'Virtual try-on flag set via API');\n        // Make sure the widget is open - with safety checks\n        const chatStore = useChatStore.getState();\n        if (chatStore && typeof chatStore.setIsOpen === 'function') {\n            logComponentRender('API', 'action', 'Opening widget for virtual try-on');\n            chatStore.setIsOpen(true);\n            return true;\n        }\n        else {\n            logComponentRender('API', 'warning', 'Virtual try-on flag set but widget could not be opened', {\n                error: 'Chat store not available or setIsOpen not a function'\n            });\n            return false;\n        }\n    },\n    __debug: {\n        addMockItems: () => {\n            logComponentRender('API', 'debug', 'Adding mock items via debug API');\n            try {\n                const recStore = useRecommendationStore.getState();\n                if (!recStore || typeof recStore.setRecommendedItems !== 'function') {\n                    console.warn('Recommendation store not initialized');\n                    logComponentRender('API', 'error', 'Failed to add mock items - store not initialized');\n                    return {\n                        success: false,\n                        message: 'Recommendation store not initialized'\n                    };\n                }\n                // Create properly typed mock items\n                const mockItems = [\n                    {\n                        id: 'mock1',\n                        name: 'Stylish Jeans',\n                        brand: 'DenimCo',\n                        category: 'Pants',\n                        price: 79.99,\n                        retailerId: 'demo',\n                        imageUrls: ['https://via.placeholder.com/150'],\n                        colors: [],\n                        sizes: [],\n                        url: '#',\n                        matchScore: 0.95,\n                        matchReasons: ['Based on your style profile'],\n                        inStock: true\n                    },\n                    {\n                        id: 'mock2',\n                        name: 'Casual T-Shirt',\n                        brand: 'Basics',\n                        category: 'Tops',\n                        price: 24.99,\n                        retailerId: 'demo',\n                        imageUrls: ['https://via.placeholder.com/150'],\n                        colors: [],\n                        sizes: [],\n                        url: '#',\n                        matchScore: 0.92,\n                        matchReasons: ['Matches your preferences'],\n                        inStock: true\n                    },\n                    {\n                        id: 'mock3',\n                        name: 'Leather Boots',\n                        brand: 'Footwear',\n                        category: 'Shoes',\n                        price: 129.99,\n                        retailerId: 'demo',\n                        imageUrls: ['https://via.placeholder.com/150'],\n                        colors: [],\n                        sizes: [],\n                        url: '#',\n                        matchScore: 0.88,\n                        matchReasons: ['Complements your style'],\n                        inStock: true\n                    }\n                ];\n                // Create properly typed mock outfit\n                const mockOutfit = {\n                    id: 'outfit1',\n                    name: 'Casual Weekend Look',\n                    occasion: 'Casual',\n                    items: mockItems,\n                    matchScore: 0.93,\n                    matchReasons: ['Perfect for weekends']\n                };\n                logComponentRender('API', 'debug', 'Setting mock items in recommendation store');\n                recStore.setRecommendedItems(mockItems);\n                if (typeof recStore.setRecommendedOutfits === 'function') {\n                    logComponentRender('API', 'debug', 'Setting mock outfits in recommendation store');\n                    recStore.setRecommendedOutfits([mockOutfit]);\n                }\n                return {\n                    success: true,\n                    message: 'Mock items and outfit added successfully',\n                    data: {\n                        itemCount: mockItems.length,\n                        outfitCount: 1\n                    }\n                };\n            }\n            catch (error) {\n                console.error('Error adding mock items:', error);\n                logComponentRender('API', 'error', 'Error adding mock items', {\n                    error: error instanceof Error ? error.message : String(error),\n                    stack: error instanceof Error ? error.stack : undefined\n                });\n                return {\n                    success: false,\n                    message: 'Error adding mock items',\n                    error: error instanceof Error ? error.message : String(error)\n                };\n            }\n        },\n        getDiagnostics: () => {\n            // Export diagnostic logs to the consumer\n            if (typeof window !== 'undefined' && window.__STYLIST_DIAGNOSTICS) {\n                logComponentRender('API', 'debug', 'Getting diagnostics via debug API');\n                return {\n                    logs: window.__STYLIST_DIAGNOSTICS.logs || [],\n                    flags: {\n                        initialized: !!window.__STYLIST_WIDGET_INITIALIZED,\n                        mounted: !!window.__STYLIST_WIDGET_DOM_MOUNTED,\n                        renderComplete: !!window.__STYLIST_WIDGET_RENDER_COMPLETE,\n                        storesInitialized: !!window.__STYLIST_STORES_INITIALIZED,\n                        backgroundInitComplete: !!window.__STYLIST_BACKGROUND_INIT_COMPLETE\n                    }\n                };\n            }\n            else {\n                return {\n                    logs: [],\n                    flags: {\n                        initialized: false,\n                        mounted: false,\n                        renderComplete: false,\n                        storesInitialized: false,\n                        backgroundInitComplete: false\n                    }\n                };\n            }\n        },\n        clearDiagnostics: () => {\n            logComponentRender('API', 'debug', 'Clearing diagnostics via debug API');\n            // If we have the diagnostics module, use it to clear logs\n            if (typeof window !== 'undefined' && window.__STYLIST_DIAGNOSTICS) {\n                window.__STYLIST_DIAGNOSTICS.logs = [];\n                // Also try to remove from localStorage\n                try {\n                    localStorage.removeItem('__STYLIST_DIAGNOSTICS_LOGS');\n                }\n                catch (e) {\n                    // Silently fail if localStorage is not available\n                }\n                return { success: true, message: 'Diagnostics cleared successfully' };\n            }\n            return { success: false, message: 'Diagnostics module not initialized' };\n        }\n    }\n};\n// Add to global window object\n// Use type assertion to ensure TypeScript knows this is a valid operation\nwindow.StylistWidget = widgetAPI;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// Hook for detecting and managing network connectivity status\nimport { useState, useEffect, useCallback } from 'react';\nexport const useNetworkStatus = () => {\n    const [status, setStatus] = useState({\n        isOnline: navigator.onLine,\n        isSlowConnection: false,\n        effectiveType: null,\n        lastChecked: Date.now()\n    });\n    // Update connection quality information if available\n    const updateConnectionQuality = useCallback(() => {\n        if ('connection' in navigator) {\n            const connection = navigator.connection;\n            setStatus(prev => (Object.assign(Object.assign({}, prev), { isSlowConnection: connection.effectiveType === 'slow-2g' ||\n                    connection.effectiveType === '2g' ||\n                    connection.saveData === true, effectiveType: connection.effectiveType, lastChecked: Date.now() })));\n        }\n    }, []);\n    // Handle online status change\n    const handleOnline = useCallback(() => {\n        setStatus(prev => (Object.assign(Object.assign({}, prev), { isOnline: true, lastChecked: Date.now() })));\n        updateConnectionQuality();\n    }, [updateConnectionQuality]);\n    // Handle offline status change\n    const handleOffline = useCallback(() => {\n        setStatus(prev => (Object.assign(Object.assign({}, prev), { isOnline: false, lastChecked: Date.now() })));\n    }, []);\n    // Handle connection change events\n    const handleConnectionChange = useCallback(() => {\n        updateConnectionQuality();\n    }, [updateConnectionQuality]);\n    // Set up event listeners for network status changes\n    useEffect(() => {\n        // Initial check\n        updateConnectionQuality();\n        // Add event listeners\n        window.addEventListener('online', handleOnline);\n        window.addEventListener('offline', handleOffline);\n        // Add connection change listener if available\n        if ('connection' in navigator) {\n            const connection = navigator.connection;\n            connection.addEventListener('change', handleConnectionChange);\n        }\n        // Clean up event listeners\n        return () => {\n            window.removeEventListener('online', handleOnline);\n            window.removeEventListener('offline', handleOffline);\n            if ('connection' in navigator) {\n                const connection = navigator.connection;\n                connection.removeEventListener('change', handleConnectionChange);\n            }\n        };\n    }, [handleOnline, handleOffline, handleConnectionChange, updateConnectionQuality]);\n    // Manual check function\n    const checkConnection = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        try {\n            // Try to fetch a tiny resource to verify connectivity\n            // This is more reliable than just checking navigator.onLine\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), 5000);\n            const response = yield fetch('/api/ping', {\n                method: 'HEAD',\n                signal: controller.signal\n            });\n            clearTimeout(timeoutId);\n            const isConnected = response.ok;\n            setStatus(prev => (Object.assign(Object.assign({}, prev), { isOnline: isConnected, lastChecked: Date.now() })));\n            return isConnected;\n        }\n        catch (_) {\n            // If fetch fails, we're likely offline\n            setStatus(prev => (Object.assign(Object.assign({}, prev), { isOnline: false, lastChecked: Date.now() })));\n            return false;\n        }\n    }), []);\n    return Object.assign(Object.assign({}, status), { checkConnection });\n};\nexport default useNetworkStatus;\n","// Diagnostics logging system for Stylist Widget\nimport { useEffect } from 'react';\n// Configuration\nconst LOG_DIAGNOSTICS = process.env.LOG_DIAGNOSTICS !== 'false';\nconst LOG_PATH = process.env.LOG_PATH || './logs';\nconst LOG_FILE = process.env.LOG_FILE || 'diagnostics.log.json';\nconst MAX_LOG_ENTRIES = 1000;\n// Log entry types\nexport var LogEntryType;\n(function (LogEntryType) {\n    LogEntryType[\"COMPONENT_MOUNT\"] = \"COMPONENT_MOUNT\";\n    LogEntryType[\"COMPONENT_UNMOUNT\"] = \"COMPONENT_UNMOUNT\";\n    LogEntryType[\"COMPONENT_RENDER\"] = \"COMPONENT_RENDER\";\n    LogEntryType[\"COMPONENT_ERROR\"] = \"COMPONENT_ERROR\";\n    LogEntryType[\"SUSPENSE_FALLBACK\"] = \"SUSPENSE_FALLBACK\";\n    LogEntryType[\"SUSPENSE_RESOLVED\"] = \"SUSPENSE_RESOLVED\";\n    LogEntryType[\"LAZY_LOAD_START\"] = \"LAZY_LOAD_START\";\n    LogEntryType[\"LAZY_LOAD_COMPLETE\"] = \"LAZY_LOAD_COMPLETE\";\n    LogEntryType[\"LAZY_LOAD_ERROR\"] = \"LAZY_LOAD_ERROR\";\n    LogEntryType[\"HOOK_INIT\"] = \"HOOK_INIT\";\n    LogEntryType[\"EFFECT_START\"] = \"EFFECT_START\";\n    LogEntryType[\"EFFECT_COMPLETE\"] = \"EFFECT_COMPLETE\";\n    LogEntryType[\"EFFECT_CLEANUP\"] = \"EFFECT_CLEANUP\";\n    LogEntryType[\"STORE_INIT\"] = \"STORE_INIT\";\n    LogEntryType[\"STORE_UPDATE\"] = \"STORE_UPDATE\";\n    LogEntryType[\"STORE_SUBSCRIPTION\"] = \"STORE_SUBSCRIPTION\";\n    LogEntryType[\"ERROR_BOUNDARY\"] = \"ERROR_BOUNDARY\";\n    LogEntryType[\"GLOBAL_FLAG\"] = \"GLOBAL_FLAG\";\n    LogEntryType[\"PERFORMANCE_MARK\"] = \"PERFORMANCE_MARK\";\n    LogEntryType[\"APPLICATION_ERROR\"] = \"APPLICATION_ERROR\";\n    LogEntryType[\"CUSTOM\"] = \"CUSTOM\";\n})(LogEntryType || (LogEntryType = {}));\n// Log level enum\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"CRITICAL\"] = \"CRITICAL\";\n})(LogLevel || (LogLevel = {}));\n// In-memory log storage\nlet inMemoryLog = [];\n// Ensure we're in a browser environment before using window\nconst isBrowser = typeof window !== 'undefined';\n// Initialize the in-memory log on load\nif (isBrowser) {\n    // Store the original console methods\n    const originalConsole = {\n        log: console.log,\n        warn: console.warn,\n        error: console.error,\n        info: console.info,\n        debug: console.debug,\n    };\n    // Add the diagnostics log to the window for debug access\n    window.__STYLIST_DIAGNOSTICS = {\n        logs: inMemoryLog,\n        enabled: LOG_DIAGNOSTICS,\n        originalConsole,\n    };\n}\n/**\n * Adds a diagnostic log entry\n */\nexport const logDiagnostic = (type, message, options = {}) => {\n    if (!LOG_DIAGNOSTICS)\n        return;\n    const { level = LogLevel.INFO, component, data, stack, } = options;\n    const entry = {\n        timestamp: new Date().toISOString(),\n        type,\n        level,\n        message,\n        component,\n        data,\n        stack,\n    };\n    // Add to in-memory log with size limitation\n    inMemoryLog.push(entry);\n    if (inMemoryLog.length > MAX_LOG_ENTRIES) {\n        inMemoryLog = inMemoryLog.slice(-MAX_LOG_ENTRIES);\n    }\n    // Log to console in development with special formatting\n    if (process.env.NODE_ENV === 'development') {\n        const logObject = Object.assign({ type, component: component || 'global', message }, (data ? { data } : {}));\n        console.log(`%c DIAGNOSTICS %c ${type} %c ${component || 'global'} `, 'background: #6610f2; color: white; border-radius: 3px 0 0 3px;', 'background: #fd7e14; color: white;', 'background: #17a2b8; color: white; border-radius: 0 3px 3px 0;', logObject);\n    }\n    // In browser environment, we can't write to disk directly\n    // Instead, we'll signal to any Node.js process reading our logs\n    // that we have new logs via special console output\n    if (process.env.NODE_ENV === 'development') {\n        // Output a special marker that can be picked up by diagnose.js\n        console.log(`__STYLIST_DIAGNOSTIC_LOG_ENTRY__:${JSON.stringify(entry)}`);\n    }\n    // In browser environment, if window.__STYLIST_DIAGNOSTICS_LOG_TO_TEMP is set,\n    // also log to localStorage as a fallback\n    if (isBrowser && window.__STYLIST_DIAGNOSTICS_LOG_TO_TEMP) {\n        try {\n            const storedLogs = localStorage.getItem('__STYLIST_DIAGNOSTICS_LOGS') || '[]';\n            const parsedLogs = JSON.parse(storedLogs);\n            parsedLogs.push(entry);\n            // Limit size\n            const limitedLogs = parsedLogs.slice(-MAX_LOG_ENTRIES);\n            localStorage.setItem('__STYLIST_DIAGNOSTICS_LOGS', JSON.stringify(limitedLogs));\n        }\n        catch (error) {\n            // Silently fail if localStorage is not available\n        }\n    }\n};\n/**\n * Log component rendering lifecycle\n */\nexport const logComponentRender = (component, stage, message, data) => {\n    const typeMap = {\n        mount: LogEntryType.COMPONENT_MOUNT,\n        render: LogEntryType.COMPONENT_RENDER,\n        update: LogEntryType.COMPONENT_RENDER,\n        unmount: LogEntryType.COMPONENT_UNMOUNT,\n        error: LogEntryType.COMPONENT_ERROR,\n        init: LogEntryType.COMPONENT_MOUNT,\n        action: LogEntryType.CUSTOM,\n        debug: LogEntryType.CUSTOM,\n        warning: LogEntryType.CUSTOM, // Warnings are custom\n    };\n    const levelMap = {\n        mount: LogLevel.INFO,\n        render: LogLevel.DEBUG,\n        update: LogLevel.DEBUG,\n        unmount: LogLevel.INFO,\n        error: LogLevel.ERROR,\n        init: LogLevel.INFO,\n        action: LogLevel.INFO,\n        debug: LogLevel.DEBUG,\n        warning: LogLevel.WARNING, // Warnings are warning level\n    };\n    logDiagnostic(typeMap[stage], message, {\n        level: levelMap[stage],\n        component,\n        data,\n    });\n};\n/**\n * Log suspense lifecycle\n */\nexport const logSuspense = (component, state, message, data) => {\n    const type = state === 'fallback'\n        ? LogEntryType.SUSPENSE_FALLBACK\n        : LogEntryType.SUSPENSE_RESOLVED;\n    logDiagnostic(type, message, {\n        component,\n        data,\n    });\n};\n/**\n * Log lazy loading lifecycle\n */\nexport const logLazyLoad = (component, stage, message, data) => {\n    const typeMap = {\n        start: LogEntryType.LAZY_LOAD_START,\n        complete: LogEntryType.LAZY_LOAD_COMPLETE,\n        error: LogEntryType.LAZY_LOAD_ERROR,\n    };\n    const levelMap = {\n        start: LogLevel.INFO,\n        complete: LogLevel.INFO,\n        error: LogLevel.ERROR,\n    };\n    logDiagnostic(typeMap[stage], message, {\n        level: levelMap[stage],\n        component,\n        data,\n    });\n};\n/**\n * Log React hook lifecycle\n */\nexport const logHook = (component, hook, stage, message, data) => {\n    let type = LogEntryType.HOOK_INIT;\n    if (stage === 'update') {\n        type = LogEntryType.EFFECT_START;\n    }\n    else if (stage === 'cleanup') {\n        type = LogEntryType.EFFECT_CLEANUP;\n    }\n    logDiagnostic(type, message, {\n        component,\n        data: Object.assign({ hook }, data),\n    });\n};\n/**\n * Log store operations\n */\nexport const logStore = (store, operation, message, data) => {\n    const typeMap = {\n        init: LogEntryType.STORE_INIT,\n        update: LogEntryType.STORE_UPDATE,\n        subscribe: LogEntryType.STORE_SUBSCRIPTION,\n        unsubscribe: LogEntryType.STORE_SUBSCRIPTION,\n    };\n    logDiagnostic(typeMap[operation], message, {\n        component: store,\n        data: Object.assign({ operation }, data),\n    });\n};\n/**\n * Log error boundary activations\n */\nexport const logErrorBoundary = (component, error, info) => {\n    logDiagnostic(LogEntryType.ERROR_BOUNDARY, `Error boundary triggered in ${component}`, {\n        level: LogLevel.ERROR,\n        component,\n        data: {\n            errorMessage: error.message,\n            componentStack: info === null || info === void 0 ? void 0 : info.componentStack,\n        },\n        stack: error.stack,\n    });\n};\n/**\n * Log global flag changes\n */\nexport const logGlobalFlag = (flag, value, message, data) => {\n    logDiagnostic(LogEntryType.GLOBAL_FLAG, message, {\n        data: Object.assign({ flag,\n            value }, (data || {})),\n    });\n};\n/**\n * Log performance mark\n */\nexport const logPerformance = (name, duration, data) => {\n    logDiagnostic(LogEntryType.PERFORMANCE_MARK, `Performance: ${name}`, {\n        data: Object.assign({ name,\n            duration }, data),\n    });\n};\n/**\n * React hook for component lifecycle logging\n */\nexport const useDiagnosticLifecycle = (componentName) => {\n    useEffect(() => {\n        // Component mounted\n        logComponentRender(componentName, 'mount', `${componentName} mounted`);\n        // Component will unmount\n        return () => {\n            logComponentRender(componentName, 'unmount', `${componentName} unmounted`);\n        };\n    }, [componentName]);\n};\n/**\n * Get all diagnostic logs\n */\nexport const getDiagnosticLogs = () => {\n    // First check in-memory logs\n    if (inMemoryLog.length > 0) {\n        return [...inMemoryLog];\n    }\n    // If we're in the browser, check localStorage\n    if (isBrowser) {\n        try {\n            const storedLogs = localStorage.getItem('__STYLIST_DIAGNOSTICS_LOGS');\n            if (storedLogs) {\n                return JSON.parse(storedLogs);\n            }\n        }\n        catch (error) {\n            console.error('Error retrieving logs from localStorage:', error);\n        }\n    }\n    // In browser context, we can't directly read from disk.\n    // This will be handled by the diagnose.js script in Node.js environment.\n    return [];\n};\n/**\n * Clear diagnostic logs\n */\nexport const clearDiagnosticLogs = () => {\n    inMemoryLog = [];\n    // Clear localStorage logs if we're in the browser\n    if (isBrowser) {\n        try {\n            localStorage.removeItem('__STYLIST_DIAGNOSTICS_LOGS');\n        }\n        catch (error) {\n            // Silently fail if localStorage is not available\n        }\n    }\n    // In browser context, we can't directly write to disk.\n    // File operations will be handled by the diagnose.js script.\n};\nexport default {\n    logDiagnostic,\n    logComponentRender,\n    logSuspense,\n    logLazyLoad,\n    logHook,\n    logStore,\n    logErrorBoundary,\n    logGlobalFlag,\n    logPerformance,\n    useDiagnosticLifecycle,\n    getDiagnosticLogs,\n    clearDiagnosticLogs,\n    LogEntryType,\n    LogLevel,\n};\n","/**\n * useOfflineMode Hook\n *\n * React hook for accessing offline mode functionality in components\n */\nimport { useState, useEffect, useCallback } from 'react';\nimport { addNetworkStatusListener, getNetworkStatus, setOfflineMode as setOfflineModeService, isOfflineModeEnabled as checkOfflineModeEnabled } from '../services/offlineService';\n/**\n * Hook for managing offline mode in components\n *\n * @param hasOfflineData Whether the component has offline data available\n * @returns Object with offline mode state and controls\n */\nexport const useOfflineMode = (hasOfflineData = false) => {\n    // Track network status\n    const [isOnline, setIsOnline] = useState(getNetworkStatus());\n    // Track manual offline mode\n    const [isOfflineMode, setIsOfflineMode] = useState(checkOfflineModeEnabled());\n    // Track if a network error occurred\n    const [isNetworkError, setIsNetworkError] = useState(false);\n    // Listen for network status changes\n    useEffect(() => {\n        // Add listener and get cleanup function\n        const removeListener = addNetworkStatusListener((online) => {\n            setIsOnline(online);\n            // Reset network error when connection is restored\n            if (online) {\n                setIsNetworkError(false);\n            }\n        });\n        // Cleanup on unmount\n        return () => {\n            removeListener();\n        };\n    }, []);\n    // Handler for setting offline mode\n    const setOfflineMode = useCallback((enabled) => {\n        setOfflineModeService(enabled);\n        setIsOfflineMode(enabled);\n    }, []);\n    // Handler for reporting network errors\n    const reportNetworkError = useCallback(() => {\n        setIsNetworkError(true);\n    }, []);\n    return {\n        isOnline,\n        isOfflineMode,\n        setOfflineMode,\n        hasOfflineData,\n        isNetworkError\n    };\n};\nexport default useOfflineMode;\n","// Hook for automatically synchronizing store operations with backend\nimport { useEffect, useCallback } from 'react';\nimport { useUserStore } from '../store/userStore';\nimport useRecommendationStore from '../store/recommendationStore';\nimport { useSyncService } from '../services/syncService';\n/**\n * Hook that connects store operations to sync service\n * Ensures that changes to the store are synchronized with backend\n */\nexport const useSyncedStore = () => {\n    const userStore = useUserStore();\n    const recommendationStore = useRecommendationStore();\n    const syncService = useSyncService();\n    // Sync closet operations\n    const addToCloset = useCallback((item) => {\n        if (!userStore.user)\n            return;\n        // Add to local store first\n        const now = new Date();\n        const id = `item_${now.getTime()}_${Math.random().toString(36).substring(2, 9)}`;\n        const newItem = Object.assign(Object.assign({}, item), { id, dateAdded: now, favorite: item.favorite || false, tags: item.tags || [] });\n        userStore.addToCloset(newItem);\n        // Queue for syncing\n        syncService.addClosetItem(item, userStore.user.userId);\n    }, [userStore, syncService]);\n    const removeFromCloset = useCallback((itemId) => {\n        if (!userStore.user)\n            return;\n        // Update local store first\n        userStore.removeFromCloset(itemId);\n        // Queue for syncing\n        syncService.removeClosetItem(itemId, userStore.user.userId);\n    }, [userStore, syncService]);\n    const toggleItemFavorite = useCallback((itemId, favorite) => {\n        if (!userStore.user)\n            return;\n        // Update local store first\n        userStore.toggleItemFavorite(itemId, favorite);\n        // Queue for syncing\n        syncService.toggleFavorite(itemId, favorite, userStore.user.userId);\n    }, [userStore, syncService]);\n    // Sync user preferences\n    const updatePreferences = useCallback((preferences) => {\n        if (!userStore.user)\n            return;\n        // Update local store first\n        userStore.updateUser({\n            preferences: Object.assign(Object.assign({}, userStore.user.preferences), preferences)\n        });\n        // Queue for syncing\n        syncService.updatePreferences(preferences, userStore.user.userId);\n    }, [userStore, syncService]);\n    // Sync quiz results\n    const submitStyleQuiz = useCallback((answers) => {\n        if (!userStore.user)\n            return;\n        // Submit to server (store update will happen when results are returned)\n        syncService.submitQuiz(answers, userStore.user.userId);\n    }, [userStore, syncService]);\n    // Sync feedback data\n    const addLikedItem = useCallback((itemId) => {\n        if (!userStore.user)\n            return;\n        // Update local store first\n        userStore.addLikedItem(itemId);\n        // No need to queue this specifically, it will be synced with full profile\n    }, [userStore]);\n    const addDislikedItem = useCallback((itemId) => {\n        if (!userStore.user)\n            return;\n        // Update local store first\n        userStore.addDislikedItem(itemId);\n        // No need to queue this specifically, it will be synced with full profile\n    }, [userStore]);\n    const saveOutfit = useCallback((outfit) => {\n        if (!userStore.user)\n            return;\n        // Add to local recommendation store\n        recommendationStore.saveOutfit(outfit);\n        // Queue for syncing\n        syncService.saveOutfit(outfit, userStore.user.userId);\n    }, [userStore, recommendationStore, syncService]);\n    const removeSavedOutfit = useCallback((outfitId) => {\n        if (!userStore.user)\n            return;\n        // Remove from local recommendation store\n        recommendationStore.removeSavedOutfit(outfitId);\n        // Queue for syncing\n        syncService.removeOutfit(outfitId, userStore.user.userId);\n    }, [userStore, recommendationStore, syncService]);\n    // Initial sync when component mounts\n    useEffect(() => {\n        if (userStore.user) {\n            syncService.syncNow();\n        }\n    }, [userStore.user, syncService]);\n    // Return wrapped functions that handle both local state and sync\n    return {\n        // Sync status\n        syncState: syncService.state,\n        syncNow: syncService.syncNow,\n        // Closet operations\n        addToCloset,\n        removeFromCloset,\n        toggleItemFavorite,\n        // Preference operations\n        updatePreferences,\n        // Quiz operations\n        submitStyleQuiz,\n        // Feedback operations\n        addLikedItem,\n        addDislikedItem,\n        // Outfit operations\n        saveOutfit,\n        removeSavedOutfit\n    };\n};\nexport default useSyncedStore;\n","// Hook for background removal functionality\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { useState, useCallback, useEffect } from 'react';\nimport { BackgroundRemovalMethod, ProcessingStatus } from '@/types/tryOn';\nimport { removeBackground, isTensorflowSupported, preloadBodyPixModel } from '@/services/background-removal/utils';\nimport { useTryOnStore } from '@/store/tryOnStore';\nexport const useBackgroundRemoval = (options) => {\n    const [isProcessing, setIsProcessing] = useState(false);\n    const [progress, setProgress] = useState(0);\n    const [error, setError] = useState(null);\n    const settings = useTryOnStore((state) => state.settings);\n    const updateUserImage = useTryOnStore((state) => state.updateUserImage);\n    // Check if TensorFlow.js is supported\n    const [tensorflowSupported, setTensorflowSupported] = useState(null);\n    // Check TensorFlow.js support on mount\n    useEffect(() => {\n        const checkSupport = () => __awaiter(void 0, void 0, void 0, function* () {\n            try {\n                const supported = yield isTensorflowSupported();\n                setTensorflowSupported(supported);\n                // If supported, preload the model\n                if (supported) {\n                    preloadBodyPixModel();\n                }\n            }\n            catch (error) {\n                console.warn('Error checking TensorFlow support:', error);\n                setTensorflowSupported(false);\n            }\n        });\n        checkSupport();\n    }, []);\n    // Process image to remove background\n    const removeImageBackground = useCallback((image) => __awaiter(void 0, void 0, void 0, function* () {\n        try {\n            setIsProcessing(true);\n            setProgress(10);\n            setError(null);\n            // Update image status\n            updateUserImage({\n                processingStatus: ProcessingStatus.REMOVING_BACKGROUND\n            });\n            // Determine removal method\n            let method = settings.preferredBackgroundRemovalMethod;\n            // If TensorFlow.js is not supported but selected, fall back to API\n            if (method === BackgroundRemovalMethod.TENSORFLOW &&\n                tensorflowSupported === false) {\n                console.log('TensorFlow.js not supported, falling back to Remove.bg API');\n                method = BackgroundRemovalMethod.REMOVE_BG_API;\n            }\n            setProgress(25);\n            // Track start time for timeout detection\n            const startTime = Date.now();\n            const TIMEOUT_MS = 10000; // 10 seconds timeout\n            // Use optimized resolution for all devices to ensure compatibility\n            const shouldUseOptimized = true;\n            const optimizeOptions = shouldUseOptimized ?\n                {\n                    width: 800,\n                    height: 800,\n                    quality: 'medium' // Explicitly type as one of the allowed values\n                } :\n                undefined;\n            console.log(`Using ${shouldUseOptimized ? 'optimized' : 'standard'} image processing for background removal`);\n            // Use Promise.race to add timeout handling\n            const removalPromise = removeBackground(image.url, {\n                method,\n                apiKey: settings.apiKey,\n                fallbackToTensorflow: method === BackgroundRemovalMethod.REMOVE_BG_API && tensorflowSupported === true,\n                optimizeOptions // Pass optimization options to the background removal function\n            });\n            // Proceed with background removal with timeout handling\n            const timeoutPromise = new Promise((_, reject) => {\n                setTimeout(() => {\n                    reject(new Error('Background removal timed out'));\n                }, TIMEOUT_MS);\n            });\n            const result = yield Promise.race([\n                removalPromise,\n                timeoutPromise\n            ]);\n            setProgress(90);\n            // Check if result is successful\n            if (!result || !result.success || !result.imageUrl) {\n                // If background removal failed but there's a partial result with imageUrl, use it\n                if (result && result.imageUrl) {\n                    // Update with partial result\n                    const partialImage = Object.assign(Object.assign({}, image), { url: result.imageUrl, backgroundRemoved: true, processingStatus: ProcessingStatus.COMPLETED, processingWarning: result.error || 'Background removal partially succeeded' });\n                    updateUserImage(partialImage);\n                    setProgress(100);\n                    return partialImage;\n                }\n                throw new Error((result === null || result === void 0 ? void 0 : result.error) || 'Failed to remove background');\n            }\n            // Update image with background removed\n            const updatedImage = Object.assign(Object.assign({}, image), { url: result.imageUrl, backgroundRemoved: true, processingStatus: ProcessingStatus.COMPLETED, bodyMeasurements: result.bodyMeasurements });\n            // Update user image in store\n            updateUserImage(updatedImage);\n            setProgress(100);\n            // Call success callback if provided\n            if (options === null || options === void 0 ? void 0 : options.onSuccess) {\n                options.onSuccess(updatedImage);\n            }\n            return updatedImage;\n        }\n        catch (error) {\n            console.error('Background removal error:', error);\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            setError(errorMessage);\n            // Check for WebGL shader error patterns\n            const isWebGLError = errorMessage.toLowerCase().includes('webgl') ||\n                errorMessage.toLowerCase().includes('shader') ||\n                errorMessage.toLowerCase().includes('compilation');\n            // Create a user-friendly error message\n            const userFriendlyError = isWebGLError\n                ? 'Your browser may not fully support 3D graphics required for background removal. Using original image instead.'\n                : errorMessage;\n            // For WebGL errors, use a completed status with the original image\n            if (isWebGLError) {\n                const fallbackImage = Object.assign(Object.assign({}, image), { processingStatus: ProcessingStatus.COMPLETED, backgroundRemoved: false, processingWarning: 'WebGL not fully supported. Using original image.' });\n                // Update user image in store\n                updateUserImage(fallbackImage);\n                return fallbackImage;\n            }\n            else {\n                // Standard error handling for non-WebGL errors\n                updateUserImage({\n                    processingStatus: ProcessingStatus.FAILED,\n                    processingError: userFriendlyError\n                });\n                // Call error callback if provided\n                if (options === null || options === void 0 ? void 0 : options.onError) {\n                    options.onError(userFriendlyError);\n                }\n                // Return original image with error status\n                return Object.assign(Object.assign({}, image), { processingStatus: ProcessingStatus.FAILED, processingError: userFriendlyError });\n            }\n        }\n        finally {\n            setIsProcessing(false);\n        }\n    }), [settings, tensorflowSupported, updateUserImage, options]);\n    return {\n        removeImageBackground,\n        isProcessing,\n        progress,\n        error,\n        tensorflowSupported,\n        reset: () => {\n            setError(null);\n            setProgress(0);\n        }\n    };\n};\n","// Hook for image processing functionality\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { useState, useCallback } from 'react';\nimport { ProcessingStatus } from '@/types/tryOn';\nimport { useTryOnStore } from '@/store/tryOnStore';\nimport { fileToDataUrl, getImageDimensions } from '@/services/image-processing/fileUtils';\nimport { calculateAspectRatioDimensions } from '@/services/image-processing/imageScaling';\nimport { useBackgroundRemoval } from './useBackgroundRemoval';\nexport const useImageProcessing = (options) => {\n    const [isProcessing, setIsProcessing] = useState(false);\n    const [progress, setProgress] = useState(0);\n    const [error, setError] = useState(null);\n    // Get state and actions from store\n    const settings = useTryOnStore((state) => state.settings);\n    const setUserImage = useTryOnStore((state) => state.setUserImage);\n    const updateUserImage = useTryOnStore((state) => state.updateUserImage);\n    // Background removal hook\n    const { removeImageBackground } = useBackgroundRemoval({\n        onError: (errorMsg) => setError(errorMsg)\n    });\n    // Process image (load, resize, and optionally remove background)\n    const processImage = useCallback((file) => __awaiter(void 0, void 0, void 0, function* () {\n        try {\n            setIsProcessing(true);\n            setProgress(0);\n            setError(null);\n            // Check if file is an image\n            if (!file.type.startsWith('image/')) {\n                throw new Error('File is not an image');\n            }\n            // Create initial user image object\n            const userImage = {\n                id: `img_${Date.now()}`,\n                url: '',\n                file,\n                processingStatus: ProcessingStatus.UPLOADING\n            };\n            // Store initial state\n            setUserImage(userImage);\n            // Convert to data URL\n            setProgress(10);\n            const dataUrl = yield fileToDataUrl(file);\n            // Get image dimensions\n            setProgress(20);\n            const dimensions = yield getImageDimensions(dataUrl);\n            // Resize if needed\n            const processedUrl = dataUrl;\n            let processedDimensions = dimensions;\n            const maxWidth = (options === null || options === void 0 ? void 0 : options.maxWidth) || 1200;\n            const maxHeight = (options === null || options === void 0 ? void 0 : options.maxHeight) || 1600;\n            if (dimensions.width > maxWidth || dimensions.height > maxHeight) {\n                setProgress(30);\n                processedDimensions = calculateAspectRatioDimensions(dimensions.width, dimensions.height, undefined, undefined, maxWidth, maxHeight);\n                // Resize image (will happen when drawing to canvas)\n                // processedUrl remains the same for now\n            }\n            // Update user image with URL and dimensions\n            const updatedImage = Object.assign(Object.assign({}, userImage), { url: processedUrl, dimensions: processedDimensions, originalDimensions: dimensions, processingStatus: ProcessingStatus.PROCESSING });\n            setUserImage(updatedImage);\n            setProgress(40);\n            // Optionally remove background\n            const autoRemoveBackground = (options === null || options === void 0 ? void 0 : options.autoRemoveBackground) !== undefined\n                ? options.autoRemoveBackground\n                : settings.removeBackgroundAutomatically;\n            let finalImage = updatedImage;\n            if (autoRemoveBackground) {\n                // Update status\n                updateUserImage({\n                    processingStatus: ProcessingStatus.REMOVING_BACKGROUND\n                });\n                // Process with background removal\n                finalImage = yield removeImageBackground(updatedImage);\n            }\n            else {\n                // Mark as completed without background removal\n                finalImage = Object.assign(Object.assign({}, updatedImage), { processingStatus: ProcessingStatus.COMPLETED });\n                updateUserImage(finalImage);\n            }\n            setProgress(100);\n            // Call completion callback if provided\n            if (options === null || options === void 0 ? void 0 : options.onProcessingComplete) {\n                options.onProcessingComplete(finalImage);\n            }\n            return finalImage;\n        }\n        catch (error) {\n            console.error('Image processing error:', error);\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            setError(errorMessage);\n            // Update image status to failed\n            updateUserImage({\n                processingStatus: ProcessingStatus.FAILED,\n                processingError: errorMessage\n            });\n            return null;\n        }\n        finally {\n            setIsProcessing(false);\n        }\n    }), [\n        options,\n        settings.removeBackgroundAutomatically,\n        setUserImage,\n        updateUserImage,\n        removeImageBackground\n    ]);\n    return {\n        processImage,\n        isProcessing,\n        progress,\n        error,\n        reset: () => {\n            setError(null);\n            setProgress(0);\n        }\n    };\n};\n","// Main hook for virtual try-on functionality\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { useState, useCallback, useEffect } from 'react';\nimport { useTryOnStore } from '@/store/tryOnStore';\nimport { useImageProcessing } from './useImageProcessing';\nimport { canvasToImage } from '@/services/image-processing/canvasUtils';\nimport { getImageDimensions } from '@/services/image-processing/fileUtils';\nimport { getDefaultBodyPosition, getDefaultZIndex } from '@/services/image-processing/imagePositioning';\nexport const useTryOn = () => {\n    const { currentOutfit, userImage, settings, isLoading, error, canvasWidth, canvasHeight, setCurrentOutfit, addGarmentToOutfit, removeGarmentFromOutfit, updateGarment, \n    /* setUserImage and updateUserImage are defined but not used directly */\n    clearUserImage, setLoading, setError, saveResult, openTryOnModal, closeTryOnModal } = useTryOnStore();\n    const { processImage } = useImageProcessing();\n    const [canvasRef, setCanvasRef] = useState(null);\n    // Initialize a new outfit if none exists\n    useEffect(() => {\n        if (!currentOutfit) {\n            setCurrentOutfit({\n                id: `outfit_${Date.now()}`,\n                garments: [],\n                createdAt: new Date()\n            });\n        }\n    }, [currentOutfit, setCurrentOutfit]);\n    // Upload user image for try-on\n    const uploadUserImage = useCallback((file) => __awaiter(void 0, void 0, void 0, function* () {\n        setLoading(true);\n        setError(null);\n        try {\n            yield processImage(file);\n        }\n        catch (error) {\n            console.error('Error uploading user image:', error);\n            setError(error instanceof Error ? error.message : String(error));\n        }\n        finally {\n            setLoading(false);\n        }\n    }), [processImage, setLoading, setError]);\n    // Add a garment to the current outfit\n    const addGarment = useCallback((garmentImage, type) => __awaiter(void 0, void 0, void 0, function* () {\n        setLoading(true);\n        try {\n            let url;\n            let dimensions;\n            // If a file was provided, convert to data URL\n            if (typeof garmentImage === 'string') {\n                url = garmentImage;\n                dimensions = yield getImageDimensions(url);\n            }\n            else {\n                // Convert file to data URL\n                const reader = new FileReader();\n                url = yield new Promise((resolve, reject) => {\n                    reader.onload = () => resolve(reader.result);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(garmentImage);\n                });\n                dimensions = yield getImageDimensions(url);\n            }\n            // Create garment info\n            const garment = {\n                id: `garment_${Date.now()}_${Math.floor(Math.random() * 1000)}`,\n                url,\n                type,\n                bodyPosition: getDefaultBodyPosition(type),\n                zIndex: getDefaultZIndex(type),\n                layerIndex: (currentOutfit === null || currentOutfit === void 0 ? void 0 : currentOutfit.garments.length) || 0,\n                dimensions,\n                originalDimensions: dimensions,\n                scale: settings.defaultGarmentScale[type],\n                offset: settings.defaultGarmentOffset[type]\n            };\n            // Add to outfit\n            addGarmentToOutfit(garment);\n        }\n        catch (error) {\n            console.error('Error adding garment:', error);\n            setError(error instanceof Error ? error.message : String(error));\n        }\n        finally {\n            setLoading(false);\n        }\n    }), [\n        currentOutfit === null || currentOutfit === void 0 ? void 0 : currentOutfit.garments.length,\n        settings.defaultGarmentScale,\n        settings.defaultGarmentOffset,\n        addGarmentToOutfit,\n        setLoading,\n        setError\n    ]);\n    // Remove a garment from the current outfit\n    const removeGarment = useCallback((garmentId) => {\n        removeGarmentFromOutfit(garmentId);\n    }, [removeGarmentFromOutfit]);\n    // Update a garment's properties\n    const updateGarmentProperties = useCallback((garmentId, properties) => {\n        updateGarment(garmentId, properties);\n    }, [updateGarment]);\n    // Save the current try-on result\n    const saveTryOnResult = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        if (!canvasRef || !currentOutfit || !userImage) {\n            return;\n        }\n        try {\n            setLoading(true);\n            // Convert canvas to image\n            const resultImageUrl = yield canvasToImage(canvasRef);\n            // Create result object\n            const result = {\n                id: `result_${Date.now()}`,\n                outfitId: currentOutfit.id,\n                userId: 'current_user',\n                userImageUrl: userImage.url,\n                resultImageUrl,\n                garmentIds: currentOutfit.garments.map((g) => g.id),\n                createdAt: new Date()\n            };\n            // Save result\n            saveResult(result);\n            return result;\n        }\n        catch (error) {\n            console.error('Error saving try-on result:', error);\n            setError(error instanceof Error ? error.message : String(error));\n            return null;\n        }\n        finally {\n            setLoading(false);\n        }\n    }), [canvasRef, currentOutfit, userImage, setLoading, setError, saveResult]);\n    // Start new try-on session\n    const startNewTryOn = useCallback((garmentImage, garmentType) => {\n        // Create a new outfit\n        const newOutfit = {\n            id: `outfit_${Date.now()}`,\n            garments: [],\n            createdAt: new Date()\n        };\n        setCurrentOutfit(newOutfit);\n        // Add garment if provided\n        if (garmentImage && garmentType) {\n            addGarment(garmentImage, garmentType);\n        }\n        // Open try-on modal\n        openTryOnModal();\n    }, [setCurrentOutfit, addGarment, openTryOnModal]);\n    // Try on a specific outfit\n    const tryOnOutfit = useCallback((outfit) => {\n        setCurrentOutfit(outfit);\n        openTryOnModal();\n    }, [setCurrentOutfit, openTryOnModal]);\n    return {\n        // State\n        currentOutfit,\n        userImage,\n        isLoading,\n        error,\n        canvasWidth,\n        canvasHeight,\n        showGuidelines: settings.showGuidelines,\n        // Canvas ref\n        canvasRef,\n        setCanvasRef,\n        // Actions\n        uploadUserImage,\n        addGarment,\n        removeGarment,\n        updateGarmentProperties,\n        clearUserImage,\n        saveTryOnResult,\n        startNewTryOn,\n        tryOnOutfit,\n        closeTryOnModal\n    };\n};\n","import { Fragment as _Fragment, jsx as _jsx } from \"react/jsx-runtime\";\n// React hooks for component lifecycle diagnostic monitoring\nimport React, { useEffect, useState, useRef, Suspense } from 'react';\nimport { logComponentRender, logSuspense, logLazyLoad, logErrorBoundary, logHook } from './diagnostics';\n/**\n * Hook to monitor component lifecycle\n * @param componentName The name of the component to monitor\n */\nexport const useDiagnosticLifecycle = (componentName) => {\n    // Tracking mount state\n    const mountedRef = useRef(false);\n    // Tracking render count\n    const renderCountRef = useRef(0);\n    // Timing render performance\n    const renderStartTimeRef = useRef(performance.now());\n    // Log the first render\n    if (!mountedRef.current) {\n        renderStartTimeRef.current = performance.now();\n        logComponentRender(componentName, 'mount', `${componentName} initial render starting`);\n    }\n    // Increment render count and log updates\n    renderCountRef.current += 1;\n    const isInitialRender = renderCountRef.current === 1;\n    if (!isInitialRender) {\n        logComponentRender(componentName, 'update', `${componentName} re-render #${renderCountRef.current - 1}`, { renderCount: renderCountRef.current });\n    }\n    // Log mount completion on first effect\n    useEffect(() => {\n        if (!mountedRef.current) {\n            const mountDuration = performance.now() - renderStartTimeRef.current;\n            mountedRef.current = true;\n            logComponentRender(componentName, 'mount', `${componentName} mounted`, {\n                renderCount: renderCountRef.current,\n                mountDuration: `${mountDuration.toFixed(2)}ms`\n            });\n        }\n        // Log unmount\n        return () => {\n            logComponentRender(componentName, 'unmount', `${componentName} unmounted`, {\n                totalRenderCount: renderCountRef.current\n            });\n        };\n    }, [componentName]);\n};\n/**\n * Hook to monitor effects\n * @param componentName The name of the component\n * @param effectName Name of the effect for identification\n * @param deps The dependency array\n * @param effectFn The effect function\n */\nexport const useDiagnosticEffect = (componentName, effectName, deps, effectFn) => {\n    const effectRunCountRef = useRef(0);\n    useEffect(() => {\n        // Log effect starting\n        effectRunCountRef.current += 1;\n        const runCount = effectRunCountRef.current;\n        logHook(componentName, effectName, 'update', `${effectName} effect triggered in ${componentName}`, {\n            runCount,\n            dependencies: deps ? `Dependencies array length: ${deps.length}` : 'No dependencies'\n        });\n        const startTime = performance.now();\n        // Run the effect\n        const cleanup = effectFn();\n        const duration = performance.now() - startTime;\n        logHook(componentName, effectName, 'update', `${effectName} effect completed in ${componentName}`, {\n            runCount,\n            duration: `${duration.toFixed(2)}ms`,\n            hasCleanup: !!cleanup\n        });\n        // Return cleanup function\n        return () => {\n            if (cleanup) {\n                logHook(componentName, effectName, 'cleanup', `${effectName} effect cleanup in ${componentName}`, { runCount });\n                cleanup();\n            }\n        };\n    }, deps);\n};\n/**\n * Hook to monitor state changes\n * @param componentName The name of the component\n * @param stateName Name of the state variable\n * @param initialValue The initial state value\n * @returns A tuple of [state, setState] just like useState\n */\nexport function useDiagnosticState(componentName, stateName, initialValue) {\n    const [state, setState] = useState(initialValue);\n    const updatesRef = useRef(0);\n    const initialRef = useRef(true);\n    if (initialRef.current) {\n        logHook(componentName, `state:${stateName}`, 'init', `${stateName} state initialized in ${componentName}`, {\n            initialValue: typeof initialValue === 'function'\n                ? '(function)'\n                : initialValue\n        });\n        initialRef.current = false;\n    }\n    const setStateWithLogging = React.useCallback((value) => {\n        const updateCount = updatesRef.current + 1;\n        updatesRef.current = updateCount;\n        const valueIsFunction = typeof value === 'function';\n        logHook(componentName, `state:${stateName}`, 'update', `${stateName} state update in ${componentName}`, {\n            updateCount,\n            setterType: valueIsFunction ? 'function' : 'value',\n            newValue: !valueIsFunction ? value : '(function)'\n        });\n        setState(value);\n    }, [componentName, stateName]);\n    return [state, setStateWithLogging];\n}\n/**\n * Creates a monitored lazy component\n * @param factory The component factory function\n * @param componentName Name of the component for logging\n * @returns A lazy component with monitoring\n */\nexport function monitoredLazy(factory, componentName) {\n    return React.lazy(() => {\n        logLazyLoad(componentName, 'start', `${componentName} lazy loading started`);\n        const startTime = performance.now();\n        return factory()\n            .then(module => {\n            const loadTime = performance.now() - startTime;\n            logLazyLoad(componentName, 'complete', `${componentName} lazy loading completed`, {\n                loadTime: `${loadTime.toFixed(2)}ms`\n            });\n            return module;\n        })\n            .catch(error => {\n            logLazyLoad(componentName, 'error', `${componentName} lazy loading error: ${error.message}`, {\n                error: error.message,\n                stack: error.stack\n            });\n            throw error;\n        });\n    });\n}\n/**\n * A diagnostic suspense component that logs suspense events\n */\nexport const DiagnosticSuspense = ({ children, fallback, componentName = 'unknown' }) => {\n    const suspendedRef = useRef(false);\n    const resolvedRef = useRef(false);\n    const suspenseNameRef = useRef(`Suspense[${componentName}]`);\n    // Use a wrapper to track when fallback is shown\n    const FallbackTracker = ({ children }) => {\n        useEffect(() => {\n            if (!suspendedRef.current) {\n                suspendedRef.current = true;\n                logSuspense(suspenseNameRef.current, 'fallback', `Suspense fallback shown for ${componentName}`);\n            }\n            return () => {\n                if (!resolvedRef.current) {\n                    resolvedRef.current = true;\n                    logSuspense(suspenseNameRef.current, 'resolved', `Suspense resolved for ${componentName}`);\n                }\n            };\n        }, []);\n        return _jsx(_Fragment, { children: children });\n    };\n    return (_jsx(Suspense, Object.assign({ fallback: _jsx(FallbackTracker, { children: fallback }) }, { children: children })));\n};\n/**\n * A diagnostic error boundary component that logs error boundary events\n */\nexport class DiagnosticErrorBoundary extends React.Component {\n    constructor() {\n        super(...arguments);\n        this.state = { hasError: false, error: null };\n        this.resetError = () => {\n            this.setState({ hasError: false, error: null });\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return { hasError: true, error };\n    }\n    componentDidCatch(error, info) {\n        const { componentName = 'unknown', onError } = this.props;\n        logErrorBoundary(componentName, error, info);\n        if (onError) {\n            onError(error, info);\n        }\n    }\n    render() {\n        const { hasError, error } = this.state;\n        const { children, fallback, componentName = 'unknown' } = this.props;\n        if (hasError && error) {\n            return typeof fallback === 'function'\n                ? fallback(error, this.resetError)\n                : fallback;\n        }\n        return children;\n    }\n}\nexport default {\n    useDiagnosticLifecycle,\n    useDiagnosticEffect,\n    useDiagnosticState,\n    monitoredLazy,\n    DiagnosticSuspense,\n    DiagnosticErrorBoundary\n};\n"],"names":["USE_LAZY_LOADING","USE_PARALLEL_INIT","getSafeStoreValue","store","selector","defaultValue","_a","getState","error","initializeStores","window","__STYLIST_STORES_INITIALIZING","initStartTime","performance","now","phase","chatInitialState","isOpen","hasMessages","messages","length","currentView","e","Error","message","String","userInitialState","hasUser","user","recInitialState","itemCount","recommendedItems","outfitCount","recommendedOutfits","initDuration","duration","toFixed","__STYLIST_STORES_INITIALIZED","stack","undefined","setTimeout","timeoutDuration","createWidgetContainer","container","document","createElement","id","body","appendChild","mountStartTime","__STYLIST_WIDGET_DOM_MOUNTED","stylistContainer","getElementById","safetyTimeout","__STYLIST_WIDGET_RENDER_COMPLETE","elapsedTime","root","config","__StylistWidgetConfig","apiKey","retailerId","hasConfig","SyncProvider","render","children","Object","assign","clearTimeout","mountDuration","widgetAPI","init","hasApiKey","hasRetailerId","initResult","success","open","state","chatStore","toggleOpen","close","minimize","toggleMinimize","switchView","view","setCurrentView","requestedView","openStyleQuiz","__StylistShowStyleQuiz","setIsOpen","openVirtualTryOn","__StylistShowVirtualTryOn","__debug","addMockItems","recStore","setRecommendedItems","mockItems","name","brand","category","price","imageUrls","colors","sizes","url","matchScore","matchReasons","inStock","mockOutfit","occasion","items","setRecommendedOutfits","data","getDiagnostics","__STYLIST_DIAGNOSTICS","logs","flags","initialized","__STYLIST_WIDGET_INITIALIZED","mounted","renderComplete","storesInitialized","backgroundInitComplete","__STYLIST_BACKGROUND_INIT_COMPLETE","clearDiagnostics","localStorage","removeItem","StylistWidget","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","rejected","result","done","then","apply","status","setStatus","useState","isOnline","navigator","onLine","isSlowConnection","effectiveType","lastChecked","Date","updateConnectionQuality","useCallback","connection","prev","saveData","handleOnline","handleOffline","handleConnectionChange","useEffect","addEventListener","removeEventListener","checkConnection","controller","AbortController","timeoutId","abort","response","fetch","method","signal","isConnected","ok","_","LOG_DIAGNOSTICS","MAX_LOG_ENTRIES","LogEntryType","LogLevel","inMemoryLog","isBrowser","originalConsole","log","console","warn","info","debug","enabled","logDiagnostic","type","options","level","INFO","component","entry","timestamp","toISOString","push","slice","__STYLIST_DIAGNOSTICS_LOG_TO_TEMP","storedLogs","getItem","parsedLogs","JSON","parse","limitedLogs","setItem","stringify","logComponentRender","stage","typeMap","mount","COMPONENT_MOUNT","COMPONENT_RENDER","update","unmount","COMPONENT_UNMOUNT","COMPONENT_ERROR","action","CUSTOM","warning","levelMap","DEBUG","ERROR","WARNING","logSuspense","SUSPENSE_FALLBACK","SUSPENSE_RESOLVED","logLazyLoad","start","LAZY_LOAD_START","complete","LAZY_LOAD_COMPLETE","LAZY_LOAD_ERROR","logHook","hook","HOOK_INIT","EFFECT_START","EFFECT_CLEANUP","logStore","operation","STORE_INIT","STORE_UPDATE","subscribe","STORE_SUBSCRIPTION","unsubscribe","logErrorBoundary","ERROR_BOUNDARY","errorMessage","componentStack","logGlobalFlag","flag","GLOBAL_FLAG","logPerformance","PERFORMANCE_MARK","hasOfflineData","setIsOnline","isOfflineMode","setIsOfflineMode","isNetworkError","setIsNetworkError","removeListener","online","setOfflineMode","userStore","recommendationStore","syncService","addToCloset","item","getTime","Math","random","toString","substring","newItem","dateAdded","favorite","tags","addClosetItem","userId","removeFromCloset","itemId","removeClosetItem","toggleItemFavorite","toggleFavorite","updatePreferences","preferences","updateUser","submitStyleQuiz","answers","submitQuiz","addLikedItem","addDislikedItem","saveOutfit","outfit","removeSavedOutfit","outfitId","removeOutfit","syncNow","syncState","useImageProcessing","isProcessing","setIsProcessing","progress","setProgress","setError","settings","setUserImage","updateUserImage","removeImageBackground","tensorflowSupported","setTensorflowSupported","supported","image","processingStatus","REMOVING_BACKGROUND","preferredBackgroundRemovalMethod","TENSORFLOW","REMOVE_BG_API","TIMEOUT_MS","optimizeOptions","width","height","quality","removalPromise","fallbackToTensorflow","timeoutPromise","race","imageUrl","partialImage","backgroundRemoved","COMPLETED","processingWarning","updatedImage","bodyMeasurements","onSuccess","isWebGLError","toLowerCase","includes","userFriendlyError","fallbackImage","FAILED","processingError","onError","reset","useBackgroundRemoval","errorMsg","processImage","file","startsWith","userImage","UPLOADING","dataUrl","dimensions","processedUrl","processedDimensions","maxWidth","maxHeight","originalDimensions","PROCESSING","autoRemoveBackground","removeBackgroundAutomatically","finalImage","onProcessingComplete","useTryOn","currentOutfit","isLoading","canvasWidth","canvasHeight","setCurrentOutfit","addGarmentToOutfit","removeGarmentFromOutfit","updateGarment","clearUserImage","setLoading","saveResult","openTryOnModal","closeTryOnModal","canvasRef","setCanvasRef","garments","createdAt","uploadUserImage","addGarment","garmentImage","reader","FileReader","onload","onerror","readAsDataURL","garment","floor","bodyPosition","zIndex","layerIndex","scale","defaultGarmentScale","offset","defaultGarmentOffset","removeGarment","garmentId","updateGarmentProperties","properties","saveTryOnResult","resultImageUrl","userImageUrl","garmentIds","map","g","startNewTryOn","garmentType","newOutfit","tryOnOutfit","showGuidelines","useDiagnosticLifecycle","componentName","mountedRef","useRef","renderCountRef","renderStartTimeRef","current","renderCount","totalRenderCount","useDiagnosticEffect","effectName","deps","effectFn","effectRunCountRef","runCount","dependencies","startTime","cleanup","hasCleanup","monitoredLazy","factory","module","loadTime","catch","DiagnosticSuspense","fallback","suspendedRef","resolvedRef","suspenseNameRef","Suspense","DiagnosticErrorBoundary","constructor","super","arguments","this","hasError","resetError","setState","getDerivedStateFromError","componentDidCatch","props"],"sourceRoot":""}