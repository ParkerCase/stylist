"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[6591],{597:function(t,e,n){n.d(e,{bU:function(){return s},lj:function(){return r}});const i={},o={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function r(t,e){i[t]=e}function s(t){if(!(t in i)){const e=function(t){if(1!==t&&2!==t)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=function(t){if("undefined"!==typeof OffscreenCanvas&&2===t)return new OffscreenCanvas(300,150);if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(t);if(e.addEventListener("webglcontextlost",(e=>{e.preventDefault(),delete i[t]}),!1),1===t)return e.getContext("webgl",o)||e.getContext("experimental-webgl",o);return e.getContext("webgl2",o)}(t);if(null===e)return null;i[t]=e}const e=i[t];return e.isContextLost()?(delete i[t],s(t)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),i[t])}},4999:function(t,e,n){n.d(e,{E:function(){return i}});class i{constructor(t,e=!1,n=null,i=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const r=t.inHeight,s=t.inWidth,a=t.padInfo.top,u=t.padInfo.left,l=t.strideHeight,d=t.strideWidth,c=t.dilationHeight,h=t.dilationWidth,f=t.filterHeight,x=t.filterWidth,p=t.outChannels/t.inChannels;let g="",C="";n&&(g=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,C="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${l}, ${d});\n      const ivec2 pads = ivec2(${a}, ${u});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${p};\n        int q = d2 - d1 * ${p};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${f}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${r}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC++) {\n            int xC = xCCorner + wC * ${h};\n\n            if (xC < 0 || xC >= ${s}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${m}\n        ${C}\n        setOutput(result);\n      }\n    `}}},9662:function(t,e,n){n.d(e,{$:function(){return i}});class i{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(t,e){return(n,i)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(i,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(i,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}},10424:function(t,e,n){n.d(e,{K:function(){return o}});var i=n(9495);class o{constructor(t,e=!1,n=null,o=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;const s=t.outChannels/t.inChannels,a=t.inHeight,u=t.inWidth,l=t.padInfo.top,d=t.padInfo.left,c=t.strideHeight,h=t.strideWidth,f=t.dilationHeight,x=t.dilationWidth,p=t.filterHeight,g=t.filterWidth,C=g;let m="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let i=0;i<g;i++)m+=`\n          vec4 xTexelC${2*i};\n          int xTexelC${2*i}Ready;\n          vec4 xC${i};`;for(let y=0;y<p;y++){for(let t=0;t<g;t++)m+=`\n          xTexelC${2*t} = vec4(0.0);\n          xTexelC${2*t}Ready = 0;\n          xC${t} = vec4(0.0);`;m+=`\n        xR = xRCorner + ${y*f};\n        if (xR >=0 && xR < ${a}) {\n      `;for(let t=0;t<(C+1)/2;t++){const e=2*t,n=e*x;if(m+=`\n          xC = xCCorner + ${n};\n          `,1===h){if(e<g&&(d%2===1?(m+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ${u} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${u}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n              `,m+=1===x&&n>0?`\n                xC${e} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ${u}) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${u}) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${n}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                  }\n                  `):m+=`\n                if (xC >= 0 && xC < ${u} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${u}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xC${e} = xTexelC${n};\n                `,n+1<g)){const t=d%2===0?i.util.nearestLargerEven(x):x;x%2===0&&d%2===1||x%2!==0&&d%2!==1?(m+=`\n                  xCOffset = xC + ${d%2} + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < ${u} && xTexelC${n+2}Ready == 0) {\n                    xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${u}) {\n                      xTexelC${n+2}.zw = vec2(0.0);\n                    }\n                    xTexelC${n+2}Ready = 1;\n                  }\n                  `,x>1&&(m+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ${u} && xTexelC${n}Ready == 0) {\n                      xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${n}Ready = 1;\n                    }\n                    `),m+=`\n                  xC${e+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.xy);\n                  `):m+=1===t?`\n                    xC${e+1} = xTexelC${n};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < ${u} && xTexelC${n+2}Ready == 0) {\n                      xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ${u}) {\n                        xTexelC${n+2}.zw = vec2(0.0);\n                      }\n                      xTexelC${n+2}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${n+2};\n                    `}}else n<g&&(d%2===1?(m+=`\n                xCOffset = xC + 1 - ${h};\n                if(xCOffset >= 0 && xCOffset < ${u} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${u}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${u} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ${u}) {\n                    xTexelC${n+2}.zw = vec2(0.0);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n              `,n+1<g&&(m+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ${h};\n                  if(xCOffset >= 0 && xCOffset < ${u}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${n+2}.xy, final.xy);\n                `)):(m+=`\n                if(xC >= 0 && xC < ${u} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${u}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xCOffset = xC + ${h};\n                if(xCOffset >= 0 && xCOffset < ${u} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ${u}) {\n                    xTexelC${n+2}.zw = vec2(0.);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${n}.xy, xTexelC${n+2}.xy);\n              `,n+1<g&&(m+=`\n                  xC${e+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n                `)));e<g&&(m+=`\n            wTexel = getW(${y}, ${n}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,n+1<g&&(m+=`\n              wTexel = getW(${y}, ${n+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}m+="\n        }\n      "}let v="",$="";n&&(v=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,$="result = activation(result);");const R=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${c}, ${h});\n      const ivec2 pads = ivec2(${l}, ${d});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${m}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${R}\n        ${$}\n        setOutput(result);\n      }\n    `}}},14151:function(t,e,n){n.d(e,{P:function(){return o}});var i=n(9495);class o{constructor(t){this.outputShape=[],this.outputShape=i.backend_util.computeOutShape(t,1),this.variableNames=t.map(((t,e)=>`T${e}`));const e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];const n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++){const t=e[i-1];n.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${t}));`)}const o=e.length,r=e[e.length-1];n.push(`else setOutput(getT${o}(yR, yC-${r}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}},18765:function(t,e,n){n.d(e,{B:function(){return o}});var i=n(9495);function o(){let t,e,n,o,r,s,a,u,l,d;return 2===(0,i.env)().getNumber("WEBGL_VERSION")?(t="#version 300 es",e="in",n="out",o="in",r="texture",s="outputColor",a="out vec4 outputColor;",u="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",d="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(t="",e="attribute",n="varying",o="varying",r="texture2D",s="gl_FragColor",a="",u="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",d="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:t,attribute:e,varyingVs:n,varyingFs:o,texture2D:r,output:s,defineOutput:a,defineSpecialNaN:u,defineSpecialInf:l,defineRound:d}}},21005:function(t,e,n){n.d(e,{B:function(){return i},w:function(){return o}});class i{constructor(t,e=!1,n=null,i=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const r=t.padInfo.top,s=t.padInfo.left,a=t.strideHeight,u=t.strideWidth,l=t.dilationHeight,d=t.dilationWidth,c=t.filterHeight,h=t.filterWidth,f=4*Math.floor(t.inChannels/4),x=t.inChannels%4,p="channelsLast"===t.dataFormat,g=p?1:2,C=p?2:3,m=p?3:1;let v="",$="";n&&(v=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:o?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,$="result = activation(result);");const R=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${a}, ${u});\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${m}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${C}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${c}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${f}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${p}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===x}) {\n\n              if (${p}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${f}) *\n                    getW(wR, wC, ${f}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${f}, xR, xC) *\n                    getW(wR, wC, ${f}, d2);\n              }\n\n            } else if (${2===x}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2)\n              );\n\n              if (${p}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===x}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2),\n                getW(wR, wC, ${f} + 2, d2)\n              );\n\n              if (${p}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1),\n                  getX(batch, xR, xC, ${f} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC),\n                  getX(batch, ${f} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${R}\n        ${$}\n        setOutput(result);\n      }\n    `}}class o{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,n=t.padInfo.top,i=t.padInfo.left,o=t.strideDepth,r=t.strideHeight,s=t.strideWidth,a=t.dilationDepth,u=t.dilationHeight,l=t.dilationWidth,d=t.filterDepth,c=t.filterHeight,h=t.filterWidth,f=4*Math.floor(t.inChannels/4),x=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${o}, ${r}, ${s});\n      const ivec3 pads = ivec3(${e}, ${n}, ${i});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${a};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${c}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${f}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===x}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${f}) *\n                  getW(wF, wR, wC, ${f}, d2);\n              } else if (${2===x}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===x}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1),\n                  getX(batch, xF, xR, xC, ${f} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2),\n                  getW(wF, wR, wC, ${f} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},22897:function(t,e,n){n.d(e,{dR:function(){return o},x:function(){return r}});var i=n(9495);const o="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class r{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=i.backend_util.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}},27906:function(t,e,n){n.d(e,{w:function(){return i}});class i{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(t){return(e,n)=>{null==this.valueLoc&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}}},29643:function(t,e,n){n.d(e,{f:function(){return o}});var i=n(9495);class o{constructor(t,e,n,o,r,s){this.outputShape=[],this.variableNames=["x","mean","variance"],i.backend_util.assertAndGetBroadcastShape(t,e),i.backend_util.assertAndGetBroadcastShape(t,n);let a="0.0";null!=o&&(i.backend_util.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";null!=r&&(i.backend_util.assertAndGetBroadcastShape(t,r),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${u};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}},31445:function(t,e,n){n.d(e,{c:function(){return i}});class i{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map(((t,e)=>`T${e}`));const n=[];this.variableNames.forEach((t=>{n.push(`vec4 v${t} = get${t}AtOutCoords();`)}));const i=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${i};\n        setOutput(result);\n      }\n    `}}},32068:function(t,e,n){n.d(e,{e:function(){return i}});class i{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}},34673:function(t,e,n){n.d(e,{x:function(){return i}});class i{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}},35679:function(t,e,n){n.d(e,{$p:function(){return A.r}});var i=n(9495),o=n(88380);const r=(0,i.env)();r.registerFlag("HAS_WEBGL",(()=>r.getNumber("WEBGL_VERSION")>0)),r.registerFlag("WEBGL_VERSION",(()=>(0,o.Zj)(2)?2:(0,o.Zj)(1)?1:0)),r.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),r.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===r.get("WEBGL_VERSION"))),r.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),r.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),r.registerFlag("WEBGL_PACK",(()=>r.getBool("HAS_WEBGL"))),r.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>r.getBool("WEBGL_PACK"))),r.registerFlag("WEBGL_PACK_CLIP",(()=>r.getBool("WEBGL_PACK"))),r.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>r.getBool("WEBGL_PACK"))),r.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>r.getBool("WEBGL_PACK"))),r.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>r.getBool("WEBGL_PACK"))),r.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>r.getBool("WEBGL_PACK"))),r.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>r.getBool("WEBGL_PACK"))),r.registerFlag("WEBGL_PACK_REDUCE",(()=>r.getBool("WEBGL_PACK"))),r.registerFlag("WEBGL_LAZILY_UNPACK",(()=>r.getBool("WEBGL_PACK"))),r.registerFlag("WEBGL_CONV_IM2COL",(()=>r.getBool("WEBGL_PACK"))),r.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>(0,o.Se)(r.getNumber("WEBGL_VERSION")))),r.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>(0,o.jL)(r.getNumber("WEBGL_VERSION")))),r.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const t=r.getNumber("WEBGL_VERSION");return 0===t?0:(0,o.VJ)(t)})),r.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>r.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!i.device_util.isMobile())),r.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>(0,o.I2)(r.getNumber("WEBGL_VERSION")))),r.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!r.getBool("WEBGL_FORCE_F16_TEXTURES")&&r.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),r.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>(0,o.N6)(r.getNumber("WEBGL_VERSION")))),r.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>(0,o.Ut)(r.getNumber("WEBGL_VERSION")))),r.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>r.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),r.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)})),r.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>i.device_util.isMobile()&&r.getBool("IS_CHROME")?1:-1),(t=>{if(t<0&&-1!==t)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)}));var s=n(597),a=n(18765),u=n(92394),l=n(28560);class d{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=l.BB.DENSE;const e=(0,l.GM)(t),n=(0,a.B)();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${u.UG(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class c{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=l.BB.DENSE;const e=(0,l.GM)(t),n=(0,a.B)();this.outputShape=t,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${u.UG(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${e[0]}, ${e[1]}));\n        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class h{constructor(t){this.variableNames=["A"],this.outTexUsage=l.tT.DOWNLOAD;const e=(0,a.B)();this.outputShape=t,this.userCode=`\n      ${u.G2}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class f{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=l.tT.DOWNLOAD;const e=(0,a.B)();this.outputShape=t,this.userCode=`\n      ${u.G2}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}class x{constructor(t,e,n=!1){this.variableNames=["A"];const i=(0,a.B)(),[o,r]=e;this.outputShape=t;let s="result";n&&(s="floor(result * 255. + 0.5)"),this.userCode=`\n      ${u.fM(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${r};\n        int c = imod(flatIndex, ${r});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${r}.0, ${o}.0);\n        vec4 values = ${i.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${i.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class p{constructor(t,e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const i=(0,a.B)(),[o,r]=e;this.outputShape=t;let s="",l="result";n&&(l="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let e=0;e<=1;e++){const n=2*a+e;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${e} < ${t[2]}) {\n            localCoords[2] += ${e};\n            if(localCoords[1] + ${a} < ${t[1]}) {\n              localCoords[1] += ${a};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${r};\n              c = imod(flatIndex, ${r});\n              uv = (vec2(c, r) + halfCR) / vec2(${r}.0, ${o}.0);\n              values = ${i.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${u.fM(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${s}\n\n        ${i.output} = ${l};\n      }\n    `}}var g=n(47646);class C{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const e=(0,i.env)().getNumber("WEBGL_VERSION");null!=t?(this.gl=t,(0,s.lj)(e,t)):this.gl=(0,s.bU)(e);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(1===(0,i.env)().getNumber("WEBGL_VERSION")){const t="OES_texture_float",e="OES_texture_half_float";if(this.textureFloatExtension=o.HM(this.gl,t),o.Ql(this.gl,e))this.textureHalfFloatExtension=o.HM(this.gl,e);else if((0,i.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),o.Ql(this.gl,r))this.colorBufferHalfFloatExtension=o.HM(this.gl,r);else if((0,i.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",o.Ql(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!o.Ql(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=g.b1(this.gl),this.indexBuffer=g.Ng(this.gl),this.framebuffer=o.oN(this.gl),this.textureConfig=l.EZ(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,i.env)().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program,this.outputTexture;const t=this.gl;o.ul(t,(()=>t.finish())),o.ul(t,(()=>t.bindFramebuffer(t.FRAMEBUFFER,null))),o.ul(t,(()=>t.deleteFramebuffer(this.framebuffer))),o.ul(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,null))),o.ul(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null))),o.ul(t,(()=>t.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),g.cD(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),g.WH(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),g.Hw(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),g.qg(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,i){this.throwIfDisposed(),g.y7(this.gl,t,e,n,i,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),g.Me(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),g.bG(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(o.sA(this.gl,this.framebuffer),this.outputTexture=null),o.ul(this.gl,(()=>this.gl.deleteTexture(t)))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>g.ir(this.gl,e,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(t,e,n,i,o,r){return g.SD(this.gl,t,e,n,i,o,r,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return g.$k(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);const i=g.zP(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if((0,i.env)().getBool("WEBGL_FENCE_API_ENABLED")){const i=t,o=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{const t=i.clientWaitSync(o,0,0);return t===i.ALREADY_SIGNALED||t===i.CONDITION_SATISFIED},e=o}else(0,i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,(0,i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,(()=>g.uS(this.gl,e,n)))}createProgram(t){this.throwIfDisposed();const e=this.gl,n=o.yG(e,t);null==this.vertexShader&&(this.vertexShader=g.yr(e));const i=o.rC(e);return o.ul(e,(()=>e.attachShader(i,this.vertexShader))),o.ul(e,(()=>e.attachShader(i,n))),o.R7(e,i),this.debug&&o.bz(e,i),this.vertexAttrsAreBound||(this.setProgram(i),this.vertexAttrsAreBound=g.Z(e,this.program,this.vertexBuffer)),i}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&o.ul(this.gl,(()=>this.gl.deleteProgram(t)))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&o.bz(this.gl,this.program),o.ul(this.gl,(()=>this.gl.useProgram(t)))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?o.Rh(this.gl,t,e):o.Yn(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),o.ul(this.gl,(()=>this.gl.getAttribLocation(t,e)))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),o.y_(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();const[i,o]=l.NO(e,n);this.setOutputMatrixTextureDriver(t,i,o)}setOutputMatrixWriteRegion(t,e,n,i){this.setOutputMatrixWriteRegionDriver(n,t,i,e)}setOutputPackedMatrixWriteRegion(t,e,n,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&o.bz(this.gl,this.program),o.s6(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;this.debug&&this.debugValidate(),o.ul(t,(()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),o.ul(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=o.HM(this.gl,2===(0,i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2(),n=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,n),n}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===(0,i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const t=this.gl,e=this.getQueryTimerExtensionWebGL2();return void t.endQuery(e.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await i.util.repeatedTry((()=>this.disposed||this.isQueryAvailable(t,(0,i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(t,(0,i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(0===e)return null;if(2===e){const e=this.gl;return e.getQueryParameter(t,e.QUERY_RESULT)/1e6}{const e=this.getQueryTimerExtensionWebGL1();return e.getQueryObjectEXT(t,e.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const e=this.gl,n=this.getQueryTimerExtensionWebGL2(),i=e.getQueryParameter(t,e.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),i&&!this.disjoint}{const e=this.getQueryTimerExtensionWebGL1(),n=e.getQueryObjectEXT(t,e.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(e.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(t){return new Promise((e=>{this.addItemToPoll((()=>t.isFencePassed()),(()=>e()))}))}pollItems(){const t=function(t){let e=0;for(;e<t.length;++e){if(!t[e]())break}return e-1}(this.itemsToPoll.map((t=>t.isDoneFn)));for(let e=0;e<=t;++e){const{resolveFn:t}=this.itemsToPoll[e];t()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||i.util.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),o.SO(this.gl,t,this.framebuffer),this.debug&&o.s6(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(o.SO(this.gl,this.outputTexture,this.framebuffer),this.debug&&o.s6(this.gl)):o.sA(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();const i=this.gl;o.SO(i,t,this.framebuffer),this.debug&&o.s6(i),this.outputTexture=t,o.ul(i,(()=>i.viewport(0,0,e,n))),o.ul(i,(()=>i.scissor(0,0,e,n)))}setOutputMatrixWriteRegionDriver(t,e,n,i){this.throwIfDisposed(),o.ul(this.gl,(()=>this.gl.scissor(t,e,n,i)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}var m=n(27575);function v(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach(((t,n)=>{const o=t.logicalShape,r=e[n],s=r.shape;if(!i.util.arraysEqual(o,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${s} must match`);if(t.isUniform&&r.isUniform)return;const a=t.texShape,u=r.isUniform?null:r.texData.texShape;if(!i.util.arraysEqual(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)}))}var $=n(76905),R=n(30282),y=n(1404),E=n(47403),w=n(68173),b=n(74890),I=n(46969);const T=i.kernel_impls.whereImpl,_={};class O extends i.KernelBackend{constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,i.env)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==t){const t=(0,s.bU)((0,i.env)().getNumber("WEBGL_VERSION"));this.binaryCache=((e=(0,i.env)().getNumber("WEBGL_VERSION"))in _||(_[e]={}),_[e]),this.gpgpu=new C(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;var e;this.textureManager=new E.p(this.gpgpu),this.numMBBeforeWarning=null==(0,i.env)().global.screen?1024:(0,i.env)().global.screen.height*(0,i.env)().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new i.DataStorage(this,(0,i.engine)())}nextDataId(){return O.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(t,e,n){if(((0,i.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,i.env)().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===n&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const o={id:this.nextDataId()};return this.texData.set(o,{shape:e,dtype:n,values:t,usage:l.tT.UPLOAD,refCount:1}),o}refCount(t){if(this.texData.has(t)){return this.texData.get(t).refCount}return 0}incRef(t){this.texData.get(t).refCount++}decRef(t){if(this.texData.has(t)){this.texData.get(t).refCount--}}move(t,e,n,o,r){if((0,i.env)().getBool("DEBUG")&&this.checkNumericalProblems(e),"complex64"===o)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:o,values:e,usage:l.tT.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:n,dtype:o,complexTensorInfos:r,slice:s,shape:a,isPacked:u}=e;if(null!=s){let e;e=u?new b.rf(a,w.UC):new w.hE(a,w.UC);const n=this.runWebGLProgram(e,[{dataId:t,shape:a,dtype:o}],o),i=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),i}if(null!=n)return this.convertAndCacheOnCPU(t);if("string"===o)return n;const l=null!=this.activeTimers;let d,c;if(l&&(d=i.util.now()),"complex64"===o){const t=this.readSync(r.real.dataId),e=this.readSync(r.imag.dataId);c=i.backend_util.mergeRealAndImagArrays(t,e)}else c=this.getValuesFromTexture(t);return l&&(this.downloadWaitMs+=i.util.now()-d),this.convertAndCacheOnCPU(t,c)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise((t=>e.push(t)))}const e=this.texData.get(t),{values:n,shape:o,slice:r,dtype:s,complexTensorInfos:a,isPacked:u}=e;if(null!=r){let e;e=u?new b.rf(o,w.UC):new w.hE(o,w.UC);const n=this.runWebGLProgram(e,[{dataId:t,shape:o,dtype:s}],s),i=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),i}if(null!=n)return this.convertAndCacheOnCPU(t);if(!(0,i.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,i.env)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let d,c,h=null;if("complex64"!==s&&(0,i.env)().get("WEBGL_BUFFER_SUPPORTED")){d=this.decode(t);const e=this.texData.get(d.dataId);h=this.gpgpu.createBufferFromTexture(e.texture,...l.GM(o))}if(this.pendingRead.set(t,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const t=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),e=t[0],n=t[1];c=i.backend_util.mergeRealAndImagArrays(e,n)}else if(null==h)c=this.getValuesFromTexture(t);else{const t=i.util.sizeFromShape(o);c=this.gpgpu.downloadFloat32MatrixFromBuffer(h,t)}null!=d&&this.disposeIntermediateTensorInfo(d);const f=this.convertAndCacheOnCPU(t,c),x=this.pendingRead.get(t);return this.pendingRead.delete(t),x.forEach((t=>t(f))),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&(0,i.engine)().removeDataId(t,this),this.pendingDeletes--),f}bufferSync(t){const e=this.readSync(t.dataId);let n=e;if("string"===t.dtype)try{n=e.map((t=>i.util.decodeString(t)))}catch(o){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,i.buffer)(t.shape,t.dtype,n)}checkNumericalProblems(t){if(null!=t)for(let e=0;e<t.length;e++){const n=t[e];if(!o.dm(n)){if((0,i.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:e,dtype:n,isPacked:r}=this.texData.get(t),s=i.util.sizeFromShape(e);if((0,i.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(t),i=this.texData.get(n.dataId),o=this.gpgpu.downloadMatrixFromPackedTexture(i.texture,...l.GM(e)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),o}const a=(0,i.env)().getBool("WEBGL_PACK")&&!0===r,u=a?o.FP(e):e,d=a?new f(u):new h(u),c=this.runWebGLProgram(d,[{shape:u,dtype:n,dataId:t}],"float32"),x=this.texData.get(c.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(x.texture,x.texShape[0],x.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(c),p}timerAvailable(){return(0,i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(t){const e=this.activeTimers,n=[];let o=!1;null==this.programTimersStack?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,t();const r=i.util.flatten(this.activeTimers.map((t=>t.query))).filter((t=>null!=t)),s=i.util.flatten(this.activeTimers.map((t=>t.name))).filter((t=>null!=t));this.activeTimers=e,o&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if((0,i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(r);a.kernelMs=i.util.sum(t),a.getExtraProfileInfo=()=>t.map(((t,e)=>({name:s[e],ms:t}))).map((t=>`${t.name}: ${t.ms}`)).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:i.util.now(),endMs:null}}endTimer(t){return(0,i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=i.util.now(),t)}async getQueryTime(t){if((0,i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:n}=this.texData.get(t);return null!=n&&(this.disposeData(n.real.dataId,e),this.disposeData(n.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:n,texShape:i,usage:o,isPacked:r,slice:s}=this.texData.get(t),a=s&&s.origDataId||t,u=this.dataRefCount.get(a);u>1?this.dataRefCount.set(a,u-1):(this.dataRefCount.delete(a),null!=e&&(this.numBytesInGPU-=this.computeBytes(i,n),this.textureManager.releaseTexture(e,i,o,r)));const l=this.texData.get(t);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=128){return(0,i.env)().getBool("WEBGL_CPU_FORWARD")&&t.every((t=>null==this.texData.get(t.dataId).texture&&i.util.sizeFromShape(t.shape)<e))}getGPGPUContext(){return this.gpgpu}where(t){i.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return T(t.shape,e)}packedUnaryOp(t,e,n){const o=new b.rf(t.shape,e),r=this.compileAndRun(o,[t],n);return(0,i.engine)().makeTensorFromDataId(r.dataId,r.shape,r.dtype)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=(0,$.f8)(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if((0,i.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,w.pd,t.dtype);const e=new w.hE(t.shape,w.pd),n=this.compileAndRun(e,[t]);return(0,i.engine)().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(t,e,n){let o;if("string"===e&&null!=n&&n.length>0&&i.util.isString(n[0])){const r=n.map((t=>i.util.encodeString(t)));o=this.write(r,t,e)}else o=this.write(n,t,e);return this.texData.get(o).usage=null,{dataId:o,shape:t,dtype:e}}makeOutput(t,e,n){const{dataId:o}=this.makeTensorInfo(t,e,n);return(0,i.engine)().makeTensorFromDataId(o,t,e,this)}unpackTensor(t){const e=new I.z(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new R.m(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const n=[o.N0(t.shape),...o.Ph(t.shape)],i={dtype:t.dtype,shape:n,dataId:t.dataId},r=[o.N0(e),...o.Ph(e)],s=new y.R(r,n),a=this.runWebGLProgram(s,[i],t.dtype,null,!0);return{dataId:a.dataId,shape:e,dtype:a.dtype}}decode(t){const e=this.texData.get(t),{isPacked:n,shape:i,dtype:r}=e,s=o.FP(i);let a;a=n?new c(s):new d(s);return{dtype:r,shape:i,dataId:this.runWebGLProgram(a,[{shape:s,dtype:r,dataId:t}],r,null,!0).dataId}}runWebGLProgram(t,e,n,r,s=!1){const a=this.makeTensorInfo(t.outputShape,n),u=this.texData.get(a.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===l.BB.DENSE){const e=l.GM(t.outputShape);u.texShape=e.map((t=>2*t))}if(null!=t.outTexUsage&&(u.usage=t.outTexUsage),0===i.util.sizeFromShape(a.shape))return u.values=i.util.getTypedArrayFromDType(a.dtype,0),a;const d=[],c=e.map((e=>{if("complex64"===e.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(e.dataId);if(null==n.texture){if(!t.packedInputs&&i.util.sizeFromShape(e.shape)<=(0,i.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:e.shape,texData:null,isUniform:!0,uniformValues:n.values};t.packedInputs&&(n.isPacked=!0,n.shape=e.shape)}else if(!!n.isPacked!==!!t.packedInputs)e=n.isPacked?this.unpackTensor(e):this.packTensor(e),d.push(e),n=this.texData.get(e.dataId);else if(n.isPacked&&!o.P0(n.shape,e.shape)){const t=e,i=e.shape;e.shape=n.shape,e=this.packedReshape(e,i),d.push(e),n=this.texData.get(e.dataId),t.shape=i}return this.uploadToGPU(e.dataId),{shape:e.shape,texData:n,isUniform:!1}}));this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:u,isUniform:!1},f=function(t,e,n){let i="";e.concat(n).forEach((t=>{const e=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0,n=t.isUniform?"uniform":t.texData.texShape;i+=`${t.shape}_${n}_${e}`}));const o=t.userCode;let r=t.constructor.name;return r+="_"+i+"_"+o,r}(t,c,h),x=this.getAndSaveBinary(f,(()=>function(t,e,n,o){const r=e.userCode,s=n.map(((t,n)=>{const i={logicalShape:t.shape,texShape:t.isUniform?null:t.texData.texShape,isUniform:t.isUniform,isPacked:!t.isUniform&&t.texData.isPacked,flatOffset:null};return null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0&&(i.flatOffset=t.texData.slice.flatOffset),{name:e.variableNames[n],shapeInfo:i}})),a=s.map((t=>t.shapeInfo)),u={logicalShape:o.shape,texShape:o.texData.texShape,isUniform:!1,isPacked:o.texData.isPacked,flatOffset:null},l=m.y(s,u,r,e.packedInputs),d=t.createProgram(l);let c=null;const h=t.getUniformLocation(d,"NAN",!1);1===(0,i.env)().getNumber("WEBGL_VERSION")&&(c=t.getUniformLocation(d,"INFINITY",!1));const f={};for(let i=0;i<e.variableNames.length;i++){const n=e.variableNames[i],o=!1;f[n]=t.getUniformLocation(d,n,o),f[`offset${n}`]=t.getUniformLocation(d,`offset${n}`,o)}return{program:e,source:l,webGLProgram:d,uniformLocations:f,inShapeInfos:a,outShapeInfo:u,infLoc:c,nanLoc:h}}(this.gpgpu,t,c,h))),p=null!=this.activeTimers;let g;p&&(g=this.startTimer()),function(t,e,n,o,r){v(e.inShapeInfos,n),v([e.outShapeInfo],[o]);const s=o.texData.texture,a=o.texData.texShape;o.texData.isPacked?t.setOutputPackedMatrixTexture(s,a[0],a[1]):t.setOutputMatrixTexture(s,a[0],a[1]),t.setProgram(e.webGLProgram),1===(0,i.env)().getNumber("WEBGL_VERSION")&&null!==e.infLoc&&t.gl.uniform1f(e.infLoc,1/0),null!==e.nanLoc&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach(((n,o)=>{const r=e.program.variableNames[o],s=e.uniformLocations[r],a=e.uniformLocations[`offset${r}`];if(null!=s)if(n.isUniform)if(i.util.sizeFromShape(n.shape)<2)t.gl.uniform1f(s,n.uniformValues[0]);else{let e=n.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),t.gl.uniform1fv(s,e)}else null!=n.texData.slice&&null!=a&&t.gl.uniform1i(a,n.texData.slice.flatOffset),t.setInputMatrixTexture(n.texData.texture,s,o)})),null!=r&&r(t,e.webGLProgram),t.executeProgram()}(this.gpgpu,x,c,h,r),d.forEach((t=>this.disposeIntermediateTensorInfo(t))),p&&(g=this.endTimer(g),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(g)}));const C=(0,i.env)().get("WEBGL_FLUSH_THRESHOLD");if(C>0){const t=i.util.now();t-this.lastGlFlushTime>C&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=t)}if(!(0,i.env)().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===s){const t=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),t}return a}compileAndRun(t,e,n,i,o=!1){n=n||e[0].dtype;return this.runWebGLProgram(t,e,n,i,o)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!(0,i.env)().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,i.tidy)((()=>{if(!(0,i.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=(0,i.env)().getBool("DEBUG");(0,i.env)().set("DEBUG",!1);const e=this.abs((0,i.scalar)(1e-8)).dataSync()[0];if((0,i.env)().set("DEBUG",t),e>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(t){const e=this.texData.get(t),{shape:n,dtype:r,values:s,texture:a,usage:u,isPacked:d}=e;if(null!=a)return;const c=null!=this.activeTimers;let h;c&&(h=i.util.now());let f=e.texShape;if(null==f&&(f=o.fA(n,d),e.texShape=f),null!=s){const t=o.FP(n);let a,u=f[1],g=f[0];const C=s instanceof Uint8Array;d?([u,g]=l.NO(f[0],f[1]),a=new p(t,[g,u],C)):a=new x(t,[g,u],C);const m=this.makeTensorInfo([g,u],r);this.texData.get(m.dataId).usage=C?l.tT.PIXELS:l.tT.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(m.dataId),u,g,s);const v=!0,$=this.runWebGLProgram(a,[m],r,null,v),R=this.texData.get($.dataId);e.texture=R.texture,e.texShape=R.texShape,e.isPacked=R.isPacked,e.usage=R.usage,this.disposeIntermediateTensorInfo(m),this.texData.delete($.dataId),e.values=null,c&&(this.uploadWaitMs+=i.util.now()-h)}else{const t=this.acquireTexture(f,u,r,d);e.texture=t}}convertAndCacheOnCPU(t,e){const n=this.texData.get(t),{dtype:i}=n;return this.releaseGPUData(t),null!=e&&(n.values=function(t,e){if("float32"===e||"complex64"===e)return t;if("int32"===e||"bool"===e){const n="int32"===e?new Int32Array(t.length):new Uint8Array(t.length);for(let e=0;e<n.length;++e)n[e]=Math.round(t[e]);return n}throw new Error(`Unknown dtype ${e}`)}(e,i)),n.values}acquireTexture(t,e,n,i){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0}return this.textureManager.acquireTexture(t,e,i)}computeBytes(t,e){return t[0]*t[1]*i.util.bytesPerElement(e)}}O.nextDataId=0;var A=n(77104),S=n(80393);i.device_util.isBrowser()&&(0,i.registerBackend)("webgl",(()=>new O),2);S.bP;n(76202)},40025:function(t,e,n){n.d(e,{H:function(){return o}});var i=n(27575);class o{constructor(t,e,n){this.variableNames=["x"],this.outputShape=t;const o=t.length,a=e?"0.0":`getX(${r(o,"coords")})`,u=t[t.length-1];let l="",d="";e?(l=n?"end != "+(u-1):"end != 0",d=n?"end + 1":"end - 1"):(l=n?`end + pow2 < ${u}`:"end >= pow2",d=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${(0,i.b)(o)} coords = getOutputCoords();\n        int end = ${s(o,"coords")};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${d};\n          ${s(o,"coords")} = idx;\n          val += getX(${r(o,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(t){return(e,n)=>{null==this.index&&(this.index=e.getUniformLocation(n,"index")),e.gl.uniform1f(this.index,t)}}}function r(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.x, ${e}.y`;if(3===t)return`${e}.x, ${e}.y, ${e}.z`;if(4===t)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}function s(t,e){if(1===t)return`${e}`;if(2===t)return`${e}.y`;if(3===t)return`${e}.z`;if(4===t)return`${e}.w`;throw Error(`Cumulative sum for rank ${t} is not yet supported`)}},46334:function(t,e,n){n.d(e,{VI:function(){return a},dR:function(){return s}});var i=n(9495),o=n(75694),r=n(27575);const s="\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n";class a{constructor(t,e,n,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i.backend_util.assertAndGetBroadcastShape(e,n);const a=this.outputShape.length;let u="";if(s)if(0===a||1===i.util.sizeFromShape(this.outputShape))u="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(u=`\n          ${(0,r.b)(a)} coords = getOutputCoords();\n        `,1===a)u+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const t=(0,o.Jp)("coords",a);u+=`\n            bool nextRowOutOfBounds =\n              (${t[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${t[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${u}\n\n        setOutput(result);\n      }\n    `}}},47646:function(t,e,n){n.d(e,{$k:function(){return w},Hw:function(){return p},Ij:function(){return g},J$:function(){return h},Me:function(){return v},Ng:function(){return u},SD:function(){return I},WH:function(){return f},Z:function(){return $},b1:function(){return a},bG:function(){return C},cD:function(){return c},fj:function(){return d},ir:function(){return b},qg:function(){return y},uS:function(){return T},wM:function(){return x},y7:function(){return R},yr:function(){return s},z8:function(){return m},zP:function(){return E}});var i=n(18765),o=n(28560),r=n(88380);function s(t){const e=(0,i.B)(),n=`${e.version}\n    precision highp float;\n    ${e.attribute} vec3 clipSpacePos;\n    ${e.attribute} vec2 uv;\n    ${e.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return r.yr(t,n)}function a(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return r.HW(t,e)}function u(t){const e=new Uint16Array([0,1,2,2,1,3]);return r.$e(t,e)}function l(t,e,n,i,o,s){r.ph(e,n);const a=r.sZ(t),u=t.TEXTURE_2D;return r.ul(t,(()=>t.bindTexture(u,a))),r.ul(t,(()=>t.texParameteri(u,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE))),r.ul(t,(()=>t.texParameteri(u,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE))),r.ul(t,(()=>t.texParameteri(u,t.TEXTURE_MIN_FILTER,t.NEAREST))),r.ul(t,(()=>t.texParameteri(u,t.TEXTURE_MAG_FILTER,t.NEAREST))),r.ul(t,(()=>t.texImage2D(u,0,i,e,n,0,o,s,null))),r.ul(t,(()=>t.bindTexture(t.TEXTURE_2D,null))),a}function d(t){return t.internalFormatFloat}function c(t,e,n,i){const[r,s]=o.Qn(e,n);return l(t,r,s,d(i),i.textureFormatFloat,t.FLOAT)}function h(t){return t.internalFormatHalfFloat}function f(t,e,n,i){const[r,s]=o.Qn(e,n);return l(t,r,s,h(i),i.textureFormatFloat,i.textureTypeHalfFloat)}function x(t){return t.downloadTextureFormat}function p(t,e,n,i){const[r,s]=o.Qn(e,n);return l(t,r,s,x(i),t.RGBA,t.UNSIGNED_BYTE)}function g(t){return t.internalFormatPackedFloat}function C(t,e,n,i){const[r,s]=o.NO(e,n);return l(t,r,s,g(i),t.RGBA,t.FLOAT)}function m(t){return t.internalFormatPackedHalfFloat}function v(t,e,n,i){const[r,s]=o.NO(e,n);return l(t,r,s,m(i),t.RGBA,i.textureTypeHalfFloat)}function $(t,e,n){r.ul(t,(()=>t.bindBuffer(t.ARRAY_BUFFER,n)));return r.rw(t,e,"clipSpacePos",n,3,20,0)&&r.rw(t,e,"uv",n,2,20,12)}function R(t,e,n,i,o,s){let a,u,l;r.ul(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),o instanceof Uint8Array?(a=new Uint8Array(n*i*4),u=t.UNSIGNED_BYTE,l=t.RGBA):(a=new Float32Array(n*i*4),u=t.FLOAT,l=s.internalFormatPackedFloat),a.set(o),r.ul(t,(()=>t.texImage2D(t.TEXTURE_2D,0,l,n,i,0,t.RGBA,u,a))),r.ul(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}function y(t,e,n){r.ul(t,(()=>t.bindTexture(t.TEXTURE_2D,e))),n.data instanceof Uint8Array?r.ul(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data))):r.ul(t,(()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n))),r.ul(t,(()=>t.bindTexture(t.TEXTURE_2D,null)))}function E(t,e,n,i){const o=t.createBuffer();r.ul(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,o)));const s=16*e*n;return r.ul(t,(()=>t.bufferData(t.PIXEL_PACK_BUFFER,s,t.STREAM_READ))),r.ul(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0))),r.ul(t,(()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null))),o}function w(t,e,n){const i=t,o=new Float32Array(n);return i.bindBuffer(i.PIXEL_PACK_BUFFER,e),i.getBufferSubData(i.PIXEL_PACK_BUFFER,0,o),i.bindBuffer(i.PIXEL_PACK_BUFFER,null),o}function b(t,e,n,i){const[s,a]=o.Qn(e,n),u=new Uint8Array(o.EX(e*n,4));return r.ul(t,(()=>t.readPixels(0,0,s,a,i.downloadTextureFormat,t.UNSIGNED_BYTE,u))),new Float32Array(u.buffer)}function I(t,e,n,i,r,s,a,u){const l=t,d=new Float32Array(o.PM(s,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,d),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),d}function T(t,e,n){const i=new Float32Array(e*n*4);return r.ul(t,(()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,i))),i}},49873:function(t,e,n){n.d(e,{R:function(){return i}});class i{constructor(t,e,n){this.variableNames=["real","imag"];const i=e[1];this.outputShape=e;const o=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,r=n?`${i}.0`:"1.0";let s;if("real"===t)s="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);s="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${o};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${s}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${i});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${i}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${r};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}},52966:function(t,e,n){n.d(e,{R:function(){return o},f:function(){return i}});class i{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,i=t.padInfo.top,o=t.padInfo.left,r=t.outChannels/t.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${r} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${i};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class o{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,i=t.strideHeight,o=t.strideWidth,r=e-1-t.padInfo.top,s=n-1-t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${i}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${a}; dm++) {\n              int d2 = d1 * ${a} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},54057:function(t,e,n){n.d(e,{T:function(){return i}});class i{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}},58638:function(t,e,n){n.d(e,{D:function(){return o}});var i=n(18765);class o{constructor(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;const{filterWidth:o,inChannels:r,strideWidth:s,strideHeight:a,padInfo:u,outWidth:l,dilationWidth:d,dilationHeight:c,dataFormat:h}=n,{left:f,top:x}=u,p=r*o,g=(0,i.B)(),C="channelsLast"===h,m=C?0:1,v=C?1:2;let $="";for(let i=0;i<=1;i++)for(let n=0;n<=1;n++)$+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${i};\n\n          if(blockIndex < ${t[1]} && pos < ${t[0]}) {\n            offsetY = int(blockIndex / (${l})) * ${a} - ${x};\n            d0 = offsetY + ${c} * (pos / ${p});\n\n            if(d0 < ${e[m]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${l}.) * ${s}. - ${f}.);\n              d1 = offsetX + ${d} * (int(mod(float(pos), ${p}.) / ${r}.));\n\n              if(d1 < ${e[v]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${r}.));\n\n                if (${C}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*i+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*i+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${$}\n\n        ${g.output} = result;\n      }\n    `}}},59396:function(t,e,n){n.d(e,{c:function(){return i}});class i{constructor(t,e,n,i,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[r,s,a,u]=t,[l]=e,[d,c]=n;this.outputShape=[l,d,c,u];const h="bilinear"===i?1:0,[f,x]=[s-1+".0",a-1+".0"],[p,g,C]=d>1?[""+(s-1)/(d-1),"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[m,v,$]=c>1?[""+(a-1)/(c-1),"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`\n      const float height_ratio = float(${p});\n      const float width_ratio = float(${m});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${r}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${C};\n        if( in_y < 0.0 || in_y > ${f} ) {\n          setOutput(float(${o}));\n          return;\n        }\n        float in_x = ${$};\n        if( in_x < 0.0 || in_x > ${x} ) {\n          setOutput(float(${o}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}},60287:function(t,e,n){n.d(e,{l:function(){return i}});class i{constructor(t,e,n){this.variableNames=["A"];const{windowSize:i,batchSize:o,outSize:r}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[o,r];const s="max"===e?">":"<",a=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${i}; i++) {\n          int inIdx = ${a};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${s} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}},60432:function(t,e,n){n.d(e,{u:function(){return o}});var i=n(27575);class o{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const n=(0,i.b)(this.rank),o=function(t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let i=0;i<t.length;i++)2===i?n.push("int(getIndices(resRC.x, resRC.z))"):n.push(`${e[i]}`);return n.join()}(t);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${o}));\n      }\n    `}}},62780:function(t,e,n){n.d(e,{l:function(){return s}});var i=n(9495),o=n(75694),r=n(27575);class s{constructor(t,e,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,i.util.assert(t.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const a=t[t.length-1],u=Math.ceil(a/e);this.outputShape=t.slice(0,-1),u>1&&this.outputShape.push(u),s||this.variableNames.push("bestIndicesA");const l=this.outputShape,d=l.length,c=(0,r.b)(d),h=(0,o.Jp)("coords",d);let f,x;if(1===u){x=d+1;const t=(0,r.b)(x);f=`\n        ${t} sourceLocR = ${t}(${h.join()}, 0);\n        ++${h[d-1]};\n        ${t} sourceLocG = ${t}(${h.join()}, 0);\n        ++${h[d-2]};\n        ${t} sourceLocA = ${t}(${h.join()}, 0);\n        --${h[d-1]};\n        ${t} sourceLocB = ${t}(${h.join()}, 0);\n        --${h[d-2]};`}else x=d,f=`\n        ${c} sourceLocR = coords;\n        ++${h[d-1]};\n        ${c} sourceLocG = coords;\n        ++${h[d-2]};\n        ${c} sourceLocA = coords;\n        --${h[d-1]};\n        ${c} sourceLocB = coords;\n        --${h[d-2]};`;const p=["x","y","z","w","u","v"].slice(0,x),g="."+p[x-1],C=p.map((t=>"int "+t)),m=(0,o.Jp)("sourceLocR",x-1).concat("inIdx.r"),v=(0,o.Jp)("sourceLocG",x-1).concat("inIdx.g"),$=(0,o.Jp)("sourceLocB",x-1).concat("inIdx.b"),R=(0,o.Jp)("sourceLocA",x-1).concat("inIdx.a"),y="max"===n?"greaterThan":"lessThan",E=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${v.join()}),\n                             getBestIndicesAChannel(${$.join()}),\n                             getBestIndicesAChannel(${R.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${v.join()}) : 0.,\n            hasNextRow ? getAChannel(${$.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${R.join()}) : 0.)`,b=s?"":`\n      float getBestIndicesAChannel(${C.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${C.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${b}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${h[d-1]} < ${l[d-1]-1};\n        bool hasNextRow = ${h[d-2]} < ${l[d-2]-1};\n        ${f}\n        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},\n          sourceLocB${g}, sourceLocA${g}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${E}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${y}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}},65274:function(t,e,n){n.d(e,{C:function(){return o},f:function(){return r}});var i=n(9495);const o={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class r{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=i.backend_util.assertAndGetBroadcastShape(e,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}},67282:function(t,e,n){n.d(e,{t:function(){return i}});class i{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}},68616:function(t,e,n){n.d(e,{x:function(){return o}});var i=n(9495);class o{constructor(t,e,n,o,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],i.backend_util.assertAndGetBroadcastShape(t,e),i.backend_util.assertAndGetBroadcastShape(t,n);let a="vec4(0.0)";null!=o&&(i.backend_util.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=r&&(i.backend_util.assertAndGetBroadcastShape(t,r),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${u};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}},79229:function(t,e,n){n.d(e,{x:function(){return i}});class i{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:n,padInfo:i,strideHeight:o,strideWidth:r,filterHeight:s,filterWidth:a,dilationHeight:u,dilationWidth:l}=t,{top:d,left:c}=i;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${r});\n      const ivec2 pads = ivec2(${d}, ${c});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${s}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${a}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}},80273:function(t,e,n){n.d(e,{T:function(){return i}});class i{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(t,e){return(n,i)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(i,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(i,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}}},81223:function(t,e,n){n.d(e,{N7:function(){return r},S5:function(){return i},eS:function(){return o},tR:function(){return s}});class i{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,n=t.strideWidth,i=t.padInfo.top,o=t.padInfo.left,r="channelsLast"===t.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${e} - ${i};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${o};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              if (${r}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class o{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,i=t.strideHeight,o=t.strideWidth,r="channelsLast"===t.dataFormat,s=e-1-t.padInfo.top,a=n-1-t.padInfo.left,u=r?1:2,l=r?2:3,d=r?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${d}];\n\n        ivec2 dyCorner = ivec2(coords[${u}], coords[${l}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${i}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${r}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class r{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,n=t.strideHeight,i=t.strideWidth,o=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${e} - ${o};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${r};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${i} - ${s};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class s{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,i=t.filterWidth,o=t.strideDepth,r=t.strideHeight,s=t.strideWidth,a=e-1-t.padInfo.front,u=n-1-t.padInfo.top,l=i-1-t.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${a}, ${u}, ${l});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${o}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${r}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${i}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${i} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},82676:function(t,e,n){n.d(e,{V:function(){return s}});var i=n(9495),o=n(75694),r=n(27575);class s{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=i.backend_util.computeOutShape(t,e);const n=this.outputShape,s=n.length,u=(0,r.b)(s),l=(0,o.Jp)("coords",s),d=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map(((t,e)=>`T${e}`));const c=new Array(t.length-1);c[0]=t[0][e];for(let i=1;i<c.length;i++)c[i]=c[i-1]+t[i][e];const h=d[e],f=d.slice(-2),x=d.join();let p=`if (${h} < ${c[0]}) {\n        return getChannel(\n            getT0(${x}), vec2(${f.join()}));\n        }`;for(let i=1;i<c.length;i++){const t=c[i-1];p+=`\n        if (${h} < ${c[i]}  && ${h} >= ${c[i-1]}) {\n          return getChannel(\n            getT${i}(${a(d,h,t)}),\n            vec2(${a(f,h,t)}));\n        }`}const g=c.length,C=c[c.length-1];p+=`\n        return getChannel(\n          getT${g}(${a(d,h,C)}),\n          vec2(${a(f,h,C)}));`,this.userCode=`\n      float getValue(${d.map((t=>"int "+t))}) {\n        ${p}\n      }\n\n      void main() {\n        ${u} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${l}), 0., 0., 0.);\n\n        ${l[s-1]} = ${l[s-1]} + 1;\n        if (${l[s-1]} < ${n[s-1]}) {\n          result.g = getValue(${l});\n        }\n\n        ${l[s-2]} = ${l[s-2]} + 1;\n        if (${l[s-2]} < ${n[s-2]}) {\n          result.a = getValue(${l});\n        }\n\n        ${l[s-1]} = ${l[s-1]} - 1;\n        if (${l[s-2]} < ${n[s-2]} &&\n            ${l[s-1]} < ${n[s-1]}) {\n          result.b = getValue(${l});\n        }\n        setOutput(result);\n      }\n    `}}function a(t,e,n){const i=t.indexOf(e);return t.map(((t,e)=>e===i?`${t} - ${n}`:t)).join()}},90212:function(t,e,n){n.d(e,{K:function(){return i}});class i{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map(((t,e)=>`T${e}`));const n=[];this.variableNames.forEach((t=>{n.push(`float v${t} = get${t}AtOutCoords();`)}));const i=this.variableNames.map((t=>`v${t}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${i};\n        setOutput(result);\n      }\n    `}}},94491:function(t,e,n){n.d(e,{q:function(){return o},x:function(){return i}});class i{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,n=t.filterWidth,i=t.strideHeight,o=t.strideWidth,r=t.dilationHeight,s=t.dilationWidth,a=t.effectiveFilterHeight,u=t.effectiveFilterWidth,l=a-1-t.padInfo.top,d=u-1-t.padInfo.left,c=1/(e*n);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${d});\n      const float avgMultiplier = float(${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n            wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${i}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${s}) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class o{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,n=t.filterHeight,i=t.filterWidth,o=t.strideDepth,r=t.strideHeight,s=t.strideWidth,a=t.dilationDepth,u=t.dilationHeight,l=t.dilationWidth,d=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,f=d-1-t.padInfo.front,x=c-1-t.padInfo.top,p=h-1-t.padInfo.left,g=1/(e*n*i);this.userCode=`\n      const ivec3 pads = ivec3(${f}, ${x}, ${p});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${o}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            float dyR = float(dyRCorner + wR) / ${r}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}},96911:function(t,e,n){n.d(e,{g:function(){return o}});var i=n(27575);class o{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;const o=(0,i.b)(e.length),r=(0,i.b)(n.length),s=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${this.strides});\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${s};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}}}]);
//# sourceMappingURL=stylist-vendors-9dd4f2b7.a6d734984794af74f2f3.js.map