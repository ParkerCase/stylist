"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[7113],{5340:function(t,e,a){a.d(e,{Q:function(){return u}});var s=a(67897),i=a(35287),n=a(37523),r=a(9258),c=a(45702),l=a(55537),o=a(37930);class u extends o.S{static get className(){return"Momentum"}constructor(t,e,a=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=a,this.accumulations=[],this.m=(0,c.d)(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const c=s.T2.registeredVariables[e];if(null==this.accumulations[a]){const t=!1;this.accumulations[a]={originalName:`${e}/momentum`,variable:(0,i.DZ)((()=>(0,l.P)(c).variable(t)))}}const o=this.accumulations[a].variable,u=Array.isArray(t)?t[a].tensor:t[e];null!=u&&(0,i.DZ)((()=>{let t;const e=(0,n.W)((0,r.l)(this.m,o),u);t=this.useNesterov?(0,n.W)((0,r.l)(this.c,(0,n.W)(u,(0,r.l)(e,this.m))),c):(0,n.W)((0,r.l)(this.c,e),c),o.assign(e),c.assign(t)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,i.AS)(this.accumulations.map((t=>t.variable)))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulations=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}},15618:function(t,e,a){a(66652);var s=a(46574),i=a(30522),n=a(76745),r=a(66235),c=a(86448);class l{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){"undefined"!==typeof window&&(0,s._K)().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(t=>{if(t.source===window&&t.data.name===this.messageName){t.stopPropagation();(0,this.functionRefs[t.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(t,e)}isTypedArray(t){return(0,c.Y)(t)}}if((0,s._K)().get("IS_BROWSER")){(0,s._K)().setPlatform("browser",new l);try{r.dy.registerManager(n.ZT.URL_SCHEME,new n.Cd)}catch(o){}try{r.dy.registerManager(i.mn.URL_SCHEME,new i.lQ)}catch(o){}}},25727:function(t,e,a){a.d(e,{P:function(){return d}});var s=a(67897),i=a(35287),n=a(37523),r=a(89359),c=a(9258),l=a(79348),o=a(45793),u=a(77126),h=a(55537),m=a(64403);class d extends m.E{static get className(){return"RMSProp"}constructor(t,e=.9,a=0,i=null,n=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=a,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=n,null==i&&(this.epsilon=s.T2.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const m=s.T2.registeredVariables[e],d=!1;null==this.accumulatedMeanSquares[a]&&(this.accumulatedMeanSquares[a]={originalName:`${e}/rms`,variable:(0,i.DZ)((()=>(0,h.P)(m).variable(d)))}),null==this.accumulatedMoments[a]&&(this.accumulatedMoments[a]={originalName:`${e}/momentum`,variable:(0,i.DZ)((()=>(0,h.P)(m).variable(d)))}),null==this.accumulatedMeanGrads[a]&&this.centered&&(this.accumulatedMeanGrads[a]={originalName:`${e}/mg`,variable:(0,i.DZ)((()=>(0,h.P)(m).variable(d)))});const g=Array.isArray(t)?t[a].tensor:t[e];if(null==g)return;const p=this.accumulatedMeanSquares[a].variable,b=this.accumulatedMoments[a].variable;(0,i.DZ)((()=>{const t=(0,n.W)((0,c.l)(p,this.decay),(0,c.l)((0,o.E)(g),1-this.decay));if(this.centered){const e=this.accumulatedMeanGrads[a].variable,s=(0,n.W)((0,c.l)(e,this.decay),(0,c.l)(g,1-this.decay)),i=(0,r.y)((0,c.l)(g,this.learningRate),(0,l.R)((0,u.j)(t,(0,n.W)((0,o.E)(s),this.epsilon)))),h=(0,n.W)((0,c.l)(b,this.momentum),i);p.assign(t),e.assign(s),b.assign(h);const d=(0,u.j)(m,h);m.assign(d)}else{const t=(0,n.W)((0,c.l)(p,this.decay),(0,c.l)((0,o.E)(g),1-this.decay)),e=(0,n.W)((0,c.l)(b,this.momentum),(0,r.y)((0,c.l)(g,this.learningRate),(0,l.R)((0,n.W)(t,this.epsilon))));p.assign(t),b.assign(e);const a=(0,u.j)(m,e);m.assign(a)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,i.AS)(this.accumulatedMeanSquares.map((t=>t.variable))),null!=this.accumulatedMeanGrads&&this.centered&&(0,i.AS)(this.accumulatedMeanGrads.map((t=>t.variable))),null!=this.accumulatedMoments&&(0,i.AS)(this.accumulatedMoments.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,a=!1;this.accumulatedMeanSquares=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)}))),this.accumulatedMoments=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)}))),this.centered&&(this.accumulatedMeanGrads=t.slice(2*e,3*e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}},37930:function(t,e,a){a.d(e,{S:function(){return o}});var s=a(67897),i=a(35287),n=a(37523),r=a(9258),c=a(45702),l=a(64403);class o extends l.E{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const c=Array.isArray(t)?t[a].tensor:t[e];if(null==c)return;const l=s.T2.registeredVariables[e];(0,i.DZ)((()=>{const t=(0,n.W)((0,r.l)(this.c,c),l);l.assign(t)}))})),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=(0,i.aC)((0,c.d)(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(0!==(t=await this.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}},63822:function(t,e,a){a.d(e,{i:function(){return m}});var s=a(99696),i=a(85316),n=a(81409),r=a(98544),c=a(5340),l=a(25727),o=a(37930),u=a(79559);const h=[s.K,i.a,n.F,r.o,c.Q,l.P,o.S];function m(){for(const t of h)(0,u.registerClass)(t)}},64403:function(t,e,a){a.d(e,{E:function(){return c}});var s=a(35287),i=a(31830),n=a(45702),r=a(79559);class c extends r.Serializable{minimize(t,e=!1,a){const{value:i,grads:n}=this.computeGradients(t,a);if(null!=a){const t=a.map((t=>({name:t.name,tensor:n[t.name]})));this.applyGradients(t)}else this.applyGradients(n);return(0,s.AS)(n),e?i:(i.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return(0,i.y7)(t,e)}dispose(){null!=this.iterations_&&(0,s.AS)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,n.d)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(c,Symbol.hasInstance,{value:t=>null!=t.minimize&&null!=t.computeGradients&&null!=t.applyGradients})},81409:function(t,e,a){a.d(e,{F:function(){return p}});var s=a(67897),i=a(35287),n=a(37523),r=a(89359),c=a(9258),l=a(98990),o=a(45702),u=a(79348),h=a(45793),m=a(77126),d=a(55537),g=a(64403);class p extends g.E{static get className(){return"Adam"}constructor(t,e,a,n=null){super(),this.learningRate=t,this.beta1=e,this.beta2=a,this.epsilon=n,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,i.DZ)((()=>{this.accBeta1=(0,o.d)(e).variable(),this.accBeta2=(0,o.d)(a).variable()})),null==n&&(this.epsilon=s.T2.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);(0,i.DZ)((()=>{const a=(0,m.j)(1,this.accBeta1),l=(0,m.j)(1,this.accBeta2);e.forEach(((e,o)=>{const m=s.T2.registeredVariables[e],g=!1;null==this.accumulatedFirstMoment[o]&&(this.accumulatedFirstMoment[o]={originalName:`${e}/m`,variable:(0,i.DZ)((()=>(0,d.P)(m).variable(g)))}),null==this.accumulatedSecondMoment[o]&&(this.accumulatedSecondMoment[o]={originalName:`${e}/v`,variable:(0,i.DZ)((()=>(0,d.P)(m).variable(g)))});const p=Array.isArray(t)?t[o].tensor:t[e];if(null==p)return;const b=this.accumulatedFirstMoment[o].variable,f=this.accumulatedSecondMoment[o].variable,y=(0,n.W)((0,c.l)(b,this.beta1),(0,c.l)(p,1-this.beta1)),v=(0,n.W)((0,c.l)(f,this.beta2),(0,c.l)((0,h.E)(p),1-this.beta2)),w=(0,r.y)(y,a),A=(0,r.y)(v,l);b.assign(y),f.assign(v);const M=(0,n.W)((0,c.l)((0,r.y)(w,(0,n.W)((0,u.R)(A),this.epsilon)),-this.learningRate),m);m.assign(M)})),this.accBeta1.assign((0,c.l)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,c.l)(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,i.AS)(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedSecondMoment&&(0,i.AS)(this.accumulatedSecondMoment.map((t=>t.variable)))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t),(0,i.DZ)((()=>{this.accBeta1.assign((0,l.n)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,l.n)(this.beta2,this.iterations_+1))}));const e=t.length/2,a=!1;this.accumulatedFirstMoment=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)}))),this.accumulatedSecondMoment=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}},83335:function(t,e,a){a.d(e,{L:function(){return u}});var s=a(99696),i=a(85316),n=a(81409),r=a(98544),c=a(5340),l=a(25727),o=a(37930);class u{static sgd(t){return new o.S(t)}static momentum(t,e,a=!1){return new c.Q(t,e,a)}static rmsprop(t,e=.9,a=0,s=null,i=!1){return new l.P(t,e,a,s,i)}static adam(t=.001,e=.9,a=.999,s=null){return new n.F(t,e,a,s)}static adadelta(t=.001,e=.95,a=null){return new s.K(t,e,a)}static adamax(t=.002,e=.9,a=.999,s=null,i=0){return new r.o(t,e,a,s,i)}static adagrad(t,e=.1){return new i.a(t,e)}}},83672:function(t,e,a){var s=a(46574),i=a(65606);const n=()=>a(85817);let r;class c{constructor(){this.util=a(18590),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=(0,s._K)().global.fetch?(0,s._K)().global.fetch(t,e):(null==r&&(r=n()),r(t,e))}now(){const t=i.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}(0,s._K)().get("IS_NODE")&&!(0,s._K)().get("IS_BROWSER")&&(0,s._K)().setPlatform("node",new c)},85316:function(t,e,a){a.d(e,{a:function(){return m}});var s=a(67897),i=a(35287),n=a(37523),r=a(89359),c=a(96111),l=a(9258),o=a(79348),u=a(45793),h=a(64403);class m extends h.E{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const h=s.T2.registeredVariables[e];if(null==this.accumulatedGrads[a]){const t=!1;this.accumulatedGrads[a]={originalName:`${e}/accumulator`,variable:(0,i.DZ)((()=>(0,c.G)(h.shape,this.initialAccumulatorValue).variable(t)))}}const m=Array.isArray(t)?t[a].tensor:t[e];if(null==m)return;const d=this.accumulatedGrads[a].variable;(0,i.DZ)((()=>{const t=(0,n.W)(d,(0,u.E)(m));d.assign(t);const e=(0,n.W)((0,l.l)((0,r.y)(m,(0,o.R)((0,n.W)(t,s.T2.backend.epsilon()))),-this.learningRate),h);h.assign(e)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,i.AS)(this.accumulatedGrads.map((t=>t.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){t=await this.extractIterations(t);this.accumulatedGrads=t.map((t=>({originalName:t.name,variable:t.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}},86448:function(t,e,a){function s(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}a.d(e,{Y:function(){return s}})},98544:function(t,e,a){a.d(e,{o:function(){return g}});var s=a(67897),i=a(35287),n=a(4888),r=a(37523),c=a(89359),l=a(30178),o=a(9258),u=a(45702),h=a(77126),m=a(55537),d=a(64403);class g extends d.E{static get className(){return"Adamax"}constructor(t,e,a,n=null,r=0){super(),this.learningRate=t,this.beta1=e,this.beta2=a,this.epsilon=n,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,i.DZ)((()=>{this.iteration=(0,u.d)(0).variable(),this.accBeta1=(0,u.d)(e).variable()})),null==n&&(this.epsilon=s.T2.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map((t=>t.name)):Object.keys(t);(0,i.DZ)((()=>{const a=(0,h.j)(1,this.accBeta1),i=(0,c.y)(-this.learningRate,(0,r.W)((0,o.l)(this.iteration,this.decay),1));e.forEach(((e,u)=>{const h=s.T2.registeredVariables[e],d=!1;null==this.accumulatedFirstMoment[u]&&(this.accumulatedFirstMoment[u]={originalName:`${e}/m`,variable:(0,m.P)(h).variable(d)}),null==this.accumulatedWeightedInfNorm[u]&&(this.accumulatedWeightedInfNorm[u]={originalName:`${e}/v`,variable:(0,m.P)(h).variable(d)});const g=Array.isArray(t)?t[u].tensor:t[e];if(null==g)return;const p=this.accumulatedFirstMoment[u].variable,b=this.accumulatedWeightedInfNorm[u].variable,f=(0,r.W)((0,o.l)(p,this.beta1),(0,o.l)(g,1-this.beta1)),y=(0,o.l)(b,this.beta2),v=(0,n.t)(g),w=(0,l.P)(y,v);p.assign(f),b.assign(w);const A=(0,r.W)((0,o.l)((0,c.y)(i,a),(0,c.y)(f,(0,r.W)(w,this.epsilon))),h);h.assign(A)})),this.iteration.assign((0,r.W)(this.iteration,1)),this.accBeta1.assign((0,o.l)(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,i.AS)(this.accumulatedFirstMoment.map((t=>t.variable))),null!=this.accumulatedWeightedInfNorm&&(0,i.AS)(this.accumulatedWeightedInfNorm.map((t=>t.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}},99696:function(t,e,a){a.d(e,{K:function(){return m}});var s=a(67897),i=a(35287),n=a(37523),r=a(89359),c=a(9258),l=a(79348),o=a(45793),u=a(55537),h=a(64403);class m extends h.E{static get className(){return"Adadelta"}constructor(t,e,a=null){super(),this.learningRate=t,this.rho=e,this.epsilon=a,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==a&&(this.epsilon=s.T2.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map((t=>t.name)):Object.keys(t)).forEach(((e,a)=>{const h=s.T2.registeredVariables[e],m=!1;null==this.accumulatedGrads[a]&&(this.accumulatedGrads[a]={originalName:`${e}/accum_grad`,variable:(0,i.DZ)((()=>(0,u.P)(h).variable(m)))}),null==this.accumulatedUpdates[a]&&(this.accumulatedUpdates[a]={originalName:`${e}/accum_var`,variable:(0,i.DZ)((()=>(0,u.P)(h).variable(m)))});const d=Array.isArray(t)?t[a].tensor:t[e];if(null==d)return;const g=this.accumulatedGrads[a].variable,p=this.accumulatedUpdates[a].variable;(0,i.DZ)((()=>{const t=(0,n.W)((0,c.l)(g,this.rho),(0,c.l)((0,o.E)(d),1-this.rho)),e=(0,c.l)((0,r.y)((0,l.R)((0,n.W)(p,this.epsilon)),(0,l.R)((0,n.W)(g,this.epsilon))),d),a=(0,n.W)((0,c.l)(p,this.rho),(0,c.l)((0,o.E)(e),1-this.rho));g.assign(t),p.assign(a);const s=(0,n.W)((0,c.l)(e,-this.learningRate),h);h.assign(s)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,i.AS)(this.accumulatedGrads.map((t=>t.variable))),(0,i.AS)(this.accumulatedUpdates.map((t=>t.variable))))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map((t=>({name:t.originalName,tensor:t.variable}))))}async setWeights(t){const e=(t=await this.extractIterations(t)).length/2,a=!1;this.accumulatedGrads=t.slice(0,e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)}))),this.accumulatedUpdates=t.slice(e,2*e).map((t=>({originalName:t.name,variable:t.tensor.variable(a)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}}}]);
//# sourceMappingURL=stylist-vendors-4f68e0f9.b1816ef67d7b295f63f2.js.map