"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[7],{4092:function(e,t,n){n.d(t,{Lt:function(){return c},Zy:function(){return o}});var r=n(9495),a=n(45705),s=n(21694);const o=(0,a.o)((e=>1/Math.sqrt(e))),u=(0,s.F)(r.Rsqrt,o),c={kernelName:r.Rsqrt,backendName:"cpu",kernelFunc:u}},5744:function(e,t,n){n.d(t,{y:function(){return a}});var r=n(9495);function a(e,t,n,a,s,o,u){const c=t[0],i=o[0],d=new Array(i),l=new Array(c),p=t[1];if(0===i){if(0!==c)throw new Error(r.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(c));return[r.util.getArrayFromDType(n,0),[0,p],r.util.getArrayFromDType(s,0),d,l]}let f=!0,h=0;const m=new Array(i).fill(0);for(let g=0;g<c;++g){const t=e[g*p];if(t<0)throw new Error(r.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,t));if(t>=i)throw new Error(r.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,t,i));++m[t],f=f&&t>=h,h=t}let k=!0;for(let r=0;r<i;++r){const e=0===m[r];d[r]=e,k=k&&!e,m[r]=Math.max(m[r],1),r>0&&(m[r]+=m[r-1])}if(k&&f){const t=e,n=a;for(let e=0;e<c;++e)l[e]=e;return[t,[c,p],n,d,l]}{const t=m[i-1],o=r.util.getArrayFromDType(n,t*p),f=r.util.getArrayFromDType(s,t),h=new Array(i).fill(0);for(let n=0;n<c;++n){const t=e[n*p],r=h[t],s=(0===t?0:m[t-1])+r;h[t]++;for(let a=0;a<p;++a)o[s*p+a]=e[n*p+a];f[s]=a[n],l[n]=s}for(let e=0;e<i;++e){if(0===h[e]){const t=0===e?0:m[e-1];o[t*p+0]=e;for(let e=1;e<p;++e)o[t*p+e]=0;f[t]=u}}return[o,[t,p],f,d,l]}}},10229:function(e,t,n){n.d(t,{k:function(){return c}});var r=n(9495),a=n(21694);const s=r.backend_util.SELU_SCALEALPHA,o=r.backend_util.SELU_SCALE,u=(0,a.v)(r.Selu,(e=>e>=0?o*e:s*(Math.exp(e)-1))),c={kernelName:r.Selu,backendName:"cpu",kernelFunc:u}},10494:function(e,t,n){n.d(t,{b2:function(){return c}});var r=n(9495),a=n(8195),s=n(98880);const o=(0,a.Z)(((e,t)=>{const n=e-t;return n*n})),u=(0,s.j)(r.SquaredDifference,o),c={kernelName:r.SquaredDifference,backendName:"cpu",kernelFunc:u}},12184:function(e,t,n){n.d(t,{$:function(){return s}});var r=n(9495);const a=(0,n(21694).v)(r.Round,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),s={kernelName:r.Round,backendName:"cpu",kernelFunc:a}},15194:function(e,t,n){n.d(t,{j:function(){return s}});var r=n(9495),a=n(55589);const s={kernelName:r.SparseSegmentSum,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const u=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,i=n.data.get(o.dataId).values,[d,l]=(0,a.z)(u,r.shape,r.dtype,c,i);return n.makeTensorInfo(l,r.dtype,d)}}},17985:function(e,t,n){n.d(t,{C:function(){return c},_:function(){return o}});var r=n(9495),a=n(45705),s=n(21694);const o=(0,a.o)(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:a}=t;return e.replace(new RegExp(n,r?"g":""),a)})),u=(0,s.F)(r.StaticRegexReplace,o),c={kernelName:r.StaticRegexReplace,backendName:"cpu",kernelFunc:u}},19095:function(e,t,n){n.d(t,{b:function(){return a}});var r=n(9495);function a(e,t,n,a,s,o,u,c,i,d){const l=[a/s,s],p=e.values,f=t.values;if(0===a)return(0,r.buffer)(n,t.dtype);const h=i instanceof r.TensorBuffer?i:(0,r.buffer)(l,t.dtype);"string"===typeof i||"number"===typeof i?h.values.fill(i):"boolean"===typeof i&&h.values.fill(+i);for(let r=0;r<o;r++){const e=[];let o=0;for(let t=0;t<u;t++){const n=p[r*u+t];e.push(n),o+=n*c[t]}if(o<0||o>=a/s)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<s;n++)d?h.values[o*s+n]+=f[r*s+n]:h.values[o*s+n]=0===t.rank?f[0]:f[r*s+n]}return h}},19105:function(e,t,n){n.d(t,{e:function(){return s}});var r=n(9495),a=n(97870);const s={kernelName:r.Square,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;(0,a.C)(n,"square");const s=r.data.get(n.dataId).values,o=new Float32Array(s.length);for(let a=0;a<s.length;++a){const e=s[a];o[a]=e*e}return{dataId:r.write(o,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}}},25441:function(e,t,n){n.d(t,{M:function(){return o}});var r=n(9495);function a(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function s(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}const o={kernelName:r.SearchSorted,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:o}=e,{sortedSequence:u,values:c}=t,{side:i}=o,d=function(e,t,n,o,u,c){const i=r.util.getArrayFromDType("int32",n*u);for(let r=0;r<n;++r){const n=e.slice(r*o,(r+1)*o),d=r*u;for(let e=0;e<u;++e)i[d+e]="left"===c?a(n,t[e+d]):s(n,t[e+d])}return i}(n.data.get(u.dataId).values,n.data.get(c.dataId).values,u.shape[0],u.shape[1],c.shape[1],i);return n.makeTensorInfo(c.shape,"int32",d)}}},35019:function(e,t,n){n.d(t,{C:function(){return s}});var r=n(9495);const a=(0,n(21694).v)(r.Sign,(e=>e<0?-1:e>0?1:0)),s={kernelName:r.Sign,backendName:"cpu",kernelFunc:a}},40259:function(e,t,n){n.d(t,{K:function(){return s}});var r=n(9495),a=n(5744);const s={kernelName:r.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:o,defaultValue:u}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==u.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${u.shape}`);const c=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,l=n.data.get(u.dataId).values[0],[p,f,h,m,k]=(0,a.y)(c,r.shape,r.dtype,i,s.dtype,d,l);return[n.makeTensorInfo(f,r.dtype,p),n.makeTensorInfo([f[0]],s.dtype,h),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map((e=>Number(e))))),n.makeTensorInfo([k.length],r.dtype,new Int32Array(k))]}}},42180:function(e,t,n){n.d(t,{$:function(){return s}});var r=n(9495);const a=(0,n(21694).v)(r.Sinh,(e=>Math.sinh(e))),s={kernelName:r.Sinh,backendName:"cpu",kernelFunc:a}},43201:function(e,t,n){n.d(t,{W:function(){return c}});var r=n(9495),a=n(97870),s=n(94237),o=n(14590),u=n(85655);const c={kernelName:r.SpaceToBatchND,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:c}=e,{x:i}=t,{blockShape:d,paddings:l}=c;(0,a.C)([i],"spaceToBatchND");const p=r.util.sizeFromShape(d),f=[[0,0]];f.push(...l);for(let r=1+d.length;r<i.shape.length;++r)f.push([0,0]);const h=s.e.kernelFunc({inputs:{x:i},backend:n,attrs:{paddings:f,constantValue:0}}),m=r.backend_util.getReshaped(h.shape,d,p,!1),k=r.backend_util.getPermuted(m.length,d.length,!1),g=r.backend_util.getReshapedPermuted(h.shape,d,p,!1),b={x:h},S={shape:m},v=(0,o.t)({inputs:b,backend:n,attrs:S}),w={x:v},I={perm:k},y=(0,u.m)({inputs:w,backend:n,attrs:I}),N={x:y},E={shape:g},F=(0,o.t)({inputs:N,backend:n,attrs:E});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(y),F}}},55589:function(e,t,n){n.d(t,{z:function(){return a}});var r=n(9495);function a(e,t,n,a,s,o=!1,u=0){const c=a.length,i=[t[0],e.length/t[0]],d=i[1],l=c>0?s[c-1]+1:0;if(l<0)throw new Error(r.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const p=t.slice();p[0]=l;const f=p.reduce(((e,t)=>e*t),1),h=r.util.getArrayFromDType(n,f);if(0===c)return l>0&&h.fill(u),[h,p];if(l<=0)throw new Error(r.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,k=1,g=0,b=s[m];for(;;){let t=0;if(k<c){if(t=s[k],b===t){++k;continue}if(b>=t)throw new Error(r.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=l)throw new Error(r.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,l));b>g&&h.fill(u,g*d,b*d);for(let n=m;n<k;++n){const t=a[n];if(t<0||t>=i[0])throw new Error(r.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,a[n],i[0]));for(let n=0;n<d;n++)h[b*d+n]+=e[t*d+n]}if(o)for(let e=0;e<d;e++)h[b*d+e]/=k-m;if(m=k,++k,g=b+1,b=t,k>c)break}return g<l&&h.fill(u,g*d,l*d),[h,p]}},55758:function(e,t,n){n.d(t,{Z:function(){return u}});var r=n(9495),a=n(21694);const s=Math.log(1.1920928955078125e-7)+2,o=(0,a.v)(r.Softplus,(e=>{const t=e>-s,n=e<s,r=Math.exp(e);let a;return a=n?r:t?e:Math.log(1+r),a})),u={kernelName:r.Softplus,backendName:"cpu",kernelFunc:o}},62282:function(e,t,n){n.d(t,{$:function(){return l},V:function(){return d}});var r=n(9495),a=n(66423),s=n(99730),o=n(61879),u=n(14590),c=n(18566),i=n(25231);function d(e){const{inputs:t,backend:n,attrs:d}=e,{logits:l}=t,{dim:p}=d,f=l.shape.length;let h=p;if(-1===h&&(h=f-1),h!==f-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${f} and dim was ${h}`);const m=r.util.parseAxisParam([h],l.shape),k=(0,s.T)({inputs:{x:l},backend:n,attrs:{reductionIndices:m,keepDims:!1}}),g=r.backend_util.expandShapeToKeepDim(k.shape,m),b=(0,u.t)({inputs:{x:k},backend:n,attrs:{shape:g}}),S=(0,c.jb)({inputs:{a:l,b:b},backend:n}),v=(0,a.oN)({inputs:{x:S},backend:n}),w=(0,i.c)({inputs:{x:v},backend:n,attrs:{axis:m,keepDims:!1}}),I=(0,u.t)({inputs:{x:w},backend:n,attrs:{shape:g}}),y=(0,o.y4)({inputs:{a:v,b:I},backend:n});return n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(S),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(I),y}const l={kernelName:r.Softmax,backendName:"cpu",kernelFunc:d}},63252:function(e,t,n){n.d(t,{Fu:function(){return c},x6:function(){return o}});var r=n(9495),a=n(45705),s=n(21694);const o=(0,a.o)((e=>Math.sqrt(e))),u=(0,s.v)(r.Sqrt,(e=>Math.sqrt(e))),c={kernelName:r.Sqrt,backendName:"cpu",kernelFunc:u}},64904:function(e,t,n){n.d(t,{X3:function(){return c},ry:function(){return u},zv:function(){return o}});var r=n(9495),a=n(45705),s=n(21694);const o=(0,a.o)((e=>1/(1+Math.exp(-e)))),u=(0,s.v)(r.Sigmoid,(e=>1/(1+Math.exp(-e)))),c={kernelName:r.Sigmoid,backendName:"cpu",kernelFunc:u}},67654:function(e,t,n){n.d(t,{F:function(){return s}});var r=n(9495),a=n(95587);const s={kernelName:r.SparseReshape,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:o}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const u=Array.from(n.data.get(s.dataId).values),c=n.data.get(r.dataId).values,i=Array.from(n.data.get(o.dataId).values),[d,l,p]=(0,a.l)(c,r.shape,r.dtype,u,i);return[n.makeTensorInfo(l,r.dtype,d),n.makeTensorInfo([p.length],o.dtype,new Int32Array(p))]}}},75166:function(e,t,n){n.d(t,{b:function(){return s}});var r=n(9495);const a=(0,n(21694).v)(r.Sin,(e=>Math.sin(e))),s={kernelName:r.Sin,backendName:"cpu",kernelFunc:a}},75320:function(e,t,n){n.d(t,{v:function(){return s}});var r=n(9495),a=n(55589);const s={kernelName:r.SparseSegmentMean,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${o.shape}`);if(s.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const u=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,i=n.data.get(o.dataId).values,[d,l]=(0,a.z)(u,r.shape,r.dtype,c,i,!0);return n.makeTensorInfo(l,r.dtype,d)}}},87906:function(e,t,n){n.d(t,{HS:function(){return s},di:function(){return o},lv:function(){return u}});var r=n(9495),a=n(97870);function s(e,t,n,a,s){const o=r.slice_util.isSliceContinous(a,t,n),u=r.util.sizeFromShape(n),c=r.util.computeStrides(a);if(o){const n=r.slice_util.computeFlatOffset(t,c);return"string"===s?e.slice(n,n+u):e.subarray(n,n+u)}const i="string"===s?r.backend_util.fromUint8ToStringArray(e):e,d=(0,r.buffer)(a,s,i),l=(0,r.buffer)(n,s);for(let r=0;r<l.size;++r){const e=l.indexToLoc(r),n=e.map(((e,n)=>e+t[n]));l.set(d.get(...n),...e)}return"string"===s?r.backend_util.fromStringArrayToUint8(l.values):l.values}function o(e){const{inputs:t,backend:n,attrs:o}=e,{x:u}=t,{begin:c,size:i}=o;(0,a.C)(u,"slice");const[d,l]=r.slice_util.parseSliceParams(u,c,i);r.slice_util.assertParamsValid(u,d,l);const p=s(n.data.get(u.dataId).values,d,l,u.shape,u.dtype);return n.makeTensorInfo(l,u.dtype,p)}const u={kernelName:r.Slice,backendName:"cpu",kernelFunc:o}},91518:function(e,t,n){n.d(t,{z:function(){return s}});var r=n(9495),a=n(97870);const s={kernelName:r.Select,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:s,t:o,e:u}=t;(0,a.C)([s,o,u],"select");const c=s.shape.length,i=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,l=n.data.get(u.dataId).values,p=(0,r.upcastType)(o.dtype,u.dtype),f=r.util.makeZerosTypedArray(r.util.sizeFromShape(o.shape),p);let h=0;const m=0===c||c>1||1===o.shape.length?1:r.util.sizeFromShape(o.shape.slice(1));for(let r=0;r<i.length;r++)for(let e=0;e<m;e++)1===i[r]?f[h++]=d[r]:f[h++]=l[r];return n.makeTensorInfo(o.shape,p,f)}}},92292:function(e,t,n){n.d(t,{t:function(){return s}});var r=n(9495),a=n(87906);const s={kernelName:r.SplitV,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:o}=t,{numOrSizeSplits:u,axis:c}=s,i=r.util.parseAxisParam(c,o.shape)[0],d=r.backend_util.prepareSplitSize(o,u,i),l=new Array(o.shape.length).fill(0),p=o.shape.slice();return d.map((e=>{const t=[...p];t[i]=e;const r=(0,a.di)({inputs:{x:o},backend:n,attrs:{begin:l,size:t}});return l[i]+=e,r}))}}},95587:function(e,t,n){n.d(t,{l:function(){return a}});var r=n(9495);function a(e,t,n,a,s){const o=r.util.sizeFromShape(a),u=t[0],c=s.length,i=[];let d=1,l=-1;for(let k=0;k<c;++k){const e=s[k];if(-1===e){if(-1!==l)throw new Error(r.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(l,k));l=k,i.push(1)}else{if(e<0)throw new Error(r.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(k,e));d*=e,i.push(e)}}if(-1!==l){if(d<=0)throw new Error(r.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(o/d);if(d*e!==o)throw new Error(r.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(a,i));i[l]=e}if(r.util.sizeFromShape(i)!==o)throw new Error(r.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(a,i));const p=a.length,f=[];if(p>0){f[p-1]=1;for(let e=p-2;e>=0;--e)f[e]=f[e+1]*a[e+1]}const h=[];if(c>0){h[c-1]=1;for(let e=c-2;e>=0;--e)h[e]=h[e+1]*i[e+1]}const m=r.util.getArrayFromDType(n,u*c);for(let r=0;r<u;++r){let t=0;for(let n=0;n<p;++n)t+=e[r*p+n]*f[n];for(let e=0;e<c;++e)m[r*c+e]=Math.trunc(t/h[e]),t%=h[e]}return[m,[u,c],i]}},96320:function(e,t,n){n.d(t,{H:function(){return s}});var r=n(9495),a=n(19095);const s={kernelName:r.ScatterNd,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:o,updates:u}=t,{shape:c}=s,{sliceRank:i,numUpdates:d,sliceSize:l,strides:p,outputSize:f}=r.backend_util.calculateShapes(u,o,c),h=n.bufferSync(o),m=n.bufferSync(u),k=(0,a.b)(h,m,c,f,l,d,i,p,0,!0);return n.makeTensorInfo(c,k.dtype,k.values)}}},96844:function(e,t,n){n.d(t,{x:function(){return s}});var r=n(9495),a=n(19095);const s={kernelName:r.SparseToDense,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{sparseIndices:o,sparseValues:u,defaultValue:c}=t,{outputShape:i}=s,{sliceRank:d,numUpdates:l,sliceSize:p,strides:f,outputSize:h}=r.backend_util.calculateShapes(u,o,i),m=!1,k=n.bufferSync(o);let g;switch(u.dtype){case"bool":{const e=n.bufferSync(u),t=Boolean(n.data.get(c.dataId).values[0]);g=(0,a.b)(k,e,i,h,p,l,d,f,t,m);break}case"float32":{const e=n.bufferSync(u),t=n.data.get(c.dataId).values[0];g=(0,a.b)(k,e,i,h,p,l,d,f,t,m);break}case"int32":{const e=n.bufferSync(u),t=n.data.get(c.dataId).values[0];g=(0,a.b)(k,e,i,h,p,l,d,f,t,m);break}case"string":{const e=n.bufferSync(u),t=r.util.decodeString(n.data.get(c.dataId).values[0]);g=(0,a.b)(k,e,i,h,p,l,d,f,t,m);break}default:throw new Error(`Unsupported type ${u.dtype}`)}return n.makeTensorInfo(i,g.dtype,g.values)}}}}]);
//# sourceMappingURL=stylist-vendors-2fd89fc2.7e41cc335fc211fb694b.js.map