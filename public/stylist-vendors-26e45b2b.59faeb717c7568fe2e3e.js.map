{"version":3,"file":"stylist-vendors-26e45b2b.59faeb717c7568fe2e3e.js","mappings":"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","sources":["webpack://StylistWidget/./node_modules/@tensorflow/tfjs-layers/dist/base_callbacks.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\nexport var ModelLoggingVerbosity;\n(function (ModelLoggingVerbosity) {\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport class BaseCallback {\n    constructor() {\n        // TODO(michaelterry): This type is a best guess.\n        this.validationData = null;\n    }\n    setParams(params) {\n        this.params = params;\n    }\n    async onEpochBegin(epoch, logs) { }\n    async onEpochEnd(epoch, logs) { }\n    async onBatchBegin(batch, logs) { }\n    async onBatchEnd(batch, logs) { }\n    async onTrainBegin(logs) { }\n    async onTrainEnd(logs) { }\n    // LayersModel needs to call Callback.setModel(), but cannot actually depend\n    // on Callback because that creates a cyclic dependency.  Providing this no-op\n    // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n    // BaseCallback but not on Callback.  The argument is typed as `Container`\n    // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n    // overrides this method and enforces that the argument is really a\n    // LayersModel.\n    setModel(model) {\n        // Do nothing. Use Callback instead of BaseCallback to track the model.\n    }\n}\n/**\n * Container abstracting a list of callbacks.\n */\nexport class CallbackList {\n    // TODO(cais): When the need arises, uncomment the following lines and\n    // implement the queue for time values.\n    // private deltaTBatch: number;\n    // private deltaTsBatchBegin: Array<number>;\n    // private deltaTsBatchEnd: Array<number>;\n    /**\n     * Constructor of CallbackList.\n     * @param callbacks Array of `Callback` instances.\n     * @param queueLength Queue length for keeping running statistics over\n     *   callback execution time.\n     */\n    constructor(callbacks, queueLength = 10) {\n        // TODO(cais): Make use of queueLength when implementing the queue for time\n        // values.\n        if (callbacks == null) {\n            callbacks = [];\n        }\n        this.callbacks = callbacks;\n        this.queueLength = queueLength;\n    }\n    append(callback) {\n        this.callbacks.push(callback);\n    }\n    setParams(params) {\n        for (const callback of this.callbacks) {\n            callback.setParams(params);\n        }\n    }\n    setModel(model) {\n        for (const callback of this.callbacks) {\n            callback.setModel(model);\n        }\n    }\n    /**\n     * Called at the start of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochBegin(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochBegin(epoch, logs);\n        }\n    }\n    /**\n     * Called at the end of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochEnd(epoch, logs);\n        }\n    }\n    /**\n     * Called  right before processing a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchBegin(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchBegin(batch, logs);\n        }\n    }\n    /**\n     * Called at the end of a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchEnd(batch, logs);\n        }\n    }\n    /**\n     * Called at the beginning of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainBegin(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainBegin(logs);\n        }\n    }\n    /**\n     * Called at the end of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainEnd(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainEnd(logs);\n        }\n    }\n}\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport class BaseLogger extends BaseCallback {\n    constructor() {\n        super();\n    }\n    async onEpochBegin(epoch) {\n        this.seen = 0;\n        this.totals = {};\n    }\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        const batchSize = logs['size'] == null ? 0 : logs['size'];\n        this.seen += batchSize;\n        for (const key in logs) {\n            const value = logs[key];\n            if (typeof value === 'number') {\n                if (!this.totals.hasOwnProperty(key)) {\n                    this.totals[key] = 0;\n                }\n                this.totals[key] = this.totals[key] + value * batchSize;\n            }\n            else {\n                let oldTotalsToDispose;\n                if (key in this.totals) {\n                    oldTotalsToDispose = this.totals[key];\n                }\n                else {\n                    this.totals[key] = 0;\n                }\n                const total = tidy(() => add((this.totals[key]), mul(value, batchSize)));\n                this.totals[key] = total;\n                if (oldTotalsToDispose != null) {\n                    oldTotalsToDispose.dispose();\n                }\n            }\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs != null) {\n            for (const key of this.params['metrics']) {\n                if (this.totals[key] == null) {\n                    continue;\n                }\n                if (typeof this.totals[key] === 'number') {\n                    logs[key] = this.totals[key] / this.seen;\n                }\n                else {\n                    tidy(() => {\n                        const log = mul(div(1, this.seen), this.totals[key]);\n                        logs[key] = log;\n                        this.totals[key].dispose();\n                        keep(logs[key]);\n                    });\n                }\n            }\n        }\n    }\n}\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport class History extends BaseCallback {\n    async onTrainBegin(logs) {\n        this.epoch = [];\n        this.history = {};\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        this.epoch.push(epoch);\n        for (const key in logs) {\n            if (this.history[key] == null) {\n                this.history[key] = [];\n            }\n            this.history[key].push(logs[key]);\n        }\n    }\n    /**\n     * Await the values of all losses and metrics.\n     */\n    async syncData() {\n        const promises = [];\n        const keys = [];\n        const indices = [];\n        for (const key in this.history) {\n            const valueArray = this.history[key];\n            for (let i = 0; i < valueArray.length; ++i) {\n                if (typeof valueArray[i] !== 'number') {\n                    const valueScalar = valueArray[i];\n                    promises.push(valueScalar.data());\n                    keys.push(key);\n                    indices.push(i);\n                }\n            }\n        }\n        const values = await Promise.all(promises);\n        for (let n = 0; n < values.length; ++n) {\n            const tensorToDispose = this.history[keys[n]][indices[n]];\n            tensorToDispose.dispose();\n            this.history[keys[n]][indices[n]] = values[n][0];\n        }\n    }\n}\n/**\n * Custom callback for training.\n */\nexport class CustomCallback extends BaseCallback {\n    constructor(args, yieldEvery) {\n        super();\n        this.currentEpoch = 0;\n        this.yieldEvery = yieldEvery || 'auto';\n        if (this.yieldEvery === 'auto') {\n            this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n        }\n        if (this.yieldEvery === 'never' && args.onYield != null) {\n            throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' +\n                'Either change `yieldEvery` or remove the callback');\n        }\n        if (util.isNumber(this.yieldEvery)) {\n            // Decorate `maybeWait` so it will be called at most once every\n            // `yieldEvery` ms.\n            this.maybeWait = generic_utils.debounce(this.maybeWait.bind(this), this.yieldEvery);\n        }\n        this.trainBegin = args.onTrainBegin;\n        this.trainEnd = args.onTrainEnd;\n        this.epochBegin = args.onEpochBegin;\n        this.epochEnd = args.onEpochEnd;\n        this.batchBegin = args.onBatchBegin;\n        this.batchEnd = args.onBatchEnd;\n        this.yield = args.onYield;\n    }\n    async maybeWait(epoch, batch, logs) {\n        const ps = [];\n        if (this.yield != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.yield(epoch, batch, logs));\n        }\n        ps.push(nextFrame());\n        await Promise.all(ps);\n    }\n    async onEpochBegin(epoch, logs) {\n        this.currentEpoch = epoch;\n        if (this.epochBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.epochBegin(epoch, logs);\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        const ps = [];\n        if (this.epochEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.epochEnd(epoch, logs));\n        }\n        if (this.yieldEvery === 'epoch') {\n            ps.push(nextFrame());\n        }\n        await Promise.all(ps);\n    }\n    async onBatchBegin(batch, logs) {\n        if (this.batchBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.batchBegin(batch, logs);\n        }\n    }\n    async onBatchEnd(batch, logs) {\n        const ps = [];\n        if (this.batchEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.batchEnd(batch, logs));\n        }\n        if (this.yieldEvery === 'batch') {\n            ps.push(nextFrame());\n        }\n        else if (util.isNumber(this.yieldEvery)) {\n            ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n        }\n        await Promise.all(ps);\n    }\n    async onTrainBegin(logs) {\n        if (this.trainBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainBegin(logs);\n        }\n    }\n    async onTrainEnd(logs) {\n        if (this.trainEnd != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainEnd(logs);\n        }\n    }\n}\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n    if (callbacks == null) {\n        callbacks = {};\n    }\n    if (callbacks instanceof BaseCallback) {\n        return [callbacks];\n    }\n    if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n        return callbacks;\n    }\n    // Convert custom callback configs to custom callback objects.\n    const callbackConfigs = generic_utils.toList(callbacks);\n    return callbackConfigs.map(callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport class CallbackConstructorRegistry {\n    /**\n     * Blocks public access to constructor.\n     */\n    constructor() { }\n    /**\n     * Register a tf.LayersModel.fit() callback constructor.\n     *\n     * The registered callback constructor will be used to instantiate\n     * callbacks for every tf.LayersModel.fit() call afterwards.\n     *\n     * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n     *   is to be reigstered.\n     * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n     * @throws Error, if the same callbackConstructor has been registered before,\n     *   either at the same or a different `verbosityLevel`.\n     */\n    static registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n        util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, ` +\n            `but got ${verbosityLevel}`);\n        CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n        if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n            CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n        }\n        CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n    }\n    static checkForDuplicate(callbackConstructor) {\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const constructors = CallbackConstructorRegistry.constructors[+levelName];\n            constructors.forEach(ctor => {\n                if (ctor === callbackConstructor) {\n                    throw new ValueError('Duplicate callback constructor.');\n                }\n            });\n        }\n    }\n    /**\n     * Clear all registered callback constructors.\n     */\n    static clear() {\n        CallbackConstructorRegistry.constructors = {};\n    }\n    /**\n     * Create callbacks using the registered callback constructors.\n     *\n     * Given `verbosityLevel`, all constructors registered at that level or above\n     * will be called and the instantiated callbacks will be used.\n     *\n     * @param verbosityLevel: Level of verbosity.\n     */\n    static createCallbacks(verbosityLevel) {\n        const constructors = [];\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const level = +levelName;\n            if (verbosityLevel >= level) {\n                constructors.push(...CallbackConstructorRegistry.constructors[level]);\n            }\n        }\n        return constructors.map(ctor => new ctor());\n    }\n}\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n    const history = new History();\n    const actualCallbacks = [\n        new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)\n    ];\n    if (callbacks != null) {\n        actualCallbacks.push(...callbacks);\n    }\n    actualCallbacks.push(history);\n    const callbackList = new CallbackList(actualCallbacks);\n    // TODO(cais): Figure out when this LayersModel instance can have a\n    // dynamically\n    //   set property called 'callback_model' as in PyKeras.\n    callbackList.setParams({\n        epochs,\n        initialEpoch,\n        samples: numTrainSamples,\n        steps: stepsPerEpoch,\n        batchSize,\n        verbose,\n        doValidation,\n        metrics: callbackMetrics,\n    });\n    return { callbackList, history };\n}\n//# sourceMappingURL=base_callbacks.js.map"],"names":["ModelLoggingVerbosity","BaseCallback","constructor","this","validationData","setParams","params","onEpochBegin","epoch","logs","onEpochEnd","onBatchBegin","batch","onBatchEnd","onTrainBegin","onTrainEnd","setModel","model","CallbackList","callbacks","queueLength","append","callback","push","BaseLogger","super","seen","totals","batchSize","key","value","hasOwnProperty","oldTotalsToDispose","total","tidy","add","mul","dispose","log","div","keep","History","history","syncData","promises","keys","indices","valueArray","i","length","valueScalar","data","values","Promise","all","n","CustomCallback","args","yieldEvery","currentEpoch","onYield","Error","util","maybeWait","bind","trainBegin","trainEnd","epochBegin","epochEnd","batchBegin","batchEnd","yield","ps","nextFrame","standardizeCallbacks","Array","isArray","map","callbackConfig","CallbackConstructorRegistry","registerCallbackConstructor","verbosityLevel","callbackConstructor","Number","isInteger","checkForDuplicate","constructors","levelName","forEach","ctor","clear","createCallbacks","level","configureCallbacks","verbose","epochs","initialEpoch","numTrainSamples","stepsPerEpoch","doValidation","callbackMetrics","actualCallbacks","callbackList","samples","steps","metrics"],"sourceRoot":""}