"use strict";(self.webpackChunkStylistWidget=self.webpackChunkStylistWidget||[]).push([[1247],{5070:function(e,t,s){s.d(t,{j:function(){return a}});var n=s(9951),r=s(6439);const a=(e,t,s,a=n)=>{switch(e.op){case"FFT":return[a.fft((0,r.Zg)("x",e,t,s))];case"IFFT":return[a.ifft((0,r.Zg)("x",e,t,s))];case"RFFT":return[a.rfft((0,r.Zg)("x",e,t,s))];case"IRFFT":return[a.irfft((0,r.Zg)("x",e,t,s))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},6439:function(e,t,s){s.d(t,{Cq:function(){return g},Xi:function(){return u},Zg:function(){return r},cI:function(){return c},cS:function(){return a},hV:function(){return p},lz:function(){return i}});var n=s(9495);function r(e,t,s,r,c){const i=t.inputParams[e];if(i&&void 0!==i.inputIndexStart){const e=i.inputIndexStart,o=0===i.inputIndexEnd?void 0:void 0===i.inputIndexEnd?e+1:i.inputIndexEnd,u=e<0?t.inputNames.length+e:e;if("tensor"===i.type)return a(t.inputNames[u],s,r,c);if("tensors"===i.type){const n=t.inputs.slice(e,o);return t.inputNames.slice(e,o).filter(((e,t)=>{var s;return"NoOp"!==(null===(s=n[t])||void 0===s?void 0:s.op)})).map((e=>a(e,s,r,c)))}const g=a(t.inputNames[u],s,r,c),p=g.dataSync();return"number"===i.type?p[0]:n.util.toNestedArray(g.shape,p)}const o=t.attrParams[e];return o&&o.value}function a(e,t,s,n){const[r,a]=u(e,s);if(null!=n){const e=n.getHashTableHandleByName(r);if(null!=e)return e}const c=s.currentContextIds.find((e=>!!t[o(r,e)]));return void 0!==c?t[o(r,c)][a]:void 0}function c(e,t,s){return t[o(e,s.currentContextId)]}function i(e,t){const[s,n,r]=u(e,t);return[o(s,t&&t.currentContextId),n,r]}function o(e,t){return t?`${e}-${t}`:e}function u(e,t){if(""===e)return["",0,void 0];const s=null!=t&&null!=t.parseNodeNameCache;if(s){const s=t.parseNodeNameCache.get(e);if(null!=s)return s}const n=e.split(":");let r;if(1===n.length)r=[e,0,void 0];else{const e=n[0],t=3===n.length?n[1]:void 0;r=[e,Number(n[n.length-1]),t]}return s&&t.parseNodeNameCache.set(e,r),r}function g(e,t,s){let n=r("pad",e,t,s);if("explicit"===n){n=r("explicitPaddings",e,t,s);const a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=n[2*e],a[e][1]=n[2*e+1];return a}return n}function p(e){return e.kept?e:(0,n.clone)(e)}},7714:function(e,t,s){s.d(t,{j:function(){return a}});var n=s(9951),r=s(6439);const a=(e,t,s,a=n)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:n,outputValues:c,emptyRowIndicator:i,reverseIndexMap:o}=a.sparse.sparseFillEmptyRows((0,r.Zg)("indices",e,t,s),(0,r.Zg)("values",e,t,s),(0,r.Zg)("denseShape",e,t,s),(0,r.Zg)("defaultValue",e,t,s));return[n,c,i,o]}case"SparseReshape":{const{outputIndices:n,outputShape:c}=a.sparse.sparseReshape((0,r.Zg)("inputIndices",e,t,s),(0,r.Zg)("inputShape",e,t,s),(0,r.Zg)("newShape",e,t,s));return[n,c]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean((0,r.Zg)("data",e,t,s),(0,r.Zg)("indices",e,t,s),(0,r.Zg)("segmentIds",e,t,s))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum((0,r.Zg)("data",e,t,s),(0,r.Zg)("indices",e,t,s),(0,r.Zg)("segmentIds",e,t,s))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},12315:function(e,t,s){s.d(t,{j:function(){return a}});var n=s(9951),r=s(6439);const a=(e,t,s,a=n)=>{switch(e.op){case"Max":{const n=(0,r.Zg)("axis",e,t,s),c=(0,r.Zg)("keepDims",e,t,s);return[a.max((0,r.Zg)("x",e,t,s),n,c)]}case"Mean":{const n=(0,r.Zg)("axis",e,t,s),c=(0,r.Zg)("keepDims",e,t,s);return[a.mean((0,r.Zg)("x",e,t,s),n,c)]}case"Min":{const n=(0,r.Zg)("axis",e,t,s),c=(0,r.Zg)("keepDims",e,t,s);return[a.min((0,r.Zg)("x",e,t,s),n,c)]}case"Sum":{const n=(0,r.Zg)("axis",e,t,s),c=(0,r.Zg)("keepDims",e,t,s);return[a.sum((0,r.Zg)("x",e,t,s),n,c)]}case"All":{const n=(0,r.Zg)("axis",e,t,s),c=(0,r.Zg)("keepDims",e,t,s);return[a.all((0,r.Zg)("x",e,t,s),n,c)]}case"Any":{const n=(0,r.Zg)("axis",e,t,s),c=(0,r.Zg)("keepDims",e,t,s);return[a.any((0,r.Zg)("x",e,t,s),n,c)]}case"ArgMax":{const n=(0,r.Zg)("axis",e,t,s);return[a.argMax((0,r.Zg)("x",e,t,s),n)]}case"ArgMin":{const n=(0,r.Zg)("axis",e,t,s);return[a.argMin((0,r.Zg)("x",e,t,s),n)]}case"Prod":{const n=(0,r.Zg)("axis",e,t,s),c=(0,r.Zg)("keepDims",e,t,s);return[a.prod((0,r.Zg)("x",e,t,s),n,c)]}case"Cumprod":{const n=(0,r.Zg)("axis",e,t,s),c=(0,r.Zg)("exclusive",e,t,s),i=(0,r.Zg)("reverse",e,t,s);return[a.cumprod((0,r.Zg)("x",e,t,s),n,c,i)]}case"Cumsum":{const n=(0,r.Zg)("axis",e,t,s),c=(0,r.Zg)("exclusive",e,t,s),i=(0,r.Zg)("reverse",e,t,s);return[a.cumsum((0,r.Zg)("x",e,t,s),n,c,i)]}case"Bincount":const n=(0,r.Zg)("x",e,t,s),c=(0,r.Zg)("weights",e,t,s),i=(0,r.Zg)("size",e,t,s);return[a.bincount(n,c,i)];case"DenseBincount":{const n=(0,r.Zg)("x",e,t,s),c=(0,r.Zg)("weights",e,t,s),i=(0,r.Zg)("size",e,t,s),o=(0,r.Zg)("binaryOutput",e,t,s);return[a.denseBincount(n,c,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}},26512:function(e,t,s){s.d(t,{j:function(){return a}});var n=s(9951),r=s(6439);const a=(e,t,s,a=n)=>{switch(e.op){case"RaggedGather":{const{outputNestedSplits:n,outputDenseValues:c}=a.raggedGather((0,r.Zg)("paramsNestedSplits",e,t,s),(0,r.Zg)("paramsDenseValues",e,t,s),(0,r.Zg)("indices",e,t,s),(0,r.Zg)("outputRaggedRank",e,t,s));return n.concat(c)}case"RaggedRange":{const{rtNestedSplits:n,rtDenseValues:c}=a.raggedRange((0,r.Zg)("starts",e,t,s),(0,r.Zg)("limits",e,t,s),(0,r.Zg)("splits",e,t,s));return[n,c]}case"RaggedTensorToTensor":return[a.raggedTensorToTensor((0,r.Zg)("shape",e,t,s),(0,r.Zg)("values",e,t,s),(0,r.Zg)("defaultValue",e,t,s),(0,r.Zg)("rowPartitionTensors",e,t,s),(0,r.Zg)("rowPartitionTypes",e,t,s))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},41557:function(e,t,s){s.d(t,{j:function(){return a}});var n=s(9951),r=s(6439);const a=(e,t,s,a=n)=>{switch(e.op){case"StaticRegexReplace":return[a.string.staticRegexReplace((0,r.Zg)("input",e,t,s),(0,r.Zg)("pattern",e,t,s),(0,r.Zg)("rewrite",e,t,s),(0,r.Zg)("replaceGlobal",e,t,s))];case"StringNGrams":{const{nGrams:n,nGramsSplits:c}=a.string.stringNGrams((0,r.Zg)("data",e,t,s),(0,r.Zg)("dataSplits",e,t,s),(0,r.Zg)("separator",e,t,s),(0,r.Zg)("nGramWidths",e,t,s),(0,r.Zg)("leftPad",e,t,s),(0,r.Zg)("rightPad",e,t,s),(0,r.Zg)("padWidth",e,t,s),(0,r.Zg)("preserveShortSequences",e,t,s));return[n,c]}case"StringSplit":{const{indices:n,values:c,shape:i}=a.string.stringSplit((0,r.Zg)("input",e,t,s),(0,r.Zg)("delimiter",e,t,s),(0,r.Zg)("skipEmpty",e,t,s));return[n,c,i]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast((0,r.Zg)("input",e,t,s),(0,r.Zg)("numBuckets",e,t,s))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}},55659:function(e,t,s){s.d(t,{j:function(){return c}});var n=s(9495),r=s(9951),a=s(6439);const c=(e,t,s,c=r)=>{switch(e.op){case"ConcatV2":case"Concat":{const n=(0,a.Zg)("n",e,t,s),r=(0,a.Zg)("axis",e,t,s);let i=(0,a.Zg)("tensors",e,t,s);return i=i.slice(0,n),[c.concat(i,r)]}case"Gather":{const n=(0,a.Zg)("x",e,t,s),r=(0,a.Zg)("indices",e,t,s);return[c.gather(n,c.cast(r,"int32"),0)]}case"GatherV2":{const n=(0,a.Zg)("axis",e,t,s),r=(0,a.Zg)("batchDims",e,t,s),i=(0,a.Zg)("x",e,t,s),o=(0,a.Zg)("indices",e,t,s);return[c.gather(i,c.cast(o,"int32"),n,r)]}case"Reverse":{const n=(0,a.Zg)("dims",e,t,s),r=[];for(let e=0;e<n.length;e++)n[e]&&r.push(e);const i=(0,a.Zg)("x",e,t,s);return[c.reverse(i,r)]}case"ReverseV2":{const n=(0,a.Zg)("axis",e,t,s),r=(0,a.Zg)("x",e,t,s);return[c.reverse(r,n)]}case"Slice":{const n=(0,a.Zg)("begin",e,t,s),r=(0,a.Zg)("size",e,t,s);return[c.slice((0,a.Zg)("x",e,t,s),n,r)]}case"StridedSlice":{const n=(0,a.Zg)("begin",e,t,s),r=(0,a.Zg)("end",e,t,s),i=(0,a.Zg)("strides",e,t,s),o=(0,a.Zg)("beginMask",e,t,s),u=(0,a.Zg)("endMask",e,t,s),g=(0,a.Zg)("ellipsisMask",e,t,s),p=(0,a.Zg)("newAxisMask",e,t,s),Z=(0,a.Zg)("shrinkAxisMask",e,t,s),d=(0,a.Zg)("x",e,t,s);return[c.stridedSlice(d,n,r,i,o,u,g,p,Z)]}case"Pack":return(0,n.tidy)((()=>{const r=(0,a.Zg)("axis",e,t,s),i=(0,a.Zg)("tensors",e,t,s),o=i[0].shape,u=c.squeeze(i[0]).shape,g=i.map((e=>{const t=n.util.arraysEqual(e.shape,o);if(!t&&!n.util.arraysEqual(c.squeeze(e).shape,u))throw new Error("the input tensors shape does not match");return t?e:c.reshape(e,o)}));return[c.stack(g,r)]}));case"Unpack":{const n=(0,a.Zg)("axis",e,t,s),r=(0,a.Zg)("tensor",e,t,s);return c.unstack(r,n)}case"Tile":{const n=(0,a.Zg)("reps",e,t,s);return[c.tile((0,a.Zg)("x",e,t,s),n)]}case"Split":case"SplitV":{const n=(0,a.Zg)("axis",e,t,s),r=(0,a.Zg)("numOrSizeSplits",e,t,s),i=(0,a.Zg)("x",e,t,s);return c.split(i,r,n)}case"ScatterNd":{const n=(0,a.Zg)("indices",e,t,s),r=(0,a.Zg)("values",e,t,s),i=(0,a.Zg)("shape",e,t,s);return[c.scatterND(n,r,i)]}case"GatherNd":{const n=(0,a.Zg)("x",e,t,s),r=(0,a.Zg)("indices",e,t,s);return[c.gatherND(n,r)]}case"SparseToDense":{const n=(0,a.Zg)("sparseIndices",e,t,s),r=(0,a.Zg)("outputShape",e,t,s),i=(0,a.Zg)("sparseValues",e,t,s),o=(0,a.Zg)("defaultValue",e,t,s);return[c.sparseToDense(n,i,r,i.dtype===o.dtype?o:c.cast(o,i.dtype))]}case"TensorScatterUpdate":{const n=(0,a.Zg)("indices",e,t,s),r=(0,a.Zg)("values",e,t,s),i=(0,a.Zg)("tensor",e,t,s);return[c.tensorScatterUpdate(i,n,r)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}},74477:function(e,t,s){s.d(t,{j:function(){return a}});var n=s(9951),r=s(6439);const a=(e,t,s,a=n)=>{switch(e.op){case"Cast":return[a.cast((0,r.Zg)("x",e,t,s),(0,r.Zg)("dtype",e,t,s))];case"ExpandDims":{const n=(0,r.Zg)("axis",e,t,s);return[a.expandDims((0,r.Zg)("x",e,t,s),n)]}case"Squeeze":{const n=(0,r.Zg)("axis",e,t,s);return[a.squeeze((0,r.Zg)("x",e,t,s),n)]}case"Reshape":return[a.reshape((0,r.Zg)("x",e,t,s),(0,r.Zg)("shape",e,t,s))];case"EnsureShape":return[a.ensureShape((0,r.Zg)("x",e,t,s),(0,r.Zg)("shape",e,t,s))];case"MirrorPad":return[a.mirrorPad((0,r.Zg)("x",e,t,s),(0,r.Zg)("padding",e,t,s),(0,r.Zg)("mode",e,t,s))];case"PadV2":case"Pad":return[a.pad((0,r.Zg)("x",e,t,s),(0,r.Zg)("padding",e,t,s),(0,r.Zg)("constantValue",e,t,s))];case"SpaceToBatchND":{const n=(0,r.Zg)("blockShape",e,t,s),c=(0,r.Zg)("paddings",e,t,s);return[a.spaceToBatchND((0,r.Zg)("x",e,t,s),n,c)]}case"BatchToSpaceND":{const n=(0,r.Zg)("blockShape",e,t,s),c=(0,r.Zg)("crops",e,t,s);return[a.batchToSpaceND((0,r.Zg)("x",e,t,s),n,c)]}case"DepthToSpace":{const n=(0,r.Zg)("blockSize",e,t,s),c=(0,r.Zg)("dataFormat",e,t,s).toUpperCase();return[a.depthToSpace((0,r.Zg)("x",e,t,s),n,c)]}case"BroadcastTo":return[a.broadcastTo((0,r.Zg)("x",e,t,s),(0,r.Zg)("shape",e,t,s))];case"BroadcastArgs":return[a.broadcastArgs((0,r.Zg)("s0",e,t,s),(0,r.Zg)("s1",e,t,s))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}}}]);
//# sourceMappingURL=stylist-vendors-6d79a8be.d151e2638819d45f3489.js.map